1
00:00:00,069 --> 00:00:00,469
All right.
好的

2
00:00:01,510 --> 00:00:02,591
Allegedly we're on Twitch.
听说我们已经在 Twitch 上了

3
00:00:02,591 --> 00:00:03,512
Can somebody, is somebody
有人能

4
00:00:03,512 --> 00:00:04,572
anybody on there can check?
在那边看看吗？

5
00:00:07,034 --> 00:00:07,680
Yeah.
好的

6
00:00:10,474 --> 00:00:11,237
And if you're lucky
如果幸运的话

7
00:00:11,237 --> 00:00:12,398
you even hear yourself.
你甚至能听到自己的声音

8
00:00:15,340 --> 00:00:15,901
All right.
好的

9
00:00:15,901 --> 00:00:17,402
I'm going to open up this stupid thing
我要打开这玩意儿

10
00:00:17,402 --> 00:00:20,965
so I can answer people who are just like looking at stuff on their thing.
这样我就可以回复那些正在看东西的人了

11
00:00:20,965 --> 00:00:22,146
Okay.
行

12
00:00:22,146 --> 00:00:23,286
Great.
太棒了

13
00:00:23,286 --> 00:00:23,707
All right.
行了

14
00:00:25,128 --> 00:00:25,908
Uh, thanks everyone.
呃 谢谢各位

15
00:00:25,908 --> 00:00:26,449
Please.
来吧

16
00:00:26,449 --> 00:00:27,910
Somebody, oh, there's zero people on Twitch.
还有人吗 哦 Twitch 上一个人也没有

17
00:00:27,910 --> 00:00:28,410
Awesome.
真好

18
00:00:28,410 --> 00:00:28,710
Okay.
行

19
00:00:28,710 --> 00:00:31,096
So, uh, Hello, everyone.
呃 大家好

20
00:00:31,096 --> 00:00:33,237
In case you are super confused
如果你们感到很困惑

21
00:00:33,237 --> 00:00:34,638
I am the real Adam.
我是真正的亚当

22
00:00:37,360 --> 00:00:39,381
Everything you heard last week was a lie.
上周你们听到的都是假的

23
00:00:43,203 --> 00:00:43,969
Let's see.
我们来看看

24
00:00:44,289 --> 00:00:47,849
Any questions from last week about the course?
对上周的课程有什么问题吗？

25
00:00:51,141 --> 00:00:51,681
No?
没有？

26
00:00:52,009 --> 00:00:54,694
Everyone feel like they're ARM masters?
大家都觉得自己是 ARM 专家了吗？

27
00:00:56,034 --> 00:00:57,414
Expert ARM people?
ARM 专家吗？

28
00:00:58,528 --> 00:00:59,021
No?
没有？

29
00:01:00,048 --> 00:01:00,462
Not yet?
还没呢？

30
00:01:00,515 --> 00:01:01,229
Do you want to be?
你们想成为专家吗？

31
00:01:01,915 --> 00:01:04,471
So far, based on what you've done
基于你们目前的经历

32
00:01:04,471 --> 00:01:07,274
what's the big difference between ARM and x86-64?
ARM 和 x86-64 有什么主要区别？

33
00:01:07,274 --> 00:01:10,275
Or ARM64, because there are several versions of ARM.
或者 ARM64 因为 ARM 有多个版本

34
00:01:13,016 --> 00:01:14,191
Loading registers suck.
加载寄存器真头疼

35
00:01:14,684 --> 00:01:15,890
What was it? Say it again.
什么？再说一遍

36
00:01:15,984 --> 00:01:17,090
Loading registers suck.
加载寄存器真头疼

37
00:01:17,299 --> 00:01:18,260
Loading registers suck.
加载寄存器真头疼

38
00:01:18,260 --> 00:01:18,680
What do you mean?
什么意思？

39
00:01:18,680 --> 00:01:20,042
You don't like loading registers?
你不喜欢加载寄存器？

40
00:01:20,733 --> 00:01:22,913
loading the same register multiple times
重复加载同一个寄存器

41
00:01:23,106 --> 00:01:27,186
Ah, you don't like loading the same register multiple times.
啊 你不喜欢重复加载同一个寄存器

42
00:01:27,325 --> 00:01:28,319
Interesting.
挺有意思的

43
00:01:28,626 --> 00:01:29,999
Why? is that a problem?
为什么这是个问题？

44
00:01:30,259 --> 00:01:32,052
Oh, with the big numbers and stuff?
哦 是因为处理大数之类的问题吗？

45
00:01:32,759 --> 00:01:33,892
Big numbers, yeah.
大数 对

46
00:01:34,482 --> 00:01:36,064
Big numbers are a big problem, right?
大数确实是个大问题 对吧？

47
00:01:36,110 --> 00:01:37,849
And I know Rob talked about that, right?
我记得 Rob 也提过这个问题 对吧？

48
00:01:37,849 --> 00:01:40,419
You only have 32 bits for a single instruction
每个指令只有 32 位

49
00:01:40,950 --> 00:01:43,510
which fundamentally limits what...
这从根本上限制了你...

50
00:01:43,510 --> 00:01:45,076
literals you can put in there.
能放进去的立即数

51
00:01:45,336 --> 00:01:47,929
It always helps to think of, for me
个人觉得 这样想会好一点

52
00:01:47,994 --> 00:01:52,799
like how would I design this if I was designing like the ARM compiler,
比如 如果我要设计 ARM 编译器 我会怎么设计

53
00:01:52,799 --> 00:01:53,099
right?
对吧？

54
00:01:53,099 --> 00:01:54,420
So you have 32 bits
所以你有 32 位

55
00:01:54,420 --> 00:01:55,200
you need to like
你需要考虑

56
00:01:56,282 --> 00:01:58,104
you have to deal with these limitations.
你得应对这些限制

57
00:01:59,885 --> 00:02:03,828
Okay, so any other ARM comments, questions?
好的 关于 ARM 还有其他意见或问题吗？

58
00:02:07,803 --> 00:02:08,296
Yes.
你说

59
00:02:18,430 --> 00:02:20,036
ooh, say it again
再说一下

60
00:02:30,063 --> 00:02:31,316
Yeah, so it gets tricky.
是的 这问题确实复杂

61
00:02:31,783 --> 00:02:32,771
I mean, I'll be honest
实话说

62
00:02:32,796 --> 00:02:33,783
I'm not like a...
我不是个...

63
00:02:34,190 --> 00:02:35,410
Super ARM expert.
ARM 专家

64
00:02:35,443 --> 00:02:37,329
I guess the big confession is
坦白讲

65
00:02:37,396 --> 00:02:41,102
I didn't actually have to read any ARM when I was doing XNU analysis
在分析 XNU 时，我其实不需要阅读任何 ARM 代码

66
00:02:42,103 --> 00:02:44,384
because it's actually way easier.
因为实际更容易

67
00:02:44,384 --> 00:02:46,105
I had an x86 machine
我有一台 x86 机器

68
00:02:46,105 --> 00:02:49,527
and at the time you could run the same operating system versions on both
你可以在两台机器上，运行相同版本的系统

69
00:02:49,527 --> 00:02:51,068
and it was way easier to debug that.
这样调试起来容易得多

70
00:02:52,129 --> 00:02:54,110
Plus, as we'll see as we go into things
随着我们深入探讨

71
00:02:54,110 --> 00:02:58,138
it's way easier to read source code and the decompilation code
阅读源代码以及反编译代码更容易

72
00:02:58,463 --> 00:03:00,414
rather than having to dig into the binary code
相较于研究二进制代码

73
00:03:00,414 --> 00:03:01,616
but sometimes I would have to.
但有时候我不得不这么做

74
00:03:02,937 --> 00:03:04,277
But, yeah, so if I remember correctly
不过 如果我没记错的话

75
00:03:04,277 --> 00:03:07,040
the floating point registers on ARM are 128 bits
ARM 的浮点寄存器是 128 位

76
00:03:07,040 --> 00:03:08,582
so they for sure have this problem.
所以它们肯定会有这个问题

77
00:03:08,582 --> 00:03:11,466
I think the other thing probably to think about is, like, a lot of,
我觉得还需要考虑的是 很多情况下

78
00:03:11,799 --> 00:03:12,799
you know, what you're doing is
你是

79
00:03:12,824 --> 00:03:14,898
writing assembly code from the perspective of
你写汇编代码的角度是

80
00:03:14,952 --> 00:03:16,332
you're doing assembly code  because
你写它是因为

81
00:03:16,372 --> 00:03:19,876
there's shellcoding and ROP and all that stuff, right?
要写shellcode还有 ROP 之类的 对吧？

82
00:03:20,496 --> 00:03:21,736
When you're doing exploitation
在进行利用时

83
00:03:21,736 --> 00:03:23,518
you often can control instructions
你通常能控制指令

84
00:03:23,518 --> 00:03:24,437
and do those kinds of things.
做这类的事情

85
00:03:24,437 --> 00:03:27,503
But if you are writing an ELF file
但如果你在编写 ELF 文件

86
00:03:28,323 --> 00:03:31,102
you don't need to load immediates from instructions.
你就不需要从指令中加载立即数

87
00:03:31,102 --> 00:03:32,596
You can always load them from memory.
你总是可以从内存中加载

88
00:03:32,863 --> 00:03:34,524
You have to probably then deal with...
你可能需要处理...

89
00:03:34,524 --> 00:03:37,351
Compilers would have to deal with the performance trade-offs.
编译器需要处理性能权衡

90
00:03:37,545 --> 00:03:41,728
So any big literal that they want to shove into a floating point register
所以任何要放到浮点寄存器的大常量

91
00:03:41,728 --> 00:03:42,908
maybe goes into the...
可能会放入...

92
00:03:44,346 --> 00:03:47,105
goes into BSS or something that they can then read from there
放入 BSS 或其他可以读取的地方

93
00:03:47,191 --> 00:03:49,185
and shove it into the register that way through memory.
然后通过内存将其载入寄存器

94
00:03:51,072 --> 00:03:51,771
Yeah, exactly.
没错

95
00:03:51,771 --> 00:03:53,872
But it's probably faster to use the immediates
使用立即数可能更快

96
00:03:53,924 --> 00:03:55,430
but then you have to worry about, you know
但你得考虑

97
00:03:55,613 --> 00:03:57,257
compilers always have to deal with
编译器总是需要处理

98
00:03:57,517 --> 00:03:58,614
which is exactly what you see, right?
正如你看到的

99
00:03:58,614 --> 00:04:02,144
Your instructions get, the size of your code gets larger
你代码的大小会增加

100
00:04:02,435 --> 00:04:03,615
when you have to do these things.
当你需要做这些弯弯绕绕的时候

101
00:04:03,615 --> 00:04:06,036
Like if loading an immediate takes five instructions
比如用5条指令实现一个加载立即数

102
00:04:06,036 --> 00:04:08,016
and you want to load a hundred of them
而你想要加载一百个

103
00:04:08,016 --> 00:04:10,076
your code is getting this 5x increase.
你的代码会增加 5 倍

104
00:04:10,076 --> 00:04:11,437
So that actually may be slower
所以这可能会变慢

105
00:04:11,437 --> 00:04:13,818
because of caching and all this other stuff that has to happen
因为缓存和其他操作的影响

106
00:04:13,818 --> 00:04:15,699
and you don't get the benefits of like,
你无法获得

107
00:04:15,699 --> 00:04:18,038
especially like in a tight optimization loop
比如在一个高优化的循环中的好处

108
00:04:18,038 --> 00:04:20,430
you may not like the...
你可能

109
00:04:20,430 --> 00:04:23,791
Values and other things may not fit into L1 cache or the instruction cache
值和其他数据可能无法完整放入 L1 或指令缓存

110
00:04:23,850 --> 00:04:26,436
because it's getting flushed because the instructions are so large.
导致缓存频繁命中失败然后刷新

111
00:04:26,791 --> 00:04:28,632
This is why when building compilers
这就是为什么在构建编译器时

112
00:04:28,632 --> 00:04:30,533
it's very much an art rather than a science
这更像是一门艺术

113
00:04:30,533 --> 00:04:33,615
because depending on one person's workload
因为这取决于每个人的工作量

114
00:04:33,615 --> 00:04:35,055
it may be faster to do it one way
某种方法可能更快

115
00:04:35,055 --> 00:04:38,276
whereas another workload may be faster to do it a third way.
而另一种情况可能用第三种方法更快

116
00:04:42,697 --> 00:04:45,999
Is there ambient music on the stream or just me hallucinating again?
直播里有背景音乐吗 还是我又幻听了？

117
00:04:48,434 --> 00:04:50,375
i don't know i can't i have no way of testing that
我不知道 没法测试

118
00:04:50,375 --> 00:04:54,203
so hopefully it's a good hallucination that's what you're doing
希望这是个好的幻听 这就是你在做的

119
00:04:56,699 --> 00:04:57,692
should clarify that's on twitch
澄清一下，这是在 Twitch 上的留言。

120
00:04:57,779 --> 00:05:00,045
i'm not just hallucinating where that came from
不是我的幻觉

121
00:05:00,923 --> 00:05:01,644
okay other things
好的 其他事情

122
00:05:01,644 --> 00:05:02,764
i think the other thing that
我觉得另一件事是

123
00:05:04,071 --> 00:05:05,466
oh i don't really want to bring the slides
我其实不太想用幻灯片

124
00:05:05,466 --> 00:05:09,072
but uh another thing that um rob very graciously
不过 Rob非常慷慨

125
00:05:09,119 --> 00:05:11,526
is he here I said he would be here today.
他来了吗？本来答应今天来的

126
00:05:11,526 --> 00:05:13,485
So I was going to say what a great job he did
我本来想说他做得真不错

127
00:05:13,485 --> 00:05:14,307
but since he's not here
但既然他没来

128
00:05:14,307 --> 00:05:14,826
I won't say that.
我就不说了

129
00:05:16,327 --> 00:05:19,509
But specifically, there was a discussion of why is ARM so weird?
我们讨论了为什么 ARM 这么特别？

130
00:05:19,509 --> 00:05:23,320
So a lot of you have been learning and dealing with x86.
所以你们很多人都在学习和使用 x86

131
00:05:23,345 --> 00:05:24,771
So do you feel that ARM is weird?
所以你们觉得 ARM 特别吗？

132
00:05:26,331 --> 00:05:27,020
Why?
为什么呢？

133
00:05:27,432 --> 00:05:30,340
Besides the one we already talked about at 64 versus 32.
除了我们讨论过的 64 位和 32 位的区别外

134
00:05:37,883 --> 00:05:39,230
Yeah, there's no push or pop.
没错 没有 push 或 pop 操作

135
00:05:39,276 --> 00:05:39,879
That's weird.
真奇怪

136
00:05:39,879 --> 00:05:40,863
What other things are weird?
还有什么奇怪的地方？

137
00:05:44,702 --> 00:05:44,903
Yeah,
嗯

138
00:05:44,903 --> 00:05:45,504
but well, I mean
不过 我是说

139
00:05:45,504 --> 00:05:46,223
when you're coding
编程的时候

140
00:05:46,223 --> 00:05:48,466
does the length of the instructions have anything
汇编指令的长度

141
00:05:48,466 --> 00:05:49,427
when you're writing assembly?
在编写汇编时有影响吗？

142
00:05:51,089 --> 00:05:51,788
Maybe, maybe not,
可能有 也可能没有

143
00:05:51,788 --> 00:05:52,430
but yeah, what other...
不过 还有什么其他……

144
00:05:54,365 --> 00:05:55,987
Yeah, the stack has to be 16-bit aligned.
是的 栈必须 16 位对齐

145
00:05:55,987 --> 00:05:56,927
That is so weird.
这太奇怪了

146
00:05:56,927 --> 00:05:58,428
I don't fully understand why.
我不太明白为什么

147
00:05:58,428 --> 00:06:01,329
There must be some optimizations they can do because of that.
他们肯定基于这个做了一些优化

148
00:06:01,329 --> 00:06:03,629
But yeah, that's also weird.
但是 这也挺奇怪的

149
00:06:03,629 --> 00:06:04,149
What other things?
还有什么？

150
00:06:05,801 --> 00:06:09,432
Do you guys remember how the conditional flags are set?
你们还记得条件标志是怎么设置的吗？

151
00:06:15,245 --> 00:06:18,548
Yeah, there's a – so on x86, right
对 在 x86 上 就是这样

152
00:06:18,548 --> 00:06:20,730
every single add compare instruction
每条加法、比较指令

153
00:06:20,730 --> 00:06:22,868
will change the conditional flag registers.
都会改变条件标志寄存器

154
00:06:23,351 --> 00:06:24,692
On ARM, you have to –
在 ARM 上 你必须 –

155
00:06:24,692 --> 00:06:27,533
if you want an add to change the conditional registers
如果你想让加法指令改变条件寄存器

156
00:06:27,533 --> 00:06:29,855
you have to do the add S
你必须使用带 S 的加法指令，即ADDS

157
00:06:29,855 --> 00:06:31,916
which probably stands for set flags or something.
这可能是指设置标志 或类似的操作

158
00:06:32,956 --> 00:06:37,499
So every – Every addition, multiplication
所以 每次加法、乘法等操作

159
00:06:37,499 --> 00:06:41,999
these operations have an S variant added to the end that updates the flags
这些末尾加S 的变体指令，会更新标志位

160
00:06:41,999 --> 00:06:42,980
which I guess can be nice
我觉得这样挺好的

161
00:06:42,980 --> 00:06:44,379
because if you know you're already doing this
因为如果你知道要做这些操作

162
00:06:44,379 --> 00:06:45,399
you can update the flags
你就可以更新标志位

163
00:06:45,399 --> 00:06:48,661
and maybe the processor has to do less work on every add instruction
这样处理器在每个加法指令上可能就少做些工作

164
00:06:48,661 --> 00:06:50,060
when it doesn't have to update these flags.
在不需要更新标志位的时候

165
00:06:51,420 --> 00:06:52,793
So it gives more power.
这样就提供了更多的灵活性

166
00:06:53,302 --> 00:06:54,461
What other weird things?
还有什么其他奇怪的地方？

167
00:06:54,461 --> 00:06:55,274
To me, that's weird
我觉得这很奇怪

168
00:06:55,334 --> 00:06:56,278
because you're just used to these.
因为你已经习惯了这些

169
00:06:56,302 --> 00:06:57,341
You don't even think about the flags.
你甚至都不用想这些标志

170
00:06:57,341 --> 00:06:58,221
They just get set.
它们会自动设置

171
00:06:59,627 --> 00:07:00,423
Any other weird things?
还有其他奇怪的地方吗？

172
00:07:03,586 --> 00:07:05,181
Using the linking register.
使用链接寄存器

173
00:07:05,394 --> 00:07:06,801
Using the linking register.
使用链接寄存器

174
00:07:07,209 --> 00:07:07,990
Yeah, super weird.
是的 真奇怪

175
00:07:07,990 --> 00:07:11,736
Rather than pushing the stack also for pROPedure calls, right?
而不是在过程调用时也用栈 对吧？

176
00:07:11,932 --> 00:07:15,532
So the fact that registers are always passed into
寄存器总是被传入

177
00:07:15,557 --> 00:07:18,577
or parameters are always passed into the register is kind of weird.
参数总是传入到寄存器 这挺奇怪的

178
00:07:18,815 --> 00:07:21,456
And also weird that like the same first argument
而且很奇怪 传递给函数的第一个参数

179
00:07:21,456 --> 00:07:25,139
passed into the function is also the return thing
竟然也是返回值

180
00:07:25,139 --> 00:07:25,920
which I don't know
这一点我不太懂

181
00:07:25,920 --> 00:07:28,180
maybe there's some weird optimizations why that makes sense.
可能出于某些优化的考虑 所以才会这样设计

182
00:07:28,226 --> 00:07:31,886
But is there anything you'd like about ARM?
你们对 ARM 有什么喜欢的点吗？

183
00:07:37,393 --> 00:07:39,553
yeah cool 32-bit align. what else?
好，32位对齐，还有吗？

184
00:07:41,870 --> 00:07:43,810
loading multiple registers at the same time
同时加载多个寄存器

185
00:07:44,476 --> 00:07:48,383
Loading multiple registers with the STP and LDP
用 STP 和 LDP 指令加载多个寄存器

186
00:07:48,616 --> 00:07:49,866
right pairs of registers
是的，寄存器对

187
00:07:53,202 --> 00:07:55,507
disassembly is very easy because of this fact, right?
因为这个，反汇编都变简单了对吧？

188
00:07:55,507 --> 00:07:57,350
You don't have this madness
你不会遇到这种疯狂的情况

189
00:07:57,350 --> 00:08:01,733
where you have to guess about how long the instruction sizes are.
你不需要猜测指令的长度

190
00:08:01,733 --> 00:08:07,158
And then when you're doing the problem of identifying functions in a binary
在处理二进制文件中的函数识别问题时

191
00:08:07,158 --> 00:08:08,420
it makes it way easier
这会让事情简单很多

192
00:08:08,420 --> 00:08:11,723
because you can just know exactly where the instructions are.
因为你清楚地知道指令的位置

193
00:08:12,296 --> 00:08:12,785
Yeah.
对

194
00:08:12,785 --> 00:08:13,769
Anything else?
还有其他问题吗？

195
00:08:13,769 --> 00:08:16,990
Nobody likes the super, like
没有人喜欢

196
00:08:16,990 --> 00:08:17,870
I feel like this should, like
我觉得这应该

197
00:08:17,870 --> 00:08:20,531
speak to your computer science souls, that, like
会触动你们的计算机科学心灵

198
00:08:20,531 --> 00:08:23,250
the registers are just 0 through 31
寄存器命名直接从 0 到 31

199
00:08:23,250 --> 00:08:24,531
and they start at 0
并且从 0 开始

200
00:08:24,531 --> 00:08:26,752
and there's no weird names that you have to remember
没有那些奇怪的名字需要记住

201
00:08:26,752 --> 00:08:29,492
of, like, A, B, C, D,
像 先是A, B, C, D

202
00:08:29,492 --> 00:08:32,313
but then RSI and all these other registers,
然后 RSI 等其他寄存器

203
00:08:32,313 --> 00:08:32,894
RDI
RDI

204
00:08:32,894 --> 00:08:34,413
and the shit that doesn't make sense.
还有那些让人看不懂的东西

205
00:08:34,458 --> 00:08:36,495
Like, no, it's just, you know, X0 through X31
不 就是 X0 到 X31

206
00:08:36,495 --> 00:08:37,925
and these are your registers.
这些就是寄存器

207
00:08:38,125 --> 00:08:38,995
Does anybody else like that?
有人喜欢这样吗？

208
00:08:39,113 --> 00:08:42,240
Yeah, I was going to say the calling convention is really nice.
对 我想说调用约定很好

209
00:08:42,691 --> 00:08:47,232
Yeah, the calling convention being defined in the architecture,
我觉得架构中定义调用约定

210
00:08:47,232 --> 00:08:48,433
I think, is important, right?
很重要 对吧？

211
00:08:48,433 --> 00:08:49,914
Because if you've done x86
因为如果你用过 x86

212
00:08:49,914 --> 00:08:56,158
you know that the calling convention is different on Linux versus Windows.
你会知道 Linux 和 Windows 的调用约定不同

213
00:08:56,158 --> 00:08:58,759
And you can even in one project have different calling,
甚至在同一个项目中 也可以有不同的调用约定

214
00:08:58,759 --> 00:09:00,200
C calling conventions,
C 调用约定

215
00:09:00,200 --> 00:09:01,961
standard call, cdecl, all this stuff.
标准调用，cdecl调用 等等

216
00:09:01,961 --> 00:09:06,067
And it just makes interoperability really difficult.
这使得互操作性变得非常困难

217
00:09:06,355 --> 00:09:09,457
My guess is that's something that they learned from those architectures
我猜他们从中吸取了教训

218
00:09:09,457 --> 00:09:11,674
of how bad it is when you have different things.
不同的调用约定有多么糟糕

219
00:09:12,720 --> 00:09:15,841
Does anybody miss fights between Intel and AT&T syntax?
有人怀念 Intel 和 AT&T 语法之间的争斗吗？

220
00:09:17,581 --> 00:09:18,663
Yeah, there's no difference.
没什么区别

221
00:09:18,663 --> 00:09:19,964
It's just this is the way it is.
就是这样

222
00:09:19,964 --> 00:09:22,024
You want to do it another way?
你想换个方式吗？

223
00:09:22,024 --> 00:09:22,644
Just too bad.
太遗憾了

224
00:09:24,513 --> 00:09:25,667
Any other good thoughts?
还有其他好主意吗？

225
00:09:35,248 --> 00:09:36,249
The super long instructions?
超长的指令？

226
00:09:36,249 --> 00:09:38,230
You mean like having like 10 arguments?
你是说有 10 个参数？

227
00:09:41,561 --> 00:09:42,793
Yeah, that's like bonkers.
是的 那真够疯狂的

228
00:09:42,793 --> 00:09:43,454
I hate that part.
我讨厌这部分

229
00:09:43,528 --> 00:09:46,676
But it seems kind of ironic, right?
但这也挺讽刺的 对吧？

230
00:09:46,676 --> 00:09:49,898
Because you think like RISC Reduced Instruction Set Computing should mean
因为你觉得精简指令集应该是意味着

231
00:09:49,898 --> 00:09:54,041
that there's each thing does one simple thing and then it should be
每条指令只做一件简单的事

232
00:09:54,041 --> 00:09:56,129
but then you can have really complex instructions.
但却能有非常复杂的指令

233
00:09:56,303 --> 00:09:57,976
So why is it so weird?
所以它为什么这么奇怪呢？

234
00:09:58,124 --> 00:10:00,373
That was kind of the point I wanted to discuss.
这正是我想讨论的重点

235
00:10:03,524 --> 00:10:06,850
Because it's not x86, yes, I mean, that's correct.
因为这不是 x86 对 这是正确的

236
00:10:07,067 --> 00:10:07,907
But you could make
但是你可以做出

237
00:10:07,907 --> 00:10:09,388
has anybody done Yan85?
有人做过 Yan85 吗？

238
00:10:10,528 --> 00:10:13,931
Yan85 is not, I guess it's weird in its own way.
Yan85 也有它自己独特的地方 挺奇怪的

239
00:10:13,931 --> 00:10:15,472
Actually, it's probably more similar to ARM, but anyways.
其实它更像 ARM 不过算了

240
00:10:18,315 --> 00:10:19,375
So, like, why is it weird?
那为什么它这么奇怪呢？

241
00:10:25,463 --> 00:10:27,081
Ah, okay, familiarity.
啊 明白了 是因为熟悉

242
00:10:27,081 --> 00:10:28,062
I would definitely buy that.
我完全赞同

243
00:10:29,221 --> 00:10:29,702
That's cool.
挺好的

244
00:10:29,702 --> 00:10:30,462
I think there's actually, like
我觉得其实有

245
00:10:30,462 --> 00:10:32,404
a technical reason why this stuff is weird.
技术上的原因让这些显得奇怪

246
00:10:33,842 --> 00:10:35,787
Like, why is there an add and an adds?
比如说 为什么有 add 和 adds？

247
00:10:36,965 --> 00:10:40,678
Or why is there a load register, right?
或者为什么有加载寄存器 对吧？

248
00:10:40,858 --> 00:10:45,629
LDR, you could do the prefix, postfix, and memory dereferences,
LDR 可以处理前缀、后缀 还有内存解引用

249
00:10:45,629 --> 00:10:46,948
and register, like
还有寄存器

250
00:10:46,948 --> 00:10:49,250
you could do like five different things in like one instruction.
你可以在一条指令中做五种不同的操作

251
00:10:51,191 --> 00:10:55,714
This feels like ARM was made more to be created
感觉 ARM 更适合由机器生成

252
00:10:55,714 --> 00:10:58,448
rather than written by people.
而不是由人来编写

253
00:10:58,521 --> 00:10:59,495
Ah, interesting.
有趣

254
00:11:01,551 --> 00:11:02,519
I haven't thought about that
我以前没想过

255
00:11:02,519 --> 00:11:03,559
but that does make sense.
但确实有道理

256
00:11:03,559 --> 00:11:05,140
I mean, if you think about it, right?
我是说 仔细想想 对吧？

257
00:11:05,140 --> 00:11:08,462
Yeah, like assembly code should not be written by humans, just like
是的 汇编代码不应该由人类编写 就像……

258
00:11:08,970 --> 00:11:09,384
I don't know
我不知道

259
00:11:09,384 --> 00:11:10,644
has anybody done web stuff?
有人做过网页开发吗？

260
00:11:10,644 --> 00:11:13,426
Do you like hand write HTML code all the time?
你喜欢一直手写 HTML 代码吗？

261
00:11:14,547 --> 00:11:16,668
You can, but you can, you know
可以 但你可以

262
00:11:16,668 --> 00:11:17,828
shunt that off to something else
交给其他工具处理

263
00:11:17,828 --> 00:11:20,211
or you use an ORM wrapper that talks to the database
或者用 ORM 封装器与数据库通信

264
00:11:20,211 --> 00:11:22,172
so you don't have to write SQL, right?
这样你就不用写 SQL 了 对吧？

265
00:11:22,172 --> 00:11:25,674
This is kind of thinking out of the low level thing that you don't need.
这是不需要考虑底层细节的思维方式

266
00:11:25,674 --> 00:11:26,634
Another thing is like, okay
还有

267
00:11:26,634 --> 00:11:27,855
so there's no push and pop.
没有 push 和 pop 操作

268
00:11:27,855 --> 00:11:30,457
Why is there no push and pop in ARM?
为什么 ARM 里没有 push 和 pop 操作？

269
00:11:37,919 --> 00:11:39,100
you know you you
你知道的 你

270
00:11:39,100 --> 00:11:41,266
you have the equivalent of a push and pop right
你有类似 push 和 pop 的操作

271
00:11:41,700 --> 00:11:43,800
that auto increments the stack pointer
这会自动递增栈指针

272
00:11:49,664 --> 00:11:51,245
that you don't have to use the stack
你不需要直接用栈

273
00:11:57,594 --> 00:12:01,541
Yeah, so you can think like it's more abstract, I would say
是的 你可以认为 这更抽象

274
00:12:01,541 --> 00:12:04,446
rather than push and pop that sets dedicated register.
而不是像 push 和 pop 用专用寄存器

275
00:12:04,446 --> 00:12:07,892
You could technically use different registers to push and pop things, too.
你也可以使用不同的寄存器来执行 push 和 pop 操作

276
00:12:09,614 --> 00:12:11,787
ah great food twitch already got you guys
啊 Twitch 已经解决了你们的问题

277
00:12:11,887 --> 00:12:15,467
they're like 30 seconds behind this stream so
他们大概落后了这个直播 30 秒

278
00:12:15,494 --> 00:12:18,284
even though i won't i don't know if i want to say names on stream
我不确定要不要在直播时提名字

279
00:12:18,284 --> 00:12:19,585
but because this is well recorded
因为这会被录下来

280
00:12:19,585 --> 00:12:20,706
but uh
但

281
00:12:20,706 --> 00:12:22,407
yeah this person's hallucinating music
嗯 这个人幻听到音乐

282
00:12:22,407 --> 00:12:24,107
but still was able to get there
但还能跟得上

283
00:12:24,107 --> 00:12:26,548
it'd be a waste of four bytes right
浪费四个字节对吧

284
00:12:26,548 --> 00:12:29,110
every instruction is four bytes so
每条指令都是四个字节 所以

285
00:12:29,110 --> 00:12:32,023
if you had a push instruction that does one thing
如果你有一个只做一件事的push指令

286
00:12:33,027 --> 00:12:35,956
That takes up, like, from your, like, if you think
这会占用 如果你这么想

287
00:12:36,330 --> 00:12:37,428
if you think of, like
如果你想想

288
00:12:37,428 --> 00:12:40,370
what are all the different instructions you can encode in four bytes
所有可以用四个字节编码的不同指令

289
00:12:40,789 --> 00:12:43,110
Your limit, you can have two to the 32 technically
理论上 上限是 2 的 32 次方

290
00:12:43,110 --> 00:12:44,591
but you fundamentally can't have that.
但实际上你不可能有那么多

291
00:12:44,591 --> 00:12:46,468
So you can do things like with Yan85
所以你可以像 Yan85 那样处理

292
00:12:46,508 --> 00:12:49,234
where you have the first byte, which is
其中第一个字节用来

293
00:12:49,234 --> 00:12:51,550
defines which instruction it is, right?
定义这是哪条指令 对吧？

294
00:12:51,730 --> 00:12:54,255
So, but fundamentally, if you go that route
所以 如果你选择这样做 从根本上说

295
00:12:54,255 --> 00:12:56,716
you are wasting all the rest of the bytes
你会浪费掉

296
00:12:56,716 --> 00:12:58,437
that don't specify that instruction
不用于指定指令的其他字节

297
00:12:58,437 --> 00:13:00,220
because this push or this pop.
因为这些 push 或 pop 命令

298
00:13:00,220 --> 00:13:01,961
So this is really, in my view
依我看 这正是

299
00:13:01,961 --> 00:13:06,443
this is like the fundamental difference between x86 and ARM.
这是 x86 和 ARM 的根本区别

300
00:13:06,443 --> 00:13:09,576
Because you don't want to have these special purpose instructions
因为你不希望有这些专用指令

301
00:13:09,616 --> 00:13:13,836
like push or pop that are just for this one operation.
像push或pop这类只做某一操作的指令

302
00:13:14,116 --> 00:13:16,969
Because you're wasting an entire possibility
因为你会浪费掉一个机会

303
00:13:17,070 --> 00:13:18,630
that you could jam stuff in.
可以用来塞更多内容

304
00:13:18,630 --> 00:13:21,276
It's the same reason why you have add and add s.
这也是为什么有 add 和 add s

305
00:13:21,510 --> 00:13:23,494
Because you have an add instruction and everything else
已经有了add 和其他的指令

306
00:13:23,494 --> 00:13:24,894
but there's probably an extra bit there.
但可能还有一比特可用

307
00:13:24,894 --> 00:13:26,235
They're like, what are we going to do with this?
他们会想 这一比特怎么用？

308
00:13:26,235 --> 00:13:28,017
Like, well, let's make it useful and expose it.
嗯 让我们把它用起来

309
00:13:28,017 --> 00:13:28,917
Or like...
或者……

310
00:13:28,917 --> 00:13:30,483
The other thing that's crazy to me is like
还有一件让我觉得不可思议的是

311
00:13:30,508 --> 00:13:34,998
loading in constant values with left shifts a certain amount, right?
通过左移一定的位数加载常量值 对吧？

312
00:13:34,998 --> 00:13:39,259
That's just like efficient usage of the 32 bits that you have.
这样就能充分利用 32 位

313
00:13:39,259 --> 00:13:40,279
So this is like
所以这就像……

314
00:13:40,279 --> 00:13:42,740
it's like almost like a bin packing problem or something, right?
几乎就像是一个装箱问题 对吧？

315
00:13:43,260 --> 00:13:47,640
that the designers have to do of these RISC architectures.
这也是 RISC 架构设计师们需要考虑的

316
00:13:53,885 --> 00:13:55,501
Um, so anyways, that's kind of
嗯 总之

317
00:13:55,548 --> 00:13:56,661
I think that's why it's interesting
我觉得这就是为什么

318
00:13:56,714 --> 00:13:59,471
to think of these things as like the technical decision
把这些问题看成技术决策很有趣

319
00:13:59,471 --> 00:14:00,172
to be like, okay
就像是 好吧

320
00:14:00,172 --> 00:14:02,601
we will have four byte instructions
我们有四字节指令

321
00:14:02,847 --> 00:14:07,999
almost forces you to be efficient with the instructions that you have
这几乎迫使你更高效地使用现有的指令

322
00:14:07,999 --> 00:14:12,593
and have each instruction be as flexible as the bits that remain allow it to be.
 并且让每个指令尽可能灵活

323
00:14:12,682 --> 00:14:15,105
So you'll just tack on all this weird junk to it.
所以你就会给它加一堆奇怪的玩意儿

324
00:14:16,366 --> 00:14:16,687
Cool.
不错

325
00:14:17,768 --> 00:14:18,179
Okay.
行

326
00:14:18,345 --> 00:14:19,750
Any other questions or thoughts on that stuff?
关于这些内容还有其他问题或想法吗？

327
00:14:24,244 --> 00:14:26,985
Okay, now, is the screen black?
行 现在屏幕是黑的吗？

328
00:14:26,985 --> 00:14:28,096
I can't see what's going on.
我看不见发生了什么

329
00:14:28,307 --> 00:14:29,003
Okay, perfect.
行 完美

330
00:14:30,227 --> 00:14:33,250
Okay, so now it will be choose your own adventure.
行 现在选一下接下来的内容

331
00:14:33,309 --> 00:14:34,691
So I'm kind of still figuring out
我还在尝试弄清楚

332
00:14:34,691 --> 00:14:35,772
as you maybe saw last week
就像上周你们看到的

333
00:14:35,772 --> 00:14:37,922
I didn't even really know what the name of this class was.
我甚至都不知道这门课叫什么

334
00:14:38,254 --> 00:14:39,495
I only knew the AVR.
我只知道 AVR

335
00:14:40,674 --> 00:14:42,216
Well, I did have it write on the syllabus, but...
不过 我确实把课程名称写在了教学大纲上 但是……

336
00:14:43,236 --> 00:14:48,082
So the... Big thing that I'm trying to do is
所以 我努力做的……大事是

337
00:14:48,082 --> 00:14:53,268
figuring out how in the world to get you all access to a XNU system
正在想办法让大家能够访问到一个 XNU 系统

338
00:14:53,308 --> 00:14:54,827
 so that you can hack on it and stuff.
以便你们可以在上面进行破解等操作

339
00:14:58,441 --> 00:15:00,322
minimizing costs and getting everything to run so
尽量降低成本 让一切顺利运行

340
00:15:00,322 --> 00:15:03,166
hopefully I'll have that in a week or two or so
希望一两周内能够搞定

341
00:15:03,224 --> 00:15:06,385
so we're spending this time getting ready for ready for that
这段时间我们都在为此做准备

342
00:15:06,385 --> 00:15:10,248
and doing learning arm stuff or sorry
同时也在学习 ARM 相关内容

343
00:15:10,248 --> 00:15:11,648
yeah arms arm 64
是的 ARM64

344
00:15:11,648 --> 00:15:12,708
so today
所以今天

345
00:15:12,708 --> 00:15:14,850
and I think what I also want to do is make sure
我还想确保

346
00:15:14,850 --> 00:15:17,110
that you guys are getting some discussion
大家能够进行一些讨论

347
00:15:17,110 --> 00:15:21,052
and understanding of actual like applied vulnerability research
了解和实际应用中的漏洞研究

348
00:15:21,052 --> 00:15:23,514
right finding stuff on real targets
也就是在真实系统中找漏洞

349
00:15:23,514 --> 00:15:25,893
so I have basically two different topics today
今天我有两个主要话题

350
00:15:26,772 --> 00:15:27,912
that we're gonna cover.
我们今天会讲到

351
00:15:27,912 --> 00:15:28,993
One goal is ROP.
一个重点是 ROP

352
00:15:28,993 --> 00:15:30,693
So we're gonna look at ARM
我们会研究 ARM

353
00:15:30,693 --> 00:15:33,235
and do ROP ARM and study that.
并在 ARM 上进行 ROP 研究

354
00:15:34,315 --> 00:15:40,256
And then I also have a discussion slash lecture on target selection.
另外 我还会讨论如何选择目标

355
00:15:40,256 --> 00:15:43,538
So like how to go about even the first step
比如 如何开始第一步

356
00:15:43,538 --> 00:15:46,360
before you wanna try to find vulnerabilities in a real system.
在你尝试发现真实系统中的漏洞之前

357
00:15:46,360 --> 00:15:49,013
What system do you wanna find vulnerabilities in?
你想要在哪个系统中找漏洞？

358
00:15:49,541 --> 00:15:51,902
So I will, I don't know how to let you decide
我不知道如何让你们决定

359
00:15:51,902 --> 00:15:54,783
but I'll let you decide which one we wanna do first.
但你想让你们决定先说哪个

360
00:16:01,481 --> 00:16:02,091
What was that?
什么？

361
00:16:05,117 --> 00:16:05,871
I can't hear.
我听不见

362
00:16:07,757 --> 00:16:08,504
Oh, coin toss.
哦 抛硬币

363
00:16:08,551 --> 00:16:09,551
Oh, that's cool.
哦 挺不错的

364
00:16:09,577 --> 00:16:10,585
Anybody else have another idea?
还有人有别的主意吗？

365
00:16:11,726 --> 00:16:12,097
Yeah.
你说

366
00:16:13,306 --> 00:16:14,166
That's the same idea.
那是一样的想法

367
00:16:15,193 --> 00:16:16,567
They just slipped each other out.
他们只是没配合好

368
00:16:16,567 --> 00:16:17,219
Okay.
好的

369
00:16:17,933 --> 00:16:18,988
Which one do we want as which?
我们要哪个当哪个？

370
00:16:21,109 --> 00:16:24,370
Heads will be ROP and tails will be target selection.
正面是 ROP 反面是目标选择

371
00:16:25,431 --> 00:16:26,130
Siri, flip a coin.
Siri 抛个硬币

372
00:16:27,946 --> 00:16:28,800
It's tails.
是反面

373
00:16:29,413 --> 00:16:30,540
Oh, no, this one says it's tails
哦 不 这个说是反面

374
00:16:30,616 --> 00:16:31,577
but this one says it's heads
但这个说是正面

375
00:16:31,613 --> 00:16:32,486
so we have to do it again.
所以得再做一次

376
00:16:33,192 --> 00:16:34,819
Okay, this is insane.
这太离谱了

377
00:16:34,918 --> 00:16:36,113
Does anybody remember which one was which?
有人记得哪个是哪个？

378
00:16:37,499 --> 00:16:38,193
Head ROP?
正面是ROP？

379
00:16:38,879 --> 00:16:39,726
Head ROP, okay.
正面是ROP，好的

380
00:16:40,418 --> 00:16:40,960
Flip a coin.
抛硬币

381
00:16:42,659 --> 00:16:44,379
Heads, okay, so we're doing ROP first.
正面 好的 先讲ROP

382
00:16:44,819 --> 00:16:45,520
All right, cool.
好的 太棒了

383
00:16:48,321 --> 00:16:53,662
So, you will, okay
所以 你来 好的

384
00:16:53,662 --> 00:16:58,687
so the next module is going to be ARM
所以下一个模块是 ARM

385
00:16:58,687 --> 00:17:01,328
I should call it, ARM64 ROP, to be more specific.
我应该叫它 ARM64 ROP 这样更具体

386
00:17:01,328 --> 00:17:05,711
Okay, the first assignment will be ARM ROP, or the next assignment, sorry
好的 第一个任务是 ARM ROP 或者说是下个任务 抱歉

387
00:17:05,711 --> 00:17:07,334
because we already have one assignment.
因为我们已经有了一个任务

388
00:17:07,334 --> 00:17:08,795
This will launch at 8 p.m. tonight.
今晚 8 点启动

389
00:17:08,795 --> 00:17:10,796
I think that's kind of a decent cadence.
我觉得这个节奏还可以

390
00:17:10,796 --> 00:17:11,777
It'll launch at 8 p.m.
8 点启动

391
00:17:11,777 --> 00:17:13,218
and then do the next week.
然后是下一周

392
00:17:13,218 --> 00:17:16,381
We'll probably have two-week assignments, just depending on how long
我们可能会有两周一次的任务 具体取决于任务的长度

393
00:17:16,381 --> 00:17:18,623
and how difficult the things take.
以及任务的难度

394
00:17:18,623 --> 00:17:21,326
For this in particular...
这个任务尤其如此

395
00:17:22,284 --> 00:17:23,365
So it's a little bit tough
所以有点难

396
00:17:23,365 --> 00:17:26,747
and it's gonna be something that hopefully will be easier going forward
但希望以后会简单一些

397
00:17:26,747 --> 00:17:27,768
but you have to understand
但你得明白

398
00:17:27,768 --> 00:17:32,646
that you are running right now in Pwn College on an x86-64 host
你当前在 Pwn 学院的 x86-64 主机上运行

399
00:17:32,810 --> 00:17:35,506
but you will have an ARM binary that you need to pop.
但你需要运行一个 ARM 二进制文件

400
00:17:35,792 --> 00:17:36,826
That is the goal.
这就是目标

401
00:17:37,034 --> 00:17:39,800
So let's go in there.
那么让我们开始吧

402
00:17:40,926 --> 00:17:41,600
Okay.
好的

403
00:17:41,755 --> 00:17:44,346
So there should be some stuff in here about how to do this.
这里应该有一些关于如何操作的说明

404
00:17:44,435 --> 00:17:45,596
It actually is even more of a pain
实际上 这更麻烦

405
00:17:45,596 --> 00:17:47,636
because your favorite tools like object dump
因为你的常用工具 比如 objdump

406
00:17:47,636 --> 00:17:51,038
you can't even use correctly because object dump will say
你甚至不能正确使用 因为 objdump 会报错

407
00:17:51,038 --> 00:17:52,798
I don't understand this file format
不支持这种文件格式

408
00:17:52,798 --> 00:17:56,680
because the one you have installed is the one with your architecture.
因为你安装的是和你架构匹配的版本

409
00:17:56,680 --> 00:17:58,180
So you have to install other packages.
所以你需要安装其他包

410
00:17:58,180 --> 00:17:59,520
I should have installed everything in there
我本应该把所有东西都装上

411
00:17:59,520 --> 00:18:00,820
but like this is
但这次

412
00:18:00,820 --> 00:18:02,981
I think the first time we've done on pwn.college
我觉得这是我们第一次在pwn学院

413
00:18:02,981 --> 00:18:04,301
is like cross architecture stuff.
做跨架构的项目

414
00:18:04,301 --> 00:18:08,423
So I just solve a lot of insane problems that I really am upset about
所以我解决了很多让我很头疼的问题

415
00:18:08,423 --> 00:18:10,431
that I can talk to you about later.
这些问题我之后再和你细说

416
00:18:10,431 --> 00:18:12,392
It also means that debugging
这也意味着调试时

417
00:18:12,392 --> 00:18:14,193
and using GDB is a two-step process.
使用 GDB 要分两步进行

418
00:18:14,193 --> 00:18:19,376
You can't just GDB an ARM binary
你不能直接用 GDB 调试 ARM 二进制文件

419
00:18:19,376 --> 00:18:22,338
and expect GDB to somehow figure out magically what's going on.
期望 GDB 能神奇地搞清楚一切

420
00:18:23,480 --> 00:18:24,880
So we'll go over that real quickly.
我们很快就会讲到这一点

421
00:18:24,880 --> 00:18:30,436
So what we'll do is I'll start off with how to get started in this thing.
我先讲讲如何开始这个过程

422
00:18:31,816 --> 00:18:33,957
And then we'll go to slides
然后进入幻灯片

423
00:18:33,957 --> 00:18:36,136
talk about like how to even approach this
讨论如何入手这个问题

424
00:18:36,136 --> 00:18:37,738
why it's different than x86.
为什么它与 x86 不同

425
00:18:38,917 --> 00:18:42,350
You should all have already experienced using ROP on x86-64
你们都应该在 x86-64 上使用过 ROP

426
00:18:42,383 --> 00:18:43,878
so that should be very familiar.
所以应该都很熟悉

427
00:18:43,878 --> 00:18:45,720
The goal here is to then
这里的目标是

428
00:18:45,720 --> 00:18:47,519
and really the goal of this course is to try to
这门课程的真正目标是

429
00:18:48,443 --> 00:18:49,701
abstract your knowledge away
提炼你的知识

430
00:18:49,701 --> 00:18:51,901
from just the one thing that you know, right?
把你已知的抽象出来

431
00:18:51,901 --> 00:18:53,942
You know ROP on x86
你了解 x86 上的 ROP 对吧？

432
00:18:53,942 --> 00:18:55,202
but what is ROP, right?
但 ROP 是什么呢？

433
00:18:55,202 --> 00:18:57,082
What does that fundamental thing mean?
这个基本概念意味着什么？

434
00:18:57,082 --> 00:19:00,252
How do differences in the architecture take
不同的架构如何影响

435
00:19:00,252 --> 00:19:02,755
how differently you approach exploiting this stuff.
你利用这些漏洞的方法？

436
00:19:04,497 --> 00:19:05,217
And then we'll go back.
然后我们再回到这个问题

437
00:19:05,217 --> 00:19:07,199
I also found a CTF challenge.
我还找到了一个 CTF 挑战

438
00:19:07,199 --> 00:19:09,340
I was thinking it'd be fun to hack together for a while
我觉得我们可以花点时间一起来破解这个二进制文件

439
00:19:09,340 --> 00:19:10,280
and break this binary.
这会很有趣

440
00:19:10,280 --> 00:19:13,123
It's supposed to be a very simple ARM binary that we can go to
这是一个简单的 ARM 二进制文件 我们可以用来练习

441
00:19:13,123 --> 00:19:15,204
because I don't want to spoil your fun
我不想破坏你的乐趣

442
00:19:15,204 --> 00:19:16,746
by showing you how to do any of this stuff
我不想展示这些

443
00:19:16,746 --> 00:19:18,370
because I expect you to do that on your own.
我希望你自己搞定

444
00:19:19,463 --> 00:19:20,146
All right.
好的

445
00:19:20,368 --> 00:19:21,883
And then let's see.
我们来看看

446
00:19:21,990 --> 00:19:25,093
Oh, this is a super giant class that I've like long in time-wise
哦 这是一门超长的课程

447
00:19:25,093 --> 00:19:26,433
that I've never taught this long before.
我从没上过这么长时间的课

448
00:19:26,433 --> 00:19:27,875
So I have absolutely no idea how this is going to go.
所以我完全不知道会怎么样

449
00:19:29,200 --> 00:19:31,110
We started at 4.30.
我们从 4 点半开始

450
00:19:31,336 --> 00:19:33,721
Let's do set a timer for a half hour.
我们设个半小时的计时器吧

451
00:19:35,584 --> 00:19:39,733
That way we can take like a bio break in a half hour.
这样半小时后我们就可以休息一下

452
00:19:40,332 --> 00:19:40,580
Okay.
行

453
00:19:42,428 --> 00:19:42,768
Cool.
行 酷

454
00:19:42,768 --> 00:19:42,989
Okay.
明白了

455
00:19:44,329 --> 00:19:45,069
So this is hidden.
这个是隐藏的

456
00:19:45,069 --> 00:19:45,871
You can't see this
你看不到这个

457
00:19:45,871 --> 00:19:47,290
so don't bother doing it.
所以别浪费时间

458
00:19:47,290 --> 00:19:49,730
Also, it turns out it's a really bad idea when you tell like 20, 30
另外 让 二三十个学生同时开始挑战

459
00:19:49,850 --> 00:19:52,214
100 students to all start a challenge at the same time.
或者 100 个学生一起开始，真是个坏主意

460
00:19:52,214 --> 00:19:54,023
The dojo can't quite handle that yet.
道场还应付不来

461
00:19:54,556 --> 00:19:55,967
We're working on it.
我们正在努力解决

462
00:19:56,365 --> 00:19:58,546
Actually, technically we should have a fix by Friday
事实上 我听说最晚周五就能修复这个问题

463
00:19:59,360 --> 00:20:01,634
is what I've been told.
这是我被告知的

464
00:20:02,148 --> 00:20:03,654
Practice mode doesn't work on this.
练习模式在这儿不行

465
00:20:04,049 --> 00:20:05,026
I'm not sure exactly why.
我不太清楚为什么

466
00:20:05,106 --> 00:20:07,586
It's something that I'm going to complain to Connor about to fix.
我会找康纳抱怨 让他修

467
00:20:09,972 --> 00:20:14,626
I can get into all the nitty gritty gory details, but okay.
我可以讲得更详细 不过就算了

468
00:20:14,855 --> 00:20:16,176
Do you all care about, like
你们在乎这些问题吗？

469
00:20:16,176 --> 00:20:17,778
I feel like you guys are experienced enough.
我觉得你们经验足够了

470
00:20:17,778 --> 00:20:21,213
I can use SSH and not have to worry about this stupid GUIs and stuff.
我可以直接用 SSH 不用管这些麻烦的界面

471
00:20:21,380 --> 00:20:22,280
Okay, cool.
好的 挺好的

472
00:20:24,761 --> 00:20:25,122
Cool.
好的

473
00:20:25,122 --> 00:20:26,103
So I started my challenge.
我开始了挑战

474
00:20:27,940 --> 00:20:28,901
Wow, okay.
哇 行

475
00:20:30,501 --> 00:20:32,649
Okay, similar thing, everything's in challenge.
好的 一切都包含在挑战中

476
00:20:32,761 --> 00:20:37,674
The binary will be in level whatever whatever, level dash one dash zero.
二进制文件在level-xx-xx 比如 level-1-0

477
00:20:37,782 --> 00:20:40,404
The zeros have a little walkthrough, a little teaching
后面是0的会有一些引导和教程

478
00:20:40,404 --> 00:20:42,797
and the ones are slightly different.
是1的稍微有所不同

479
00:20:43,324 --> 00:20:46,925
This run, can you all read that, you in the back?
这次运行 大家都能看到吗 后面的也能看到？

480
00:20:48,205 --> 00:20:48,910
Read screen?
看看屏幕

481
00:20:49,286 --> 00:20:50,477
Good, okay.
好的 行

482
00:20:50,705 --> 00:20:55,123
Yeah, this just executes the emulator and executes the challenge.
是的 这会运行模拟器并执行挑战

483
00:20:55,268 --> 00:20:56,688
So there shouldn't be anything there.
所以那里不会有别的什么了

484
00:20:57,982 --> 00:21:00,284
I think I did this all correctly by clearing the environment
这样做应该能清空环境变量

485
00:21:00,284 --> 00:21:00,865
and all this stuff
以及相关内容

486
00:21:00,865 --> 00:21:02,798
because there's weird QEMU variables
因为有一些奇怪的 QEMU 变量

487
00:21:02,825 --> 00:21:04,626
you can set to get debugging as we'll show you.
你可以设置，以用于调试。 之后会展示

488
00:21:04,626 --> 00:21:05,906
So hopefully that's not there
所以希望那里没有这些变量

489
00:21:05,906 --> 00:21:07,548
but if you find a bypass
但如果你发现了绕过的方法

490
00:21:07,548 --> 00:21:08,909
please let me know right away.
请马上告诉我

491
00:21:08,909 --> 00:21:11,369
The point is to have fun and do this stuff.
重点是享受过程并完成这些任务

492
00:21:12,730 --> 00:21:15,163
Okay, so if we just run it
好的 如果我们直接运行

493
00:21:15,352 --> 00:21:16,712
this should be very
这应该非常……

494
00:21:16,712 --> 00:21:21,914
I think this is very similar to the x86-64 ROP challenges.
我觉得这和 x86-64 的 ROP 挑战很像

495
00:21:23,276 --> 00:21:24,737
I will probably add...
我打算再加几个...

496
00:21:25,865 --> 00:21:28,166
I think there's like four or five other challenges I will add
我可能再加四个或者五个挑战

497
00:21:28,191 --> 00:21:31,665
that will be pretty cool and fun to show you some differences.
来展示一下不同之处，那会很有趣

498
00:21:31,975 --> 00:21:34,932
One with like a statically linked binary with like thousands of gadgets
一个静态链接的二进制文件里有成千上万的gadget

499
00:21:34,932 --> 00:21:39,396
that you have to figure out how to tweak your way through.
你得想方设法排列好它们

500
00:21:41,038 --> 00:21:42,599
And then one with a different compiler
还有一个用了不同编译器的

501
00:21:42,599 --> 00:21:44,381
because we'll talk about that in a second.
稍后我们会讨论这个

502
00:21:44,381 --> 00:21:46,623
So anyways, there's a win function.
总之 这里有一个win函数

503
00:21:47,943 --> 00:21:49,306
The win function address is here.
win 函数的地址就在这里

504
00:21:49,306 --> 00:21:50,866
You need to call that function.
你需要调用这个函数

505
00:21:52,888 --> 00:21:55,750
We need to overflow the saved return address.
我们需要覆盖保存的返回地址

506
00:21:55,750 --> 00:21:58,691
So again, this is and we'll look at this in a second
所以 我们一会儿再详细讲

507
00:21:58,691 --> 00:22:02,873
but this is on The calling convention, right?
这涉及调用约定 对吧？

508
00:22:02,873 --> 00:22:04,792
So we have a BL call
所以我们有一个 BL 调用

509
00:22:04,792 --> 00:22:08,720
which go which redirects control flow usually to the start of a function
它通常将控制流重定向到函数的开头

510
00:22:08,934 --> 00:22:11,974
and will store the return address in the register X30
 并把返回地址存储在寄存器 X30 中

511
00:22:12,516 --> 00:22:15,533
and Then when the program wants to when the function is done
然后当函数执行完毕后

512
00:22:15,676 --> 00:22:19,100
it calls a ret to return back to register X 30
它调用 ret 返回到寄存器 X 30

513
00:22:20,107 --> 00:22:24,680
Okay So here, 139 bytes
好的 这里有 139 个字节

514
00:22:24,739 --> 00:22:27,701
means you need at least 147, yada, yada, yada.
意味着你需要至少 147 个字节 等等

515
00:22:27,701 --> 00:22:29,782
I'm sure you all read this very in-depth every single time
我相信你们每次都读得很仔细

516
00:22:29,782 --> 00:22:31,322
and don't just do something like this.
不要随便这么做

517
00:22:33,208 --> 00:22:33,988
Okay, great.
好的 很好

518
00:22:34,185 --> 00:22:36,341
And it does the printing of the ROP gadgets.
它会打印出 ROP gadget

519
00:22:36,468 --> 00:22:38,750
It's actually, as we'll talk about in a second
实际上 我们待会儿会讨论

520
00:22:38,750 --> 00:22:40,608
this is actually kind of not super helpful.
这实际上不是特别有帮助

521
00:22:40,912 --> 00:22:43,594
This kind of can be helpful for your first one
这种对于你第一次来说可能会有帮助

522
00:22:43,594 --> 00:22:46,496
but as you will find
不过你会发现

523
00:22:46,496 --> 00:22:51,283
your ROP payloads are very different on ARM rather than x86.
在 ARM 上 你的 ROP 代码与 x86 有很大区别

524
00:22:52,730 --> 00:22:55,051
So I crashed it, got a segmentation fault.
于是我把它搞崩溃了 出现了一个段错误

525
00:22:55,051 --> 00:22:55,632
Awesome.
太棒了

526
00:22:55,632 --> 00:22:56,511
If I pop this
如果我能pop它

527
00:22:56,511 --> 00:22:58,073
I should get the flag and it should be good.
我应该能拿到flag 应该没问题

528
00:22:59,393 --> 00:23:00,191
Some tools.
一些工具

529
00:23:01,794 --> 00:23:02,953
I have to go copy this
我得复制这个

530
00:23:02,953 --> 00:23:05,035
because I do not recall this exact thing.
因为我记不清这个具体的了

531
00:23:06,434 --> 00:23:06,775
All right.
好的

532
00:23:12,396 --> 00:23:14,849
objdump -d for disassemble.
用objdump反汇编

533
00:23:15,278 --> 00:23:18,356
And then I can look at this whole big guy.
然后我能看看整个内容

534
00:23:19,198 --> 00:23:22,098
And then I can get into the habit of reading ARM code
然后我可以开始熟悉读 ARM 代码

535
00:23:22,098 --> 00:23:24,019
which is part of what you're learning here.
这是你们在这里要学的

536
00:23:25,560 --> 00:23:29,384
So setting up the stack frame, subtracting B0 from the stack frame,
设置栈帧 减去 B0

537
00:23:29,651 --> 00:23:32,433
storing X29 and X30.
存储 X29 和 X30

538
00:23:32,765 --> 00:23:33,765
Why is it doing this store?
为什么要存储？

539
00:23:39,218 --> 00:23:40,338
And the link register.
还有链接寄存器

540
00:23:40,588 --> 00:23:42,289
So again, another x86 difference, right?
这是 x86 的另一个区别 对吧？

541
00:23:42,289 --> 00:23:46,991
In what usually takes two or three instructions for x86-64 to do.
通常 x86-64 需要两到三条指令

542
00:23:48,133 --> 00:23:48,893
This does it in one.
这里用一条指令就完成了

543
00:23:50,269 --> 00:23:51,891
Does that really matter for performance?
这对性能真的有影响吗？

544
00:24:00,919 --> 00:24:02,180
Yeah, maybe.
嗯 也许吧

545
00:24:02,180 --> 00:24:03,161
I mean, it really depends.
这得看具体情况

546
00:24:03,161 --> 00:24:06,462
You have to get down into lower, like, micro-architectural things.
你得深入到微架构层面

547
00:24:08,204 --> 00:24:11,666
If you learned MIPS and the MIPS pipeline, you would see, like, well, yes
如果你学过 MIPS 和它的流水线 就会明白确实如此

548
00:24:11,666 --> 00:24:15,390
if you can do in one instruction what it takes three instructions to do
如果一条指令能完成三条指令的工作

549
00:24:15,390 --> 00:24:17,570
that one instruction will definitely be faster.
那这条指令肯定会更快

550
00:24:17,570 --> 00:24:18,570
Because with three instructions
因为三条指令

551
00:24:18,570 --> 00:24:19,971
you have to have three things in the pipeline
流水线中要处理三件事情

552
00:24:19,971 --> 00:24:21,392
and worry if they invalidate things
还得担心它们会使某些东西失效

553
00:24:21,392 --> 00:24:23,971
and things can just go slower that way.
这样就会更慢

554
00:24:25,212 --> 00:24:29,292
The unfortunate truth is on modern hardware, all of this stuff
不幸的是 在现代硬件上，这些东西

555
00:24:29,292 --> 00:24:31,054
probably even on ARM
甚至在 ARM 上也一样

556
00:24:31,054 --> 00:24:32,153
I actually don't know for a fact
我也不确定

557
00:24:32,153 --> 00:24:34,405
but I'm positive they probably do something like this
但我相信他们也会这样做

558
00:24:34,614 --> 00:24:37,335
gets compiled down into micro-code that gets executed.
会被编译成微代码来执行

559
00:24:37,335 --> 00:24:41,715
So even what is three instructions or one instruction on x86-64
所以 即使是 x86-64 上的三指令或一指令

560
00:24:41,715 --> 00:24:44,797
may get compiled down to like 10 instructions
也可能被编译成 10 条指令

561
00:24:44,797 --> 00:24:47,454
or 10 micro instructions that are doing stuff.
或者是 10 条微指令

562
00:24:47,454 --> 00:24:51,014
And that actually enables the CPU to do things out of order and crazy things
这使得 CPU 能够乱序执行和其它疯狂的事

563
00:24:51,053 --> 00:24:52,838
as long as what you see in the caches
只要缓存中的内容

564
00:24:52,838 --> 00:24:54,947
is all consistent based on the architecture.
与架构保持一致

565
00:24:55,099 --> 00:24:56,767
So this is why it's super hard to say like,
所以很难说

566
00:24:57,102 --> 00:25:00,314
look, one instruction versus three instructions. This is clearly better.
一条指令比三条指令更好

567
00:25:00,445 --> 00:25:02,665
It's like, that's not really the world we live in.
现实不是这样

568
00:25:02,665 --> 00:25:04,567
And so you just have to run experiments
所以你只能通过实验来验证

569
00:25:04,567 --> 00:25:08,309
and then what you measured is true for that CPU
然后你的测量结果只适用于那款 CPU

570
00:25:09,691 --> 00:25:13,834
which may not abstract or be applied.
这些结果可能无法应用于其他地方

571
00:25:15,033 --> 00:25:15,473
Okay.
好的

572
00:25:16,868 --> 00:25:17,169
Cool.
酷

573
00:25:17,169 --> 00:25:17,409
Okay.
好的

574
00:25:17,409 --> 00:25:18,809
So yeah, storing those things.
所以 把这些东西存起来

575
00:25:18,809 --> 00:25:19,230
Cool.
酷

576
00:25:19,230 --> 00:25:19,590
Okay.
行

577
00:25:19,590 --> 00:25:21,011
So now we can look at stuff.
现在我们可以看看这些东西

578
00:25:21,011 --> 00:25:27,496
I guess I did want to show you the workspace just because...
我想展示一下工作区 因为……

579
00:25:28,777 --> 00:25:29,536
Wait, what?
等一下 什么？

580
00:25:31,077 --> 00:25:31,999
Wait, how am I seeing this?
等等 我怎么能看到这个？

581
00:25:31,999 --> 00:25:32,936
Are you guys seeing this?
你们看到这个了吗？

582
00:25:33,880 --> 00:25:34,863
Did I get logged out?
我是不是登出了？

583
00:25:35,421 --> 00:25:35,941
Yeah, whatever.
嗯 随便啦

584
00:25:35,941 --> 00:25:36,153
Okay.
行

585
00:25:37,481 --> 00:25:39,781
The other thing that's really annoying is
还有件烦人的事

586
00:25:40,974 --> 00:25:43,801
 there's only like two decompilers installed.
这里只装了两个反编译器

587
00:25:45,992 --> 00:25:46,932
Good old IDA.
还是那个 IDA

588
00:25:46,932 --> 00:25:47,801
Anybody use IDA?
有人用 IDA 吗？

589
00:25:49,374 --> 00:25:50,314
Yeah.
有

590
00:25:50,314 --> 00:25:51,314
There's a problem with IDA.
IDA 有个问题

591
00:25:55,154 --> 00:25:56,635
Anybody know what it is before I click ok
有人知道是什么问题吗 在我点ok之前

592
00:26:02,074 --> 00:26:03,747
It doesn't have any arm.
它不支持 ARM

593
00:26:04,054 --> 00:26:07,097
The free version of IDA is only x86 and x86 64.
IDA 的免费版只支持 x86 和 x86-64

594
00:26:08,558 --> 00:26:09,513
So that sucks.
这真是太糟糕了

595
00:26:10,193 --> 00:26:13,340
I don't know what to tell you, but...
我也不知该怎么说了 但是……

596
00:26:15,037 --> 00:26:18,278
So anyways, it will not work on Pwn College on these challenges.
总之 它在 Pwn College 上的这些挑战行不通

597
00:26:18,278 --> 00:26:20,884
You can, actually for a lot of these you can use objdump.
其实这里很多情况，你都可以用 objdump

598
00:26:21,298 --> 00:26:23,438
Apparently Ghidra works.
看来 Ghidra 可以用

599
00:26:26,131 --> 00:26:28,020
angr management does not it hasn't been Nixified.
angr管理还没有被 Nix 化

600
00:26:29,477 --> 00:26:30,757
I definitely agree.
我完全同意

601
00:26:33,290 --> 00:26:36,476
see, build NIX.
看，build Nix

602
00:26:37,063 --> 00:26:44,300
Anyways, that's the big problem is they needed to get the ability to,
总之 最大的问题就是他们需要获得这样的能力来...

603
00:26:46,209 --> 00:26:46,888
Like for this
比如这个

604
00:26:46,888 --> 00:26:48,631
I needed special libraries installed
我需要安装特定的库

605
00:26:48,631 --> 00:26:53,212
and special like the QEMU emulator and all that stuff.
比如 QEMU 模拟器等工具

606
00:26:53,212 --> 00:26:55,864
And so rather than going in and installing it
所以与其进入环境逐一安装它们

607
00:26:55,904 --> 00:26:59,577
so that it's on every single Pwn College challenge that ever gets launched
让每个Pwn College 的挑战无论何时启动都能配备

608
00:26:59,577 --> 00:27:02,110
we now have the ability to define your own Docker container
我们现在可以定义自己的 Docker 容器

609
00:27:02,135 --> 00:27:05,050
that I can say these challenges need this Docker container.
我可以指定这些挑战需要这个 Docker 容器

610
00:27:05,300 --> 00:27:08,390
But you also want things like this interface and everything.
但你还想要这样的界面和其他功能

611
00:27:08,437 --> 00:27:09,304
And you don't want to have to...
你肯定不想...

612
00:27:10,254 --> 00:27:12,096
Oh, man, Connor's going to if he hears this
康纳要是听见了...  他一定会发飙

613
00:27:12,096 --> 00:27:13,277
don't in any way tell him
千万别告诉他

614
00:27:13,277 --> 00:27:15,936
because this is me regurgitating all the good stuff
因为我现在在讲好的部分

615
00:27:15,936 --> 00:27:17,217
because this next thing is terrible.
接下来可就糟了

616
00:27:17,217 --> 00:27:19,218
But it has a lot of great benefits
但它有很多优点

617
00:27:19,218 --> 00:27:23,738
where you can still get this X server
你还是可以使用这个 X 服务器

618
00:27:23,738 --> 00:27:24,738
and all this stuff in here
还有这里的所有内容

619
00:27:24,738 --> 00:27:26,179
which I didn't have to install in my container.
这些都不用安装在我的容器中

620
00:27:26,179 --> 00:27:29,598
My container is literally just ubuntu 2404 base
我的容器就是基于ubuntu 2404

621
00:27:29,598 --> 00:27:31,180
installed the things I need
装了我需要的东西

622
00:27:31,180 --> 00:27:32,079
and you can do that here.
你也可以在这里这样设置

623
00:27:32,079 --> 00:27:36,099
Anyways, so eventually we'll get those other tools ready to go.
不管怎样 我们最终会把这些其他工具准备好

624
00:27:36,099 --> 00:27:36,859
New project.
新项目

625
00:27:38,520 --> 00:27:40,013
Oh, God, I hate this stuff.
哦 天哪 我真讨厌这些

626
00:27:40,147 --> 00:27:40,607
project
项目

627
00:27:44,013 --> 00:27:49,977
sorry i'm just trying to be a good person to show you how to use this
我只是想做个好人，展示一下怎么用这个

628
00:27:55,099 --> 00:28:02,506
 open import yep
打开 导入？ 是的

629
00:28:03,891 --> 00:28:05,030
This is why it's so difficult.
这就是为什么这么难

630
00:28:05,030 --> 00:28:06,051
Don't learn anything new.
不要学新东西

631
00:28:06,051 --> 00:28:08,311
Just learn something and just get used to that forever.
学一点东西 然后一直用下去

632
00:28:08,311 --> 00:28:10,670
Use it for the rest of your life and never learn anything new.
用一辈子 别学新东西

633
00:28:11,333 --> 00:28:11,953
That's my advice.
这是我的建议

634
00:28:31,579 --> 00:28:32,140
Oh, I didn't.
哦 我没...

635
00:28:36,885 --> 00:28:37,826
It's not been analyzed.
还没分析过

636
00:28:37,826 --> 00:28:38,567
Would you like to...
你想...？

637
00:28:38,567 --> 00:28:39,906
No, I would just like to look at the binary.
不 我想看0101

638
00:28:39,906 --> 00:28:42,066
Of course I want you to analyze it.
我当然想让你分析一下

639
00:28:44,449 --> 00:28:44,868
Oh, come on.
拜托了

640
00:28:47,569 --> 00:28:48,470
Hey, okay.
嘿 行

641
00:28:48,470 --> 00:28:48,809
There we are.
好了

642
00:28:49,910 --> 00:28:51,056
Wait, why does this font look weird?
等等 这字体怎么怪怪的？

643
00:28:51,171 --> 00:28:52,236
Is this how it always looks?
它一直都是这样吗？

644
00:28:54,011 --> 00:28:54,711
Is it really?
真的吗？

645
00:28:54,711 --> 00:28:55,243
Oh, God.
哦 天啊

646
00:28:56,272 --> 00:28:56,863
I'm so sorry.
真对不起

647
00:28:56,992 --> 00:28:58,053
Some people get used to this
有些人习惯了

648
00:28:58,053 --> 00:28:59,603
and I don't understand why
我也不明白为什么

649
00:28:59,713 --> 00:29:06,195
but I respect people's ability to get...
但我尊重大家能习惯这点

650
00:29:06,195 --> 00:29:06,783
Okay.
好吧

651
00:29:07,147 --> 00:29:08,867
I mean, I do kind of like them side by side
我觉得这样并排显示也挺好的

652
00:29:08,867 --> 00:29:09,468
but I don't know.
但我也说不准

653
00:29:09,468 --> 00:29:10,689
You just get so used to IDA.
你们对 IDA 已经非常习惯了

654
00:29:10,689 --> 00:29:12,108
Anyways, so there you go.
就这样了

655
00:29:12,108 --> 00:29:15,933
You have the disassembly on the right, the assembly on the left.
右边是反汇编 左边是汇编

656
00:29:16,089 --> 00:29:17,710
No, I guess we can use angr management.
我们可以试试angr

657
00:29:17,710 --> 00:29:20,750
Is Zion, no, Zion's not here
齐昂不在这里

658
00:29:20,750 --> 00:29:23,802
but let's see.
我们来看看

659
00:29:24,211 --> 00:29:26,570
There should be a decompiler on the command line here.
命令行里应该有个反编译器

660
00:29:35,192 --> 00:29:36,472
We'll just do all the functions.
我们来反编译所有函数

661
00:29:40,075 --> 00:29:41,035
There's no way this is going to work.
这肯定不行

662
00:29:49,238 --> 00:29:49,978
What do you think?
你觉得呢？

663
00:29:50,003 --> 00:29:51,578
Should we put bets? Is it going to work?
打个赌吗？赌一下这能行吗？

664
00:29:54,398 --> 00:29:54,838
Errors.
出错了

665
00:29:54,838 --> 00:29:55,719
Always great to see.
看到这总是挺好的

666
00:29:59,640 --> 00:30:00,619
This is when you kill it
这就该结束了

667
00:30:00,619 --> 00:30:02,861
because you realize this was a terrible idea and you go
因为你意识到这是个坏主意 然后你这么做

668
00:30:14,660 --> 00:30:16,502
Adam burning up the, hey, that actually worked.
亚当耗 嘿 居然成功了

669
00:30:16,502 --> 00:30:17,366
Okay, cool.
行 真酷

670
00:30:17,502 --> 00:30:19,444
So anyways, angr management doesn't work
总之 angr management图形界面不起作用

671
00:30:19,444 --> 00:30:22,325
but angr is installed and you can get some kind of, you know
但angr已经安装了 你可以用来 你知道的

672
00:30:22,325 --> 00:30:24,707
everyone knows C looks exactly like this.
大家都知道 C 就是这样写的

673
00:30:24,707 --> 00:30:25,768
And this is valid C.
这是有效的 C 代码

674
00:30:27,369 --> 00:30:28,309
But you can, let's see
但你可以 我们来看看

675
00:30:28,309 --> 00:30:29,964
can you even see the buffer here?
你在这里能看到缓冲区吗？

676
00:30:31,051 --> 00:30:32,172
So there should be a read.
所以应该有个读取操作

677
00:30:32,172 --> 00:30:33,152
I'm just looking for a read.
我就是在找读取操作

678
00:30:33,152 --> 00:30:35,360
Yeah, read into V1.
对 读取到 V1 中

679
00:30:35,694 --> 00:30:38,373
V1 is the address of V4.
V1 是 V4 的地址

680
00:30:40,199 --> 00:30:42,373
And V4 must be on the stack.
V4 应该在栈上

681
00:30:42,926 --> 00:30:48,460
And V4, BP minus hex 93.
V4 的地址是 BP 减 0x93

682
00:30:48,460 --> 00:30:50,881
So we actually do roughly know
所以我们对它大致有了解

683
00:30:50,881 --> 00:30:52,902
like this actually gives us enough information about
这些信息已经足够了

684
00:30:52,902 --> 00:30:54,643
where this is on the stack in relation
它在栈上的具体位置

685
00:30:54,643 --> 00:30:56,303
so we should be able to pop this.
所以我们应该可以pop它

686
00:30:56,745 --> 00:30:58,045
Let's double check that
我们再确认一下

687
00:30:58,078 --> 00:31:06,531
that I can't do in my head conversions between binary and hex yet.
我还不能在脑子里快速转换二进制和十六进制

688
00:31:07,951 --> 00:31:09,132
And then what did the challenge say?
那么挑战中怎么说的？

689
00:31:10,333 --> 00:31:12,693
Did it say that it was 197?
它说的是 197 吗？

690
00:31:13,858 --> 00:31:14,679
Look at that.
来看看这个

691
00:31:14,778 --> 00:31:16,678
Hey, angr management got something right.
嘿 angr management这次居然做对了

692
00:31:18,239 --> 00:31:19,819
Don't count on it though.
不过别指望它

693
00:31:19,819 --> 00:31:20,059
Okay.
好的

694
00:31:21,419 --> 00:31:24,300
Okay, so clear how to use it or start it.
好的 知道如何启动它了

695
00:31:24,300 --> 00:31:25,940
Okay, wait, I guess let me show you one more way.
好的 等一下 我再给你演示一种方法

696
00:31:28,421 --> 00:31:30,061
Just in case nobody's ever showed this to you.
万一之前没人给你演示过

697
00:31:34,041 --> 00:31:36,842
So I'm using SCP secure copy uses SSH.
所以我用 SCP（安全复制） 它用 SSH

698
00:31:36,842 --> 00:31:39,923
I'm going to SCP challenge.
我要用 SCP 传输挑战文件

699
00:31:39,923 --> 00:31:40,703
And I press tab
然后我按 Tab 键

700
00:31:40,703 --> 00:31:43,150
which always takes a little, there we go, level.
这通常需要一点时间 好了 这就搞定了

701
00:31:45,079 --> 00:31:47,203
So copy this file to here.
所以把文件复制到这里来

702
00:31:49,362 --> 00:31:49,623
What?
什么？

703
00:31:54,925 --> 00:31:55,758
Why didn't that work?
为什么没成功呢？

704
00:32:04,070 --> 00:32:05,731
Okay, anybody know the other trick?
好的 有谁知道其他的小技巧吗？

705
00:32:08,133 --> 00:32:09,894
If you have SSH access, my friends
如果你有 SSH 访问权限 朋友们

706
00:32:09,894 --> 00:32:11,695
you can always get a file.
你随时可以获取文件

707
00:32:11,695 --> 00:32:14,473
This is a poor man's transferring of files.
这是一种土办法来传输文件

708
00:32:14,626 --> 00:32:15,647
So what you're doing
所以你做的就是

709
00:32:15,647 --> 00:32:17,688
if you've never done this or used this before
如果你之前没做过或没用过这个

710
00:32:17,688 --> 00:32:19,021
you SSH and
使用 SSH 连接时

711
00:32:19,788 --> 00:32:24,608
the last argument can be a command that you execute on the SSH connection.
最后一个参数可以是你想在这个 SSH 连接上执行的命令

712
00:32:24,852 --> 00:32:27,554
So you SSH catting out the file
因此 你可以通过 SSH 使用 cat 命令输出文件

713
00:32:27,588 --> 00:32:31,176
which will dump this to standard input of your terminal here.
这会将文件内容输出到终端的标准输入

714
00:32:31,176 --> 00:32:32,977
And then you can just redirect that to here.
然后你可以将这些内容重定向到这里

715
00:32:36,126 --> 00:32:36,980
And I've definitely done this.
我做过这个

716
00:32:36,980 --> 00:32:38,041
You can also do this the other way.
你也可以反过来操作

717
00:32:38,041 --> 00:32:39,281
You can cat a file
你可以用 cat 输出文件

718
00:32:39,281 --> 00:32:40,422
pipe it to SSH
然后通过管道传递给 SSH

719
00:32:40,422 --> 00:32:42,123
and then your command is cat dash
然后你的命令是 cat -

720
00:32:42,123 --> 00:32:43,644
and then redirect that to a file.
然后将其重定向到一个文件

721
00:32:44,114 --> 00:32:46,006
See, I'm working around, like
看 我在绕过这个问题

722
00:32:46,006 --> 00:32:47,507
why did SCP not work?
为什么 SCP 不行？

723
00:32:47,507 --> 00:32:48,167
I have no idea.
我也不知道

724
00:32:48,167 --> 00:32:49,208
Do I want to debug it?
我想要调试一下吗？

725
00:32:49,208 --> 00:32:50,249
Absolutely not.
绝对不想

726
00:32:50,249 --> 00:32:51,489
Figure out a way to make it work.
想办法让它能用

727
00:32:51,489 --> 00:32:52,053
It works.
搞定了

728
00:32:53,651 --> 00:32:54,792
And if I really wanted to make sure
如果我真想确保的话

729
00:32:54,792 --> 00:32:55,552
I would try to, like
我会尝试

730
00:32:55,552 --> 00:32:57,753
MD5 both files to make sure they're exactly the same.
对比两个文件的 MD5 确保它们完全一致

731
00:32:57,753 --> 00:32:58,694
I'm actually pretty confident.
我其实挺有把握的

732
00:32:58,694 --> 00:33:03,197
So the other thing you can do is open
另外 你也可以打开

733
00:33:03,197 --> 00:33:06,099
use SCP or this SSH method
使用 SCP 或 这个SSH 方法

734
00:33:07,666 --> 00:33:12,472
and disassemble your buddy right here.
在这里反汇编

735
00:33:17,819 --> 00:33:18,725
So much faster.
快多了

736
00:33:20,426 --> 00:33:21,687
Yay, so there's main.
耶 main在这

737
00:33:22,687 --> 00:33:24,248
Welcome, challenge.
欢迎挑战

738
00:33:24,248 --> 00:33:25,353
I can look at challenge.
我可以查看这个挑战

739
00:33:26,309 --> 00:33:29,011
V9, I bet that's our buffer.
V9 我猜应该是我们的缓冲区

740
00:33:29,011 --> 00:33:30,852
Let's look at the read.
我们看看这个read

741
00:33:30,852 --> 00:33:32,672
Buff equals V9.
buf 来自 V9

742
00:33:32,672 --> 00:33:33,473
Read into buff.
数据读入缓冲区

743
00:33:34,732 --> 00:33:38,896
And base pointer minus 98 hex.
基址指针减 98（十六进制）

744
00:33:38,896 --> 00:33:40,236
Wasn't that exactly what we looked at before?
不就是我们之前看的吗？

745
00:33:41,397 --> 00:33:43,638
No. 93 hex.
不 是 93（十六进制）

746
00:33:43,638 --> 00:33:46,599
Fuck, it's because of stupid reasons that I don't understand.
靠 是因为我搞不懂的某些蠢原因

747
00:33:46,599 --> 00:33:47,440
But they do them.
但他们就是这么做的

748
00:33:47,440 --> 00:33:47,700
Oh, no, wait.
哦 不 等等

749
00:33:48,810 --> 00:33:49,671
Yeah.
嗯

750
00:33:49,671 --> 00:33:52,872
Anyways, I don't know why it does that, but look at the binary.
不管怎样 虽然我不清楚为什么 但看看这个二进制

751
00:33:52,872 --> 00:33:55,094
That's my tip for all this stuff in these offsets
这是我对于这些偏移量内容的建议

752
00:33:55,094 --> 00:33:55,974
because binaries don't lie.
因为二进制代码不会撒谎

753
00:33:58,355 --> 00:33:59,116
Okay.
好的

754
00:33:59,116 --> 00:34:01,033
Any questions about how to access the stuff?
怎么访问这些内容 有什么问题吗？

755
00:34:01,153 --> 00:34:02,578
Oh, debugging.
哦 调试一下

756
00:34:02,604 --> 00:34:03,104
Okay, great.
好的 太棒了

757
00:34:04,239 --> 00:34:05,546
Nope, that's not what I want.
不 这不是我要的

758
00:34:07,161 --> 00:34:07,321
Okay.
好的

759
00:34:08,962 --> 00:34:11,966
So the other thing is...
还有就是……

760
00:34:21,666 --> 00:34:26,722
Ah, why is this not installed?
啊 为什么这个没装上？

761
00:34:29,939 --> 00:34:31,393
Screen?

762
00:34:31,819 --> 00:34:34,268
I actually prefer screen.
我更喜欢screen

763
00:34:35,549 --> 00:34:37,346
Anyways, this is a problem I could fix
不过 这个问题我可以解决

764
00:34:39,231 --> 00:34:39,953
but I won't.
但我现在不解决

765
00:34:43,214 --> 00:34:44,833
I mean, I will fix it later, but not now.
我意思是 我会稍后再解决

766
00:34:45,936 --> 00:34:46,036
Okay.
好的

767
00:34:46,036 --> 00:34:46,930
Okay.
好的

768
00:34:46,930 --> 00:34:49,211
You need to, so first thing to do
你需要做的是 首先

769
00:34:49,211 --> 00:34:50,232
so if you didn't, you know
如果你没这样做 你知道的

770
00:34:50,232 --> 00:34:51,032
this is a grad class
这是研究生课程

771
00:34:51,032 --> 00:34:52,893
so I kind of expect you all to poke around at stuff
我期望你们自己去探索这些东西

772
00:34:52,893 --> 00:34:54,794
and not need to be handheld through all this stuff
而不是需要我手把手地教

773
00:34:54,794 --> 00:34:58,636
but I want to show you how to think about approaching these things.
但我想给你们展示怎样思考如何解决这些问题

774
00:34:58,636 --> 00:34:59,977
So we know what the challenges run
我们知道挑战题执行了什么

775
00:34:59,977 --> 00:35:03,259
because we can see that it's running QEMU and then the challenge.
因为我们可以看到它正在运行 QEMU 然后是具体的挑战

776
00:35:03,259 --> 00:35:04,400
So if we ever wanted to
所以如果我们想做的话

777
00:35:04,400 --> 00:35:05,220
and if Rob was here
如果 Rob 在这里

778
00:35:05,220 --> 00:35:07,081
he would tell us to pass dash h
他会说用 -h 参数

779
00:35:07,081 --> 00:35:08,722
and read the man page for QEMU
并查看 QEMU 的帮助文档

780
00:35:08,722 --> 00:35:10,743
or read the help documentation for QEMU.
或者查阅 QEMU 的帮助文档

781
00:35:12,564 --> 00:35:14,254
And there's a ton of arguments in here.
这里有很多参数选项

782
00:35:14,526 --> 00:35:16,067
The one that you can check out
你可以查看这一个

783
00:35:16,067 --> 00:35:18,248
the one we care about right now, is debug.
我们现在关注的是调试

784
00:35:19,268 --> 00:35:22,089
So just like, has anybody done debugging,
有人用过调试参数吗

785
00:35:22,089 --> 00:35:24,290
like using QEMU system to debug a kernel?
用 QEMU 调试过内核吗？

786
00:35:25,651 --> 00:35:28,072
I think you've implicitly done it in Pwn College without knowing it.
我认为你们在 Pwn College 时已经不知不觉地做过

787
00:35:28,072 --> 00:35:29,232
If you've done the kernel modules
如果你完成了内核模块的练习

788
00:35:29,232 --> 00:35:31,533
like VM debug actually creates QEMU
vm debug会创建 QEMU

789
00:35:31,533 --> 00:35:36,035
and sets up a GDB server there to wait for your connection
并在那儿设置一个 GDB 服务器等待连接

790
00:35:36,035 --> 00:35:38,279
and then you connect on another GDB instance.
然后你通过另一个 GDB 实例连接

791
00:35:38,737 --> 00:35:40,117
Similar thing here, this is all built in.
这里也是类似的 这些功能都是内置的

792
00:35:40,117 --> 00:35:41,319
So g 1234,
-g 1234

793
00:35:41,950 --> 00:35:46,925
it's dash G, and then the port number,then the port number
-g 后面加上端口号

794
00:35:51,587 --> 00:35:52,047
okay
好的

795
00:35:52,047 --> 00:35:54,627
and then the binary challenge
接下来是二进制文件 challeng

796
00:35:58,163 --> 00:36:01,511
and I would also recommend
我建议

797
00:36:01,535 --> 00:36:04,290
it's a good for what we're trying to do
对我们做的很有益处

798
00:36:04,290 --> 00:36:07,783
is a good idea to be used to things not working that should
习惯意料外的问题 是个好主意

799
00:36:08,156 --> 00:36:14,913
so this for instance when I was doing vulnerability analysis on XNU
例如 我在对 XNU 进行漏洞分析时

800
00:36:14,913 --> 00:36:19,323
I would There's a whole setup you can go through to load, to get
我需要经历一整套加载过程才能获取

801
00:36:20,358 --> 00:36:24,022
I think it's KDB kernel debug on the kernel.
我记得是 KDB 内核调试

802
00:36:24,022 --> 00:36:25,744
You can have it trigger a breakpoint
你可以让它触发一个断点

803
00:36:25,744 --> 00:36:27,987
which then waits for a port just like this.
然后它就会像这样等待一个端口

804
00:36:27,987 --> 00:36:30,129
It's actually a similar service and connect to it.
实际上是一个类似的服务 可以连接到它

805
00:36:30,129 --> 00:36:32,110
You can set breakpoints amazingly.
你可以非常方便地设置断点

806
00:36:32,472 --> 00:36:34,254
Then you break on that
然后你在那儿设置断点

807
00:36:34,254 --> 00:36:35,275
and you try to single step.
然后尝试单步执行

808
00:36:35,275 --> 00:36:36,216
It just doesn't work.
但就是不行

809
00:36:36,768 --> 00:36:39,210
You can inspect memory and look at things.
你可以检查内存和其他内容

810
00:36:39,210 --> 00:36:39,910
It just doesn't work.
但就是不行

811
00:36:39,910 --> 00:36:40,931
I have absolutely no idea why.
我完全不清楚为什么

812
00:36:40,931 --> 00:36:43,816
Do you think I want to spend weeks figuring out why I can't do this?
你觉得我想花几周时间弄清楚为什么做不到这一点吗？

813
00:36:43,916 --> 00:36:44,413
No.
不

814
00:36:44,413 --> 00:36:46,974
You figure out other ways around it to debug what you want to debug
你可以找到其他方法来调试你想要的内容

815
00:36:46,974 --> 00:36:49,429
and just set breakpoints and look at things and then continue worked.
然后设置断点 查看状态 再继续运行

816
00:36:49,756 --> 00:36:50,336
So that was fine.
这样就行

817
00:36:50,336 --> 00:36:52,149
You can just set multiple breakpoints.
你可以设置多个断点

818
00:36:52,377 --> 00:36:55,379
You have to be very flexible in what your target allows you to do.
你得灵活应对目标允许你做的事情

819
00:36:56,396 --> 00:36:58,121
Okay, so why isn't this doing anything?
好的 那为什么它不工作呢？

820
00:37:03,181 --> 00:37:05,336
Yeah, it's waiting for something to connect to the port, right?
是的 它在等东西连到端口 对吧？

821
00:37:05,443 --> 00:37:06,529
You want to debug it
你想调试它

822
00:37:06,784 --> 00:37:08,390
but it ran concurrently.
但它是在并发运行的

823
00:37:08,746 --> 00:37:12,629
You want it to wait for you to connect to it to actually start debugging.
你希望它等你连接后再开始调试

824
00:37:18,534 --> 00:37:20,847
So we need gdb-multiarch.
所以我们需要 gdb-multiarch

825
00:37:20,963 --> 00:37:23,063
You will make that mistake of doing GDB
你可能会误用 GDB

826
00:37:23,063 --> 00:37:24,340
and putting in the thing
然后加载程序

827
00:37:24,404 --> 00:37:25,767
and there'll be slightly subtle errors.
结果会出现一些细微的错误

828
00:37:25,824 --> 00:37:26,704
You'll connect to this thing
你会连接到程序

829
00:37:26,704 --> 00:37:27,924
and it says stuff about XML
然后会显示一些关于 XML 的信息

830
00:37:27,924 --> 00:37:29,585
which sounds like bonkers insane
这些信息听起来有点离谱

831
00:37:29,585 --> 00:37:32,465
but you just have to realize you did not use the right GDB
但你得明白 问题是你没有使用正确的 GDB

832
00:37:32,465 --> 00:37:33,853
because this stuff does work.
功能是可以工作的

833
00:37:34,265 --> 00:37:35,886
So gdb-multiarch
所以 GDB 多架构

834
00:37:35,886 --> 00:37:37,213
I'm setting that up here.
我正在这里设置

835
00:37:38,333 --> 00:37:39,873
No debugging symbols.
没有调试符号

836
00:37:40,053 --> 00:37:41,772
I don't have gef installed here.
我没有在这里安装 gef

837
00:37:42,127 --> 00:37:45,287
And there is like a weird thing with gef to talk to a remote target.
而且 用 gef 跟远程目标通信时有点问题

838
00:37:45,287 --> 00:37:47,008
I don't actually know if it works well or not.
我也不知道它能不能正常工作

839
00:37:47,739 --> 00:37:49,521
I don't know, but...
我不知道 但是……

840
00:37:49,521 --> 00:37:51,662
What you want is target remote.
你要执行target remote

841
00:37:53,383 --> 00:37:55,076
I do localhost 1234.
我连接到本地 1234 端口

842
00:37:55,250 --> 00:37:56,725
This is actually pretty cool if you think about it.
想想看 这其实挺酷的

843
00:37:56,725 --> 00:38:00,643
Like what we're doing is connecting to a GDB server through a port.
我们通过端口连接到 GDB 服务器

844
00:38:01,068 --> 00:38:02,128
So this, you know
所以 你知道的

845
00:38:02,128 --> 00:38:04,230
conceptually what this allows you to do
这样你就可以

846
00:38:04,376 --> 00:38:08,932
is debug a remote machine from your local GDB
用本地的 GDB 调试远程机器

847
00:38:08,932 --> 00:38:09,903
which is really cool.
这真是太酷了

848
00:38:09,990 --> 00:38:10,910
I think it's really cool.
我觉得这也挺酷的

849
00:38:11,170 --> 00:38:14,263
So you technically could be running that GDB on your local machine,
所以你可以在本地机器上运行 GDB

850
00:38:14,383 --> 00:38:17,103
SSH into Pwn College doing port forwarding.
通过 SSH 连接到 Pwn College 并进行端口转发

851
00:38:17,399 --> 00:38:19,881
or doing local port forwarding through the remote one
或者通过远程机器进行本地端口转发

852
00:38:19,881 --> 00:38:22,402
and then connect your GDB to that remote instance
然后将 GDB 连接到远程实例

853
00:38:22,402 --> 00:38:24,946
and actually be able to do everything on your local GDB.
并且可以在本地 GDB 上完成所有操作

854
00:38:25,204 --> 00:38:27,306
The problem there is that connection can be slow
问题在于这种连接可能会很慢

855
00:38:27,306 --> 00:38:29,427
and like when you debug things, right?
在你调试时

856
00:38:29,427 --> 00:38:30,688
All the state of the CPU
CPU 的所有状态信息

857
00:38:30,688 --> 00:38:32,649
and registers that your GDB needs
以及 GDB 需要的寄存器信息

858
00:38:32,649 --> 00:38:35,640
gets sent back over UDP and that can be slow.
会通过 UDP 发送回来 可能会很慢

859
00:38:35,791 --> 00:38:37,833
So if you can get on the same host you want to
所以 如果能连接到同一台主机上

860
00:38:37,833 --> 00:38:40,495
but in case you need to do this to debug two things
但你需要调试两件事时

861
00:38:40,495 --> 00:38:41,433
it's very useful.
这非常有用

862
00:38:41,833 --> 00:38:43,346
All right, great.
好的 很棒

863
00:38:43,459 --> 00:38:44,657
Okay, target available.
好的 目标已就绪

864
00:38:44,657 --> 00:38:45,498
So I am here.
所以 我在这里了

865
00:38:47,356 --> 00:38:49,478
Breakpoint, continue.
断点 继续

866
00:38:54,109 --> 00:38:56,743
And the other thing you need to be careful of is those register names
另一个需要注意的是这些寄存器名称

867
00:38:56,743 --> 00:38:58,745
because you're used to x86 register names.
因为你习惯了 x86 的寄存器名称

868
00:38:58,745 --> 00:39:00,006
You will type in RIP.
你会输入 RIP

869
00:39:00,006 --> 00:39:02,447
You will type in all kinds of stuff that doesn't work.
你会输入各种不起作用的东西

870
00:39:02,447 --> 00:39:06,343
EBP, you will get used to it
比如EBP。你会习惯的

871
00:39:06,652 --> 00:39:07,571
Everything will be fine.
一切都会好起来的

872
00:39:08,659 --> 00:39:09,245
Okay.
好的

873
00:39:09,388 --> 00:39:10,569
And then here we can do everything we want.
在这里 我们可以做想做的事

874
00:39:10,594 --> 00:39:12,775
We normally do in GDB, right?
做我们通常在 GDB 里做的

875
00:39:12,775 --> 00:39:16,519
We can dump the stack, look at all kinds of stuff.
我们可以输出栈 查看各种信息

876
00:39:17,386 --> 00:39:21,486
even though we're running the program inside of an emulator.
虽然我们在模拟器里运行程序

877
00:39:21,611 --> 00:39:22,472
So it's emulating
它实际上是在模拟

878
00:39:22,472 --> 00:39:24,714
like QEMU is emulating all those ARM instructions
QEMU 模拟所有的 ARM 指令

879
00:39:24,714 --> 00:39:26,116
and figuring out all the stuff
处理各种事情

880
00:39:27,157 --> 00:39:29,079
and then translating system calls and everything for you
还帮你翻译系统调用等

881
00:39:29,079 --> 00:39:29,959
so you don't have to think about it.
这样你就不用操心了

882
00:39:31,381 --> 00:39:31,681
Cool.
酷

883
00:39:33,383 --> 00:39:39,389
So I can't digest Win.
所以我无法运行 Win

884
00:39:46,810 --> 00:39:49,571
So why can't I just jump to Win if I knew how to find the address of Win?
如果我知道如何找到win的地址，我为什么不直接跳转过去

885
00:39:58,654 --> 00:39:59,495
Good point, maybe.
好想法 可能吧

886
00:40:02,486 --> 00:40:04,577
we are talking about in GDB or in ARM
是在说在gdb中，还是在arm里

887
00:40:05,613 --> 00:40:06,720
in gdb
在gdb中

888
00:40:07,883 --> 00:40:10,523
in gdb drops the privilege
在gdb中会降低特权级别

889
00:40:10,779 --> 00:40:15,199
Yes, well, yes, but we, yeah,exactly,
嗯 是的

890
00:40:15,245 --> 00:40:19,132
so we ran the QEMU as our user
我们用我们的用户运行的QEMU

891
00:40:19,379 --> 00:40:22,127
 QEMU should not be set uid root
QEMU 不应设SUID为 root

892
00:40:22,127 --> 00:40:23,375
so it's not running as root
它不是以 root运行的。

893
00:40:23,399 --> 00:40:25,730
so we can get QEMU to do anything
我们能让 QEMU 做任意事

894
00:40:26,173 --> 00:40:27,332
and it will do it for us
并且它会为我们执行

895
00:40:27,332 --> 00:40:29,260
but we can't get the flag
但我们拿不到 flag

896
00:40:29,374 --> 00:40:29,594
right
对吧

897
00:40:29,594 --> 00:40:30,995
so you have to run challenge run
所以你得运行 challenge run

898
00:40:30,995 --> 00:40:33,161
this is why you should not be able to debug
这就是为什么你不能

899
00:40:33,588 --> 00:40:36,461
the running instance that does get the flag
靠调试运行实例，拿到 flag

900
00:40:37,441 --> 00:40:38,602
uh great okay
好的

901
00:40:38,602 --> 00:40:39,628
thanks
谢谢

902
00:40:40,041 --> 00:40:43,762
Some guy on the Twitch mentioned
有 Twitch 的观众提到

903
00:40:43,762 --> 00:40:46,363
when you do the target remote
在远程调试时

904
00:40:46,363 --> 00:40:49,009
you can drop the local host here.
可以省略 localhost

905
00:40:49,109 --> 00:40:51,525
I like including it so you can completely remove that
我喜欢包括它 你可以完全删除它

906
00:40:51,525 --> 00:40:52,811
and just do colon 1234.
然后直接写 :1234

907
00:40:52,836 --> 00:40:55,283
That's the port you put into the dash G command.
这就是 -g 命令中的端口

908
00:40:55,687 --> 00:40:56,508
I personally kind of like it
我个人挺喜欢这样做

909
00:40:56,508 --> 00:40:58,509
because you are specifying exactly where to go
因为你明确指定了目标

910
00:40:58,509 --> 00:41:00,029
and it reminds you that you can go other places
并且提醒你可以连接到其他地方

911
00:41:00,029 --> 00:41:01,390
but do what you want to do.
但按你的喜好来做吧

912
00:41:02,871 --> 00:41:04,572
Okay, any other questions here?
好的 还有其他问题吗？

913
00:41:04,572 --> 00:41:07,413
I think this gets you up to speed and you can get going.
我觉得这能让您快速上手 可以开始了

914
00:41:09,448 --> 00:41:10,213
Oh, great question.
哦 好问题

915
00:41:10,349 --> 00:41:16,506
Does pwntools work with ARM payloads on here?
pwntools 支持生成这里的ARM payload吗？

916
00:41:16,593 --> 00:41:18,214
The question is, I do not know.
问题是 我不清楚

917
00:41:18,214 --> 00:41:19,055
I haven't tested that yet.
我还没有测试过

918
00:41:20,115 --> 00:41:21,276
But you will tell me soon.
但你很快就会告诉我

919
00:41:22,757 --> 00:41:23,318
I think so.
我想是这样

920
00:41:23,318 --> 00:41:26,043
There's probably a packet that needs to install now that I think about it.
想来是需要安装一个包

921
00:41:26,260 --> 00:41:28,329
Like for creating ARM payloads?
比如创建 ARM 载荷？

922
00:41:28,909 --> 00:41:29,649
It does.
是的

923
00:41:29,982 --> 00:41:30,482
Oh, it does.
哦 确实

924
00:41:30,482 --> 00:41:31,483
Yeah, it already did.
对 它已经安装好了

925
00:41:31,483 --> 00:41:33,184
Well, no, no, that was on the previous one.
不 那个是在之前的版本里

926
00:41:33,184 --> 00:41:34,045
That's not this image
这不是这个镜像

927
00:41:34,045 --> 00:41:35,306
so it may not work on this image.
所以它可能在这一版上不好用

928
00:41:36,589 --> 00:41:38,733
I think pwntools installs pwntools.
我觉得 pwntools 会自己安装

929
00:41:41,122 --> 00:41:42,269
I don't know.
我不知道

930
00:41:47,867 --> 00:41:48,467
Yes.
是的

931
00:41:48,467 --> 00:41:49,468
Yeah, it actually should be fine.
对 应该没问题

932
00:41:49,468 --> 00:41:49,828
I don't know.
我不知道

933
00:41:49,828 --> 00:41:52,490
I'm just thinking of if you ever need it
我只是在想 如果有一天你会用到

934
00:41:52,490 --> 00:41:55,632
maybe you're doing some ROPk payload that does mprotect or something
可能你在做一些需要 mprotect 的 payload

935
00:41:55,632 --> 00:41:59,319
and then you want to execute your own shellcode, basically
然后你可能需要执行自己的 shellcode

936
00:41:59,595 --> 00:42:05,646
like making sure that pwn.assemble actually does work with ARM64.
比如确保 pwn.assemble 能支持 ARM64

937
00:42:06,316 --> 00:42:07,366
It should, but...
应该可以 但是……

938
00:42:08,489 --> 00:42:09,229
I haven't tested it.
我还没测试过

939
00:42:09,277 --> 00:42:10,038
It's just what I'm saying.
我只是这么说的

940
00:42:10,038 --> 00:42:11,018
So tell me if it breaks.
如果出问题了 告诉我

941
00:42:14,681 --> 00:42:16,742
Yeah, but does it work here?
是的 但在这里能用吗？

942
00:42:18,263 --> 00:42:19,724
Yeah, you need that special binutils thing
你得用那个特别的 binutils 工具

943
00:42:19,724 --> 00:42:20,404
which I don't know how it does.
我也不清楚它是怎么弄得

944
00:42:20,439 --> 00:42:21,990
Okay, any other questions here?
好的 还有其他问题吗？

945
00:42:26,848 --> 00:42:27,619
Oh, great question.
哦 好问题

946
00:42:27,908 --> 00:42:30,890
No, no, we're going to get there, Twitch user.
别急 Twitch 的朋友们 我们马上就会讲到

947
00:42:32,091 --> 00:42:34,332
Maybe a stupid question, but isn't the return address in a register?
也许是个简单的问题 但返回地址不是在寄存器里吗？

948
00:42:34,332 --> 00:42:35,533
How can we overflow?
我们怎么让它溢出呢？

949
00:42:35,533 --> 00:42:35,953
Great question.
好问题

950
00:42:38,540 --> 00:42:39,133
say it again
再说一遍

951
00:42:51,766 --> 00:42:55,179
Yeah, let's look at the first instructions here.
我们来看看这里的前几条指令

952
00:42:55,301 --> 00:42:57,141
So if we look at the challenge function here
所以 来看一下这里的 challenge 函数

953
00:42:57,141 --> 00:43:01,883
the very first thing that happens is the stack pointer subtracts hex B0
首先 栈指针会从自身减去十六进制 B0

954
00:43:01,883 --> 00:43:02,583
from the stack pointer
（从栈指针中）

955
00:43:04,024 --> 00:43:05,130
puts it into the stack pointer
然后将结果存回栈指针

956
00:43:05,324 --> 00:43:06,484
Also isn't this crazy?
这不是很疯狂吗？

957
00:43:06,484 --> 00:43:08,745
Now you don't have implicit destination registers.
现在没有隐式的目标寄存器了

958
00:43:08,745 --> 00:43:11,066
You actually are very explicit of where the thing goes.
你明确指出了数据的去向

959
00:43:11,066 --> 00:43:11,867
I actually really like that.
我真的很喜欢这一点

960
00:43:11,867 --> 00:43:12,496
It's cool.
这很酷

961
00:43:14,368 --> 00:43:18,050
And then this one here, store pointer, STP, is going to...
接下来 存储指针指令（STP）将会...

962
00:43:19,291 --> 00:43:19,651
Let's see.
我们来看看

963
00:43:21,103 --> 00:43:23,196
I always have to remember how this is done.
我总是需要记住这是怎么操作的

964
00:43:23,353 --> 00:43:28,270
I think this will store it at SP plus 160.
我认为这会把它存到 SP 加 160 的位置

965
00:43:28,496 --> 00:43:30,689
So it'll take X29
所以会用 X29

966
00:43:30,776 --> 00:43:34,783
put it at 160, and then put X30 at 160 plus 8.
放到 160 X30 放到 160 加 8

967
00:43:36,079 --> 00:43:37,380
and store those registers in there?
然后把那些寄存器存进去？

968
00:43:46,524 --> 00:43:48,084
Yes, okay, that actually
对 不错的 这

969
00:43:48,084 --> 00:43:49,465
that also makes sense.
这也有道理

970
00:43:51,946 --> 00:43:53,247
We can look at the documentation later
我们可以之后再看文档

971
00:43:53,247 --> 00:43:55,548
and we'll do that in a second, but anyways, the point is
我们一会儿再做 但重点是

972
00:43:55,548 --> 00:43:57,468
it's stored on the stack somewhere, right?
它会存到栈上的某个位置 对吧？

973
00:43:57,468 --> 00:43:59,949
And why does it need to store the return address on the stack
为什么要将返回地址存到栈上呢？

974
00:43:59,949 --> 00:44:02,173
if the return address is passed into a register?
返回地址不是传到寄存器中吗？

975
00:44:02,886 --> 00:44:06,094
There's something right there in the register
寄存器里有东西

976
00:44:06,338 --> 00:44:06,998
Something might be what?
那可能是什么呢？

977
00:44:17,373 --> 00:44:17,685
Yeah,
嗯

978
00:44:17,685 --> 00:44:18,505
but we just got called.
但我们刚被调用

979
00:44:18,505 --> 00:44:19,326
We don't care about it.
我们不在乎

980
00:44:19,326 --> 00:44:22,900
Somebody called us, but they put in that register X30 of where to go.
有人调用了我们 但把返回地址放到了寄存器 X30 中

981
00:44:23,348 --> 00:44:24,949
So why do we need to store it onto the stack?
那为什么还要把它存到栈上？

982
00:44:27,973 --> 00:44:28,511
What was it?
那是什么？

983
00:44:31,784 --> 00:44:33,245
More specific.
具体点

984
00:44:34,387 --> 00:44:37,073
Feels just like a word salad that you just said.
听起来就像你刚说的一堆词

985
00:44:40,051 --> 00:44:41,251
Yeah, but when do you need to do that?
是啊 但什么时候需要这样做呢？

986
00:44:41,251 --> 00:44:44,213
Does every function need to store the X30 onto the stack?
每个函数都需要把 X30 存到栈上吗？

987
00:44:49,036 --> 00:44:50,723
Yeah, what's the leaf function?
嗯 什么是叶子函数？

988
00:44:58,362 --> 00:45:00,043
And why is that important for this discussion?
为什么这对我们的讨论很重要？

989
00:45:01,694 --> 00:45:03,535
So if there are less functions
如果函数更少的话

990
00:45:03,535 --> 00:45:07,017
I think they don't need to call the register on the stack.
我认为它们不需要把寄存器存到栈上

991
00:45:07,017 --> 00:45:07,519
Why?
为什么？

992
00:45:08,377 --> 00:45:10,589
They're not going to get anything.
它们什么也得不到

993
00:45:10,778 --> 00:45:11,279
Exactly.
没错

994
00:45:11,279 --> 00:45:12,639
They're never going to get called
它们永远不会被调用

995
00:45:12,639 --> 00:45:14,700
which means that it's totally fine.
这就没问题了

996
00:45:14,700 --> 00:45:16,461
You're not calling any other functions.
你不会调用其他函数

997
00:45:16,461 --> 00:45:19,202
So if your function ever needs to call another function
如果函数需要调用其他函数

998
00:45:19,202 --> 00:45:22,264
you need to store X30 on the stack because it's a call.
你需要把 X30 存到栈上 因为这是一个调用

999
00:45:22,264 --> 00:45:25,645
I mean, it seems silly calling it a caller-preserved register
它被称为调用者保存寄存器 听起来有点傻

1000
00:45:25,645 --> 00:45:26,306
because, of course
因为显然

1001
00:45:26,306 --> 00:45:27,266
it's the return address.
是返回地址

1002
00:45:27,266 --> 00:45:28,447
And when you call a BL
当你调用 BL

1003
00:45:28,447 --> 00:45:29,907
you need to come back.
你需要返回

1004
00:45:29,907 --> 00:45:30,148
And so...
所以……

1005
00:45:31,301 --> 00:45:34,442
But yeah, that's another one you think about why, right?
对 这也是个值得思考的问题 对吧？

1006
00:45:34,442 --> 00:45:36,262
Because I always like to think of like, oh, that's interesting.
因为我觉得 哇 这很有趣

1007
00:45:36,262 --> 00:45:37,403
It's different from x86.
它和 x86 不同

1008
00:45:37,403 --> 00:45:38,009
Why?
为什么？

1009
00:45:38,236 --> 00:45:40,243
I think it's because you can see
我认为这是因为你可以看到

1010
00:45:40,243 --> 00:45:45,945
that you can make leaf functions more efficient, right?
你可以让叶子函数更高效 对吧？

1011
00:45:45,945 --> 00:45:48,606
Rather than every single time you have a call instruction
而不是每次调用指令时

1012
00:45:48,606 --> 00:45:50,676
it shoves the address onto the stack.
都把地址压入栈中

1013
00:45:50,846 --> 00:45:51,767
When it leaf functions
处理叶子函数时

1014
00:45:51,767 --> 00:45:53,187
you don't need to do that.
你不需要这样做

1015
00:45:54,227 --> 00:45:56,923
So you're saving space there.
这样就省空间了

1016
00:45:57,148 --> 00:45:57,748
Very similar.
非常相似

1017
00:45:57,748 --> 00:46:00,183
Anybody remember the red zone in x86-64?
有人记得 x86-64 的红色区域吗？

1018
00:46:06,571 --> 00:46:07,311
Well, that's the question.
嗯 这就是问题

1019
00:46:09,793 --> 00:46:11,170
Yes, you're asking me.
是的 你在问我

1020
00:46:13,009 --> 00:46:16,357
Have you ever seen a function that writes past the stack pointer?
你见过函数超出栈指针写入的情况吗？

1021
00:46:19,459 --> 00:46:21,120
Right, so on, I believe it's like
对 接着 我认为是这样

1022
00:46:21,120 --> 00:46:23,701
I can't remember if it's like 128 bits
我不记得是不是 128 位

1023
00:46:23,701 --> 00:46:25,102
or something like that or bytes.
或者是字节

1024
00:46:25,102 --> 00:46:25,843
No, it can't be bits.
不 不可能是位

1025
00:46:25,843 --> 00:46:26,923
It must be bytes.
肯定是字节

1026
00:46:26,923 --> 00:46:29,745
But anyways, it's implicit stack space.
反正这是隐式的栈空间

1027
00:46:29,745 --> 00:46:33,047
So when your function is executing...
所以当函数执行时...

1028
00:46:34,288 --> 00:46:38,709
There is an implicit space that is saved that will not be if the
会有一个隐式空间被保存 除非...

1029
00:46:38,709 --> 00:46:41,810
I think it's like even if there's an interrupt or anything happens
我认为即使发生中断...

1030
00:46:41,810 --> 00:46:45,850
it's guaranteed that nobody will write to lower than I think
可以保证没有人会写入低于

1031
00:46:45,850 --> 00:46:48,033
it's 128 bytes of the stack.
128 字节的栈空间

1032
00:46:48,193 --> 00:46:49,491
ARM has the exact same thing.
ARM 也有同样的机制

1033
00:46:49,491 --> 00:46:52,392
And the reason is so that you have these optimizations,
这样做是为了实现这些优化

1034
00:46:52,392 --> 00:46:55,172
like a leaf function doesn't need to set up its own stack frame
例如 叶函数不需要为其自身设置栈帧

1035
00:46:55,198 --> 00:46:58,444
if it uses less than 128 bytes in its local function.
如果局部空间占用少于 128 字节

1036
00:46:58,653 --> 00:47:00,173
It doesn't need to do the decrementing stack.
不需要调整栈

1037
00:47:00,173 --> 00:47:03,872
And then in ARM it doesn't need to do the saving of the X30 register.
而在 ARM 架构中 不需要保存 X30 寄存器

1038
00:47:04,089 --> 00:47:06,772
So it's making these things more efficient
因此这些操作更加高效

1039
00:47:06,850 --> 00:47:09,731
and these special cases of these tail functions become way more efficient.
这些叶子函数的特殊情况也更高效

1040
00:47:11,992 --> 00:47:12,383
Cool.
真不错

1041
00:47:20,595 --> 00:47:21,961
What the hell were we talking about?
我们刚才在说什么来着？

1042
00:47:25,717 --> 00:47:26,777
Oh, yes, okay, yes.
哦 对 记得了

1043
00:47:26,777 --> 00:47:28,758
So there would probably then be
那么接下来可能会有

1044
00:47:28,758 --> 00:47:31,499
so if you have an overflow in a function that's a leaf function
如果你在一个叶函数中出现溢出

1045
00:47:32,846 --> 00:47:34,067
There's nothing to overwrite.
没什么可以覆盖的

1046
00:47:34,067 --> 00:47:36,069
There's no saved return address on the stack.
栈里没有保存的返回地址

1047
00:47:36,069 --> 00:47:37,550
That return address is in a register.
返回地址在寄存器里

1048
00:47:37,550 --> 00:47:39,311
You are just like SOL.
你就只能碰运气了

1049
00:47:39,311 --> 00:47:40,712
Well, of course, you could maybe have...
当然 你也可以……

1050
00:47:40,712 --> 00:47:42,274
Actually, that would be a fun challenge
那倒是个有趣的挑战

1051
00:47:42,274 --> 00:47:44,255
but you could probably
但你可能

1052
00:47:44,255 --> 00:47:47,638
depending on if the frame pointer needs to be saved or is saved
取决于帧指针是否需要或已被保存

1053
00:47:47,638 --> 00:47:49,399
then you could control the frame pointer.
你就能控制帧指针了

1054
00:47:49,399 --> 00:47:53,062
Otherwise, you can control whatever is stored in the function that calls you, right?
否则 你可以控制调用你的函数中的内容 对吧？

1055
00:47:55,044 --> 00:47:55,444
Cool.
不错

1056
00:47:55,444 --> 00:47:55,704
Okay.
好的

1057
00:47:57,386 --> 00:48:00,128
Yes, so this was all of the how can we overflow
对 这就是我们如何造成溢出的全部方法

1058
00:48:00,128 --> 00:48:01,606
which is exactly what we're talking about here.
这正是我们在说的

1059
00:48:02,079 --> 00:48:05,872
because this specific, this STP, exactly right here
因为这里这个特定的 STP 指令

1060
00:48:06,050 --> 00:48:11,816
stores the frame pointer and the link register onto the stack.
将帧指针和链接寄存器存入栈

1061
00:48:11,913 --> 00:48:14,799
And then if we go to the end of challenge
然后 challenge的结尾

1062
00:48:16,034 --> 00:48:17,993
and we'll know it's the end because we'll see a ret.
我们知道它是结尾，因为会看到一个 ret

1063
00:48:21,036 --> 00:48:23,479
Is this really a ret?
这真的是一条ret指令吗？

1064
00:48:24,817 --> 00:48:26,026
Actually, I haven't looked it up.
实际上 我还没查过

1065
00:48:26,118 --> 00:48:28,959
I usually try to not say things I don't actually know
我通常尽量不说我不知道的事

1066
00:48:28,959 --> 00:48:30,637
but I'd probably put money on
但我敢打赌

1067
00:48:30,637 --> 00:48:32,778
we talked about like pushes and pulls, right?
我们之前讨论过push和pop 对吧？

1068
00:48:32,778 --> 00:48:34,139
Pushes and pops, right?
push和pop 对吧？

1069
00:48:34,139 --> 00:48:36,620
So this seems wasteful because it's one instruction.
所以这看起来挺浪费的 专门设立一条指令

1070
00:48:36,620 --> 00:48:41,943
I believe this is just syntactic sugar for branch register X30
我相信这只是B X30寄存器的一个语法糖

1071
00:48:42,242 --> 00:48:44,523
but it's just much nicer to see the ret
ret更直观

1072
00:48:44,523 --> 00:48:46,235
because everyone is familiar with that.
因为大家都很熟悉

1073
00:48:46,344 --> 00:48:48,405
But this way, you don't have one instruction.
但这样，就没有单独的特殊指令

1074
00:48:48,405 --> 00:48:50,506
You have what looks to be one instruction to you
看着是一条特殊指令 但实际上……

1075
00:48:50,506 --> 00:48:53,447
but actually maps to a more complex function
但实际上它映射到一个更复杂的功能

1076
00:48:53,447 --> 00:48:55,528
that can branch to any of the 30 registers.
它可以跳转到 30 个寄存器中的任意一个

1077
00:48:57,296 --> 00:48:57,910
Okay.
好的

1078
00:48:58,127 --> 00:49:00,508
Cool, so let's go through the prologue here.
好的 我们看看这里的序言（应该是尾声）部分

1079
00:49:00,508 --> 00:49:02,188
So here, load pointer.(pair)
这里 ldp

1080
00:49:02,188 --> 00:49:07,229
So loading X29 and X30 from the stack pointer plus 160.
从栈指针加 160 的位置加载 X29 和 X30

1081
00:49:10,701 --> 00:49:11,941
Yeah, is this infix?
这是中缀表达式吗？

1082
00:49:12,030 --> 00:49:13,591
I think this is not infix.
我认为这不是中缀表达式

1083
00:49:13,591 --> 00:49:15,251
I think this doesn't change the value.
我认为这不会改变值

1084
00:49:15,276 --> 00:49:17,161
I think it changes it when it's outside
我觉得它在外部时才会改变值

1085
00:49:18,169 --> 00:49:24,718
like another example somewhere.
像某处的例子

1086
00:49:26,654 --> 00:49:28,190
Yeah, because this is, so basically
对 因为这样， 基本上

1087
00:49:28,190 --> 00:49:29,451
Wherever the stack currently is
不管当前栈的位置在哪

1088
00:49:29,451 --> 00:49:31,676
whatever stack pointer plus 160 is
不管栈指针加 160 是多少

1089
00:49:31,909 --> 00:49:33,053
take that memory location
取出该内存地址的值

1090
00:49:33,078 --> 00:49:37,988
put it into X29, and then at stack pointer plus 168
放入 X29 然后在栈指针加 168 处

1091
00:49:38,249 --> 00:49:41,738
move that into X30, and then
将它放入 X30 然后

1092
00:49:41,738 --> 00:49:46,361
increment the stack pointer by B0, filling up this stack frame.
将栈指针增加 0xB0 释放这个栈帧

1093
00:49:46,361 --> 00:49:49,522
I actually really hate how it doesn't do everything in hex.
我真的很讨厌，它不全用十六进制表示

1094
00:49:49,522 --> 00:49:50,743
This is driving me crazy.
这让我抓狂

1095
00:49:50,743 --> 00:49:52,184
I don't know if that's also for you all
不知道你们是不是也有同感

1096
00:49:52,184 --> 00:49:54,976
but if somebody finds a way to make...
但如果有人能找到方法让...

1097
00:49:54,976 --> 00:49:57,578
GDB and all these tools do that that would be amazing
GDB 和这些工具都用16进制表示 那就太好了

1098
00:49:57,578 --> 00:49:58,124
because I want
因为我

1099
00:49:58,178 --> 00:49:59,722
in all the instructions I just want to see hex
我只想看到十六进制的指令

1100
00:50:03,001 --> 00:50:05,501
Okay, so the stack frame
好的 栈帧

1101
00:50:07,764 --> 00:50:10,586
Cool okay, this is uh Yeah
酷 好的 就是这样

1102
00:50:10,586 --> 00:50:13,366
so this is exactly what I wanted to talk about here right
这正是我想讨论的

1103
00:50:13,472 --> 00:50:18,591
is that there's fundamental differences here between x86 64, right
是它和x86_64 存在根本区别 对吧

1104
00:50:18,591 --> 00:50:22,810
the fact that the return address is passed in a register is important
它通过寄存器传递返回地址 这点很重要

1105
00:50:23,004 --> 00:50:27,284
also the way that parameters are passed, right?
参数传递的方式也是这样 对吧？

1106
00:50:27,407 --> 00:50:30,957
By passing parameters through registers and all parameters
通过寄存器传递所有参数

1107
00:50:31,149 --> 00:50:34,791
I guess it's less very less similar to X32
这一点和x86 相差很大

1108
00:50:34,791 --> 00:50:36,644
where everything was passed on the stack.
在 x86 中 所有东西都是通过栈传递的

1109
00:50:39,933 --> 00:50:42,394
But yeah, so even having stack control
即便有了栈控制权

1110
00:50:42,394 --> 00:50:43,254
so setting up the
设置……

1111
00:50:43,335 --> 00:50:45,396
if you're trying to call a function and pass it arguments
如果你尝试ROP调用一个函数并传递参数

1112
00:50:45,396 --> 00:50:47,956
you need to use gadgets in order to put things
你需要使用一些gadgets

1113
00:50:48,249 --> 00:50:51,609
on the stack or from places you control into those registers
将数据从栈，或其它你能控制的地方，放入寄存器中

1114
00:50:51,822 --> 00:50:53,315
before you call that function.
再调用函数

1115
00:50:53,793 --> 00:50:54,142
Okay.
好的

1116
00:50:54,756 --> 00:50:55,669
And we talked about that.
我们已经讨论过它了

1117
00:50:55,731 --> 00:50:57,156
Yeah, so this is exactly what I wanted to show
对 这就是我要展示的

1118
00:50:57,649 --> 00:51:00,703
is that also the other thing that's crazy
另一个疯狂的地方是

1119
00:51:00,743 --> 00:51:02,816
is that different compilers are different.
不同的编译器编译结果也不同

1120
00:51:03,455 --> 00:51:06,983
This was not something I was prepared for before looking at this.
这是我之前没想到的

1121
00:51:07,350 --> 00:51:10,699
So, and maybe I'll...
所以 也许我会……

1122
00:51:12,781 --> 00:51:15,771
Oh, anyways, you'll find it in one of the challenges that I release later
哦 总之 你可以在稍后我发布的挑战中发现这一点

1123
00:51:15,771 --> 00:51:17,493
but I will compile these with a different compiler
但我将用不同的编译器编译这些代码

1124
00:51:17,493 --> 00:51:21,290
and you will see that like even the exact same source code
你会发现即使是完全相同的源代码

1125
00:51:21,536 --> 00:51:23,637
the overflow that you have to do is actually different
需要进行的溢出操作也会不同

1126
00:51:23,637 --> 00:51:26,850
because the compiler does weird things with how things are laid out.
因为编译器在布局上会搞一些奇怪的花样

1127
00:51:27,026 --> 00:51:29,282
So important things to remember of all of these, right?
所以 这里重要的是

1128
00:51:29,282 --> 00:51:31,983
Is, okay, where's my buffer on this stack?
目标缓冲区在栈上哪里？

1129
00:51:32,144 --> 00:51:34,005
How many bytes do I need to overwrite
我需要覆盖多少字节

1130
00:51:34,005 --> 00:51:36,842
to get to the saved frame pointer X29?
才能到达保存的栈帧指针 X29？

1131
00:51:37,048 --> 00:51:38,075
And then the next four
以及后面的四

1132
00:51:38,100 --> 00:51:43,020
next eight bytes will be the saved instruction point, program counter.
后面的保存着 程序计数器 的八个字节

1133
00:51:43,107 --> 00:51:45,880
In X30 and then that's where we want to go.
X30里的，就是要跳到的地方

1134
00:51:45,913 --> 00:51:47,494
I guess save link register.
大概叫保存的链接寄存器

1135
00:51:47,494 --> 00:51:49,014
It feels really weird calling it that.
这么叫它感觉很奇怪

1136
00:51:51,592 --> 00:51:55,012
And because we're trying to do exactly this part here.
我们想要做的，其实就是这部分

1137
00:51:55,157 --> 00:51:57,038
Okay, great.
好的 很好

1138
00:51:59,178 --> 00:52:00,159
Yeah, so this is
对 就是这个

1139
00:52:02,500 --> 00:52:04,863
there's one important thing.
有个重要的点

1140
00:52:04,888 --> 00:52:09,342
So, okay, this thing.
好吧 这个

1141
00:52:10,623 --> 00:52:13,056
Okay, we're almost done here with this part.
好的 这部分快完成了

1142
00:52:14,925 --> 00:52:16,306
So let's do...
那我们来...

1143
00:52:19,568 --> 00:52:21,563
So one of the most classic ROP...
这是最经典的 ROP 之一...

1144
00:52:24,971 --> 00:52:28,352
So for instance, we want to jump to this win function, right?
比如 我们要跳到这个 win 函数 对吧？

1145
00:52:28,352 --> 00:52:29,223
That's our goal.
这就是目标

1146
00:52:29,769 --> 00:52:30,803
Everyone agree here?
大家同意吗？

1147
00:52:31,283 --> 00:52:32,410
And when are other times?
其他时候呢？

1148
00:52:32,443 --> 00:52:34,956
So oftentimes we will not have just a win function.
很多时候 我们不会直接有一个win函数

1149
00:52:37,718 --> 00:52:39,679
But why would we want to jump to a whole function?
但为什么要跳转到整个函数呢？

1150
00:52:42,740 --> 00:52:43,061
Say again?
再说一遍？

1151
00:52:44,447 --> 00:52:45,028
Alignment?
对齐？

1152
00:52:46,013 --> 00:52:46,846
Eh, maybe.
嗯 可能吧

1153
00:52:48,713 --> 00:52:50,673
I think we can technically jump to any instruction.
我认为技术上可以跳转到任何指令

1154
00:52:51,274 --> 00:52:52,859
I think instructions are fine
我认为指令没问题

1155
00:52:53,155 --> 00:52:54,240
because there are four bytes.
因为这里有四个字节

1156
00:52:55,137 --> 00:52:57,026
I don't know if we can jump to halfway through an instruction.
我不确定能不能跳转到在一条指令的中间

1157
00:52:57,119 --> 00:52:59,472
I think that will cause a seg fault, I believe
我觉得这会导致段错误

1158
00:52:59,532 --> 00:53:03,606
or any other non-four offset into an instruction.
或者偏移不是四的倍数的指令

1159
00:53:09,970 --> 00:53:12,472
In any of your exploiting careers of targets
在你们攻击目标的职业生涯中

1160
00:53:12,472 --> 00:53:14,954
have you ever had to jump to a function or something?
你们有没有跳转到某个函数或类似的？

1161
00:53:17,116 --> 00:53:17,776
What was it?
是什么？

1162
00:53:18,996 --> 00:53:19,770
Execve?
execve？

1163
00:53:19,810 --> 00:53:24,476
Yeah, so jumping to ret to sys, ret to libc.
对 跳转到返回系统调用 返回到 libc

1164
00:53:24,681 --> 00:53:26,736
That's too many rets.
有太多可以ret了

1165
00:53:27,438 --> 00:53:32,127
But yeah, that whole idea of just returning to a specific function in the library
这个方法就是直接返回到库中的某个函数

1166
00:53:32,127 --> 00:53:33,458
that does what you want to do
这个函数能实现你的需求

1167
00:53:33,828 --> 00:53:36,850
that's great because you're reusing a whole chunk of thing
这样做很棒 因为你可以重用一大段代码

1168
00:53:36,850 --> 00:53:39,411
rather than building it up through little gadgets.
而不是通过gadget一点点构建

1169
00:53:39,411 --> 00:53:39,992
What other things?
还有其他方法吗？

1170
00:53:42,813 --> 00:53:46,083
Sometimes your overflow isn't enough to do anything super meaningful
有时候溢出的量不足以做太有意义的事

1171
00:53:46,155 --> 00:53:49,396
so you need to re-read and re-overflow some more.
所以需要再次读取 制造更多的溢出

1172
00:53:49,857 --> 00:53:52,150
Yeah, so it is if you're...
是的 如果你……

1173
00:53:52,531 --> 00:53:56,853
You may not have enough of a payload to generate a great ROP chain
你可能没有足够的载荷来生成一个高质量的 ROP 链

1174
00:53:57,295 --> 00:53:59,957
but if you can redirect control flow back to main
但如果能将控制流重定向回 main 函数

1175
00:53:59,957 --> 00:54:02,539
and get another right and maybe get several of them
再获得一次 甚至几次

1176
00:54:02,539 --> 00:54:04,581
you can build up a nice ROP chain.
你就能构建一个不错的ROP链

1177
00:54:05,766 --> 00:54:07,026
Yeah, that's a great example.
是的 这是个很好的例子

1178
00:54:09,325 --> 00:54:13,000
Yeah, so executing system calls, returning into libc
执行系统调用 返回到 libc

1179
00:54:13,113 --> 00:54:14,269
all that stuff is super important.
这些都非常重要

1180
00:54:14,269 --> 00:54:15,773
So let's go...
那么 开始...

1181
00:54:16,953 --> 00:54:20,482
I'm confident that you guys can all give input to this application
我相信你们都能给这个程序提供输入

1182
00:54:20,482 --> 00:54:24,713
in order to overwrite the saved link register X 30
覆盖保存的链接寄存器 X30

1183
00:54:25,204 --> 00:54:26,605
and then redirect control flow.
然后重定向控制流

1184
00:54:26,605 --> 00:54:28,377
So let's put ourselves in that mindset.
所以让我们进入这种思维模式

1185
00:54:28,786 --> 00:54:32,487
We have just, because I think it's really important.
我们强调这一点 是因为它真的很重要

1186
00:54:32,487 --> 00:54:35,124
One of the things that I always emphasize is like
我经常强调的一点是

1187
00:54:35,848 --> 00:54:39,041
you want to be able to kind of let's say
你希望能够做到 比如说

1188
00:54:39,041 --> 00:54:40,076
do this stuff in your head.
在脑子里完成这些操作

1189
00:54:40,129 --> 00:54:41,343
It doesn't have to be complete in your head.
不一定非得完全在脑中进行

1190
00:54:41,395 --> 00:54:43,284
I think it's totally fine to draw and do that.
我认为用画图或其他方法辅助完全没有问题

1191
00:54:43,284 --> 00:54:44,025
I do that all the time
我经常这样做

1192
00:54:44,025 --> 00:54:46,201
when I'm looking at things like exact offsets.
比如在查看精确偏移量等细节时

1193
00:54:46,346 --> 00:54:48,648
But being able to look at these instructions and
但能够查看这些指令并

1194
00:54:48,673 --> 00:54:51,106
walk through step-by-step exactly what's happening
逐步分析每一步发生了什么

1195
00:54:51,267 --> 00:54:52,931
so that you can be prepared for
以便做好准备

1196
00:54:52,931 --> 00:54:55,679
when you actually are running it against the real target
当你实际运行时

1197
00:54:55,953 --> 00:54:57,246
is super important.
这一点非常重要

1198
00:54:57,454 --> 00:54:59,636
And so, for instance
例如

1199
00:54:59,636 --> 00:55:00,586
let's say we're here.
假设我们在这一位置

1200
00:55:00,773 --> 00:55:02,559
We've probably done the overflow.
我们可能已经完成了溢出

1201
00:55:02,718 --> 00:55:06,040
We've changed here now X30 is
我们现在修改了 X30

1202
00:55:06,040 --> 00:55:06,641
where do we want to go?
我们想跳到哪里？

1203
00:55:09,435 --> 00:55:10,196
The win function.
win 函数

1204
00:55:10,196 --> 00:55:10,756
We want to win.
我们想获胜

1205
00:55:10,756 --> 00:55:12,217
So we want to go to the win function.
因此 我们想跳转到 win 函数

1206
00:55:12,217 --> 00:55:13,549
We put it into X30.
我们把它放到 X30 里

1207
00:55:14,218 --> 00:55:16,780
Now this instruction executes our stack pointer
现在这条指令操作栈指针

1208
00:55:16,780 --> 00:55:18,871
but it's incremented, cleaning up that whole thing.
增加了它，清理了整个栈帧

1209
00:55:19,931 --> 00:55:20,923
And we have the ret
然后是 ret

1210
00:55:20,923 --> 00:55:24,098
which is a branch to register X30.
这是一个跳转到寄存器 X30 的指令

1211
00:55:24,306 --> 00:55:25,397
That takes us to win.
这会带我们进入 win

1212
00:55:26,200 --> 00:55:26,860
All right.
好的

1213
00:55:27,268 --> 00:55:28,893
What's the first thing that happens at win?
在 win 里首先会发生什么？

1214
00:55:33,481 --> 00:55:35,581
So it stores X29
所以它存储 X29

1215
00:55:35,635 --> 00:55:36,515
whatever was in there
不管里面是什么

1216
00:55:36,515 --> 00:55:40,537
we controlled that because we must have controlled that because we
我们必须控制它

1217
00:55:40,537 --> 00:55:41,917
and actually that's another important thing
这其实是另一件重要的事情

1218
00:55:41,917 --> 00:55:43,298
when you're talking about overflows, right?
在谈论溢出时 对吧？

1219
00:55:43,298 --> 00:55:45,758
It's like, what did you overwrite and change?
你覆盖和改变了什么？

1220
00:55:45,758 --> 00:55:49,116
Because X29, if there had to be something special in there
因为 X29 里面可能有特别的东西

1221
00:55:49,300 --> 00:55:51,630
but so we're storing X29 and X30
我们在存储 X29 和 X30

1222
00:55:51,656 --> 00:55:52,581
and this is a cool way
这是一种很酷的方法

1223
00:55:52,581 --> 00:55:55,422
that you can see that like we're doing a ton of stack setup
你可以看到 我们通过一条指令就完成了

1224
00:55:55,422 --> 00:55:56,522
just in one instruction,
大量栈设置

1225
00:55:56,782 --> 00:55:58,236
Or function frame setup.
或者说函数栈帧设置

1226
00:55:58,538 --> 00:56:02,434
We are storing this X29 and X30, So this is
我们正在存储 X29 和 X30

1227
00:56:02,459 --> 00:56:04,021
I believe the prefix operator.
这是前缀操作符

1228
00:56:04,021 --> 00:56:07,861
So this will do a stack pointer minus 16
这会将栈指针减去 16

1229
00:56:08,083 --> 00:56:11,145
and then store at stack pointer at that current stack pointer
然后在当前栈指针位置存储

1230
00:56:11,145 --> 00:56:12,774
which is stack pointer minus 16.
即栈指针减 16 的位置

1231
00:56:13,034 --> 00:56:14,307
It'll store X 29
会存储 X29

1232
00:56:14,307 --> 00:56:18,230
and then eight bytes above that will store at stack pointer minus eight.
然后在栈指针减 8 处存储

1233
00:56:18,230 --> 00:56:19,366
Will store the
会存储 X30

1234
00:56:19,480 --> 00:56:20,151
so this was basically
所以这基本上

1235
00:56:20,151 --> 00:56:23,633
you can think of this as exactly equivalent to like push X 29.
你可以把它理解为类似于 push X29

1236
00:56:23,633 --> 00:56:29,129
No, I guess push X 30 and then push X 29.
不是 应该是先 push X30 再 push X29

1237
00:56:29,797 --> 00:56:31,806
注：括号后有!,会改括号里的寄存器。没有不改。

1238
00:56:32,403 --> 00:56:33,683
I have to diagram that out.
我得把这个画出来

1239
00:56:34,320 --> 00:56:39,276
But anyways, the semantics are x29 goes at stack pointer minus 16,
总之 X29 的位置是栈指针减 16

1240
00:56:39,483 --> 00:56:44,823
and then 8 bytes above that at stack pointer plus 8 is where x30 goes.
接着 X30 位于当前栈指针（-16后）加 8 的位置

1241
00:56:45,620 --> 00:56:46,294
Okay.
好的

1242
00:56:46,488 --> 00:56:49,710
But now the stack pointer is pointing right to x29 and x30, right?
现在栈指针指向了 X29 和 X30 对吗？

1243
00:56:49,710 --> 00:56:50,430
Everyone agree?
大家都同意吗？

1244
00:56:51,291 --> 00:56:51,491
Okay.
好的

1245
00:56:52,631 --> 00:56:54,756
The next instruction, what's the point of this instruction?
下一条指令 它的目的是什么？

1246
00:57:09,029 --> 00:57:09,991
Yeah, why?
嗯 为什么？

1247
00:57:11,411 --> 00:57:13,636
It's moving the stack pointer into the X29
它把栈指针移到了 X29

1248
00:57:13,932 --> 00:57:14,991
which is the frame pointer.
也就是帧指针

1249
00:57:15,523 --> 00:57:16,109
What was that?
什么？

1250
00:57:19,273 --> 00:57:20,371
Is it a leaf function?
这是叶函数吗？

1251
00:57:20,396 --> 00:57:21,874
No, because we're doing a lot of BLs here.
不是 因为这里有很多分支链接指令

1252
00:57:28,815 --> 00:57:29,315
This is great.
太好了

1253
00:57:29,315 --> 00:57:30,576
If I don't get good answers for you all
如果我不能给大家好的答案

1254
00:57:30,576 --> 00:57:31,636
I can just go to the chat(gpt).
我就可以去问gpt

1255
00:57:34,435 --> 00:57:36,713
It's like having a better smarter kid you can go to.
就像是有个聪明的孩子，可以去问

1256
00:57:37,497 --> 00:57:40,719
Yeah, it's just moving the base pointer down to where the stack pointer is.
对 就是把基指针移到栈指针的位置

1257
00:57:42,280 --> 00:57:45,102
Yes, so setting up the new function frame by setting up.
是的 通过设置新的函数帧来完成

1258
00:57:45,102 --> 00:57:47,244
So now this current function frame starts at
所以现在这个函数帧从

1259
00:57:47,244 --> 00:57:48,264
where the current stack pointer is.
当前栈指针的位置

1260
00:57:49,265 --> 00:57:49,983
Exactly.
对

1261
00:57:50,526 --> 00:57:50,926
Cool.
好极了

1262
00:57:50,926 --> 00:57:57,186
Okay, and I think actually your comment may actually be mostly...
好的 你们的评论可能大部分是...

1263
00:57:57,239 --> 00:57:59,469
It's not a leaf function because it's calling things
这不是叶函数 因为它在调用其他函数

1264
00:57:59,469 --> 00:58:02,582
but I think there's no local variables here
但我觉得这里没有局部变量

1265
00:58:02,607 --> 00:58:05,031
so it's not decrementing the stack pointer anymore
所以现在不再减少栈指针

1266
00:58:05,031 --> 00:58:06,811
to set up actually a space on the function frame.
来为函数帧分配空间了

1267
00:58:08,872 --> 00:58:12,393
And I believe, I don't know if it's 100%
我认为 虽然不确定是不是 100% 对

1268
00:58:12,393 --> 00:58:15,254
but I believe so that you can debug
但这样可以方便调试

1269
00:58:15,254 --> 00:58:16,813
and walk the stack back up
并且回溯整个调用栈

1270
00:58:16,853 --> 00:58:19,155
every function pointer should point exactly
每个函数指针都应该准确指向

1271
00:58:19,155 --> 00:58:22,160
where the other's function frame is.
其他函数的帧

1272
00:58:22,473 --> 00:58:24,833
So at your current X29
所以 你当前在 X29 处

1273
00:58:25,093 --> 00:58:26,976
If you dereference that memory location
如果解引用该内存位置

1274
00:58:27,053 --> 00:58:30,689
that should be your caller's X29
那应该就是调用者的 X29

1275
00:58:30,754 --> 00:58:32,594
and then all the way back up your call stack.
然后一路回溯到调用栈的顶部

1276
00:58:32,594 --> 00:58:33,794
And that allows you to walk that.
这就能让你遍历它了

1277
00:58:33,794 --> 00:58:35,996
And then you can know exactly where you came from
然后你就能准确知道你是从哪里来的

1278
00:58:36,063 --> 00:58:39,340
because that 29 plus eight is the stored link register.
因为 X29 加 8 就是存储的LR

1279
00:58:39,435 --> 00:58:41,027
So that's how you can walk the whole stack back up.
这样你就能遍历整个调用栈了

1280
00:58:41,433 --> 00:58:45,473
Okay, do we care what else happens here for exploitation purposes?
好了 我们还关心这里有没有其他可以利用的吗？

1281
00:58:46,057 --> 00:58:47,217
Not really, stuff happens, right?
不太关心 反正这里会发生一些事情 对吧？

1282
00:58:47,217 --> 00:58:49,617
This is all stuff that's like gonna happen in this function.
这些事情都会在这个函数中发生

1283
00:58:49,617 --> 00:58:50,783
It's target specific,
这是特定目标相关的

1284
00:58:51,217 --> 00:58:54,298
whatever, blah, blah, blah, blah, blah, blah, blah.
不管了 随便什么 巴拉巴拉

1285
00:58:55,583 --> 00:58:59,083
Okay, now we get to the good stuff at the end here.
好了 现在我们来看看最后这部分精彩内容

1286
00:58:59,536 --> 00:59:02,183
Now, what happens here?
现在 这里发生了什么？

1287
00:59:03,982 --> 00:59:08,363
So this is a post-fix operator.
这是一个后索引操作

1288
00:59:08,686 --> 00:59:10,129
So this is, yeah,
对 就是这样

1289
00:59:10,209 --> 00:59:11,296
so when it's
所以当它这样时

1290
00:59:11,663 --> 00:59:13,016
I guess the way to remember it is
我觉得记它的方法是

1291
00:59:13,043 --> 00:59:15,350
when it's inside like this
当立即数在括号里面

1292
00:59:15,383 --> 00:59:17,163
and there's a exclamation point
并且有个感叹号

1293
00:59:17,188 --> 00:59:19,128
it does the operation first.
它会先执行括号里的操作

1294
00:59:19,450 --> 00:59:20,643
If it's outside of this
如果立即数在外面

1295
00:59:20,775 --> 00:59:25,636
it does this operation because this makes sense of loading LDP X29 X30
它会执行这个 LDP X29 X30 [sp]

1296
00:59:25,689 --> 00:59:29,222
SP in brackets like this means dereference SP
SP像这样放在括号中，表示解引用 SP

1297
00:59:29,415 --> 00:59:32,020
load whatever the eight bytes that are there into X29
将 它里面的8 个字节加载到 X29 中

1298
00:59:32,020 --> 00:59:35,495
and the eight bytes above that into X30
将再上面 8 个字节加载到 X30 中

1299
00:59:35,755 --> 00:59:37,545
and then add 16 to it.
然后sp += 16

1300
00:59:43,173 --> 00:59:44,371
Okay, so we loaded that.
好的 已经加载好了

1301
00:59:44,371 --> 00:59:45,346
Now what happens?
接下来会发生什么？

1302
00:59:46,553 --> 00:59:48,353
When we do this ret, what happens next?
执行 ret 后 接下来会发生什么？

1303
00:59:53,239 --> 00:59:53,839
What was that?
什么？

1304
00:59:58,534 --> 01:00:00,819
X30. X29 is the frame pointer
X30. X29 是帧指针

1305
01:00:04,700 --> 01:00:05,967
Yeah, but what's in X30?
那 X30 里面是什么呢？

1306
01:00:07,987 --> 01:00:08,767
What was it?
是什么？

1307
01:00:09,880 --> 01:00:10,807
Why is it win?
为什么是 win？

1308
01:00:15,624 --> 01:00:18,706
Yeah, so we went right to win.
所以我们直接去了 win

1309
01:00:19,353 --> 01:00:24,146
So this will, when we return, go back here.
所以 当win返回时 会回到这里

1310
01:00:26,703 --> 01:00:28,536
And then what will happen when win returns?
那么 当 win 再返回时会发生什么？

1311
01:00:31,473 --> 01:00:33,843
Yeah, it will keep doing this forever.
是的 它会一直这样做下去

1312
01:00:35,240 --> 01:00:40,981
I think in this case you'll run out of file descriptors.
我觉得在这种情况下 你会用完文件描述符

1313
01:00:40,981 --> 01:00:44,236
You will open up every possible file descriptor for the flag.
会为flag打开所有可能的文件描述符

1314
01:00:44,261 --> 01:00:45,562
The flag will print out
flag会打印出来

1315
01:00:45,562 --> 01:00:48,703
and it will just keep printing this over and over again.
它会不断地重复打印这个，一遍又一遍

1316
01:00:49,176 --> 01:00:50,563
The reason why I'm telling you this now
我现在告诉你这一点

1317
01:00:50,563 --> 01:00:52,723
instead of letting you figure this out on your own is
而不是让你自己去发现

1318
01:00:52,784 --> 01:00:54,904
that I want you to be nice to our servers
是因为我希望你对我们的服务器友好些

1319
01:00:54,904 --> 01:00:57,225
and I don't want them to just do busy work for no stupid reason.
我不希望它们因为不必要的原因而做无用功

1320
01:00:57,225 --> 01:00:58,370
So if you can protect that.
所以请尽量避免这种情况

1321
01:00:59,245 --> 01:01:02,390
So this is the pitfall of returning to the start of a function
这就是返回到函数起点的隐患

1322
01:01:02,991 --> 01:01:07,737
And this is exactly because of the architecture saying that
这正是由于体系结构要求

1323
01:01:07,971 --> 01:01:11,934
jumping to like a function uses whatever's in that register.
跳转到函数时，直接使用寄存器中的内容

1324
01:01:11,934 --> 01:01:13,435
Well, how did you get there on a return?
那么 你是怎么通过ret到那里的

1325
01:01:13,435 --> 01:01:15,195
Because whatever is in there is in that register.
因为寄存器里的内容决定了跳转目标

1326
01:01:18,577 --> 01:01:19,697
Yeah, that's a great question.
是的 这是个很好的问题

1327
01:01:19,697 --> 01:01:20,284
I'm going to ask you.
应该我来问你

1328
01:01:20,309 --> 01:01:21,151
I don't have a lot of answers.
我没有什么答案

1329
01:01:21,176 --> 01:01:21,983
You're full of answers.
你们才有答案

1330
01:01:22,398 --> 01:01:23,056
What was it?
是什么？

1331
01:01:24,299 --> 01:01:25,259
Skip the first instruction.
跳过第一条指令

1332
01:01:26,920 --> 01:01:28,076
So what happens if we jump here?
那么 如果我们在这里跳转会怎么样？

1333
01:01:37,685 --> 01:01:41,127
Yeah , and then , so if we skipped and jumped to win plus four ,
是的 如果我们跳过并跳转到 win +4

1334
01:01:44,829 --> 01:01:46,688
move stack pointer into X29 ,
将栈指针移到 X29

1335
01:01:48,883 --> 01:01:50,830
and then do all the stuff ,
然后执行所有的操作

1336
01:01:50,883 --> 01:01:55,483
and then finally at the end , yeah
最后

1337
01:01:55,749 --> 01:01:59,943
so then go load from stack pointer plus 16 , oh sorry ,
从栈指针加 16 处加载 抱歉

1338
01:02:00,049 --> 01:02:04,679
from the stack pointer , load into X29 and then X30
从栈指针处加载到 X29 和 X30

1339
01:02:05,091 --> 01:02:08,052
So those were on the stack right above where the stack pointer is.
这些就在栈指针的上方

1340
01:02:08,052 --> 01:02:09,793
The stack pointer is actually getting
栈指针实际上会被

1341
01:02:09,793 --> 01:02:11,114
because it's here in this case
因为在这种情况下

1342
01:02:11,114 --> 01:02:13,895
it'll get popped off 16 bytes every time.
每次都会弹出 16 字节

1343
01:02:15,936 --> 01:02:19,303
So yeah, then we don't have to deal with the prologue
所以 我们就不需要处理序言了

1344
01:02:19,357 --> 01:02:21,069
This is the beauty of ROP, right?
这就是 ROP 的美妙之处 对吧？

1345
01:02:21,136 --> 01:02:23,402
Rather than having to go right to the start of a function,
不必从函数的起点开始

1346
01:02:23,859 --> 01:02:25,402
go to another point in the function
可以直接跳到函数的其他位置

1347
01:02:25,540 --> 01:02:26,956
and then you can generalize that concept
这样你就可以把这个概念推广开来

1348
01:02:26,981 --> 01:02:29,356
and go, well let's just skip that part where it's sourced on the stack.
我们可以跳过从栈中获取的那部分

1349
01:02:29,761 --> 01:02:31,461
This means that your payloads will be
这意味着你的攻击载荷会

1350
01:02:32,684 --> 01:02:35,766
very different than what you are used to in x86-64.
与你在 x86-64 上习惯的大不相同

1351
01:02:35,766 --> 01:02:37,567
This is part of why I think this is fun to do
这就是我觉得这很有趣的原因之一

1352
01:02:37,567 --> 01:02:40,988
because you have to get all of these offsets
因为你需要获取这些偏移量

1353
01:02:40,988 --> 01:02:43,053
of calling these functions correctly
并正确地调用这些函数

1354
01:02:43,110 --> 01:02:44,590
and they're going to do different things
这些函数会执行不同的操作

1355
01:02:44,590 --> 01:02:46,211
and it's going to be fun.
这将会很有趣

1356
01:02:51,314 --> 01:02:51,654
Cool.
好的

1357
01:02:52,895 --> 01:02:53,395
Any other questions?
还有其他问题吗？

1358
01:02:59,850 --> 01:03:00,770
say it again
再说一遍

1359
01:03:03,189 --> 01:03:07,529
Yes, the stack pointer always has to be 16-byte aligned.
是的 栈指针必须始终 16 字节对齐

1360
01:03:17,115 --> 01:03:18,626
Yeah, so the way...
嗯 就是这样

1361
01:03:21,901 --> 01:03:23,640
I would probably...
我可能会...

1362
01:03:24,886 --> 01:03:26,787
I don't know the direct answer to your question.
我不能直接回答你的问题

1363
01:03:26,787 --> 01:03:31,148
My intuition is that every single one of these instructions
我的直觉是每个指令

1364
01:03:31,148 --> 01:03:33,609
has to leave the stack aligned correctly.
都必须使栈对齐

1365
01:03:38,410 --> 01:03:42,091
But even then, if ever that instruction was executed
但即使如此 如果某条指令被执行

1366
01:03:42,091 --> 01:03:44,649
the stack must be aligned properly
栈必须正确对齐

1367
01:03:44,771 --> 01:03:47,036
especially if you're executing an entire function.
尤其是当你执行整个函数时

1368
01:03:48,943 --> 01:03:52,016
Every single instruction has to leave the stack aligned correctly.
每条指令都必须保证栈正确对齐

1369
01:03:53,154 --> 01:03:53,854
So I think...
我觉得...

1370
01:03:55,580 --> 01:03:57,621
You don't need to worry about that.
你不用担心这个

1371
01:04:04,223 --> 01:04:06,963
Yeah, so that's on gadgets you would need to worry about that.
是的 用gadget时才需要担心这一点

1372
01:04:07,609 --> 01:04:08,143
Yeah.
是的

1373
01:04:08,283 --> 01:04:11,271
And if you're using a pushy pop style gadget
如果你用的是 push-pop 风格的gadget

1374
01:04:11,271 --> 01:04:12,250
you will need to do that.
你就得这样操作

1375
01:04:13,113 --> 01:04:13,993
Oh, let's look if...
哦 我们看看...

1376
01:04:15,754 --> 01:04:16,455
Did I install this?
我安装了吗？

1377
01:04:22,405 --> 01:04:23,160
Why does nothing work?
为什么什么都不行？

1378
01:04:23,160 --> 01:04:23,658
Okay.
好的

1379
01:04:29,573 --> 01:04:33,170
Okay, well it's going to be hard to not find any gadgets without any tools
好吧 没有工具 想找些gadget真挺难的

1380
01:04:33,170 --> 01:04:34,931
but we'll get that fixed.
但我们马上解决

1381
01:04:36,052 --> 01:04:37,219
There should be something here.
这里应该有点东西

1382
01:04:37,313 --> 01:04:38,153
Anyways, okay.
不管了 好的

1383
01:04:45,123 --> 01:04:46,009
Oh, this thing?
哦 这个？

1384
01:04:46,103 --> 01:04:46,841
Ah, there we go, okay.
啊 找到了 好了

1385
01:04:49,836 --> 01:04:51,623
I believe this has...
我觉得这个有……

1386
01:04:55,048 --> 01:04:56,169
Yeah, okay, great.
嗯 好的 太好了

1387
01:04:56,169 --> 01:04:58,136
It has support already for ARM.
它已经支持 ARM 了

1388
01:04:59,084 --> 01:05:01,084
If there's other stuff that's not installed, let me know.
如果还有其他没安装的 告诉我

1389
01:05:01,084 --> 01:05:05,045
I think I use Ropper usually or other stuff.
我通常用 Ropper 或其他工具

1390
01:05:05,045 --> 01:05:07,366
But anyways, so yeah, tons of weird gadgets.
不过 确实有很多奇怪的gadget

1391
01:05:07,366 --> 01:05:09,236
So you will have a fun time with this.
所以你会玩得很开心的

1392
01:05:11,127 --> 01:05:11,987
But that's the goal.
但这正是目标

1393
01:05:14,340 --> 01:05:14,907
Anything else?
还有其他事吗？

1394
01:05:16,481 --> 01:05:16,889
Okay.
好的

1395
01:05:17,128 --> 01:05:20,143
Let's break for five minutes
我们休息五分钟

1396
01:05:20,209 --> 01:05:22,923
because I've been going for over an hour.
因为我已经播了一个多小时了

1397
01:05:24,556 --> 01:05:25,076
Okay.
好的

1398
01:05:25,150 --> 01:05:26,359
I guess I'll pause the stream.
我先暂停一下吧

1399
01:05:27,593 --> 01:05:28,394
Do, do, do.
嗒 嗒 嗒

1400
01:05:28,419 --> 01:05:30,753
Now you can listen to music, Twitch stream.
现在可以听音乐了 Twitch 直播间

1401
01:05:32,897 --> 01:05:33,898
Or do I just stop streaming?
或者我直接停播？

1402
01:05:33,898 --> 01:05:34,798
I don't want to stop streaming.
我可不想停播

1403
01:05:36,566 --> 01:05:37,280
I'm just going to mute it.
我先把它静音

1404
01:11:26,642 --> 01:11:27,209
Okay.
好的

1405
01:11:27,209 --> 01:11:28,522
Hello, Twitch.
大家好 Twitch 直播间

1406
01:11:29,255 --> 01:11:30,829
I hope you enjoyed that break.
希望你们喜欢刚才的休息

1407
01:11:31,535 --> 01:11:32,775
I hope this stuff works.
希望这些能派上用场

1408
01:11:33,711 --> 01:11:34,050
We'll see.
咱们拭目以待吧

1409
01:11:34,075 --> 01:11:35,062
Actually, I have no idea if it's going to work,
其实 我也不确定这能不能行

1410
01:11:35,087 --> 01:11:37,531
 but anyways it won't break right now.
总之，暂时不会出问题

1411
01:11:37,531 --> 01:11:38,582
I'll just fix it later.
到时候再修好了

1412
01:11:38,732 --> 01:11:39,332
Okay.
好的

1413
01:11:39,332 --> 01:11:40,626
So we did that.
所以搞定了

1414
01:11:40,773 --> 01:11:43,573
Let's do, because I don't know how long the CTF
我们 因为我不确定 CTF 能持续多久

1415
01:11:45,173 --> 01:11:46,746
the live breaking will work.
现场破解能成功吗

1416
01:11:46,946 --> 01:11:49,206
So let's shift gears
那我们换个话题

1417
01:11:50,073 --> 01:11:57,323
and go over to how to identify targets.
谈谈如何确定目标

1418
01:11:59,904 --> 01:12:02,044
Okay, we don't want to check, make sure here
好的 我们确认一下

1419
01:12:02,044 --> 01:12:03,549
whatever they can see presenter mode.
确保他们能看到演示模式

1420
01:12:03,730 --> 01:12:05,216
Okay, cool.
好的 可以

1421
01:12:05,363 --> 01:12:07,583
So why do we care about picking targets?
为什么我们要关心目标选择呢？

1422
01:12:14,906 --> 01:12:16,127
You might pick something
你可能会选择一些

1423
01:12:16,127 --> 01:12:19,647
where let's say the developers don't want you to find bugs in their stuff
开发者不希望你发现bug的东西

1424
01:12:19,647 --> 01:12:21,207
or vulnerabilities in their stuff.
或者他们产品的漏洞

1425
01:12:21,508 --> 01:12:22,840
Yeah, that's definitely true.
是的 确实如此

1426
01:12:23,268 --> 01:12:23,687
What else?
还有什么？

1427
01:12:27,254 --> 01:12:27,974
follow me okay
跟着我，好了

1428
01:12:28,535 --> 01:12:29,126
What else?
还有什么吗？

1429
01:12:32,176 --> 01:12:33,886
Some targets are easier than others?
有些目标比其他的好对付？

1430
01:12:34,778 --> 01:12:36,518
Why do you care about either of those things?
你为什么在意这些东西？

1431
01:12:39,520 --> 01:12:40,638
You want to find bugs?
你想找bug？

1432
01:12:40,861 --> 01:12:42,051
Finding bugs is easy.
找bug很简单

1433
01:12:42,642 --> 01:12:43,522
Look at your own code.
看看你自己的代码

1434
01:12:43,522 --> 01:12:44,424
You will find bugs.
你就能看到bug

1435
01:12:49,626 --> 01:12:52,146
Picking targets that are maybe more exploitable than others?
选择更容易被利用的目标？

1436
01:12:52,927 --> 01:12:53,488
Yeah, so...
嗯 所以...

1437
01:12:56,539 --> 01:12:59,800
What I want you to be thinking about, and I guess, I mean
我希望你们思考的 我想说的是...

1438
01:12:59,800 --> 01:13:02,380
I guess Yan talked about it a little bit
我想Yan已经提过一些

1439
01:13:02,380 --> 01:13:05,881
but so the background here is I spent a year
背景是我花了一年时间

1440
01:13:05,881 --> 01:13:08,240
doing basically vulnerability analysis,
做漏洞分析

1441
01:13:08,461 --> 01:13:10,626
targeting the XNU kernel and Mac.
目标是 XNU 内核和 Mac 系统

1442
01:13:10,673 --> 01:13:13,942
I didn't originally intend to target the kernel.
一开始我没打算针对内核

1443
01:13:13,942 --> 01:13:15,602
I wanted to do like Apple stuff.
我想做苹果的东西

1444
01:13:15,602 --> 01:13:17,643
And so I read a bunch of books about it
所以我读了很多相关书籍

1445
01:13:17,668 --> 01:13:21,110
and looked at user space programs and tried to
看了用户空间的程序 尝试

1446
01:13:22,083 --> 01:13:26,585
I think I was, D, not decompiling
我想我，不是反编译

1447
01:13:26,585 --> 01:13:28,988
but disassembling the kernel cache
而是反汇编内核缓存

1448
01:13:28,988 --> 01:13:29,828
which we'll get into,
我们之后会详细讲

1449
01:13:29,861 --> 01:13:33,626
but is basically like the kernel and every single driver in it.
 但基本上就是内核以及里面的驱动

1450
01:13:33,893 --> 01:13:34,694
And I set that up
我把一切都设置好了

1451
01:13:34,694 --> 01:13:37,842
and it took literally like a day and a half in IDA to disassemble
我又花了一天半在 IDA 上反汇编

1452
01:13:37,867 --> 01:13:38,960
Anybody know?
有人知道吗？

1453
01:13:39,060 --> 01:13:42,922
Yeah, to even disassemble and create the control flow graph and everything.
是的 包括反汇编和生成控制流图

1454
01:13:42,922 --> 01:13:44,023
Does anybody know the trick?
有人知道这个技巧吗？

1455
01:13:44,023 --> 01:13:46,422
Or I think it used to be an older trick to speed up IDA
有个加速 IDA 的老技巧

1456
01:13:46,608 --> 01:13:47,814
It'd save you a long time
能节省很多时间

1457
01:13:51,718 --> 01:13:53,439
close like the console window
关闭控制台窗口

1458
01:13:53,439 --> 01:13:54,768
and all the other windows
以及其他所有窗口

1459
01:13:54,839 --> 01:14:00,141
because there's GUI refreshing that happens on like those side panels and stuff
 因为那些侧边栏之类的会发生GUI刷新

1460
01:14:00,141 --> 01:14:02,019
and it speeds it up by like 30%.
这能提升大约 30% 的速度

1461
01:14:02,519 --> 01:14:03,579
It's like crazy stuff.
真是太神奇了

1462
01:14:03,772 --> 01:14:05,759
Anyways, so I spent a lot of time
总之 我花了好多时间

1463
01:14:06,152 --> 01:14:10,486
and what I'm trying to get through here is the lessons that I learned.
我想传达的是我学到的经验教训

1464
01:14:10,565 --> 01:14:19,015
So for those that don't know and aren't in academia, so sabbatical is...
对于不了解学术界的人来说 学术休假是...

1465
01:14:19,015 --> 01:14:24,238
Like, there's a specific thing in academia where every seven years
学术界有一种特殊的制度 每七年...

1466
01:14:24,238 --> 01:14:25,259
so your seventh year
也就是第七年

1467
01:14:25,259 --> 01:14:26,980
that's where seven comes from.
这就是‘七’的来源

1468
01:14:26,980 --> 01:14:29,141
Sabbath is similar to sabbatical.
学术休假和 sabatical 很类似

1469
01:14:29,141 --> 01:14:30,349
It has the same root.
词源相同

1470
01:14:30,523 --> 01:14:33,484
Every seven years, you can take time off
每隔七年 你可以休假

1471
01:14:33,484 --> 01:14:36,085
to go in different research directions or whatever.
去研究不同的方向或其他事情

1472
01:14:36,085 --> 01:14:37,806
That's, like, negotiated through your contract.
这通常是在合同中协商的

1473
01:14:37,806 --> 01:14:43,730
It's part of the reason why us academics put up with those lovely students
这是我们这些学者能够容忍那些淘气学生的部分原因

1474
01:14:43,730 --> 01:14:46,591
and our lack of pay compared to our industry peers
也是我们相比行业同行收入较低的原因之一

1475
01:14:46,591 --> 01:14:47,963
because we get a lot of freedoms.
因为我们有很多自由

1476
01:14:48,179 --> 01:14:50,201
And one of those freedoms is the ability to just like
其中一项自由就是可以

1477
01:14:51,202 --> 01:14:53,504
not have any university responsibilities for a year
一年不承担任何大学的职责

1478
01:14:53,504 --> 01:14:54,825
and be able to focus on other things.
能够专注于其他的事情

1479
01:14:54,825 --> 01:14:58,943
So I focused on bug finding and vulnerability analysis.
所以我专注于找漏洞和分析漏洞

1480
01:14:59,230 --> 01:15:01,211
And as part of that, some people
其中有些人

1481
01:15:01,211 --> 01:15:03,963
when they do a sabbatical, go and work at a company
休学术假时 会去公司工作

1482
01:15:04,250 --> 01:15:05,316
and make a bunch of money.
赚一大笔钱

1483
01:15:05,375 --> 01:15:08,943
And that's a great way to see what research problems like companies have.
这是了解公司在研究什么问题的好方法

1484
01:15:09,103 --> 01:15:12,699
And you get to make a salary because even though, you know
你还能拿到薪水 尽管

1485
01:15:12,699 --> 01:15:16,062
Your lovely tax dollars are paying my salary at ASU.
你们的税款支付了我在ASU工作的工资

1486
01:15:16,062 --> 01:15:17,083
Well, if you guys are working
嗯 如果你们在工作

1487
01:15:17,083 --> 01:15:19,968
I don't know if you're working, but the broader you.
我不知道你们是否在工作 但广义上的你们

1488
01:15:21,495 --> 01:15:24,229
And so the university will let you have that time off
所以大学会给你这段休假时间

1489
01:15:24,229 --> 01:15:27,011
but depending on your university
但不同大学情况可能不一样

1490
01:15:27,011 --> 01:15:29,736
you don't get full pay during that full time.
这段时间你拿不到全额工资

1491
01:15:29,853 --> 01:15:32,155
So my plan was I would make up my salary
所以我打算补足我的工资

1492
01:15:32,155 --> 01:15:34,617
by finding bugs and reporting bugs.
通过找漏洞和报告漏洞

1493
01:15:34,617 --> 01:15:35,576
That was the idea.
这就是我的打算

1494
01:15:35,658 --> 01:15:39,061
So this is something that I actually had to learn the hard way about
所以我是在实践中才慢慢学到这一点的

1495
01:15:39,061 --> 01:15:42,647
not just like what to target and why
不仅是选择什么目标，还有为什么要这样做

1496
01:15:42,701 --> 01:15:44,281
 but i think i learned a lot about like
 但我确实学到了很多

1497
01:15:45,074 --> 01:15:50,691
approaching it from the mindset of maximizing your money payout
如何从最大收益的角度来思考这个问题

1498
01:15:50,691 --> 01:15:53,173
which i did not think of as i was starting this
这是我刚开始时没想到的

1499
01:15:53,173 --> 01:15:55,214
i really only figured that out the last like three months
其实我是在过去的三个月才意识到这一点的

1500
01:15:55,214 --> 01:15:58,516
and then uh couldn't do anything with that information
然后不知道怎么用这些信息

1501
01:15:58,516 --> 01:16:00,057
um so this is why thinking about
所以才有了这些想法

1502
01:16:00,057 --> 01:16:05,262
because i spent months just poking around at like uh Mac OS,
因为我花了好几个月的时间在 Mac OS 上瞎摸

1503
01:16:05,262 --> 01:16:08,144
learning different things, but like not really
学了很多东西 但都没有深入

1504
01:16:08,144 --> 01:16:11,986
probably took like three months until I really like focused on the kernel
大概花了三个月 我才真正集中精力研究内核

1505
01:16:11,986 --> 01:16:12,566
and was like, okay
然后心想 好吧

1506
01:16:12,566 --> 01:16:13,566
I'm going to find this thing.
我要找到这个东西

1507
01:16:13,566 --> 01:16:15,070
But so I want you to
但我想请你

1508
01:16:15,196 --> 01:16:15,927
I want to talk about
我想谈谈

1509
01:16:15,927 --> 01:16:19,809
and I want us to discuss how to like pick, pick targets.
我还想和大家讨论如何选择目标

1510
01:16:19,809 --> 01:16:22,971
So one thing you can do is just randomly, right?
你可以随便选一个 对吧？

1511
01:16:22,971 --> 01:16:24,110
Just like pointed a thing.
比如随便找一个项目

1512
01:16:24,929 --> 01:16:26,696
Ah, there's a GitHub project.
啊 找到了个 GitHub 项目

1513
01:16:26,913 --> 01:16:29,134
I'm going to look for bugs and vulnerabilities in that target.
我打算在这个项目里找漏洞

1514
01:16:31,235 --> 01:16:32,263
Probably not effective.
可能不太有效

1515
01:16:33,196 --> 01:16:33,496
Right?
对吧？

1516
01:16:33,496 --> 01:16:35,957
Because just like random stuff may or may not
因为随便选的项目不一定有漏洞

1517
01:16:37,778 --> 01:16:39,479
you will find bugs by doing this.
你能找到漏洞

1518
01:16:39,479 --> 01:16:40,740
I absolutely guarantee you.
我绝对可以保证

1519
01:16:40,740 --> 01:16:46,516
If anybody, a good habit to do for bug finding is like reading code.
找漏洞的一个好习惯就是阅读代码

1520
01:16:46,603 --> 01:16:48,256
You can just read random source code.
你可以随便找些源代码来看看

1521
01:16:48,524 --> 01:16:50,545
If you do a Google, like not a Google search,
如果你用Google搜索，不对

1522
01:16:50,545 --> 01:16:52,671
a GitHub code search for just system.
你可以到 GitHub 上搜索有system的代码

1523
01:16:53,649 --> 01:16:58,189
and start looking at every C code that has system
然后查看所有包含system的 C 代码

1524
01:16:58,391 --> 01:17:00,789
you will absolutely find a vulnerability.
你绝对能找到漏洞

1525
01:17:00,815 --> 01:17:03,269
Or probably in Python, os.system
或者在 Python 的 `os.system` 中

1526
01:17:03,712 --> 01:17:05,073
you will absolutely find stuff.
你肯定能找到一些东西

1527
01:17:05,073 --> 01:17:06,433
There is stuff out there.
外面确实有些东西

1528
01:17:06,433 --> 01:17:09,114
You could, if you wanted to find real bugs in real systems
如果你想在实际系统中找真正的漏洞

1529
01:17:09,114 --> 01:17:10,366
you could do this for sure.
你这样做肯定行

1530
01:17:11,975 --> 01:17:14,080
You can choose what you know, right?
你可以选择你熟悉的东西 对吧？

1531
01:17:14,696 --> 01:17:16,933
What's the benefit of choosing software that you know?
选择熟悉的软件有什么好处？

1532
01:17:20,566 --> 01:17:21,279
What was it?
什么？

1533
01:17:21,279 --> 01:17:22,885
You already know what's in the code.
你已经知道代码的内容

1534
01:17:23,452 --> 01:17:25,913
Yeah, you already know, well, maybe the code.
对 你已经知道了 可能是代码

1535
01:17:25,913 --> 01:17:28,534
I mean, it depends on how really familiar you are with it, right?
这取决于你对它有多熟悉 对吧？

1536
01:17:28,534 --> 01:17:30,095
But it may be something you're very familiar with
但你可能非常熟悉

1537
01:17:30,095 --> 01:17:31,976
so you know how it works, right?
所以你知道它的运作方式 对吧？

1538
01:17:31,976 --> 01:17:34,937
That's a key thing of any kind of vulnerability analysis is
这是任何漏洞分析的关键

1539
01:17:34,937 --> 01:17:38,266
trying to identify and understand the target at a really deep level
即尝试识别并深入了解目标

1540
01:17:38,499 --> 01:17:42,990
so they can understand what are bad things.
以识别潜在问题

1541
01:17:43,101 --> 01:17:44,889
What's the downside of choosing what you know?
选择你熟悉的有什么坏处？

1542
01:17:49,276 --> 01:17:49,815
Say it again?
再说一遍？

1543
01:17:52,709 --> 01:17:54,509
Ah, the search stage becomes too small.
啊 搜索范围太小了

1544
01:17:54,653 --> 01:17:55,269
Yeah.
嗯

1545
01:17:56,754 --> 01:18:00,366
You know, if your daily driver is some Nix OS
你知道 如果你的日常系统是 Nix 系统

1546
01:18:00,515 --> 01:18:02,246
like if you find some Nix bug
比如你发现了一个 Nix 的 bug

1547
01:18:02,775 --> 01:18:04,766
I'm sure people will care, but like
我相信会有人关心 但是

1548
01:18:05,116 --> 01:18:08,736
would you want to find a bug in that or a bug in
你愿意在那个系统里找 bug 还是在

1549
01:18:08,736 --> 01:18:10,519
I don't know, Exchange server?
例如，Exchange 服务器里？

1550
01:18:10,566 --> 01:18:12,559
Anybody know what Exchange server is?
有人知道什么是 Exchange 服务器吗？

1551
01:18:14,317 --> 01:18:14,958
Anybody?
有人吗？

1552
01:18:15,218 --> 01:18:16,120
What's Exchange?
Exchange 是什么？

1553
01:18:16,951 --> 01:18:17,279
Yeah.
对

1554
01:18:17,333 --> 01:18:18,100
Email server.
邮件服务器

1555
01:18:18,100 --> 01:18:20,860
That's every, almost every large organization on earth
几乎所有的大型组织

1556
01:18:20,900 --> 01:18:23,386
uses exchange server to run their email.
都在用 Exchange 服务器来处理邮件

1557
01:18:23,693 --> 01:18:25,840
If they're either on Google or this basically.
如果他们用的是 Google 或类似的

1558
01:18:26,360 --> 01:18:28,268
And like, and exchange servers
还有 Exchange 服务器

1559
01:18:28,268 --> 01:18:29,869
do they have like an email server?
它们有邮件服务器

1560
01:18:29,869 --> 01:18:31,230
Does it have to be exposed to the internet?
它们必须暴露在互联网上吗？

1561
01:18:34,193 --> 01:18:34,993
Yeah, it has to.
是的 必须的

1562
01:18:34,993 --> 01:18:36,655
It collects messages.
它收集邮件

1563
01:18:36,655 --> 01:18:39,637
You find a bug where you can send an email to somebody's exchange server
你发现了一个漏洞 可以通过发送邮件到某人的 Exchange 服务器

1564
01:18:39,637 --> 01:18:41,666
and pop their exchange thing.
并入侵他们的 Exchange 服务器

1565
01:18:41,959 --> 01:18:45,446
You've taken over like multi-million dollar company's emails.
你就接管了市值数百万美元公司的邮件

1566
01:18:46,303 --> 01:18:47,313
That's like insane.
这太疯狂了

1567
01:18:47,865 --> 01:18:54,196
So this is part of some things to think about.
所以这是需要考虑的问题之一

1568
01:18:54,221 --> 01:18:55,531
Also, what's available?
还有 有哪些能使用到的？

1569
01:18:55,531 --> 01:18:57,243
What do you actually have access to, right?
你要能访问到的，对吧？

1570
01:18:57,268 --> 01:18:58,316
I mentioned Exchange,
我提到了 Exchange，

1571
01:18:58,341 --> 01:19:02,117
but anybody here have experience with Windows Server?
有人用过 Windows Server 吗？

1572
01:19:04,179 --> 01:19:04,643
Yeah?
嗯？

1573
01:19:05,200 --> 01:19:06,361
Do you have access to Exchange?
你能用 Exchange 吗？

1574
01:19:07,722 --> 01:19:12,353
Yeah, you have to have an MSDN subscription in order to install Exchange.
是的 需要 MSDN 订阅才能安装 Exchange

1575
01:19:12,605 --> 01:19:13,820
I think back in my day
依我以前的经验

1576
01:19:14,005 --> 01:19:15,826
students had access to MSDN and it was great
学生能用 MSDN 非常棒

1577
01:19:15,826 --> 01:19:19,306
but you need access to the software, right?
但你得有软件才行 对吧？

1578
01:19:19,306 --> 01:19:23,007
It would be super cool to find bugs in industrial control systems
在工业控制系统中找到漏洞会很酷

1579
01:19:23,007 --> 01:19:26,328
that do nuclear enrichment and all kinds of stuff
比如核浓缩和其他系统的漏洞

1580
01:19:26,353 --> 01:19:27,888
but like I don't know.
但我不知道

1581
01:19:27,888 --> 01:19:29,223
Do you have access to that stuff?
你能接触到那些东西吗？

1582
01:19:30,216 --> 01:19:31,689
If you do, don't say anything to me.
如果有的话 别告诉我

1583
01:19:31,689 --> 01:19:32,789
I don't want to know about it
我不想知道

1584
01:19:32,789 --> 01:19:34,849
but this is the kind of thing.
就是这样

1585
01:19:34,849 --> 01:19:36,696
What's available to you?
你有什么能接触到的？

1586
01:19:36,756 --> 01:19:38,049
You do have to think about this stuff
你确实需要考虑这些问题

1587
01:19:38,090 --> 01:19:39,891
because you can set your eyes on a target
因为你可能会定个目标

1588
01:19:39,891 --> 01:19:41,211
and then be like, okay, well, crap.
结果发现 完了 搞砸了

1589
01:19:41,211 --> 01:19:43,637
How do I get How do I run it?
我怎么得到它？怎么运行它？

1590
01:19:43,637 --> 01:19:44,664
And we'll talk about other things.
我们再聊点别的

1591
01:19:45,198 --> 01:19:50,944
Now, these are kind of, you know
现在 这些都是你知道的

1592
01:19:50,991 --> 01:19:52,364
one of the things, I mean
我是说 其中的一件事

1593
01:19:52,804 --> 01:19:54,125
what it really comes down to, honestly
说白了 就是

1594
01:19:54,125 --> 01:19:55,966
is you and your time, right?
就是你和你的时间 对吧？

1595
01:19:55,966 --> 01:19:58,166
If you're going to invest time in finding bugs
如果你打算花时间找 bug

1596
01:19:59,128 --> 01:20:00,249
like you should be thinking about
你应该好好想想

1597
01:20:00,249 --> 01:20:01,010
and I'll get there in a second
我马上要做了

1598
01:20:01,010 --> 01:20:03,392
like what do you want out of this,
你想要什么

1599
01:20:03,392 --> 01:20:03,880
right?
对吧？

1600
01:20:04,120 --> 01:20:07,475
And, you know, if you want to have an impact
如果你想产生影响

1601
01:20:07,475 --> 01:20:10,197
and you want to find bugs that are important that people care about
并找到那些重要且受人关注的 bug

1602
01:20:10,197 --> 01:20:11,580
anybody know of a named bug?
有没有人知道什么有名的 bug？

1603
01:20:12,766 --> 01:20:13,436
Of top of their head
马上能想到的

1604
01:20:13,436 --> 01:20:14,720
like a bug that has a name.
像是有名的漏洞

1605
01:20:15,106 --> 01:20:15,906
Heartbleed.
心脏出血

1606
01:20:16,677 --> 01:20:17,639
What are some other ones?
还有哪些？

1607
01:20:19,518 --> 01:20:20,040
What was it?
是什么？

1608
01:20:20,646 --> 01:20:21,339
Log4j.
Log4j

1609
01:20:21,339 --> 01:20:23,120
That was literally, does anybody know Log4j?
那不就是 有人知道 Log4j 吗？

1610
01:20:24,160 --> 01:20:24,400
Yeah.
对

1611
01:20:24,400 --> 01:20:28,300
Was anybody looking at bugs in the Java logging libraries
有人研究过 Java 日志库的漏洞吗？

1612
01:20:29,382 --> 01:20:31,442
that allowed arbitrary command execution
这些漏洞允许任意命令执行

1613
01:20:31,442 --> 01:20:33,843
that every company on earth freaked out about
让全球的公司都慌了

1614
01:20:33,843 --> 01:20:38,085
because every Java software uses logging and every
因为每个 Java 软件都会用到日志功能 每个

1615
01:20:38,085 --> 01:20:42,956
like so many companies use Java behind the scenes in their web services.
很多公司在他们的网络服务中都用到了 Java

1616
01:20:44,530 --> 01:20:46,243
Yeah, any other bugs, named bugs?
嗯 还有其他有名的漏洞吗？

1617
01:20:50,733 --> 01:20:52,116
Spectre, Meltdown?
幽灵， 熔断？

1618
01:20:52,969 --> 01:20:53,296
Yeah.
嗯

1619
01:20:54,355 --> 01:20:54,809
Huh?
什么？

1620
01:20:55,370 --> 01:20:55,995
Shell shock?
Shellshock？

1621
01:20:55,995 --> 01:20:56,783
Yeah, that was a great one.
嗯 那个确实很厉害

1622
01:20:57,516 --> 01:20:58,369
Yeah, so like, you know
嗯 你知道的

1623
01:20:58,457 --> 01:21:02,939
it's not that you necessarily, I wouldn't, oh, the question is
不一定非要这样做 我不会 哦 关键问题是

1624
01:21:02,939 --> 01:21:04,820
will we go over extracting firmware from real devices
我们会讨论如何从设备中提取固件吗？

1625
01:21:04,820 --> 01:21:07,589
and how to emulate it for VR purposes?
以及如何在虚拟现实中仿真它？

1626
01:21:07,629 --> 01:21:08,410
Absolutely not.
绝对不

1627
01:21:09,102 --> 01:21:10,422
That's something that you can do on your own.
这是你可以自己做的

1628
01:21:12,944 --> 01:21:18,606
The Zenbleed or the XZ Backstore was a great one.
Zenbleed 和 XZ Backstore 都很棒

1629
01:21:19,519 --> 01:21:22,940
And so it's important to consider something to think about.
所以考虑一下还是很重要的

1630
01:21:22,966 --> 01:21:24,840
You have limited time. Where are you going to spend your time?
时间有限 你打算把时间花在哪里？

1631
01:21:24,865 --> 01:21:25,794
Is it on something important?
是在重要的事情上吗？

1632
01:21:25,794 --> 01:21:27,415
I'm not saying you should find bugs.
我不是说你应该去找漏洞

1633
01:21:27,415 --> 01:21:28,195
I'm not even saying
我也不是说

1634
01:21:28,195 --> 01:21:30,717
that I like these weird named bug things.
我喜欢这些奇怪命名的 bug

1635
01:21:30,717 --> 01:21:31,898
I think it's kind of a weird trend
我觉得这是一股奇怪潮流

1636
01:21:31,898 --> 01:21:33,119
but I don't know.
但我也不清楚

1637
01:21:33,119 --> 01:21:34,413
I understand why people do it.
我能理解为什么有人这么做

1638
01:21:35,621 --> 01:21:37,242
But that's like
但就像

1639
01:21:38,543 --> 01:21:41,166
do you want to spend your weekends or your life finding bugs in...
你愿意花上周末或一生，

1640
01:21:41,853 --> 01:21:43,260
Game Boy emulators?
找游戏机模拟器上的 bug吗？

1641
01:21:44,441 --> 01:21:44,880
I don't know.
我不知道

1642
01:21:45,062 --> 01:21:46,623
Like, it's cool. It's cool.
真的挺酷

1643
01:21:46,623 --> 01:21:48,303
But, you know.
但是你知道

1644
01:21:48,663 --> 01:21:50,627
Availability, like we talked about, right?
获取的方便性 就像我们之前说的 对吧？

1645
01:21:50,627 --> 01:21:51,748
Can I get my hands on that thing?
我能弄到那东西吗？

1646
01:21:51,748 --> 01:21:52,823
Can I run that thing?
我能运行那东西吗？

1647
01:21:53,343 --> 01:21:57,913
This is honestly, I will try to abstract this as much as possible
说实话 我会尽量简化这个问题

1648
01:21:57,913 --> 01:22:01,650
but this is the main thing that's a pain of doing XNU research.
但这确实是进行 XNU 研究的难点

1649
01:22:02,130 --> 01:22:06,289
Because, like, especially with the ARM
因为 特别是 ARM 处理器

1650
01:22:06,630 --> 01:22:08,302
And the Apple Silicon Macs
还有苹果芯片

1651
01:22:08,302 --> 01:22:12,003
they have locked down access to these systems so much that like loading
他们对这些系统的访问限制得非常严格 以至于加载

1652
01:22:12,003 --> 01:22:15,325
because on the Intel Macs
因为用Intel芯片 的 Mac

1653
01:22:15,325 --> 01:22:17,526
you can load alternative kernels and stuff.
你可以加载其他内核等

1654
01:22:17,526 --> 01:22:19,707
So loading a like a KASAN kernel
比如加载有 KASAN 的内核

1655
01:22:19,707 --> 01:22:22,275
which has address sanitizers to prove
它有地址检查器来证明

1656
01:22:22,275 --> 01:22:24,437
that you found some out of bounds write
你发现的越界写问题

1657
01:22:24,437 --> 01:22:25,872
because you can get a case and report
因为你可以得到一个用例和报告

1658
01:22:25,897 --> 01:22:28,383
that you could use in your bug report to Apple
它能用在你给苹果的bug报告中

1659
01:22:28,770 --> 01:22:29,801
is super important.
这非常重要

1660
01:22:29,801 --> 01:22:31,782
But like I had to use separate machines.
但我不得不使用单独的机器

1661
01:22:31,782 --> 01:22:33,684
Like I had kept an old laptop around for that.
我一直留着一台旧笔记本用于这个

1662
01:22:33,684 --> 01:22:36,666
Like people buy other machines for this and it's a pain.
人们为此要买其他设备 确实麻烦

1663
01:22:38,129 --> 01:22:39,323
Yes, Chad is very good.
是的 查德真的很牛

1664
01:22:39,516 --> 01:22:41,756
Weird names are at least more recognizable than CV numbers.
奇怪的名字至少比简历编号好记

1665
01:22:41,843 --> 01:22:43,932
Absolutely agree, which is why that's, I think, cool.
完全同意 我觉得这点很酷

1666
01:22:44,916 --> 01:22:46,403
Money, right?
钱 对吧？

1667
01:22:46,830 --> 01:22:48,616
If you're gonna be spending your time, there's...
你要花时间 就得……

1668
01:22:49,027 --> 01:22:51,731
Oh, wow, I should have had a whole slide on ethics.
哦 天哪 我应该用一整张幻灯片来讲伦理

1669
01:22:51,756 --> 01:22:53,349
We should probably just talk about that next.
我们接下来就讨论这个

1670
01:22:55,849 --> 01:22:57,749
Yeah, well, maybe, I mean
嗯 也许 我是说

1671
01:22:57,774 --> 01:22:58,750
I like learning stuff
我喜欢学习

1672
01:22:58,750 --> 01:23:00,410
but when I say money, I mean
我说的钱就是指

1673
01:23:00,450 --> 01:23:02,131
this was like literally my reality
这是要面对的现实

1674
01:23:02,131 --> 01:23:08,493
where I had to hypothetically feed myself by the bugs that I found.
我得靠找到的bug来养活自己

1675
01:23:09,573 --> 01:23:13,636
And so that can affect what target you choose.
这会影响你选择的目标

1676
01:23:13,754 --> 01:23:16,390
Does the Game Boy emulator have a bug bounty program?
Game Boy 模拟器有漏洞赏金计划吗？

1677
01:23:17,975 --> 01:23:19,115
I mean, maybe, I don't know.
可能有吧 我不知道

1678
01:23:19,115 --> 01:23:20,496
I don't write Game Boy emulators
我不写 Game Boy 模拟器

1679
01:23:20,496 --> 01:23:22,546
but they probably don't.
但他们可能没有

1680
01:23:22,677 --> 01:23:23,797
Yeah, exactly.
对 没错

1681
01:23:26,178 --> 01:23:29,486
And what is that bug bounty program like?
那个漏洞赏金计划是怎样的？

1682
01:23:29,660 --> 01:23:33,706
How often are people paid?
人们多久领一次酬劳？

1683
01:23:33,761 --> 01:23:34,701
What do you know about that?
你对这个了解多少？

1684
01:23:34,701 --> 01:23:36,342
Do you know anybody that's getting paid by that?
你知道有人靠这个挣钱吗？

1685
01:23:39,083 --> 01:23:40,744
The other thing, this isn't a word
还有一点 这不是一个词

1686
01:23:40,744 --> 01:23:43,060
but I think maybe you probably know this.
但我认为你们可能知道这个

1687
01:23:43,425 --> 01:23:45,085
It's kind of similar to availability.
它有点像可用性

1688
01:23:45,085 --> 01:23:46,843
How easy is it to debug this thing?
调试这个东西容易吗？

1689
01:23:47,530 --> 01:23:51,335
Is it such a pain that it makes you want to rip your hair out?
这会让人痛苦到想抓头发吗？

1690
01:23:51,335 --> 01:23:53,056
On one hand, that can actually be a benefit
一方面 这实际上是个优势

1691
01:23:53,056 --> 01:23:54,916
because it's a bit of a moat, right?
因为这有点像护城河 对吧？

1692
01:23:54,916 --> 01:23:57,737
If you think like nobody else is probably popping that target
如果你觉得没人会去碰这个目标

1693
01:23:57,737 --> 01:23:59,258
because it's such a pain to debug
因为调试太麻烦了

1694
01:23:59,258 --> 01:24:00,178
and figure out what's going on.
还要搞清楚发生了什么

1695
01:24:01,278 --> 01:24:02,990
But if it takes you a month
但如果你花了一个月

1696
01:24:03,050 --> 01:24:06,400
 to go from I know this bug exists to creating an exploit
才从发现漏洞到创建利用

1697
01:24:06,400 --> 01:24:09,341
or doing something that you can demonstrate to the bug banning program
或者展示给漏洞赏金计划

1698
01:24:09,341 --> 01:24:10,436
or whatever you're doing
或你在做的事情

1699
01:24:11,057 --> 01:24:13,919
That's a lot of time that you're not finding other bugs, right?
这一大段时间你都没在找其他漏洞 对吧

1700
01:24:13,919 --> 01:24:15,440
You're maybe learning a lot, which is great.
不过你可能学到了很多 这挺好的

1701
01:24:15,440 --> 01:24:17,801
I guess I should have thought of like learning stuff.
也许我应该多考虑学习这些东西

1702
01:24:19,390 --> 01:24:20,003
Ah, great.
啊 挺好

1703
01:24:22,165 --> 01:24:23,271
The question on here
问题来了

1704
01:24:23,298 --> 01:24:24,526
how do companies like Raytheon
像雷神这样的公司

1705
01:24:24,526 --> 01:24:27,508
or other defense contract companies decide on targets?
或其他国防承包商是如何确定目标的？

1706
01:24:27,508 --> 01:24:29,289
Yeah, they do not decide targets.
没错 他们不决定目标

1707
01:24:29,289 --> 01:24:33,498
So there are, let's talk about
那么 我们来谈谈

1708
01:24:34,645 --> 01:24:37,416
I'm just going to make a slide so I can fill it in later.
我先做个幻灯片 一会儿再填内容

1709
01:24:46,269 --> 01:24:48,737
See, JIT is not just for compilers.
看，JIT 不仅能用在编译器上（哈哈）

1710
01:24:48,737 --> 01:24:48,977
Okay.
好的

1711
01:24:50,029 --> 01:24:52,538
So, ethics, don't go to jail.
所以 道德 不要进监狱

1712
01:24:52,538 --> 01:24:54,729
This is what I always tell the 365 students.
这是我常对 365 学生说的

1713
01:24:54,979 --> 01:24:57,320
I'm actually not worried about any of the 365 students going to jail.
我其实不担心 365 班的学生会坐牢

1714
01:24:57,320 --> 01:25:00,839
They learn not quite enough to even be dangrous
他们学得还不够多 不足以造成危险

1715
01:25:01,293 --> 01:25:06,779
and the ones that do do know how to do things are usually smart enough
那些知道怎么做的通常也足够聪明

1716
01:25:06,779 --> 01:25:07,900
where they're not gonna go to jail.
他们不会去坐牢

1717
01:25:09,681 --> 01:25:13,665
And for here, specifically we're talking about vulnerability research.
在这里 我们说的是漏洞研究

1718
01:25:13,665 --> 01:25:16,507
This is like finding bugs in software, right?
这就是在软件中找漏洞 对吧？

1719
01:25:16,507 --> 01:25:17,588
You need to be able to have it.
你需要能够拥有它

1720
01:25:17,588 --> 01:25:19,256
You need to be able to run it on your own machine.
你需要在自己的机器上运行它

1721
01:25:19,283 --> 01:25:23,203
Never do this on a production real system.
永远不要在生产系统上做这件事

1722
01:25:23,313 --> 01:25:25,114
That's just like absolutely crazy
那简直太疯狂了

1723
01:25:25,114 --> 01:25:28,897
unless it's part of the parameters of the bug bounty program.
除非它是漏洞赏金计划的一部分

1724
01:25:28,897 --> 01:25:30,398
Facebook is very good about this.
Facebook 在这方面做得很好

1725
01:25:30,398 --> 01:25:31,659
They have a completely separate
他们有一个完全独立的

1726
01:25:32,740 --> 01:25:36,283
social network and testing system that you can do everything on there
社交网络和测试系统 你可以在那里做任何事情

1727
01:25:36,283 --> 01:25:37,629
and as long as you use that
只要你使用这些系统

1728
01:25:38,190 --> 01:25:41,947
you can test their like basically test production system um
你就可以测试他们近乎真实的生产系统

1729
01:25:45,389 --> 01:25:49,975
and then so the question is then what happens when you find something
那么 找到了什么之后，做什么

1730
01:25:50,635 --> 01:25:52,875
so you find a bug it's an exploitable bug
当你发现一个可利用的漏洞时

1731
01:25:52,875 --> 01:25:55,798
you've written either a proof of concept i guess
你编写了概念验证（PoC） 我想

1732
01:25:55,798 --> 01:25:57,911
what's the difference between a proof of concept and an exploit
PoC和攻击利用有什么区别？

1733
01:26:04,161 --> 01:26:06,462
Yeah, a little bit tricky.
嗯 这个问题有点复杂

1734
01:26:06,462 --> 01:26:09,523
I wouldn't necessarily say that a proof of concept shows that it's exploitable.
我未必会说 PoC 能证明漏洞能被利用

1735
01:26:09,523 --> 01:26:11,255
It shows that the bug exists
它证明了这个漏洞确实存在

1736
01:26:11,865 --> 01:26:14,368
and that it's probably a real bug.
而且很可能是一个真正的漏洞

1737
01:26:14,746 --> 01:26:17,287
Whether it's exploitable depends on your goals
它是否可以被利用取决于你的目的

1738
01:26:17,287 --> 01:26:20,789
and it's one of these things like it could be exploitable
而且这种漏洞可能需要

1739
01:26:20,789 --> 01:26:22,769
chained with other things, right?
和其他漏洞结合后才能被利用 对吧？

1740
01:26:22,794 --> 01:26:25,352
Or there's a lot of mitigations in place, but, you know.
或者有很多缓解措施在起作用 不过你知道的

1741
01:26:26,581 --> 01:26:26,849
like
比如说

1742
01:26:27,041 --> 01:26:30,523
so but taking that step from like this is a proof of concept
所以 从PoC

1743
01:26:30,523 --> 01:26:34,894
something that triggers a bug that a developer can use to identify that bug and fix it
一个能触发bug，方便开发者找到并修复问题的东西

1744
01:26:35,147 --> 01:26:37,940
to a full exploit chain that actually achieves control
到构建一个完整的利用链 实现控制

1745
01:26:37,966 --> 01:26:41,033
is there's a ton of like variants in there and difference
这里面有很多变化和不同

1746
01:26:41,787 --> 01:26:43,369
 we'll try to learn as much as we can
我们会尽量多学

1747
01:26:43,369 --> 01:26:45,610
because i think that's interesting of like how systems work
因为我觉得了解系统的工作原理很有趣

1748
01:26:45,610 --> 01:26:48,243
of how to build like an exploit chain and these kinds of things
以及如何构建利用链这些事也很有趣

1749
01:26:48,582 --> 01:26:49,648
uh that's also what you know
你也是知道的

1750
01:26:49,811 --> 01:26:51,382
i want i want to find find
我想找到

1751
01:26:51,407 --> 01:26:52,473
and not just find things
不仅是发现这些问题

1752
01:26:52,473 --> 01:26:54,108
but exploit things that's the fun thing
还能利用这些问题 这才是真正有趣的地方

1753
01:26:54,395 --> 01:26:54,862
okay
好的

1754
01:26:54,922 --> 01:26:58,063
so then So what are your options?
那接下来 你有哪些选择呢？

1755
01:26:58,129 --> 01:26:59,676
So you found a bug.
所以你发现了一个漏洞

1756
01:27:00,311 --> 01:27:01,269
You want to get paid.
你想拿到报酬

1757
01:27:01,352 --> 01:27:04,669
What are some things that you guys have heard of to get paid?
大家都知道哪些方法可以拿到报酬？

1758
01:27:07,358 --> 01:27:08,439
Yeah, you make a proof of concept.
对 你可以做个概念验证

1759
01:27:08,439 --> 01:27:09,079
Let's say you have that.
假设你已经有一个了

1760
01:27:09,079 --> 01:27:10,076
You have that in your hand.
你手头有这个了

1761
01:27:18,748 --> 01:27:20,770
Yeah, so there's different types of bug bounty programs.
是的 漏洞赏金计划有多种类型

1762
01:27:20,770 --> 01:27:25,947
There can be You can think of outsourced bug bounty programs
可以是外包的漏洞赏金计划

1763
01:27:25,947 --> 01:27:28,889
where the company itself doesn't run it, but another one like HackerOne
公司不直接运营 而是由像 HackerOne 这样的第三方来运行

1764
01:27:28,889 --> 01:27:31,650
or one of these other sites has a bug bounty program.
或者由其他类似平台运营的漏洞赏金计划

1765
01:27:34,363 --> 01:27:40,003
And it could be an in-house bug bounty program that is run by the company.
也可能是公司自己运营的内部计划

1766
01:27:40,028 --> 01:27:41,737
I believe, I don't know for certain
我认为 但不敢确定

1767
01:27:41,737 --> 01:27:45,720
but I think Microsoft was one of the first companies to do a bug bounty program.
微软可能是最早推出漏洞赏金计划的公司之一

1768
01:27:48,243 --> 01:27:50,025
And so companies do this.
所以很多公司都会这样做

1769
01:27:50,025 --> 01:27:53,047
So you have the – you find the bug.
所以你发现漏洞

1770
01:27:53,047 --> 01:27:54,849
You report the information to the company.
你把信息报告给公司

1771
01:27:57,156 --> 01:27:57,531
I don't know.
我不知道

1772
01:27:57,531 --> 01:27:58,290
What happens next?
接下来会发生什么？

1773
01:28:05,597 --> 01:28:08,356
They fix it, hopefully, right?
他们应该会修复它 对吧？

1774
01:28:08,699 --> 01:28:09,620
So you can –
所以你可以——

1775
01:28:13,463 --> 01:28:19,363
so, yeah, they will – almost always attempt to fix it
是的 他们几乎总是会尝试修复它

1776
01:28:20,321 --> 01:28:24,856
this is like a whole thing of like how much time do you give them to fix it
这就像一个问题——你需要给他们多长时间来修复它

1777
01:28:24,923 --> 01:28:27,456
and if they're dragging their feet
如果他们拖拖拉拉

1778
01:28:27,547 --> 01:28:29,469
the theory there is like you're not that smart
理论上——你并不聪明绝顶

1779
01:28:29,469 --> 01:28:30,227
so if you found it
所以 如果你发现了

1780
01:28:30,252 --> 01:28:33,012
somebody else better and smarter than you has already found it
比你更聪明的人可能也已经发现了它

1781
01:28:33,012 --> 01:28:34,433
and maybe actually weaponizing it
甚至可能会将其用作武器

1782
01:28:34,433 --> 01:28:35,534
and using it against people
用来对付别人

1783
01:28:35,534 --> 01:28:37,946
so it's better than everyone knows it's a problem
所以最好大家都知道到这个问题

1784
01:28:39,037 --> 01:28:40,940
um Yeah, it's a whole thing.
嗯 这确实是个问题

1785
01:28:40,940 --> 01:28:43,641
I don't want to get into all this of bug bounty.
我不想讨论漏洞赏金的事

1786
01:28:43,641 --> 01:28:44,901
We can talk about that later, I think.
我们之后再讨论这个吧

1787
01:28:44,901 --> 01:28:46,920
But basically, so you can report to the company
但基本上 你可以向公司报告

1788
01:28:47,241 --> 01:28:49,822
and you know it's highly likely that it gets fixed.
你知道它很可能会被修复

1789
01:28:51,322 --> 01:28:52,602
And they will often
他们通常会

1790
01:28:52,602 --> 01:28:54,243
depending on their bug bounty program
根据他们的漏洞赏金计划

1791
01:28:54,243 --> 01:28:55,283
give you some money.
给你一些钱

1792
01:28:57,423 --> 01:29:02,553
Now, the next, let's say on the ethics spectrum
接下来 我们来看看道德光谱上的一个例子

1793
01:29:03,024 --> 01:29:04,053
this is my opinion
这只是我的看法

1794
01:29:04,078 --> 01:29:05,305
I will be telling you.
我来告诉你们

1795
01:29:05,305 --> 01:29:09,273
I hope you think... that that is reasonable, but you know, whatever
希望你们觉得这合情合理 不过 随你们怎么想吧

1796
01:29:09,320 --> 01:29:10,083
you're your own people.
你们自己拿主意

1797
01:29:10,083 --> 01:29:11,523
I'm not gonna control how you think.
我不会干涉你们的想法

1798
01:29:11,523 --> 01:29:18,459
So kind of the next step over is companies like, who does Pwn2Own?
再下一个层次 就是像举办 Pwn2Own 的公司 你们知道是谁吗？

1799
01:29:19,465 --> 01:29:21,820
ZDI, yeah, ZDI.
ZDI 对 就是 ZDI

1800
01:29:21,925 --> 01:29:24,276
So why does ZDI pay for bugs?
那么为什么 ZDI 会给漏洞付费呢？

1801
01:29:25,626 --> 01:29:26,603
Does anybody know?
有人知道吗？

1802
01:29:26,886 --> 01:29:27,866
Wait, let me go over here.
等等 我过去一下

1803
01:29:29,516 --> 01:29:29,867
Why?
为什么？

1804
01:29:30,596 --> 01:29:32,287
You've been to Pwn2Own and done this.
你参加过 Pwn2Own 而且做过这个

1805
01:29:32,356 --> 01:29:33,788
You've gotten money from this company.
你从这家公司拿过钱

1806
01:29:33,788 --> 01:29:35,148
You don't know why they give you money?
你不知道他们为什么给你钱？

1807
01:29:36,260 --> 01:29:37,841
Okay, if anybody gives you money
如果有人给你钱

1808
01:29:37,841 --> 01:29:38,541
you should know why.
你应该知道为什么

1809
01:29:38,541 --> 01:29:40,122
This is a general life thing.
这是生活常识

1810
01:29:40,122 --> 01:29:42,010
This is literally why we're talking about ethics here.
这就是我们在这里讨论伦理的原因

1811
01:29:53,123 --> 01:29:54,327
That part I don't know.
那部分我不清楚

1812
01:29:54,327 --> 01:29:56,929
I think, yeah, partly
我觉得是的 部分确实如此

1813
01:29:56,929 --> 01:29:59,963
but a lot of those targets they don't necessarily work with them.
但很多目标并不一定与他们合作

1814
01:30:01,903 --> 01:30:05,466
And you can do it outside of Pwn2Own and sell bugs to them.
你也可以在 Pwn2Own 之外发现漏洞并出售给他们

1815
01:30:05,912 --> 01:30:06,332
you know,
你知道

1816
01:30:25,363 --> 01:30:26,497
a marketing aware
市场营销方面的考虑

1817
01:30:27,955 --> 01:30:32,499
So they specifically at least the way they were created
至少在创建时 他们

1818
01:30:32,650 --> 01:30:37,333
they were with an antivirus company.
是与一家杀毒公司合作的

1819
01:30:37,429 --> 01:30:39,489
So they would take the exploits that they would buy
他们会购买这些漏洞利用

1820
01:30:39,489 --> 01:30:42,990
they would write signatures that they could push out to their AV system
编写签名并推送到防病毒系统

1821
01:30:42,990 --> 01:30:46,791
and say that they have basically pre-zero day detection of these bugs.
并声称可以检测这些未公开漏洞

1822
01:30:46,791 --> 01:30:49,031
And then they would work with, probably concurrently then
然后他们会，通常会同时

1823
01:30:49,031 --> 01:30:50,591
report the bugs and work with them too.
报告并协助修复这些漏洞

1824
01:30:50,652 --> 01:30:51,152
Right, yes.
对 没错

1825
01:30:51,152 --> 01:30:52,871
Trend Micro, ZDI
趋势科技的ZDI项目

1826
01:30:52,897 --> 01:30:53,452
Exactly.
没错

1827
01:30:53,452 --> 01:30:56,633
Yeah, they put it in their product, but they also
是的 他们会把这些加入产品中 但还会

1828
01:30:56,633 --> 01:30:58,674
I think mainly what the guys are saying is
我觉得他们主要是想说

1829
01:30:58,674 --> 01:31:01,494
they just get to put the numbers in their presentations
他们可以将这些数字放在演示中

1830
01:31:01,494 --> 01:31:03,455
like we found or we...
比如我们发现或协助修复了……

1831
01:31:04,495 --> 01:31:09,779
you know, facilitated the fixing of 30 critical, say, zero days.
比如说 协助修复了 30 个关键的零日漏洞

1832
01:31:09,779 --> 01:31:11,473
You've got millions of dollars.
你们有几百万美元

1833
01:31:11,820 --> 01:31:13,621
You've got the largest competition in the world.
你参加的是世界上最大的比赛

1834
01:31:13,621 --> 01:31:13,961
So, yeah,
所以 是的

1835
01:31:13,961 --> 01:31:16,083
I think it's going to be a marketing thing.
我觉得这会是个营销手段

1836
01:31:16,083 --> 01:31:17,343
And they still get money in the balance.
而且他们还是有收入的

1837
01:31:17,343 --> 01:31:18,664
Like, if they train a Chromebook
比如 如果他们培训了 Chromebook 用户

1838
01:31:18,664 --> 01:31:20,243
they still get value.
他们还是能获得价值

1839
01:31:20,278 --> 01:31:20,749
Interesting.
有趣

1840
01:31:20,785 --> 01:31:22,567
But the money they give you is more than the Chromebook.
但他们给你的钱比Chromebook 多

1841
01:31:22,567 --> 01:31:23,087
Oh, yeah.
哦 对

1842
01:31:23,087 --> 01:31:24,068
It's like double.
差不多是两倍

1843
01:31:24,068 --> 01:31:24,848
Exactly, yeah.
没错 就是这样

1844
01:31:24,848 --> 01:31:26,609
So they're making money.
所以他们是在赚钱

1845
01:31:26,609 --> 01:31:28,831
Somebody's getting paid some way, right, through this stuff.
总有人会通过这些赚到钱 对吧？

1846
01:31:28,831 --> 01:31:29,697
So it's important to remember.
所以记住这一点很重要

1847
01:31:29,904 --> 01:31:32,870
So that's also if you notice in the spectrum we will walk down.
如果你注意到，在我们要继续讲的变现方法中

1848
01:31:32,990 --> 01:31:35,312
The money that you can get paid for this.
你能从这当中赚到的钱

1849
01:31:35,312 --> 01:31:36,352
I think the good
我觉得好的一点是

1850
01:31:37,433 --> 01:31:41,690
the thing I like to go with is like
我是这么想的……

1851
01:31:41,784 --> 01:31:43,097
I think the point
我觉得重点在于

1852
01:31:43,097 --> 01:31:45,258
actually maybe have I increased it, but anyways
可能我夸大了 不过总之

1853
01:31:45,258 --> 01:31:49,501
when I was doing this stuff, a fully remote exploit for the iPhone
我弄的时候，有个 iPhone 的完全远程漏洞利用

1854
01:31:49,501 --> 01:31:50,522
that's zero click
是一个0交互的漏洞利用

1855
01:31:50,522 --> 01:31:52,063
meaning absolutely no interaction.
意味着完全不需要用户互动

1856
01:31:52,063 --> 01:31:54,364
So you send a text message
所以你给用户发送一条短信

1857
01:31:54,364 --> 01:31:56,486
or something to the user's device
或是其他东西到用户的设备

1858
01:31:56,486 --> 01:31:59,368
and it completely takes over the device all the way to the kernel.
然后它会完全接管设备 一直渗透到内核

1859
01:31:59,368 --> 01:32:03,819
So complete root level, well, no, actually, I mean
所以是完全的 root 级别， 不对 我是说

1860
01:32:03,819 --> 01:32:05,188
we'll get this on Mac.
我们谈到 Mac 时会提到

1861
01:32:06,222 --> 01:32:07,764
Root is not the final word.
Root 并不是终点

1862
01:32:07,764 --> 01:32:08,985
It's actually kernel access
它只是拿到了内核访问权

1863
01:32:08,985 --> 01:32:10,727
because of all the system integrity protection
因为系统有各种完整性保护

1864
01:32:10,727 --> 01:32:11,868
and stuff that's on there.
以及其他各种保护

1865
01:32:11,868 --> 01:32:13,590
But that's a million dollars.
但这价值一百万美元

1866
01:32:13,590 --> 01:32:16,033
So Apple themselves will give you a million dollars for that.
所以苹果会为此支付一百万美元

1867
01:32:16,033 --> 01:32:17,634
I actually don't know if anybody's done this yet.
实际上我不知道是否有人已经做到了

1868
01:32:17,634 --> 01:32:18,530
I don't know.
我不知道

1869
01:32:18,896 --> 01:32:20,758
Because that's like that chains like
因为它链接了一串漏洞

1870
01:32:20,758 --> 01:32:22,500
I don't know, so many bugs together.
我不知道 这么多漏洞组合在一起

1871
01:32:22,500 --> 01:32:24,702
It's like it's hard to even think about.
简直让人难以想象

1872
01:32:26,789 --> 01:32:30,790
But, and if you send that to somebody like ZDI
但如果你把它发给，比如 ZDI

1873
01:32:30,790 --> 01:32:32,651
they will give you much more than that.
他们会给你更多的钱

1874
01:32:32,651 --> 01:32:33,851
I don't know exactly how much more.
我不知道具体能多多少

1875
01:32:33,851 --> 01:32:34,772
You can see all of this.
这些你都能看到

1876
01:32:36,252 --> 01:32:38,593
Then you get into, let's say
接下来 比如说

1877
01:32:39,793 --> 01:32:41,274
and I'm not trying to offend anyone.
我不是要冒犯任何人

1878
01:32:41,274 --> 01:32:42,394
There's different steps.
有不同的步骤

1879
01:32:42,394 --> 01:32:45,075
So then, okay, we're in the United States right now,
所以 我们现在都在美国

1880
01:32:45,075 --> 01:32:46,935
at least everyone in this room.
至少在场的每个人都是

1881
01:32:46,935 --> 01:32:48,096
You could sell this
你可以卖掉这个

1882
01:32:48,096 --> 01:32:50,136
you could sell that information to a government
你可以把这信息卖给政府

1883
01:32:50,136 --> 01:32:51,517
let's say that you trust
比方说 你信任的某个政府

1884
01:32:51,517 --> 01:32:53,137
like the U.S. government has a
比如美国政府，就有一个

1885
01:32:53,137 --> 01:32:55,547
I think it's VRP is what they call it.
他们称之为 VRP

1886
01:32:55,547 --> 01:32:58,889
Vulnerability Research Program or something like that a reporting program
漏洞研究或报告项目

1887
01:32:58,889 --> 01:33:01,870
where you can sell this vulnerability to the US government
你可以在这些项目中把漏洞卖给美国政府

1888
01:33:01,870 --> 01:33:03,231
they actually have a system in place
他们有一套系统

1889
01:33:03,231 --> 01:33:07,172
to decide if they should disclose it to the vendor
来决定是否告诉供应商

1890
01:33:07,172 --> 01:33:10,374
and get it fixed or if they use it operationally
修复漏洞或者在行动中使用

1891
01:33:10,374 --> 01:33:12,020
and never disclose it to the vendor
永远不告诉供应商

1892
01:33:12,207 --> 01:33:14,596
so that's up to you and your personal ethics
这由你个人的道德标准决定

1893
01:33:14,596 --> 01:33:17,597
whether you're okay with your stuff being used by the US government
你是否接受自己的东西被美国政府使用

1894
01:33:18,637 --> 01:33:21,865
then there are Further than that
还有更进一步的

1895
01:33:21,865 --> 01:33:23,743
I actually don't know exactly how much that pays.
实际上我并不清楚这能赚多少钱

1896
01:33:23,886 --> 01:33:26,467
I haven't actually done any, you know
我实际上还没做过这些 你知道的

1897
01:33:26,467 --> 01:33:29,008
I stuck just to the reporting to Apple, just to be very clear.
我只是向苹果报告漏洞 非常明确

1898
01:33:29,876 --> 01:33:35,390
And so then the next step beyond that is basically, well
然后接下来的步骤基本上是

1899
01:33:35,390 --> 01:33:37,216
I guess there's two more-ish SAPs.
我想还有两个类似的程序

1900
01:33:37,432 --> 01:33:38,953
The next one will be reporting it to a company
下一个就是向一家公司报告

1901
01:33:38,953 --> 01:33:40,394
that will pay you a ton of money
他们会给你一大笔钱

1902
01:33:40,394 --> 01:33:43,733
and will never tell you who they're selling it to
而且永远不会告诉你他们把漏洞卖给谁

1903
01:33:43,957 --> 01:33:45,266
or where it's being used for.
或用在哪里

1904
01:33:46,159 --> 01:33:48,842
So you have absolutely no control over what governments
所以你完全无从控制，是卖给哪个政府

1905
01:33:48,842 --> 01:33:50,620
or things that are buying that
或是购买这些信息的其他机构

1906
01:33:50,726 --> 01:33:55,207
and you are getting paid to keep silent about the stuff that you found.
而给你的钱包括了封口费

1907
01:33:57,128 --> 01:33:59,852
And then the even one beyond that is dealing directly
更进一步 可能直接面对那些

1908
01:33:59,852 --> 01:34:03,857
with what some of you would probably consider a hostile foreign government
一些人可能认为是敌对的外国政府

1909
01:34:03,857 --> 01:34:06,661
that buys this stuff to use against their citizens
这些政府会购买这些信息用来针对他们的公民

1910
01:34:06,661 --> 01:34:08,323
or journalists or all this kind of stuff.
或记者等人群

1911
01:34:08,323 --> 01:34:11,127
So anyways, it's very important to understand.
所以 了解这些很重要

1912
01:34:14,830 --> 01:34:17,991
what you are doing and in what context it could be used
你在做什么 以及你的漏洞会在什么情况下使用

1913
01:34:17,991 --> 01:34:19,851
so that you are comfortable.
这样你才会安心

1914
01:34:19,851 --> 01:34:21,126
For instance, if you just think, ah
比如 你可能心想 啊

1915
01:34:21,151 --> 01:34:22,012
I'm a cool hacker
我是个酷黑客

1916
01:34:22,012 --> 01:34:24,012
I like finding stuff, I love CTFs
我喜欢找东西 特别喜欢 CTFs

1917
01:34:24,012 --> 01:34:25,843
I love this real world
我喜欢这个真实世界

1918
01:34:25,943 --> 01:34:27,863
an actual real world CTF
一个真正现实中的 CTF

1919
01:34:28,028 --> 01:34:30,638
I've got this exploit against the iPhone, this is awesome
我有一个针对 iPhone 的漏洞 太棒了

1920
01:34:30,663 --> 01:34:32,034
I don't want Apple's million dollars
我不想要苹果的那一百万

1921
01:34:32,034 --> 01:34:32,994
I want $10 million
我要 1000 万美元

1922
01:34:32,994 --> 01:34:34,235
or $15 million
或者是 1500 万美元

1923
01:34:34,235 --> 01:34:39,820
or whatever the price on the street is for a zero-click remote iPhone exploit.
 或别的黑市上0交互远程 iPhone 漏洞的价格

1924
01:34:40,100 --> 01:34:40,800
And then you find out
然后你发现

1925
01:34:40,800 --> 01:34:44,839
that Google Project Zero does a teardown of your exploit
Google Project Zero 对你的漏洞利用进行了分析

1926
01:34:44,921 --> 01:34:46,782
where they caught it being used against
他们发现该漏洞被用来针对

1927
01:34:46,782 --> 01:34:50,183
I don't know, a vulnerable population in China, for instance.
比如说 中国的某个易受攻击群体

1928
01:34:51,519 --> 01:34:51,873
I don't know
我不知道

1929
01:34:51,926 --> 01:34:55,504
you have to live with that the rest of your life.
你这辈子都得背着这个

1930
01:34:55,504 --> 01:34:58,933
So think about the decisions that you're making, make right decisions.
所以 三思而后行 做出正确的决定

1931
01:34:59,100 --> 01:35:00,706
Oh, and then somebody, sorry
哦 对不起 有个人

1932
01:35:00,706 --> 01:35:02,020
the whole reason why we got onto this
我们讨论这个话题的原因是

1933
01:35:02,220 --> 01:35:03,967
somebody asked about defense contractors.
有人提到了国防承包商

1934
01:35:03,967 --> 01:35:06,767
So one of the jobs you can get for doing vulnerability research
你可以通过漏洞研究获得的工作之一是

1935
01:35:06,767 --> 01:35:07,828
especially in the United States
尤其是在美国

1936
01:35:07,828 --> 01:35:09,246
if you can get a clearance
如果你能获得安全许可

1937
01:35:09,419 --> 01:35:13,033
is with a company that does vulnerability research and finding bugs there
为一家专门研究漏洞的公司工作

1938
01:35:13,033 --> 01:35:14,534
you do not define the target.
你不会指定目标

1939
01:35:14,534 --> 01:35:17,035
The US government defines the target and tells you
美国政府会指定目标并通知你

1940
01:35:17,035 --> 01:35:18,276
find us bugs in here
在这里找到漏洞

1941
01:35:18,276 --> 01:35:20,486
and find us exploits and vulnerabilities in here.
并在这些地方发现利用手段和漏洞

1942
01:35:20,957 --> 01:35:23,179
And your job in that company is cranking that stuff out.
在那家公司 你的任务就是不断完成这些工作

1943
01:35:23,179 --> 01:35:28,461
So that's, I'm happy to talk with people.
所以我很愿意和大家聊聊

1944
01:35:28,461 --> 01:35:30,362
I've talked to some people in this line of work.
我跟这行的一些人交流过

1945
01:35:30,362 --> 01:35:32,263
It can be very demoralizing
这份工作可能会让人很沮丧

1946
01:35:32,263 --> 01:35:33,884
because you don't get to choose the target
因为你没有选择目标的权利

1947
01:35:33,884 --> 01:35:35,265
and it's just like given to you.
目标都是分配给你的

1948
01:35:35,265 --> 01:35:36,509
So it may not be interesting
所以这些工作可能没什么意思

1949
01:35:36,669 --> 01:35:39,641
but somebody thinks it's important enough to pay for you to do that
但有人觉得足够重要 愿意为此付费

1950
01:35:39,641 --> 01:35:41,316
so i don't know all right
我也不好说

1951
01:35:41,702 --> 01:35:45,329
cool any ethics questions act ethically please
好的 有什么伦理问题吗？请大家遵守伦理规范

1952
01:35:49,153 --> 01:35:49,820
all right
好的 没问题

1953
01:35:50,686 --> 01:35:53,593
oh cool corporate bug finding great we did this all right
哦 不错 公司找bug 我们讲完了

1954
01:35:53,646 --> 01:35:54,460
awesome
太好了

1955
01:35:54,552 --> 01:36:00,366
okay so is working with defense contractors ethical
那么 和国防承包商合作算不算道德呢

1956
01:36:00,391 --> 01:36:01,577
i will not touch that
这个问题我不评论

1957
01:36:01,577 --> 01:36:03,950
that's again I think
我认为

1958
01:36:04,123 --> 01:36:08,423
you need to make your own decisions about what is or is not ethical in your mind.
你得自己判断是否道德

1959
01:36:10,667 --> 01:36:11,403
Okay.
行

1960
01:36:11,943 --> 01:36:13,236
So you've decided on a target.
所以你已经选好目标了

1961
01:36:13,236 --> 01:36:17,840
I would say one of the biggest flaws that I ran into
我觉得我遇到的最大问题之一是

1962
01:36:17,840 --> 01:36:19,326
that some of you may also
你们可能也会遇到

1963
01:36:19,351 --> 01:36:22,744
is to resist the temptation to just dive right in and find bugs.
就是如何抵制，直接跳进去找漏洞的诱惑

1964
01:36:22,744 --> 01:36:24,525
Like you've been doing pwn college
你一直在做pwn college

1965
01:36:24,525 --> 01:36:25,306
you've been doing CTFs
你一直在参加 CTF

1966
01:36:25,306 --> 01:36:26,697
you just want to like find bugs.
你只想找到漏洞

1967
01:36:27,488 --> 01:36:29,109
You can do that, but
你可以这样做 但是

1968
01:36:31,051 --> 01:36:32,157
and you'll find stuff
你会找到一些东西

1969
01:36:32,210 --> 01:36:36,419
but it's much better to take time to plan it out.
但花时间好好规划会更好

1970
01:36:36,616 --> 01:36:38,893
Right, like how am I going to find these bugs?
对 我该怎么找到这些漏洞？

1971
01:36:39,480 --> 01:36:41,340
What tools am I going to use?
我打算用什么工具？

1972
01:36:41,340 --> 01:36:42,821
Am I gonna use static analysis?
我打算用静态分析吗？

1973
01:36:42,821 --> 01:36:44,182
Am I gonna use symbolic execution?
我会用符号执行吗？

1974
01:36:44,182 --> 01:36:45,584
Am I gonna use fuzzing?
我会用模糊测试吗？

1975
01:36:45,584 --> 01:36:47,625
I will tell you if you can use fuzzing, use fuzzing.
能用模糊测试就用

1976
01:36:47,625 --> 01:36:51,976
Fuzzing is absolutely hands down the best way to find bugs in anything.
模糊测试绝对是找 Bug 的最佳方法

1977
01:36:52,289 --> 01:36:54,591
Like you want to make money doing this stuff
你想靠这行赚钱的话

1978
01:36:54,591 --> 01:36:55,896
the best thing you can do
你能做的最好就是

1979
01:36:56,353 --> 01:36:58,570
find an important target that pays money
找一个能赚钱的重要目标

1980
01:36:59,203 --> 01:37:01,657
figure out what the important components are of that target
弄清楚目标的重要部分

1981
01:37:01,657 --> 01:37:02,698
that maybe pays you more.
也许能赚更多

1982
01:37:02,698 --> 01:37:05,096
This is again, kind of a metagaming thing.
这又是一个策略上的事情

1983
01:37:05,302 --> 01:37:07,650
and then figure out how to fuzz that thing.
然后弄清楚怎么对那个目标进行模糊测试

1984
01:37:07,923 --> 01:37:10,236
Like, AFL++ is great.
AFL++ 真不错

1985
01:37:10,343 --> 01:37:10,963
Use it.
用它

1986
01:37:11,044 --> 01:37:11,929
Fuzz stuff.
做模糊测试

1987
01:37:12,023 --> 01:37:12,936
It finds stuff.
它能发现问题

1988
01:37:13,049 --> 01:37:13,705
It's amazing.
它真的很厉害

1989
01:37:18,326 --> 01:37:18,786
Yeah.
嗯

1990
01:37:19,793 --> 01:37:21,167
Other things to think about.
还有其他需要考虑的

1991
01:37:21,167 --> 01:37:22,519
This is something that
这是只有在……

1992
01:37:22,920 --> 01:37:24,168
until it's bit you in the butt
你碰到问题之后

1993
01:37:24,168 --> 01:37:26,506
you won't actually really think about
你才会考虑的

1994
01:37:26,580 --> 01:37:28,889
especially if you're doing static analysis or...
特别是在做静态分析时 或者...

1995
01:37:28,889 --> 01:37:32,036
Oh, the question is, why is fuzzing the best?
问题来了 为什么模糊测试最好？

1996
01:37:32,951 --> 01:37:34,230
Fuzzing is the...
模糊测试是...

1997
01:37:34,310 --> 01:37:35,604
I mean, I have a lot of stories about this
这个我能讲很多

1998
01:37:35,604 --> 01:37:37,685
but fuzzing is the best because it's
但模糊测试是最好的 因为它

1999
01:37:38,516 --> 01:37:41,276
A you get a result that is
首先 你能得到一个结果

2000
01:37:41,416 --> 01:37:43,030
if it's a reproducible crash
如果是可重现的崩溃

2001
01:37:43,087 --> 01:37:46,076
you get an input that causes a crash in the target.
你会得到一个导致目标崩溃的输入

2002
01:37:46,388 --> 01:37:47,889
And that's like absolutely critical
这非常重要

2003
01:37:49,070 --> 01:37:50,650
because then you can debug the root cause
因为这样你就可以调试根本原因

2004
01:37:50,650 --> 01:37:51,651
figure out what's going on.
搞清楚是怎么回事

2005
01:37:52,856 --> 01:37:56,493
And you can think of like
你可以这样想

2006
01:37:57,693 --> 01:37:59,414
so when I was doing the XNU stuff
在我研究 XNU 的时候

2007
01:37:59,414 --> 01:38:01,046
I was harnessing different things.
我使用了不同的方法

2008
01:38:01,135 --> 01:38:02,195
And when I created
当我创建时

2009
01:38:02,195 --> 01:38:06,726
which is basically like, letting the fuzzer target that specific system.
基本上是让模糊测试工具针对那个特定的系统

2010
01:38:06,851 --> 01:38:11,111
So I gave the fuzzer this one subsystem I was fuzzing.
所以我让模糊测试工具针对这个子系统

2011
01:38:11,111 --> 01:38:12,497
I think it was the PF
我记得是 PF

2012
01:38:12,617 --> 01:38:18,253
which is the packet filter, like before eBPF, like the E part,
它是数据包过滤器 在有 eBPF 以前

2013
01:38:18,253 --> 01:38:21,853
just the BPF, the firewall component.
只有 BPF 部分，它就是防火墙的组件

2014
01:38:22,233 --> 01:38:25,194
There's two different devices that you can talk to it from.
有两个不同的设备 你可以通过它们通信

2015
01:38:25,194 --> 01:38:27,774
It was like dev PF and dev PFM.
就像 /dev/PF 和 /dev/PFM 这样的设备

2016
01:38:28,094 --> 01:38:32,027
And then where that went into the kernel code
然后等进入到内核代码中

2017
01:38:33,127 --> 01:38:35,140
it could select which one that came from.
它可以区分这些请求来自哪个设备

2018
01:38:35,227 --> 01:38:36,228
And I was harnessing it.
我当时就利用了这一点

2019
01:38:36,228 --> 01:38:37,168
I'm like, sure, whatever.
我心想 好吧 随便

2020
01:38:37,168 --> 01:38:39,063
I'll let the fuzzer decide which one.
我让模糊测试器来决定是哪一个

2021
01:38:39,290 --> 01:38:40,050
Thinking in my mind, like
我心里想

2022
01:38:40,050 --> 01:38:42,932
this is stupid because how could that ever make a difference?
这太蠢了 这怎么可能有区别？

2023
01:38:42,932 --> 01:38:45,170
Like, I don't even understand what these two different things are.
我甚至不明白这两个东西是什么

2024
01:38:45,203 --> 01:38:47,034
I still don't understand what they are
我到现在还是不明白它们是什么

2025
01:38:47,034 --> 01:38:51,497
but the fuzzer found a use after free bug by creating something on one
但模糊测试工具找到了一个UAF漏洞，通过在一个地方创建了一个对象

2026
01:38:51,497 --> 01:38:52,998
and then deleting it on the other
然后在另一个地方删除了这个对象

2027
01:38:52,998 --> 01:38:55,039
and then accessing it from the other one.
接着从另一个地方又访问了这个对象

2028
01:38:55,039 --> 01:38:57,241
And like, without giving it that thing
而且 根本没给它那个东西

2029
01:38:57,241 --> 01:38:59,942
like I never would have in a hundred years.
我这辈子都想不到

2030
01:38:59,942 --> 01:39:02,024
thought that that could have possibly been a bug.
那竟然可能是个 Bug

2031
01:39:02,024 --> 01:39:03,045
Like I grabbed the source code
我找了源代码

2032
01:39:03,045 --> 01:39:04,766
and I looked for these differences
找了找这些差异

2033
01:39:04,766 --> 01:39:06,288
and I couldn't like see it right away.
我没能看出来

2034
01:39:06,288 --> 01:39:07,449
And so I was just like, yeah, whatever.
所以 我就想 算了

2035
01:39:07,449 --> 01:39:08,349
I'd be like
我就会这么说

2036
01:39:08,349 --> 01:39:09,370
let the fuzzer figure it out.
让模糊测试器搞定吧

2037
01:39:09,370 --> 01:39:13,974
So even if the fuzzer is like smartly using a lot of input combinations
所以即使模糊测试器用了多种输入组合

2038
01:39:13,974 --> 01:39:15,896
to generate crazy inputs.
来生成奇怪的输入

2039
01:39:15,896 --> 01:39:19,776
So yeah, anyways, it's great.
所以 总之 挺好的

2040
01:39:20,853 --> 01:39:21,416
Okay.
好的

2041
01:39:21,573 --> 01:39:23,376
One thing that can, that especially
有一件事尤其要注意

2042
01:39:23,402 --> 01:39:24,996
so we've talked about exchange, right?
我们讨论过 Exchange 了 对吧？

2043
01:39:27,364 --> 01:39:29,525
People configure systems, right?
人们会配置系统 对吧？

2044
01:39:30,625 --> 01:39:33,703
And oftentimes code is gated by that configuration.
而且代码经常受限于这些配置

2045
01:39:34,006 --> 01:39:38,263
So if you spend three or four months finding a bug in Microsoft Exchange
所以如果你花了三四个月的时间，找到一个 Microsoft Exchange 的漏洞

2046
01:39:38,867 --> 01:39:41,847
and then by the end you say, oh crap
到最后你才发现 糟糕

2047
01:39:41,847 --> 01:39:47,067
this is only a real bug if this configuration is activated
这只有在激活了这个配置时才是个真正的漏洞

2048
01:39:47,149 --> 01:39:49,213
and it's a setting that nobody uses.
而这是一个几乎没人用的设置

2049
01:39:50,480 --> 01:39:51,130
I don't know
我不知道

2050
01:39:51,130 --> 01:39:51,930
is that an important bug?
这算不算重要的漏洞？

2051
01:39:53,676 --> 01:39:56,023
maybe maybe not but you probably wasted a lot of time
可能重要 也可能不重要 但你大概浪费了不少时间

2052
01:39:56,133 --> 01:40:00,815
this is a really good thing for like doing pwn2own in these types of uh competitions
这对参加pwn2own 这类比赛也很有帮助

2053
01:40:00,815 --> 01:40:04,437
because you need to make sure that the stuff you're testing
因为你需要确保你测试的内容

2054
01:40:04,437 --> 01:40:05,983
is the actual stuff that's going to be wrong
是确实会出问题的地方

2055
01:40:07,910 --> 01:40:09,455
okay cool
好的 真酷

2056
01:40:10,800 --> 01:40:14,770
we're flying by okay all right
进展顺利 很好

2057
01:40:15,157 --> 01:40:16,477
very important to play the metagame
对技术外的思考非常重要

2058
01:40:16,502 --> 01:40:19,183
this is something i did not understand until the end of it
这一点我直到最后才明白

2059
01:40:19,208 --> 01:40:22,817
because i spent um uh
因为我花了很多时间

2060
01:40:23,797 --> 01:40:27,000
I spend a lot of time just looking for bugs and having fun
找漏洞 玩得很开心

2061
01:40:27,000 --> 01:40:30,756
and it wasn't until the end I was like, oh, duh, well
直到最后我才反应过来 哦 原来如此

2062
01:40:30,781 --> 01:40:34,110
Apple pays more for bugs that are more impactful, right?
苹果公司会为更有影响力的漏洞支付更高 对吧？

2063
01:40:34,266 --> 01:40:36,936
So like, oh, I guess I should have said the million-dollar thing.
所以 哦 我应该强调一下那个百万美元的漏洞

2064
01:40:36,976 --> 01:40:38,449
Obviously, I did not win a million dollars
显然 我没赢得一百万美元

2065
01:40:38,449 --> 01:40:40,071
or maybe if I did
或者如果我赢了

2066
01:40:40,071 --> 01:40:41,312
I wouldn't be here teaching you right now.
我就不会在这里教你了

2067
01:40:41,312 --> 01:40:42,212
I'd be relaxing
我会很轻松

2068
01:40:42,212 --> 01:40:47,477
and, I don't know, retired and, I guess, living the good life.
我可能会退休 过上悠闲的生活吧

2069
01:40:47,477 --> 01:40:53,627
But... They pay different levels depending on what the impact is, right?
但是……他们会根据漏洞的影响支付不同的报酬 对吧？

2070
01:40:53,627 --> 01:40:58,329
So just like we said, so on XNU on the Mac platform
正如我们所说 在 Mac 平台的 XNU 中

2071
01:40:58,329 --> 01:41:00,889
there's a difference between root and kernel.
root 和 kernel 之间有区别

2072
01:41:00,889 --> 01:41:03,703
So root does not have full permission to the system.
所以 root 没有系统的全部权限

2073
01:41:03,983 --> 01:41:05,951
So I think actually
所以实际上

2074
01:41:05,951 --> 01:41:06,891
like I made the mistake
我犯了一个错误

2075
01:41:06,891 --> 01:41:08,977
where a lot of the stuff I was fuzzing and testing
我做的很多模糊测试

2076
01:41:09,397 --> 01:41:11,393
could only be done by the root user.
都只能由 root 用户执行

2077
01:41:12,520 --> 01:41:15,261
which meant that the bugs that I found were root to kernel bugs
这意味着，我找到的漏洞都是从root根权限到内核级别的

2078
01:41:15,261 --> 01:41:17,242
which are still bugs, and they paid
也是漏洞 也都获得了报酬

2079
01:41:17,242 --> 01:41:22,296
but not as much as if it was a user space, like from a regular user
但报酬比能从普通用户触发的漏洞 要少

2080
01:41:22,363 --> 01:41:25,190
or from even better, an iPhone app,
或者更好是能 从 iPhone 应用触发

2081
01:41:25,370 --> 01:41:28,981
from an iPhone app to the kernel and then a kernel bug.
从 iPhone 应用到内核 再到内核漏洞

2082
01:41:29,006 --> 01:41:30,496
That would have paid way better.
这种漏洞的报酬要高得多

2083
01:41:31,327 --> 01:41:33,668
And I didn't think about that to the very end.
我直到最后才想到这一点

2084
01:41:33,668 --> 01:41:35,430
And then I started, actually
然后 实际上我开始着手了

2085
01:41:35,455 --> 01:41:39,250
I actually have an example we'll go into here, but...
其实我有一个例子 我们接下来会讲到 但……

2086
01:41:39,500 --> 01:41:41,121
Yeah, I didn't do that until the very end.
是的 我直到最后才那么做

2087
01:41:41,121 --> 01:41:42,002
And then by that point
到了那时候

2088
01:41:42,002 --> 01:41:43,023
I didn't have much time
我没多少时间了

2089
01:41:43,023 --> 01:41:44,544
and I had to go back to school and everything.
我要回去教学了

2090
01:41:44,883 --> 01:41:47,347
So, but by metagaming
所以 通过玩元游戏（跳出盒子思考）

2091
01:41:47,347 --> 01:41:48,148
part of this is like
其中的一部分是

2092
01:41:48,148 --> 01:41:50,610
what other bugs have people found in this target, right?
其他人在这目标上发现了什么漏洞 对吧？

2093
01:41:50,610 --> 01:41:52,191
So read write-ups.
所以要读相关报告

2094
01:41:52,191 --> 01:41:52,932
I know it sounds simple
我知道这听起来很简单

2095
01:41:52,932 --> 01:41:57,366
but like there are people that write about and talk about these targets.
但是确实有人会写和讨论这些目标

2096
01:41:57,620 --> 01:41:59,377
What other bugs have they found?
他们还发现了哪些漏洞？

2097
01:42:00,740 --> 01:42:02,639
How did they find those bugs?
他们是怎么发现这些漏洞的？

2098
01:42:04,019 --> 01:42:05,380
Like build on other people's tools.
比如借用别人的工具

2099
01:42:05,380 --> 01:42:06,001
If you can do it
如果能做到

2100
01:42:06,001 --> 01:42:08,243
don't reinvent the wheel and build your own tools.
就不要重复造轮子 自己开发工具

2101
01:42:08,243 --> 01:42:10,406
If you can, like if somebody's got a fuzzer for a target
如果有人已经为某个目标开发了模糊测试工具

2102
01:42:10,665 --> 01:42:13,908
and it fuzzes component A, ask yourself
这个工具可以测试组件 A 你可以问自己

2103
01:42:13,908 --> 01:42:15,730
how can I just make it fuzz component B
我怎么让它测试组件 B

2104
01:42:15,730 --> 01:42:17,180
and then C and then D?
接着是 C 再是 D？

2105
01:42:17,431 --> 01:42:17,952
And guess what?
猜猜看

2106
01:42:17,952 --> 01:42:18,893
If nobody's done that before
如果之前没人这么做过

2107
01:42:18,893 --> 01:42:19,593
you'll find bugs.
你会发现漏洞

2108
01:42:19,593 --> 01:42:21,715
Like fuzzers shake out and find bugs all the time.
模糊测试工具经常能发现漏洞

2109
01:42:24,373 --> 01:42:25,099
Very important thing.
这非常重要

2110
01:42:25,099 --> 01:42:26,019
What bugs pay the most?
哪些漏洞的回报最高？

2111
01:42:26,019 --> 01:42:27,200
If you're going to spend the time on it
如果你要花时间在这上面

2112
01:42:27,200 --> 01:42:28,842
what bugs pay the most for your target?
在你的目标上 哪些漏洞的回报最高？

2113
01:42:30,008 --> 01:42:32,429
So for me, what I finally did was look at like, okay
所以 我最终决定查看 好吧

2114
01:42:32,429 --> 01:42:34,449
what kernel drivers are there in the system,
系统中有哪些内核驱动

2115
01:42:34,449 --> 01:42:37,990
like in the dev slash dev kernel devices
比如 /dev/ 下的内核设备

2116
01:42:37,990 --> 01:42:41,730
and then which ones of those are accessible from a normal user
然后哪些驱动是普通用户可以访问的

2117
01:42:41,730 --> 01:42:43,066
and not just root.
而不仅仅是 root 用户

2118
01:42:43,211 --> 01:42:43,971
And then I went in
然后我就开始行动了

2119
01:42:43,971 --> 01:42:46,589
and started looking at that code and auditing that way.
开始查看这些代码并进行审计

2120
01:42:47,610 --> 01:42:48,812
How much reversing is required?
需要多少逆向工程？

2121
01:42:48,812 --> 01:42:49,952
Do you guys love reversing?
你们喜欢逆向工程吗？

2122
01:42:49,952 --> 01:42:51,603
Are there any reverser heads here?
这里有没有逆向工程的高手？

2123
01:42:51,852 --> 01:42:52,583
Yeah?
是吗？

2124
01:42:52,753 --> 01:42:53,690
You should just leave.
你还是走吧

2125
01:42:54,973 --> 01:42:55,730
No, just kidding.
不 开玩笑的

2126
01:42:56,954 --> 01:42:58,414
But you have to think about that, right?
但你得考虑一下 对吧？

2127
01:42:58,414 --> 01:42:59,556
It's like, do you want to be
比如 你想要

2128
01:42:59,773 --> 01:43:03,396
Because if you're finding a bug in a closed source kernel driver
因为如果你要在闭源内核驱动中发现漏洞

2129
01:43:03,421 --> 01:43:07,165
you have to spend a ton of time reversing that kernel driver
你得花很多时间去逆向那个内核驱动程序

2130
01:43:07,190 --> 01:43:09,336
to understand how it works, what the data structures are
弄清楚它是怎么工作的,有什么数据结构

2131
01:43:09,456 --> 01:43:11,769
 to even then start to find bugs
 然后才能开始找漏洞

2132
01:43:12,302 --> 01:43:13,623
and then what to do with it.
然后再想怎么利用它

2133
01:43:13,963 --> 01:43:16,825
So think about that.
所以想想这个问题

2134
01:43:16,825 --> 01:43:20,190
This is actually, the ironic thing is I started
其实 讽刺的是 我一开始

2135
01:43:21,688 --> 01:43:23,649
because before I'd actually thought about targeting
并没有考虑过攻击目标

2136
01:43:23,649 --> 01:43:25,721
I was just like, yeah, Whatever
我只是无所谓

2137
01:43:25,721 --> 01:43:26,922
I like Apple products.
我喜欢苹果的产品

2138
01:43:26,922 --> 01:43:27,523
As you can see
正如你所见

2139
01:43:27,523 --> 01:43:29,504
I have like already three on this table right here
我在这张桌上已经有三个了

2140
01:43:29,504 --> 01:43:32,735
and two more in this bag and one on my wrist.
袋子里还有两个 手腕上有一个

2141
01:43:33,086 --> 01:43:33,889
Is there any more?
还有更多吗？

2142
01:43:35,368 --> 01:43:36,069
And I was like,
然后我心想

2143
01:43:36,069 --> 01:43:37,349
yeah, it'd be fun to do.
嗯 做这个挺好玩的

2144
01:43:37,456 --> 01:43:39,191
And I want to get better at reversing
我想提高逆向工程的技能

2145
01:43:39,191 --> 01:43:40,272
because I don't really like reversing
因为我不太喜欢逆向工程

2146
01:43:40,272 --> 01:43:41,753
but I want to get better at reversing.
但我还是想提高逆向工程的技能

2147
01:43:41,753 --> 01:43:45,750
And so I want to go through those kernel modules and do all this stuff.
所以我打算研究这些内核模块 做这些事情

2148
01:43:45,936 --> 01:43:46,936
And then when I started looking at it
当我开始研究时

2149
01:43:46,936 --> 01:43:49,443
I found out actually the kernel is open source
我发现内核原来是开源的

2150
01:43:49,558 --> 01:43:50,659
and the source code is there.
源代码就在这儿

2151
01:43:50,659 --> 01:43:51,373
And guess what?
猜猜怎么着

2152
01:43:51,586 --> 01:43:52,520
If I want to spend my time
如果我有时间

2153
01:43:52,520 --> 01:43:55,386
I want to spend my time finding bugs, not reversing code.
我想把时间花在找 bug 上 而不是逆向分析代码

2154
01:43:55,592 --> 01:43:57,220
And I can read the kernel source code.
而且我能读内核源代码

2155
01:43:57,493 --> 01:43:58,340
It's amazing.
那太棒了

2156
01:43:58,614 --> 01:44:02,280
And you can even compare it side by side in your editor and your IDA
你可以把代码编辑器和IDA放在一起，比较

2157
01:44:02,414 --> 01:44:03,577
 so you can match it up directly
可以直接对比

2158
01:44:03,577 --> 01:44:05,378
and make reversing so much easier.
让逆向分析更轻松

2159
01:44:06,979 --> 01:44:09,954
Yeah, so think about that depending on what you want to do it.
所以 根据你的目标好好想想

2160
01:44:10,482 --> 01:44:12,726
Okay.
好吧

2161
01:44:13,026 --> 01:44:14,173
Leading to the next point.
接下来是下一个要点

2162
01:44:14,484 --> 01:44:15,566
Why are you doing this?
你为什么要做这个？

2163
01:44:16,545 --> 01:44:16,825
Right?
对吧？

2164
01:44:16,866 --> 01:44:17,979
You should understand your own
你应该了解自己

2165
01:44:18,004 --> 01:44:18,939
I know this I don't know
我知道这，

2166
01:44:19,007 --> 01:44:21,386
maybe sounds weird or metaphysical or something, but like
可能听起来有点奇怪或玄乎 但就是说

2167
01:44:21,506 --> 01:44:24,712
why do you want to do this and find bugs?
你为什么想做这个并找到漏洞？

2168
01:44:24,915 --> 01:44:26,472
This probably should have been the first slide
这本来应该是第一个幻灯片

2169
01:44:26,497 --> 01:44:28,116
but do you just want to make money?
但你只是想赚钱吗？

2170
01:44:30,052 --> 01:44:30,652
Yeah, you can do it.
当然可以

2171
01:44:30,677 --> 01:44:31,737
You may want to have fun.
你可能想图个乐子

2172
01:44:31,737 --> 01:44:33,038
You may want to learn.
你可能想学点东西

2173
01:44:33,038 --> 01:44:35,903
You may want to do a combination of those things.
你可能想兼顾以上几方面

2174
01:44:36,776 --> 01:44:38,356
So yeah, what's your goal doing all this?
所以 你做这些的目的是什么？

2175
01:44:38,459 --> 01:44:39,809
How much time and effort do you have?
你有多少时间和精力？

2176
01:44:39,834 --> 01:44:41,395
Is this going to be just a weekend thing
这会只是周末做的事情吗

2177
01:44:41,420 --> 01:44:43,081
that you're doing while you're in school?
你上学时会做吗

2178
01:44:43,081 --> 01:44:44,940
So maybe you'll take one or two days a week,
所以你可能会每周抽出一两天

2179
01:44:45,121 --> 01:44:46,620
do some vulnerability analysis.
来做漏洞分析

2180
01:44:47,506 --> 01:44:48,526
If that is your plan
如果这是你的计划

2181
01:44:48,573 --> 01:44:53,366
I would then use that to select a target correctly that...
接下来我会用它来选择合适的目标...

2182
01:44:54,153 --> 01:44:55,419
And make sure,
确保

2183
01:44:55,419 --> 01:44:58,983
because if you've ever tried to reverse something like one day a week
因为如果你尝试过每周花一天时间做逆向

2184
01:44:59,060 --> 01:45:00,581
it can be a massive pain
这会非常头疼

2185
01:45:00,581 --> 01:45:03,323
because you forget everything from your last reversing session.
因为你可能会忘了上次逆向的内容

2186
01:45:03,543 --> 01:45:05,283
That stuff really builds on each other.
这些内容是互相累积的

2187
01:45:05,283 --> 01:45:07,423
So if you don't have enough time
所以如果你时间不够

2188
01:45:07,696 --> 01:45:09,385
if it's something that's easier to reverse
如果是比较容易逆向的

2189
01:45:09,385 --> 01:45:11,006
or you can set up a fuzzer
或者你可以设置一个模糊器

2190
01:45:11,006 --> 01:45:11,847
and just let it run
让它运行

2191
01:45:11,847 --> 01:45:13,003
and then check it once a week
每周检查一次

2192
01:45:13,127 --> 01:45:14,388
that would be kind of a good strategy there.
这确实是个不错的方法

2193
01:45:14,388 --> 01:45:15,965
But you can think about your time and effort
但也可以考虑你的时间和精力

2194
01:45:15,990 --> 01:45:17,156
and how that impacts things.
以及这些的影响

2195
01:45:17,608 --> 01:45:18,696
And again, what do you know?
再说 你了解什么？

2196
01:45:18,769 --> 01:45:20,248
What is something that you know, right?
你了解什么 对吧？

2197
01:45:20,248 --> 01:45:21,389
What are your strengths?
你的优势是什么？

2198
01:45:21,389 --> 01:45:22,489
Play to your strengths.
发挥你的优势

2199
01:45:22,489 --> 01:45:24,610
I've been saying fuzzing is great over and over again.
我反复说 模糊测试非常棒

2200
01:45:24,909 --> 01:45:26,190
Maybe you don't know anything about fuzzing.
也许你对模糊测试不太了解

2201
01:45:26,190 --> 01:45:28,756
Maybe you're a code QL expert or a static analysis expert.
也许你是代码查询或静态分析的专家

2202
01:45:28,830 --> 01:45:30,470
Like those are actually totally fine.
这些都挺好

2203
01:45:30,470 --> 01:45:33,490
But like, yeah, play to those things.
不过 利用好这些长处

2204
01:45:34,843 --> 01:45:35,150
Okay.
好的

2205
01:45:36,976 --> 01:45:38,016
How are we doing on time?
我们时间怎么样？

2206
01:45:38,092 --> 01:45:39,676
How long does this class actually go to?
这堂课要上多久？

2207
01:45:43,744 --> 01:45:44,743
Okay, wow.
好 哇

2208
01:45:46,634 --> 01:45:47,676
I guess I got to go faster.
看来我得加快进度了

2209
01:45:50,162 --> 01:45:51,107
Let's do some more stuff.
我们再做点其他的事情

2210
01:45:51,627 --> 01:45:55,083
Anyways, selecting things.
话说 选择工具

2211
01:45:56,290 --> 01:46:00,065
These are things that you should absolutely be thinking about all the time.
这些是你应该时刻考虑的

2212
01:46:00,065 --> 01:46:00,885
Can you build it?
你能构建出来吗？

2213
01:46:00,885 --> 01:46:01,605
Can you run it?
你能运行吗？

2214
01:46:01,605 --> 01:46:02,425
Can you debug it?
你能调试吗？

2215
01:46:02,425 --> 01:46:03,626
Can you modify it?
你能修改吗？

2216
01:46:04,246 --> 01:46:04,506
Right?
对吧？

2217
01:46:04,506 --> 01:46:09,007
Oftentimes I, well, I won't blow up anyone's secret information
通常 嗯 我不会泄露别人的秘密信息

2218
01:46:09,007 --> 01:46:12,920
but I know people that even though they had access to systems
但我认识一些人 他们虽然有权限访问系统

2219
01:46:12,920 --> 01:46:14,481
and access to debug things
和调试权限

2220
01:46:14,481 --> 01:46:17,044
because they were able to build a complex target
但因为他们能编译构建复杂的系统

2221
01:46:17,044 --> 01:46:19,981
they just added print statements and did print statement debugging.
他们只是加了些打印语句来调试

2222
01:46:20,114 --> 01:46:23,369
And for them, that was way easier than learning how to debug a target.
对他们来说 这比学习调试目标容易多了

2223
01:46:23,369 --> 01:46:26,167
But they had access that not many of us can have.
但他们有我们多数人没有的权限

2224
01:46:26,192 --> 01:46:28,863
And so you have to do things the hard way.
所以你只能用更艰难的方法

2225
01:46:31,483 --> 01:46:33,396
So yeah, thinking about this kind of thing
所以 考虑这种问题很重要

2226
01:46:33,486 --> 01:46:35,436
this is like really important to figure out
这一点真的很重要 需要弄清楚

2227
01:46:35,522 --> 01:46:37,123
because if you don't have a good setup here
因为如果没有好的装备

2228
01:46:37,148 --> 01:46:38,543
you will drive yourself crazy
你会把自己逼疯

2229
01:46:38,576 --> 01:46:41,110
and you'll know that you're not being as efficient as possible
你会发现自己效率不高

2230
01:46:41,110 --> 01:46:43,150
and like wasted time is the worst time.
浪费时间最糟糕

2231
01:46:45,633 --> 01:46:46,710
Then you need to ask yourself
那你得问自己

2232
01:46:46,735 --> 01:46:49,034
how can I attack this target, right?
我该怎么对付这个目标 对吧？

2233
01:46:49,034 --> 01:46:50,295
This is the key thing
这是关键

2234
01:46:50,295 --> 01:46:52,856
and this is where like starting from a high level, right?
这就像是从大局考虑 对吧？

2235
01:46:52,856 --> 01:46:54,183
And thinking about, okay
然后想一想

2236
01:46:54,757 --> 01:46:58,980
what are all the different ways that input gets into this system, right?
有多少种不同的方式可以输入到这个系统 对吧？

2237
01:47:00,285 --> 01:47:01,985
The better you think about this
对于这个，你思考的越好

2238
01:47:01,985 --> 01:47:05,586
you can think about things that other people aren't thinking about, right?
你就能想到别人想不到的东西 对吧？

2239
01:47:05,586 --> 01:47:09,727
So, you know, I was saying text messages on here, right?
刚刚我说了，对于这个iphone，可以发短信

2240
01:47:09,727 --> 01:47:11,488
I think Android also had a problem.
我觉得 Android 也有这个问题

2241
01:47:11,488 --> 01:47:13,096
This was, I think, StageFrame
这大概是在StageFrame中

2242
01:47:13,288 --> 01:47:18,594
where they would generate automatically thumbnails of any movie or image,
他们会自动生成任何电影或图片的缩略图

2243
01:47:19,530 --> 01:47:20,701
maybe image, but anyways
也许是图片，但总之

2244
01:47:20,770 --> 01:47:24,549
I think the bug was in an audio or video library.
我觉得这个漏洞出在音频或视频库中

2245
01:47:24,611 --> 01:47:25,333
Anyways.
总之

2246
01:47:25,333 --> 01:47:26,603
They were generating thumbnails
他们在生成缩略图

2247
01:47:26,628 --> 01:47:28,275
even if you didn't even look at the text message
即使你没查看短信

2248
01:47:28,275 --> 01:47:30,256
of any message that was sent to you.
发送给你的任何消息内容

2249
01:47:30,650 --> 01:47:32,858
And there was a bug in that image parsing library
而那个图像解析库有一个漏洞

2250
01:47:32,858 --> 01:47:34,018
that allowed somebody to pop out.
可以让攻击者得逞

2251
01:47:34,018 --> 01:47:37,000
And so they could send you one text message and boom
所以他们可以给你发一条短信 然后

2252
01:47:37,000 --> 01:47:38,521
your whole phone is compromised from there.
你的整个手机就被攻破了

2253
01:47:39,622 --> 01:47:43,144
So like thinking, like understanding that the system does that, right,
理解系统是如何工作的 对吧

2254
01:47:43,144 --> 01:47:47,267
is like a key part of understanding that attack surface.
这是理解那次攻击的关键

2255
01:47:47,267 --> 01:47:48,837
Where are things coming from?
这些数据是从哪里来的？

2256
01:47:50,088 --> 01:47:55,150
Where does the system get input?
系统从哪里获取输入？

2257
01:47:59,169 --> 01:48:00,392
where does input go in
这个输入会到哪里去

2258
01:48:00,392 --> 01:48:01,876
where does the output go
输出去哪里了？

2259
01:48:01,992 --> 01:48:04,633
right what things does this talk to it sounds trivial
这东西和什么通信？听起来简单

2260
01:48:04,633 --> 01:48:08,963
but in a complex system it's like it can get crazy
但在复杂的系统中 情况会变得很复杂

2261
01:48:09,096 --> 01:48:12,275
um other things this is why part of the reason
这也是为什么我们

2262
01:48:12,275 --> 01:48:14,575
we talk about things at the lower division security levels
我们在较低的安全级别上讨论这些问题

2263
01:48:14,575 --> 01:48:16,664
what's the access control model like
访问控制模型是怎样的？

2264
01:48:18,316 --> 01:48:19,157
who can do what
谁有权限做什么？

2265
01:48:19,157 --> 01:48:20,763
and what are the privilege levels
权限层级又是怎样的？

2266
01:48:20,857 --> 01:48:24,999
Modern systems are absolutely crazy in all the different privilege levels they have
现代系统的权限层级简直太复杂了

2267
01:48:25,069 --> 01:48:25,649
right?
对吧？

2268
01:48:25,649 --> 01:48:27,810
A lot of things will pay out for privilege escalation
很多情况下 提升权限都能带来收益

2269
01:48:27,810 --> 01:48:33,269
and it doesn't have to be a use after free that leads to a yada, yada.
不一定是因为UAF 导致的一系列

2270
01:48:33,383 --> 01:48:34,672
It could be a logic bug
可能是逻辑漏洞

2271
01:48:34,672 --> 01:48:36,672
that allowed you to do something you weren't supposed to do
导致你做了不该做的事情

2272
01:48:36,672 --> 01:48:38,600
and you can get paid by that stuff.
这些漏洞也能带来收入

2273
01:48:39,673 --> 01:48:43,294
Like a key thing that's absolutely crazy to me is
比如 有一件事情我觉得特别不可思议

2274
01:48:43,294 --> 01:48:45,635
this is from research stuff, not bug bounties,
这是研究成果 不是漏洞赏金

2275
01:48:45,635 --> 01:48:48,055
but like WordPress, anybody know WordPress?
但说到 WordPress 有人知道吗？

2276
01:48:48,055 --> 01:48:50,315
Is it an important piece of software?
这算是一款重要的软件吗？

2277
01:48:52,830 --> 01:48:53,550
No?
不是吗？

2278
01:48:53,550 --> 01:48:53,911
Yeah.
对

2279
01:48:53,911 --> 01:48:57,848
You all think PHP is like so boomer technology that, yeah.
大家都觉得 PHP 是老掉牙的技术 对吧

2280
01:48:57,915 --> 01:48:59,773
It's still like one of the most deployed
但它仍然是部署最广泛的

2281
01:48:59,773 --> 01:49:01,594
and run pieces of software on earth.
在地球上运行的软件之一

2282
01:49:01,594 --> 01:49:02,354
It's like insane.
简直不可思议

2283
01:49:02,354 --> 01:49:03,775
WordPress runs so many sites.
WordPress 支撑着这么多网站

2284
01:49:04,748 --> 01:49:09,258
And so you can have a cross-site scripting in like WordPress.
WordPress 中也可能出现XSS

2285
01:49:09,258 --> 01:49:10,598
And a lot of times you'll think it's, oh
很多时候你可能会觉得 哎

2286
01:49:10,598 --> 01:49:11,859
it's just a self XSS.
这只是一个自我 XSS 问题

2287
01:49:11,859 --> 01:49:13,240
Like it's an admin.
比如 只是一个管理员

2288
01:49:13,240 --> 01:49:15,100
And on the admin panel
在管理员面板上

2289
01:49:15,100 --> 01:49:16,081
it's a cross-site scripting.
是一个XSS

2290
01:49:16,081 --> 01:49:17,241
But it turns out in WordPress
但在 WordPress 中

2291
01:49:17,241 --> 01:49:18,743
there are super admins.
有超级管理员

2292
01:49:18,743 --> 01:49:20,043
because you can have a WordPress install
你安装 WordPress后

2293
01:49:20,043 --> 01:49:22,904
where you have a bunch of different separate WordPresses
其中有多个独立的 WordPress 实例

2294
01:49:22,904 --> 01:49:24,144
and each of them are admins
每个都是管理员

2295
01:49:24,144 --> 01:49:27,625
so you could actually elevate up one more privilege level.
你可以提升到更高的权限

2296
01:49:27,625 --> 01:49:30,246
I didn't understand this until I was doing research with some people
直到和一些人研究这个时 我才明白这一点

2297
01:49:30,246 --> 01:49:31,486
and we found these self-XSSs
我们发现了这些自我 XSS

2298
01:49:31,486 --> 01:49:32,386
and we're like
我们当时就想

2299
01:49:32,386 --> 01:49:33,866
what actually is a self-XSS?
到底什么是自我 XSS？

2300
01:49:33,866 --> 01:49:37,331
And you realize these permission models are just absolute bonkers.
你才会意识到这些权限模型简直疯了

2301
01:49:37,356 --> 01:49:39,448
So if you can understand that
所以 如果你能理解到

2302
01:49:39,448 --> 01:49:41,028
to the level that you can make it do something
足以让它做些

2303
01:49:41,028 --> 01:49:41,988
it's not supposed to do
它本来不会做的事情

2304
01:49:41,988 --> 01:49:46,421
then that's great and part of understanding the attack surface.
那太好了 这也是理解攻击面的一部分

2305
01:49:46,576 --> 01:49:47,456
Where's the data stored?
数据存储在哪里？

2306
01:49:47,456 --> 01:49:48,417
How can you mess with data?
你怎样修改数据？

2307
01:49:48,417 --> 01:49:49,577
What things you can change?
你能改什么？

2308
01:49:49,577 --> 01:49:50,881
Those are all basic kind of stuff.
这些都是基础的东西

2309
01:49:51,271 --> 01:49:51,831
Okay.
好的

2310
01:49:51,878 --> 01:49:53,359
And what does the system depend on, right?
系统依赖什么？

2311
01:49:53,359 --> 01:49:54,099
The dependencies.
依赖项

2312
01:49:55,526 --> 01:49:56,016
Okay.
好的

2313
01:49:56,216 --> 01:50:00,442
Another key thing, and I'm going to show an example here.
还有一件重要的事 我来举个例子

2314
01:50:00,662 --> 01:50:02,183
This is the example I was talking about earlier.
就是我前面提到的要讲的例子

2315
01:50:02,183 --> 01:50:05,704
So you can spend
你可以花时间

2316
01:50:05,704 --> 01:50:07,325
this is not a CTF.
这不是 CTF

2317
01:50:07,325 --> 01:50:08,925
You need to get that into your heads
你们得领会这一点

2318
01:50:08,925 --> 01:50:11,413
when you are doing vulnerability analysis of a real target.
在分析真实目标的漏洞时

2319
01:50:11,646 --> 01:50:13,206
It is not a CTF.
这不是 CTF

2320
01:50:13,206 --> 01:50:15,208
Nobody planted a fun little vulnerability
没有人特意种下小漏洞

2321
01:50:15,208 --> 01:50:16,789
that you're just going to look at some code
让你从代码里找到

2322
01:50:16,789 --> 01:50:19,151
and find it immediately and be like, oh, this is great.
然后马上找到 说 哦 太棒了

2323
01:50:19,151 --> 01:50:20,016
I love this.
我喜欢这样

2324
01:50:20,532 --> 01:50:24,015
This is like, there may not be any exploitable bugs.
这里可能根本就没有可利用的漏洞

2325
01:50:24,015 --> 01:50:25,416
There may be plenty of bugs.
可能会有很多漏洞

2326
01:50:25,416 --> 01:50:26,696
They may not be exploitable.
但未必能利用

2327
01:50:28,159 --> 01:50:31,440
So you can spend a ton of time on one component and find nothing.
你可能花大把时间在一个组件上 却一无所获

2328
01:50:34,633 --> 01:50:36,773
Or you can find bugs that aren't triggerable.
或者你发现的漏洞根本触发不了

2329
01:50:38,051 --> 01:50:41,152
You can, this is like, yeah, this is crazy.
你可能会觉得 这太疯狂了

2330
01:50:41,152 --> 01:50:45,373
I think a good strategy is to try to cast a wide net
我认为一个好的策略是广泛撒网

2331
01:50:45,635 --> 01:50:46,759
as wide as you can.
尽可能广泛

2332
01:50:47,076 --> 01:50:49,639
Look for easy, dumb vulnerabilities
查找那些容易发现的低级漏洞

2333
01:50:49,664 --> 01:50:52,379
in like in a very shallow manner possible.
尽量浅显地

2334
01:50:52,379 --> 01:50:55,437
See what you can find and then explore those more.
看看你能找到什么 再进一步深入

2335
01:50:56,062 --> 01:50:58,790
And then you can go deep as you get more experience in things.
随着你对事物越来越熟悉 再深入挖掘

2336
01:50:59,124 --> 01:51:01,305
I think specifically the example here
我认为这里有一个具体的例子

2337
01:51:01,305 --> 01:51:02,065
I'll show you the guys this.
我给你们展示一下

2338
01:51:03,820 --> 01:51:05,200
I think there's a similar example Basically
我认为有个类似的例子

2339
01:51:05,200 --> 01:51:06,141
this is what I was mentioning.
这就是我提到的

2340
01:51:06,141 --> 01:51:09,522
It wasn't until the end of my XNU journey that I realized
直到我的 XNU 之旅结束 我才意识到

2341
01:51:09,522 --> 01:51:14,505
I should be targeting important things
我应该关注重要的内容

2342
01:51:14,505 --> 01:51:19,305
that are in the kernel that user space a normal user could talk to.
普通用户可以交互的内核部分

2343
01:51:19,651 --> 01:51:22,705
It turns out, anybody know SMB, Samba, what that is?
结果 有人知道 SMB 或 Samba 是什么吗？

2344
01:51:23,498 --> 01:51:24,210
Yeah, what is it?
嗯 那是什么？

2345
01:51:25,510 --> 01:51:26,478
No, no, back there.
不 不 后面那位

2346
01:51:29,272 --> 01:51:32,933
Yeah, way to remotely access files exported by one system to another.
嗯 这是一种系统之间远程访问文件的方式

2347
01:51:32,933 --> 01:51:35,114
I think it's NFS, right, underneath
我认为底层是 NFS 对吧？

2348
01:51:35,114 --> 01:51:36,374
and that's protocol is?
那个协议是？

2349
01:51:36,374 --> 01:51:37,054
That's a different one?
那是个不同的吗？

2350
01:51:37,054 --> 01:51:38,055
Okay.
好的

2351
01:51:38,055 --> 01:51:41,676
Thank you, random person who nobody in the room knows.
谢谢你 这个房间里谁都不认识的人

2352
01:51:43,716 --> 01:51:52,083
So I started looking in that right at the end of my sabbatical, and...
所以我在休学术假的末尾开始研究这个

2353
01:51:54,005 --> 01:51:55,906
Yeah, so this is, don't get too excited.
对 别太激动

2354
01:51:55,906 --> 01:51:57,367
This is a version
这是一个版本

2355
01:51:57,367 --> 01:51:58,888
so I was looking at, I think
所以我觉得我在研究

2356
01:51:58,888 --> 01:52:00,219
because I started this
因为我开始研究这个

2357
01:52:00,706 --> 01:52:07,681
I think I was looking at a version of XNU from like 2021, 2022.
我觉得我在研究 2021 年或 2022 年的 XNU 版本

2358
01:52:07,706 --> 01:52:09,210
Anyways, at the start of my sabbatical
总之 在我休假开始的时候

2359
01:52:09,436 --> 01:52:10,455
it was towards the end
已经接近尾声了

2360
01:52:10,455 --> 01:52:11,463
like nine months later
大概九个月后

2361
01:52:11,849 --> 01:52:14,778
and I set the fuzzer up
我设置了一个模糊测试器

2362
01:52:14,778 --> 01:52:19,776
I harnessed the SMB client or the SMB stuff,
利用了 SMB 客户端或者其他 SMB 相关的东西

2363
01:52:20,550 --> 01:52:21,376
And then it, boom
结果 砰的一声

2364
01:52:21,376 --> 01:52:23,656
it popped out bugs literally immediately.
结果立刻就找到了漏洞

2365
01:52:23,716 --> 01:52:25,970
And they were the stupidest, like
那些漏洞蠢得不行 比如说

2366
01:52:26,183 --> 01:52:30,522
copy the struct sent from the user has a length field
用户发送的结构体有一个长度字段

2367
01:52:30,522 --> 01:52:31,623
that was never checked.
从未被检查过

2368
01:52:31,623 --> 01:52:33,524
And it's just copied right into kernel memory.
结果直接被复制到了内核内存中

2369
01:52:33,524 --> 01:52:34,625
And I was like, oh
我心想 哦

2370
01:52:34,625 --> 01:52:35,346
I'm so smart.
我真是太聪明了

2371
01:52:35,346 --> 01:52:36,687
I am absolutely getting paid.
我肯定能拿到钱了

2372
01:52:37,707 --> 01:52:38,716
Then I tried to run it.
然后我试着运行了

2373
01:52:38,908 --> 01:52:44,092
My POC on the test laptop that I had couldn't trigger it.
我测试笔记本上的概念验证代码，触发不了这个漏洞

2374
01:52:44,092 --> 01:52:46,930
And then I realized that somebody had already found those bugs.
后来我才发现已经有人找到这些漏洞了

2375
01:52:47,554 --> 01:52:49,034
before I had ever looked at that.
在我研究之前

2376
01:52:49,034 --> 01:52:51,473
But in that time, like in the six months
但在那段时间 比如过去的六个月里

2377
01:52:51,695 --> 01:52:53,639
like when I'd started my sabbatical
比如在我开始休假时

2378
01:52:53,736 --> 01:52:55,926
I think like three months before I started looking at it
大概在我开始研究之前三个月

2379
01:52:56,097 --> 01:52:57,759
they had already fixed those bugs.
他们已经修复了那些问题

2380
01:52:57,957 --> 01:53:00,358
So anyways, I wanted to show this.
所以 我想展示一下这个

2381
01:53:00,358 --> 01:53:01,398
I think it was something like this
大概就是这样

2382
01:53:01,398 --> 01:53:03,259
of just like this put_mem.
就像这个put_mem

2383
01:53:03,259 --> 01:53:07,200
So like put memory in here from this CP with this segment length
就像这里的put_mem, 从cp, seglen长度

2384
01:53:07,200 --> 01:53:08,741
where the segment link was never checked
这个seglen从未被检查过

2385
01:53:08,741 --> 01:53:11,341
and just like copied in somewhere exactly like this.
就直接复制到了某个地方 完全就是这样

2386
01:53:13,622 --> 01:53:14,622
I wanted to find the exact thing
我想找到具体的东西

2387
01:53:14,622 --> 01:53:15,261
but I couldn't.
但我找不到了

2388
01:53:15,307 --> 01:53:16,754
I got a little distracted, but.
我有点分心了

2389
01:53:17,534 --> 01:53:18,361
It was something like this.
大致如此

2390
01:53:18,387 --> 01:53:22,606
Anyways, so it's, there are
总之 就是这样

2391
01:53:22,653 --> 01:53:24,233
if I had just probably taken the time
如果我当时花点时间

2392
01:53:24,233 --> 01:53:28,700
of understanding what are all the system calls that a user could access
了解用户可以访问的所有系统调用

2393
01:53:28,936 --> 01:53:32,820
and then just looking at them, like one or two functions deep,
然后查看这些调用 大概一两层函数深

2394
01:53:32,958 --> 01:53:33,809
like not even very deep
其实也不算深

2395
01:53:33,899 --> 01:53:35,556
of like, okay, this user input
比如 这个用户输入

2396
01:53:35,620 --> 01:53:36,816
does it have a length field?
它有没有长度字段？

2397
01:53:36,843 --> 01:53:38,783
Is the input weird in this struct?
这个结构体里的输入是否异常？

2398
01:53:38,983 --> 01:53:40,216
Let's look at where that's used.
我们看看它在哪里被使用

2399
01:53:40,283 --> 01:53:41,570
Let's look at where that's copied around.
我们再看看它在哪些地方被复制

2400
01:53:41,623 --> 01:53:42,703
Oh crap, there's a bug.
糟了 有个 bug

2401
01:53:42,785 --> 01:53:45,573
Like I could have found stuff like way, way, way faster.
我本可以快得多找到这些问题

2402
01:53:45,930 --> 01:53:48,591
than if I just got super deep into several things
而不是深陷于几件事里

2403
01:53:48,591 --> 01:53:49,912
and tried a lot of stuff.
试了很多方法

2404
01:53:49,912 --> 01:53:52,480
So anyways, learn from my experience.
所以 总之 吸取我的教训

2405
01:53:54,086 --> 01:53:54,434
Okay.
好的

2406
01:53:56,516 --> 01:53:57,596
Yeah, there we go.
对 就是这样

2407
01:53:57,596 --> 01:53:58,792
Final two things.
最后两件事

2408
01:54:02,932 --> 01:54:04,699
So this is kind of a double-edged sword.
所以这就像一把双刃剑

2409
01:54:04,724 --> 01:54:05,266
I don't know.
我不知道

2410
01:54:05,399 --> 01:54:07,561
And maybe I'm just full of it, but...
也许我只是在瞎说 但...

2411
01:54:09,682 --> 01:54:10,963
We talked about reverse engineering.
我们讨论过逆向工程了

2412
01:54:10,963 --> 01:54:15,099
Remember, reverse engineering does not just mean understanding a binary,
记住 逆向工程不只是理解二进制

2413
01:54:15,393 --> 01:54:15,809
right?
对吧？

2414
01:54:15,809 --> 01:54:17,493
Reverse engineering is understanding a system.
逆向工程是理解系统

2415
01:54:18,071 --> 01:54:19,806
If that system is only in binary form
如果系统只有二进制形式

2416
01:54:19,993 --> 01:54:22,175
you need to understand that binary.
你就需要理解这个二进制

2417
01:54:23,966 --> 01:54:25,699
So even if you have the source code
即使你有源代码

2418
01:54:25,699 --> 01:54:27,061
you need to understand the components
你也需要理解这些组件

2419
01:54:27,061 --> 01:54:28,162
and how they all work together.
以及它们是如何协同工作的

2420
01:54:28,900 --> 01:54:31,181
As you'll see later in the class
你们在接下来的课程中会看到

2421
01:54:31,206 --> 01:54:32,281
we'll get into like, I mean
我们详细讲一下 我是说

2422
01:54:32,281 --> 01:54:34,582
we saw it there in that XNU code.
我们在那个 XNU 代码里见过

2423
01:54:34,582 --> 01:54:37,724
You can like kind of see what's going on there
你可以大概看出来那里发生了什么

2424
01:54:37,724 --> 01:54:39,524
but it's not very clear.
但不是很清楚

2425
01:54:39,524 --> 01:54:40,645
And there's these MBs
还有一些 MBs

2426
01:54:40,645 --> 01:54:41,785
which are some buffers
是一些缓冲区

2427
01:54:41,785 --> 01:54:44,863
and there are special data structure that's only, I think
还有一种特殊的数据结构 我认为

2428
01:54:45,107 --> 01:54:47,008
I think it's used in network communication in the kernel.
它主要用在内核的网络通信中

2429
01:54:47,008 --> 01:54:47,468
I'm not sure.
我不确定

2430
01:54:47,468 --> 01:54:50,289
I can't remember if that was a specific thing to that kernel module or not
我不记得那是不是那个内核模块独有的

2431
01:54:50,289 --> 01:54:53,170
but you have to understand things
但你必须了解情况

2432
01:54:53,170 --> 01:54:55,123
but you have to remember this is not a CTF.
但你要记住 这不是夺旗赛

2433
01:54:55,714 --> 01:54:56,755
In a CTF, oftentimes
在夺旗赛中 通常

2434
01:54:56,755 --> 01:55:00,390
your reverse engineering goal is to understand every single bit and byte in that thing
你的逆向工程目标是理解每一个比特以及每一个字节

2435
01:55:00,657 --> 01:55:02,638
and to get this beautiful I to decompilation
并能得到这么漂亮的 IDA 反编译结果

2436
01:55:02,638 --> 01:55:05,379
where everything looks great because you know every single structure
一切看起来都很棒 因为你了解每一个结构

2437
01:55:05,379 --> 01:55:07,223
and every single field and everything.
以及每一个字段和所有细节

2438
01:55:07,480 --> 01:55:08,460
That is not the goal.
这不是目标

2439
01:55:09,590 --> 01:55:10,803
There is no end state here.
这里没有终点

2440
01:55:11,082 --> 01:55:12,623
You could do that and not find anything.
你这样做也可能什么都找不到

2441
01:55:14,503 --> 01:55:15,144
And then guess what?
你猜怎么着？

2442
01:55:15,144 --> 01:55:16,545
They'll release a new version in three months
他们将在三个月后发布一个新版本

2443
01:55:16,545 --> 01:55:17,985
that completely changed the stuff
这个版本将完全改变现有的内容

2444
01:55:17,985 --> 01:55:19,166
and you'll have to redo it.
你得重新来过

2445
01:55:19,166 --> 01:55:20,889
And then three months later, things will change.
然后三个月后 情况又会变

2446
01:55:21,047 --> 01:55:21,927
This literally happened to me
这真的发生在我身上

2447
01:55:21,927 --> 01:55:29,346
when I was trying to POC I was trying to create an exploit from a POC I had
我试图用我的 POC 来创建一个漏洞利用程序时

2448
01:55:29,346 --> 01:55:31,387
which was a heap underwrite.
它是一个堆下溢

2449
01:55:31,387 --> 01:55:35,290
So it was writing a pointer like one byte beyond a thing.
所以它在对象之外的一个字节处写入了一个指针

2450
01:55:35,290 --> 01:55:37,132
So I was trying to do all this heap grooming
所以我尝试进行堆规整

2451
01:55:37,132 --> 01:55:40,074
and everything to get exact thing that I could control.
为了能完全控制每一个细节

2452
01:55:40,074 --> 01:55:42,916
And anyways, I was almost doing it.
反正 我几乎就要搞定了

2453
01:55:42,916 --> 01:55:44,240
I was very, very close.
我就差那么一点点

2454
01:55:44,493 --> 01:55:46,199
And then I upgraded to the next version
然后我升级到了下一个版本

2455
01:55:46,199 --> 01:55:47,400
which was a point release.
那只是一个小版本更新

2456
01:55:47,400 --> 01:55:50,320
It was like 11.3 instead of 11.2.
从 11.2 更新到了 11.3

2457
01:55:50,393 --> 01:55:53,080
And they completely changed the way the allocator worked in the kernel.
他们彻底改写了内核中分配器的机制

2458
01:55:53,356 --> 01:55:55,356
And they randomized it much more.
并且使随机性大大增加

2459
01:55:55,356 --> 01:55:59,517
And then my beautifully crafted heap manipulation was like completely dead.
然后我精心设计的堆操作变得毫无用处

2460
01:55:59,517 --> 01:56:00,717
And I was like I just need to submit this.
我就剩提交了

2461
01:56:00,717 --> 01:56:04,418
I spent like a month trying to do this thing it driving myself crazy.
我花了近一个月尝试做这件事 几乎要疯了

2462
01:56:07,079 --> 01:56:10,259
But this is not to say you don't need to know things.
但这并不意味着你不需要了解相关知识

2463
01:56:10,259 --> 01:56:11,780
I think that's the flip side of the coin.
我觉得这是另一面

2464
01:56:11,780 --> 01:56:16,060
So I think one side of the coin is don't go too deep and too focused on things.
所以我觉得 不要过于深入和专注

2465
01:56:16,060 --> 01:56:16,981
You still need to remember
你还是要记住

2466
01:56:16,981 --> 01:56:19,393
that you're trying to eventually find stuff.
你最终是要找到东西的

2467
01:56:19,551 --> 01:56:22,692
Be cognizant of getting stuck when you're just spinning your wheels, right?
原地打转时 要意识到可能卡住了

2468
01:56:22,692 --> 01:56:24,400
And doing too much time reversing.
还有 不要花太多时间逆向

2469
01:56:25,654 --> 01:56:28,464
But keep notes.
但要做好记录

2470
01:56:28,489 --> 01:56:31,249
I almost never take notes on anything.
我几乎从不记笔记

2471
01:56:33,217 --> 01:56:34,397
That was an absolute mistake
那绝对是个错误

2472
01:56:34,397 --> 01:56:35,733
when I started doing this stuff.
我刚开始做这些事

2473
01:56:36,038 --> 01:56:41,340
Like you having to re-reverse engineer what the bug is
你得重新分析这个 Bug

2474
01:56:41,340 --> 01:56:43,996
and why it works and why the POC works or...
以及它为什么能工作 POC 为什么有效

2475
01:56:44,039 --> 01:56:45,196
this allocator stuff
这些内存分配器的问题

2476
01:56:45,230 --> 01:56:46,900
because I was I don't know traveling or doing something.
当初我在旅行，还是忙其他事

2477
01:56:46,900 --> 01:56:49,480
But like, I went like a week later to look at the thing
但是 一周后 我再去查看这些东西

2478
01:56:49,480 --> 01:56:52,601
and I was like, oh no, I like reversed, you know
天哪，我大概逆向了

2479
01:56:52,601 --> 01:56:54,981
five levels of this allocator and how it was working.
这个分配器的五个层级和它的工作原理

2480
01:56:54,981 --> 01:56:58,081
And I had to do all of that again to re-understand what was going on
我不得不重新做一遍 才能理解到底发生了什么

2481
01:56:58,081 --> 01:56:59,282
because I didn't take any notes.
因为我没有做笔记

2482
01:56:59,282 --> 01:57:01,762
And that's why I was like, okay, this time, writing a text
所以我这次下定决心 要写点东西

2483
01:57:01,762 --> 01:57:04,863
just whatever makes sense to you, the easiest, writing a text field,
随便写点对你有帮助的东西 用最简单的方式

2484
01:57:04,863 --> 01:57:07,443
like just please take notes.
拜托 一定要做笔记

2485
01:57:07,443 --> 01:57:09,063
Like this stuff is complex.
这些东西真的很复杂

2486
01:57:09,063 --> 01:57:10,944
It's not something you can always just keep in your head.
这些不是你能一直记在脑子里的东西

2487
01:57:13,236 --> 01:57:14,952
Because this was the crazy thing
因为这真是太疯狂了

2488
01:57:14,952 --> 01:57:17,190
and this is a story I wanted to share
这是我想要分享的一个故事

2489
01:57:17,215 --> 01:57:19,174
is that you never actually know
你永远不知道

2490
01:57:19,174 --> 01:57:20,535
when something is going to be useful.
什么时候某件事会派上用场

2491
01:57:20,535 --> 01:57:22,173
Like, you may understand a feature
比如说 你可能理解了一个功能

2492
01:57:23,106 --> 01:57:27,878
and it may actually cause a bug to be triggerable that wasn't triggerable.
这可能引发一个原本不能触发的 bug

2493
01:57:27,878 --> 01:57:32,120
So this was a bug I found to prepare for my sabbatical
所以 这是我在准备休假时发现的一个 bug

2494
01:57:32,120 --> 01:57:33,301
Wait, no, don't do that.
等一下 别这么做

2495
01:57:33,301 --> 01:57:34,742
Ah, don't do that, for sure.
啊 千万别这么做

2496
01:57:34,742 --> 01:57:35,192
What are you doing?
你在干什么？

2497
01:57:36,402 --> 01:57:36,799
Okay.
好的

2498
01:57:40,480 --> 01:57:41,019
Anyways...
总之...

2499
01:57:43,300 --> 01:57:49,783
okay before my sabbatical I wanted to like prepare and practice
在我休假前 我打算练练手

2500
01:57:49,783 --> 01:57:51,673
and I guess limbered up or whatever
热热身之类的

2501
01:57:52,360 --> 01:57:56,883
and to do that I tried to do pwn2own with somebody else
我试着和别人一起做个 pwn2own

2502
01:57:57,346 --> 01:57:58,847
targeting the Tesla so
目标是特斯拉 结果

2503
01:57:58,847 --> 01:58:02,210
we like I did the exact mistake I was warning you against.
我犯了之前警告过你们的错误

2504
01:58:02,210 --> 01:58:03,291
I went super deep
我研究得很深入

2505
01:58:03,291 --> 01:58:05,343
and I like found a feature that
我发现了一个功能

2506
01:58:05,636 --> 01:58:12,482
it's this feature where you can plug in a USB drive to get an audio thing to play.
你可以插入 U 盘播放音频

2507
01:58:12,520 --> 01:58:15,103
And the car doors open in sequence to that.
车门会随着音频依次打开

2508
01:58:15,103 --> 01:58:16,699
I can't remember what the feature is called.
我记不起这功能叫什么了

2509
01:58:16,813 --> 01:58:17,345
I was like, oh
我当时心想 哇

2510
01:58:17,345 --> 01:58:18,428
it's a super cool vector.
这是个超酷的攻击向量

2511
01:58:18,453 --> 01:58:20,749
Like think about just like plug the USB drive in and like boom
想象一下 插上 U 盘 就能搞定

2512
01:58:20,749 --> 01:58:22,419
you've popped the system.
你就搞定了系统

2513
01:58:22,796 --> 01:58:23,837
And I started digging in
然后我开始研究

2514
01:58:23,837 --> 01:58:27,159
I figured out the exact library they were using for this audio player
我查到了他们用的音频播放器的库

2515
01:58:28,460 --> 01:58:29,941
which was this GStreamer
就是 GStreamer

2516
01:58:29,941 --> 01:58:32,179
which is an open source audio playing system.
这是一个开源的音频播放系统

2517
01:58:32,362 --> 01:58:35,624
They also didn't do any checks that the MP3 file was actually MP3
他们也没有检查文件是否真的是 MP3

2518
01:58:35,624 --> 01:58:40,267
so the intact service was any of the installed plugins and libraries.
所以任何已安装的插件和库都能使用

2519
01:58:40,292 --> 01:58:43,904
So actually I used ？？ to find, I think
实际上我用 ？？ 发现了一些潜在的问题 我觉得

2520
01:58:44,066 --> 01:58:46,491
one potential bug that wasn't actually useful
一个潜在的 bug 但没实际用处

2521
01:58:46,491 --> 01:58:48,493
but I did end up patching in here.
但我还是在这里打了个补丁

2522
01:58:48,753 --> 01:58:50,506
So I used some static analysis tools
所以我用了一些静态分析工具

2523
01:58:50,605 --> 01:58:52,267
but honestly it was a lot of reading code
但说实话 这涉及到大量的代码阅读

2524
01:58:52,267 --> 01:58:55,309
and just like I would grep through all this stuff for malloc
我会用 grep 查找所有这些 malloc 的用法

2525
01:58:55,309 --> 01:58:57,630
or gmalloc because it was actually a different allocator,
或者是 gmalloc 因为那实际上是另一种内存管理器

2526
01:58:57,630 --> 01:59:01,193
but for gmalloc to find every single use
但为了找到每一个使用 gmalloc 的地方

2527
01:59:01,193 --> 01:59:03,194
and just like read the code a few lines back
然后往前看几行代码

2528
01:59:03,194 --> 01:59:07,076
and you can see super weird stuff like integer overflows,
你就能看到像整数溢出这样的奇怪问题

2529
01:59:07,076 --> 01:59:07,797
all this kind of stuff.
等等

2530
01:59:08,923 --> 01:59:11,159
Anyways, to I guess spoil it
话说回来 我要剧透一下

2531
01:59:11,184 --> 01:59:12,140
I was never able to land this
我始终没能成功利用

2532
01:59:12,140 --> 01:59:14,962
and I drove myself crazy trying to land this because it was a
我为此快把自己逼疯了 因为这实际上是个

2533
01:59:14,962 --> 01:59:16,809
actually you can see here, so
实际上 你可以看到

2534
01:59:17,416 --> 01:59:19,696
The vulnerability was an integer overflow here.
这里的漏洞是整数溢出

2535
01:59:19,953 --> 01:59:23,096
So there's this MKV is Matroska.
所以 MKV 就是 Matroska 格式

2536
01:59:24,381 --> 01:59:28,080
And this, basically there was this thing.
这，就是这个

2537
01:59:28,105 --> 01:59:29,993
So this blocksize.
这个blocksize

2538
01:59:30,187 --> 01:59:31,888
So if blocksize was very large
如果blocksize非常大

2539
01:59:31,888 --> 01:59:35,273
adding this constant value to it would cause it to be small.
加上这个常量后 它就会变得很小

2540
01:59:35,431 --> 01:59:37,253
And so it would allocate a small buffer.
于是它会分配一个小缓冲区

2541
01:59:37,253 --> 01:59:38,194
And then later on
然后稍后

2542
01:59:38,194 --> 01:59:41,536
it would copy block size from data to out data, right?
它会从data拷贝blocksize大小的数据到outdata中 对吧？

2543
01:59:41,536 --> 01:59:43,486
Classic integer overflow.
典型的整数溢出

2544
01:59:43,778 --> 01:59:44,786
I believe...
我认为……

2545
01:59:45,376 --> 01:59:47,477
Yeah, this is all in one function.
是的 这都在一个函数里

2546
01:59:47,477 --> 01:59:49,719
So this like is very clear
所以这非常明显

2547
01:59:49,719 --> 01:59:51,762
when you're looking at the code that this is a bug.
查看代码时 这是一个 bug

2548
01:59:52,060 --> 01:59:53,461
And so you get super stoked.
于是你非常兴奋

2549
01:59:53,461 --> 01:59:54,661
You're like, ah, yes
你就像 啊 好

2550
01:59:54,661 --> 01:59:55,462
I'm a genius.
我简直是个天才

2551
01:59:55,462 --> 01:59:56,262
I found this bug.
我发现了一个bug

2552
01:59:56,262 --> 01:59:57,420
I'm going to get so much money.
我要大赚一笔

2553
01:59:57,445 --> 01:59:58,083
I wanna a Tesla.
我要买一个tesla

2554
01:59:58,083 --> 01:59:59,453
This is going to be awesome.
这太棒了

2555
01:59:59,985 --> 02:00:02,066
And this is not like hyperbole.
我可不是在夸张

2556
02:00:02,066 --> 02:00:04,520
This is like actually what I was stupidly thinking at the time.
这真的是我当时很傻的想法

2557
02:00:05,008 --> 02:00:05,946
Anyways.
不管怎样

2558
02:00:06,908 --> 02:00:09,910
And then you create this MKV file.
然后你创建了这个 MKV 文件

2559
02:00:09,910 --> 02:00:11,351
So you find out the MKV format
于是你了解了 MKV 格式

2560
02:00:11,351 --> 02:00:13,512
you create an MKV file that does exactly this thing.
你创建了一个能实现这个功能的 MKV 文件

2561
02:00:14,612 --> 02:00:16,266
And then you do it and it doesn't work.
然后你这么做了 但它不起作用

2562
02:00:16,754 --> 02:00:17,894
And you're like why doesn't it work?
你心想 为什么不起作用？

2563
02:00:17,894 --> 02:00:18,615
This is insane.
这太离谱了

2564
02:00:18,615 --> 02:00:21,213
There's a classic integer overflow right here.
这里有一个典型的整数溢出

2565
02:00:21,471 --> 02:00:25,440
Well, you realize that actually there's a size check.
你发现其实有一个大小检查

2566
02:00:25,500 --> 02:00:28,206
So there's a size check in this other function.
这个大小检查在另一个函数中

2567
02:00:28,492 --> 02:00:30,633
So again, this is why this stuff can be very complex,
所以 这就是为什么这些事情非常复杂

2568
02:00:30,633 --> 02:00:31,994
especially with static analysis.
尤其是静态分析时

2569
02:00:31,994 --> 02:00:34,326
You can look at one function or several functions
你可以查看一个函数或几个函数

2570
02:00:34,653 --> 02:00:35,840
see that there's a bug
发现了一个 bug

2571
02:00:35,977 --> 02:00:38,118
but not realize that's 15 functions deep
但没意识到这个 bug 隐藏得很深 涉及到 15 个函数

2572
02:00:38,118 --> 02:00:40,483
or that data that you're using was checked
或者你输入的数据实际上检查过

2573
02:00:40,523 --> 02:00:42,842
in an earlier part of the code you haven't even looked at
在你还没看的前面的代码中

2574
02:00:42,842 --> 02:00:44,082
for size or something like that.
比如对size或类似数据的校验

2575
02:00:44,082 --> 02:00:45,623
So there's a size check
所以有大小检查

2576
02:00:45,623 --> 02:00:48,285
which checks max block size
这个会检查最大块的大小

2577
02:00:48,285 --> 02:00:49,953
which I believe was
我相信这个大小

2578
02:00:51,806 --> 02:00:52,740
I don't know.
我不太确定

2579
02:00:52,913 --> 02:00:53,649
I can't remember the size.
我不记得大小了

2580
02:00:53,649 --> 02:00:55,070
I think it was 15 megs or something
我觉得大概是 15 兆

2581
02:00:55,070 --> 02:00:58,780
which is not enough because I guess I don't have it here.
这不够 因为我这儿没有写

2582
02:00:58,901 --> 02:01:00,481
But this block size
但这个blocksize

2583
02:01:02,200 --> 02:01:04,633
I think was an int, so a 32-bit number.
我觉得是 32 位的整型

2584
02:01:05,943 --> 02:01:06,623
I think that's right
我觉得没错

2585
02:01:06,623 --> 02:01:08,084
because it was like a four gig overwrite.
因为它好像是 4GB 的覆盖

2586
02:01:08,084 --> 02:01:09,053
Yeah, that's the only thing that makes sense.
对 这是唯一的解释

2587
02:01:09,126 --> 02:01:12,065
Anyways, so to do this
总之 要实现这一点

2588
02:01:12,065 --> 02:01:13,165
because this was a fixed thing
因为这是个固定的量

2589
02:01:13,165 --> 02:01:17,360
you would have had to create a block size that was almost four gigs, right?
你得创建一个接近 4GB 的块 对吧？

2590
02:01:17,727 --> 02:01:19,187
And then added a little bit more
然后再稍微加一点

2591
02:01:19,187 --> 02:01:20,367
that would create a small buffer
这样可以创建一个小缓冲区

2592
02:01:20,367 --> 02:01:22,328
that you could overwrite with your huge buffer.
你可以用大缓冲区覆盖它

2593
02:01:23,714 --> 02:01:25,596
But this max block size stopped that.
但最大块大小限制了这一点

2594
02:01:25,596 --> 02:01:28,339
So it only allowed your block size to be 15 megs.
所以它只允许块大小为 15 兆

2595
02:01:28,339 --> 02:01:30,521
And so I was super disappointed.
所以我非常失望

2596
02:01:30,521 --> 02:01:31,782
And then like a day or two later
然后一两天后

2597
02:01:31,782 --> 02:01:33,985
it dawned on me while I was reading this code
我在读这段代码时突然意识到

2598
02:01:33,985 --> 02:01:38,449
that there was a feature in these blocks that had compression so
这些块有一个压缩功能

2599
02:01:38,449 --> 02:01:41,373
that you could decompress the block size.
你可以解压缩块大小

2600
02:01:41,492 --> 02:01:45,169
And that happened after the size check, but before this copy.
这发生在大小检查之后 但在复制之前

2601
02:01:45,583 --> 02:01:49,681
And so what I was able to do was it was Zlib
我能用的是 Zlib

2602
02:01:49,681 --> 02:01:51,522
and there was three different compression mechanisms.
有三种不同的压缩机制

2603
02:01:51,522 --> 02:01:52,902
I had to test all of them to see
我必须测试每一种

2604
02:01:52,902 --> 02:01:56,603
which one would actually let you create a resulting file
看哪种能生成我需要的

2605
02:01:56,603 --> 02:01:59,129
that was the size I needed of four gigs of memory.
4GB 的文件

2606
02:01:59,503 --> 02:02:01,084
And it was actually able to do that.
竟然真的能行

2607
02:02:01,084 --> 02:02:03,743
So using those two
所以利用这两种方法

2608
02:02:03,985 --> 02:02:06,386
like using the knowledge I'd learned just from reading the code
利用我从代码中学到的知识

2609
02:02:06,386 --> 02:02:09,366
and kind of doing that reverse engineering process was like
以及逆向工程的过程

2610
02:02:09,366 --> 02:02:12,007
I would not have been able to trigger that bug without this thing.
没有这个过程 我根本无法触发这个漏洞

2611
02:02:14,549 --> 02:02:15,116
So.
所以

2612
02:02:16,296 --> 02:02:19,130
Anyways, but landing this was almost insane.
不过 搞定这事儿简直疯了

2613
02:02:21,212 --> 02:02:23,133
I still have nightmares of trying to do this
我做梦都在尝试这事儿

2614
02:02:23,133 --> 02:02:25,355
because it's an audio file
因为这是音频文件

2615
02:02:25,355 --> 02:02:27,563
so you have one shot, right?
你只有一次机会 对吧？

2616
02:02:27,838 --> 02:02:30,300
And so I arranged the heap
所以我安排了堆内存

2617
02:02:30,300 --> 02:02:33,603
so I could survive the four gig write by making other tracks
通过创建其他音轨来完成 4GB 的写入

2618
02:02:33,603 --> 02:02:37,046
and everything that get allocated and massaging the heap.
和其它分配堆内存的操作 调整堆内存

2619
02:02:37,046 --> 02:02:38,587
You could survive that four gig write
你才能撑过那 4GB 的写入

2620
02:02:38,587 --> 02:02:40,389
and then you're like, great, I did that.
然后你心想 太好了 我做到了

2621
02:02:40,609 --> 02:02:41,536
What do I write?
我该写些什么？

2622
02:02:43,084 --> 02:02:43,905
Then you start looking.
然后你开始找

2623
02:02:43,905 --> 02:02:45,866
What are all the structs I can allocate?
我能分配哪些结构体？

2624
02:02:45,866 --> 02:02:47,156
Great, there's a function pointer.
太好了 有个函数指针

2625
02:02:47,216 --> 02:02:48,176
Ah, but there's ASLR
啊 但有 ASLR

2626
02:02:48,201 --> 02:02:50,030
so I can't just arbitrarily do anything.
所以我不能随心所欲

2627
02:02:50,310 --> 02:02:51,691
What are the targets I can go to?
我可以攻击哪些目标？

2628
02:02:51,691 --> 02:02:53,312
And I tried a bunch of things
我试了很多

2629
02:02:53,312 --> 02:02:54,113
couldn't find anything
但没找到

2630
02:02:54,113 --> 02:02:55,053
and I had to stop
我不得不停下来

2631
02:02:55,053 --> 02:02:57,135
because I was doing this on weekends
因为是在周末做的

2632
02:02:57,135 --> 02:02:58,856
and hating my life on those weekends
搞得我哪些周末都自闭了

2633
02:02:58,856 --> 02:03:00,798
because I was just getting stuck on this
因为我在这上面卡住了

2634
02:03:00,798 --> 02:03:02,999
because I'd gone down so far in this rabbit hole
因为我已经深陷这个兔子洞里了

2635
02:03:02,999 --> 02:03:05,621
of this was the only way I was going to do this
这是我唯一的办法

2636
02:03:05,621 --> 02:03:06,702
and it was just horrible.
简直太糟糕了

2637
02:03:06,702 --> 02:03:08,263
So anyways, learn from that.
所以 大家吸取教训吧

2638
02:03:09,996 --> 02:03:11,823
Okay, questions?
好了 有什么问题吗？

2639
02:03:23,546 --> 02:03:24,259
Okay.
好的

2640
02:03:25,140 --> 02:03:26,586
Do you guys think you can hack stuff now?
你们觉得现在能黑进东西了？

2641
02:03:29,602 --> 02:03:30,056
Hmm?
嗯？

2642
02:03:32,490 --> 02:03:33,556
That's mean.
这太刻薄了

2643
02:03:34,344 --> 02:03:35,496
Not here to offend himself.
不是来惹自己的

2644
02:03:36,710 --> 02:03:37,866
Ah, what's going on?
啊 怎么回事？

2645
02:03:37,866 --> 02:03:38,046
Okay.
好的

2646
02:03:39,667 --> 02:03:41,240
Well, let's see how elite you are.
好吧 看看你有多厉害

2647
02:03:41,648 --> 02:03:43,307
We'll do like 20 minutes of this.
我们来做 20 分钟吧

2648
02:03:46,490 --> 02:03:47,220
Okay.
好的

2649
02:03:57,193 --> 02:03:58,540
Where was that stupid thing?
那愚蠢的东西在哪？

2650
02:03:59,767 --> 02:04:00,520
Exploit me？

2651
02:04:04,817 --> 02:04:05,393
Okay.
好的

2652
02:04:05,712 --> 02:04:07,227
So now we are in.
现在我们进来了

2653
02:04:08,413 --> 02:04:09,748
Oh, and then the silly thing was
哦 结果呢 那事儿还挺逗的

2654
02:04:09,773 --> 02:04:14,519
so I spent all this effort on this stuff
我在这上面花了好多功夫

2655
02:04:14,980 --> 02:04:18,979
and I thankfully had read that Google has a patch,
好在我看到 Google 有个

2656
02:04:18,979 --> 02:04:20,603
a vulnerability patch program.
漏洞修补项目

2657
02:04:20,929 --> 02:04:22,950
where they will pay you for patching vulnerabilities
他们会为修补漏洞支付报酬

2658
02:04:22,950 --> 02:04:26,095
that exist in important open source software.
那些存在于重要的开源软件中的漏洞

2659
02:04:26,155 --> 02:04:27,831
And what they define as open source
他们对开源软件的定义是

2660
02:04:27,831 --> 02:04:30,348
is anything that's been harnessed with OSS fuzz.
就是用 OSS Fuzz 处理过的软件

2661
02:04:30,511 --> 02:04:32,332
And this stuff was harnessed with OSS fuzz.
这些东西就是用 OSS Fuzz 处理过的

2662
02:04:32,332 --> 02:04:34,412
So I was actually able to then get
所以我最后得了

2663
02:04:34,412 --> 02:04:35,773
I got like $500 from this.
我从这赚了 500 美元

2664
02:04:35,773 --> 02:04:38,934
So at least I got something out of like three months of effort
至少这三个月的努力 我还是有点收获的

2665
02:04:38,934 --> 02:04:40,354
besides purely failure.
不算完全失败

2666
02:04:40,354 --> 02:04:41,634
But I know it's cool.
但我还是觉得这很酷

2667
02:04:41,634 --> 02:04:42,714
I got like a bunch of bugs fixed.
我修复了一堆 bug

2668
02:04:43,995 --> 02:04:45,155
So that part was fun.
这部分还挺有趣的

2669
02:04:45,155 --> 02:04:48,867
But yeah, it was crazy.
但确实有点疯狂

2670
02:04:56,703 --> 02:04:57,363
Here's our program.
这是我们的程序

2671
02:04:58,684 --> 02:05:03,783
Have you guys ever group hacked before?
你们以前有组队开黑过吗？

2672
02:05:05,008 --> 02:05:07,423
So we have this program, exploit 64.
我们有这个叫 exploit 64 的程序

2673
02:05:08,950 --> 02:05:12,432
There's level one is hello as the password, hello and pass in a value.
第一关的密码是'hello' 输入'hello'并传递一个值

2674
02:05:14,933 --> 02:05:17,476
Value less or equals zero is not allowed.
不允许小于或等于零

2675
02:05:22,531 --> 02:05:23,744
So what do we do next?
那我们接下来该怎么办？

2676
02:05:33,689 --> 02:05:36,788
And I can just use ObjDump
我可以用 ObjDump 来分析

2677
02:05:36,788 --> 02:05:42,114
because this is actually the one nice thing about using an Apple Silicon Mac
因为这是使用苹果硅芯片 的一大优势

2678
02:05:42,332 --> 02:05:45,107
is because it's running ARM with UTM
因为用 UTM 运行的 ARM

2679
02:05:45,132 --> 02:05:47,865
 or whatever that I'm using in Apple's virtualization stuff.
还是什么苹果的虚拟化技术

2680
02:05:47,892 --> 02:05:53,945
I can run a native Linux VM locally on my thing
我可以在我的设备上本地运行一个 Linux 虚拟机

2681
02:05:53,970 --> 02:05:56,546
and then all the tools work when it works and so.
这样一切正常时 所有工具都能正常工作

2682
02:05:56,546 --> 02:05:58,059
That part's kind of nice, but ...
这部分还挺不错的 但是……

2683
02:05:58,787 --> 02:05:59,067
Okay.
好的

2684
02:06:01,466 --> 02:06:02,286
Oh, God.
天哪

2685
02:06:02,948 --> 02:06:03,646
It's ...
是……这个

2686
02:06:06,493 --> 02:06:06,969
Oh, no.
糟了

2687
02:06:06,969 --> 02:06:07,989
Does this mean it's ...
这意味着……

2688
02:06:09,069 --> 02:06:09,762
Whatchamacallit?
那个什么来着？

2689
02:06:11,490 --> 02:06:12,002
Yes.
是

2690
02:06:12,530 --> 02:06:13,071
Yeah.
嗯

2691
02:06:13,071 --> 02:06:14,731
It's C++.
是 C++

2692
02:06:15,742 --> 02:06:17,069
I'm regretting this immediately.
我立刻就后悔了

2693
02:06:17,169 --> 02:06:17,835
Okay.
行

2694
02:06:18,372 --> 02:06:19,725
Also, we just crashed objdump.
另外 刚刚把objdump搞崩了

2695
02:06:19,772 --> 02:06:20,572
Is that a failure?
这是失败了吗？

2696
02:06:23,092 --> 02:06:25,472
I feel like that shouldn't happen in objdump.
我感觉应该不是objdump出问题

2697
02:06:26,365 --> 02:06:26,996
Oh, good.
哦 还好

2698
02:06:26,996 --> 02:06:28,138
Okay, see, it's so resilient.
好的 它健壮性还挺好的

2699
02:06:31,219 --> 02:06:33,129
Okay, let's grab for level one.
好的 我们先查找一下level1

2700
02:06:35,242 --> 02:06:37,023
Okay, then we just open it up in IDA
好吧 我们用IDA看一下

2701
02:06:37,023 --> 02:06:38,935
because we tried this and said, yep.
这个没弄好

2702
02:06:40,572 --> 02:06:41,355
Okay.
好的

2703
02:06:45,355 --> 02:06:46,128
13?
13？

2704
02:06:47,696 --> 02:06:48,343
Oh, level 13.
哦 第 13 关

2705
02:06:48,369 --> 02:06:53,546
Yeah, so this is a multi-level binary challenge in one binary, basically
这是一个多关卡的二进制挑战 都在一个文件里

2706
02:06:53,615 --> 02:06:55,602
so it's I don't know.
我也不太清楚

2707
02:06:55,602 --> 02:06:57,375
I just saw it on GitHub.
我在 GitHub 上看到的

2708
02:06:57,468 --> 02:07:00,568
I have the link somewhere in here.
链接就在这儿的某个地方

2709
02:07:01,244 --> 02:07:02,808
So if you want to try it out, you can.
所以如果你想试试 就尽管来吧

2710
02:07:07,199 --> 02:07:08,519
All right.
好的

2711
02:07:09,273 --> 02:07:10,220
Source.
源码

2712
02:07:16,200 --> 02:07:17,287
Exploit me.
来黑我吧

2713
02:07:19,868 --> 02:07:21,116
I know you all saw that.
我知道你们都看到了

2714
02:07:22,990 --> 02:07:24,695
Source directory, but we're not gonna do it.
源代码目录 但我们先不这样做

2715
02:07:27,276 --> 02:07:29,269
All right, should we start at the start?
好的 要从start开始吗？

2716
02:07:30,716 --> 02:07:31,549
At main?
从main开始？

2717
02:07:33,500 --> 02:07:34,769
Can you all read this?
大家都能看清吗？

2718
02:07:35,941 --> 02:07:38,049
Or do you need me to zoom in somehow?
或者需要我放大一些？

2719
02:07:39,503 --> 02:07:41,196
Back row, yeah?
后排 看清了吗？

2720
02:07:41,464 --> 02:07:42,156
Okay.
好的

2721
02:07:45,049 --> 02:07:46,747
Oh, somebody said, why do I look like Tom Cruise?
哦 有人问为什么我长得像汤姆·克鲁斯？

2722
02:07:46,747 --> 02:07:47,488
Well, I don't know.
这个我也说不准

2723
02:07:49,769 --> 02:07:51,229
All right, okay.
好的 就这样

2724
02:07:58,549 --> 02:08:00,420
Looks like we have all the passwords here.
看来我们这里有所有的密码了

2725
02:08:01,250 --> 02:08:03,251
Hello, help, velvet, my secret.

2726
02:08:05,031 --> 02:08:06,533
Pretty nice, we've already got passwords.
不错 我们已经拿到密码了

2727
02:08:07,632 --> 02:08:09,033
But we actually want to exploit it, right?
但我们其实是想漏洞利用 对吧？

2728
02:08:09,033 --> 02:08:11,258
We're not just here for the free passwords.
我们不是为了密码来的

2729
02:08:11,574 --> 02:08:11,978
Okay.
好的

2730
02:08:14,048 --> 02:08:14,725
Okay.
好的

2731
02:08:15,785 --> 02:08:17,098
So this is...
所以这就是...

2732
02:08:18,036 --> 02:08:21,169
Okay, so argv[1], I gotta assume...
好的 argv[1] 我猜猜看...

2733
02:08:22,656 --> 02:08:23,304
Sorry, sorry.
抱歉 抱歉

2734
02:08:23,304 --> 02:08:24,922
Oh, this is passwords, aHelp.
哦 这是密码 aHelp

2735
02:08:25,576 --> 02:08:26,162
Oh, I see.
哦 明白了

2736
02:08:26,304 --> 02:08:26,889
Okay.
好的

2737
02:08:27,186 --> 02:08:28,086
It's supposed to be a list
这里是列表

2738
02:08:28,086 --> 02:08:29,886
and then it's like hard coding the value there.
这里写死的值

2739
02:08:31,347 --> 02:08:34,913
Passwords, argc, get effective user ID.
密码、argc 获取有效用户 ID

2740
02:08:34,938 --> 02:08:37,513
Oh, a nice function called int overflow.
哦 有一个很好的函数叫 int overflow

2741
02:08:37,589 --> 02:08:38,686
That seems helpful.
这看起来很有用

2742
02:08:38,913 --> 02:08:41,110
Okay, so argv[2], so our second argument.
好的 argv[2] 就是第二个参数

2743
02:08:41,110 --> 02:08:42,531
So our first argument has to be the password.
第一个参数必须是密码

2744
02:08:42,531 --> 02:08:43,779
The second argument is there.
第二个参数在这里

2745
02:08:44,399 --> 02:08:45,586
int_overflow()

2746
02:08:47,252 --> 02:08:48,333
Okay, so what's it doing?
好的 它做什么？

2747
02:08:48,333 --> 02:08:50,253
Taking our input, atoi
接收我们的输入 转换成整数

2748
02:08:50,253 --> 02:08:51,739
turning it into a local int.
转换成本地整数

2749
02:08:52,659 --> 02:08:55,020
Value less than or equal zero is not allowed.
值不能小于或等于零

2750
02:08:56,239 --> 02:08:57,199
If _WORD.

2751
02:08:58,349 --> 02:09:01,009
Okay, so now it's, if not it.
好的 如果是其他情况

2752
02:09:06,264 --> 02:09:06,856
What was that?
这是什么？

2753
02:09:13,346 --> 02:09:14,290
Yeah, okay, let's,
好的 开始吧

2754
02:09:14,317 --> 02:09:15,564
oh, oh, oh, the word.
哦 哦 哦 这个词

2755
02:09:15,667 --> 02:09:16,667
I hate these stupid things.
我讨厌这些破玩意

2756
02:09:16,667 --> 02:09:18,250
Okay, let's go here.
好的 咱们去这儿

2757
02:09:20,189 --> 02:09:20,756
Well, let's...
嗯 我们……

2758
02:09:22,454 --> 02:09:23,596
Now I want to give names.
现在我要给它们取名字

2759
02:09:27,163 --> 02:09:27,730
in_int.
输入的整数

2760
02:09:30,956 --> 02:09:32,209
Okay, great.
好的 太好了

2761
02:09:32,236 --> 02:09:32,536
Okay.
好的

2762
02:09:34,382 --> 02:09:34,837
I see.
我知道了

2763
02:09:36,197 --> 02:09:36,796
Yeah.
嗯

2764
02:09:37,052 --> 02:09:37,372
Okay.
行

2765
02:09:37,397 --> 02:09:38,576
I want to look at the assembly.
我想看看汇编

2766
02:09:41,818 --> 02:09:44,970
So we can kind of clearly see by looking at this.
这里我们可以清楚地看到

2767
02:09:46,919 --> 02:09:51,312
So move, wait, store register, load register, store register.
所以 移动 等待 存储寄存器 加载寄存器 再存储寄存器

2768
02:09:54,223 --> 02:09:55,330
What's var_8?
var_8 是什么？

2769
02:09:59,486 --> 02:10:00,576
Why didn't this update?
为什么这里没更新？

2770
02:10:02,487 --> 02:10:02,830
No.
没有

2771
02:10:11,812 --> 02:10:12,580
Okay.
好的

2772
02:10:12,992 --> 02:10:14,293
Bunch of redundant stuff.
一堆多余的东西

2773
02:10:15,260 --> 02:10:17,633
Compare W0 with 0.
比较 W0 和 0

2774
02:10:18,973 --> 02:10:19,906
And then...
然后...

2775
02:10:25,123 --> 02:10:27,461
STRH, we looked at that last week, right?
STRH 我们上周讲过 对吧？

2776
02:10:29,583 --> 02:10:31,648
Yeah, so this is the, okay
嗯 所以这是 好的

2777
02:10:31,648 --> 02:10:33,890
,so it's still a 30, ah, okay.
所以还是 30 好的

2778
02:10:33,890 --> 02:10:35,811
So it's reading in a 32-bit, right
所以它读取的是 32 位 对吗？

2779
02:10:35,811 --> 02:10:37,052
which is the W0
就是 W0

2780
02:10:37,052 --> 02:10:42,723
and then the H here means half word
这里的 H 表示半字

2781
02:10:42,783 --> 02:10:43,849
which is two bytes.
就是两字节

2782
02:10:44,857 --> 02:10:46,490
Cool, so what number do we need?
酷 我们需要哪个数字？

2783
02:10:50,841 --> 02:10:51,642
Yeah, so OX.
对 所以是 0x

2784
02:10:52,578 --> 02:10:54,146
Actually, the thing I really like to do
其实我最喜欢做的事情是

2785
02:10:54,146 --> 02:10:56,931
there's this really handy-dandy bit thing here of doing like that.
这里有一个非常方便的位操作 就像这样

2786
02:10:57,267 --> 02:10:59,691
So you can just immediately set the bits.
所以你可以直接设置这些位

2787
02:11:00,245 --> 02:11:02,245
I mean, 10,000.
我的意思是 10000

2788
02:11:03,509 --> 02:11:04,011
Come on.
拜托了

2789
02:11:05,503 --> 02:11:06,996
I can't even say it's off by 10.
我甚至不能说它差了 10

2790
02:11:11,354 --> 02:11:11,854
Exactly.
没错

2791
02:11:11,854 --> 02:11:12,403
So that's the other.
这就是另一个

2792
02:11:12,428 --> 02:11:13,935
See, people are already thinking through.
你看 大家已经开始思考了

2793
02:11:13,935 --> 02:11:14,950
So the other question, right?
所以另一个问题 对吧？

2794
02:11:15,016 --> 02:11:16,597
So we think we know the bug.
所以我们认为已经找到这个 bug 了

2795
02:11:16,631 --> 02:11:17,536
The bug is?
这个 bug 是？

2796
02:11:17,775 --> 02:11:20,690
that this check is a 32-bit integer check
这是一个针对 32 位整数的检查

2797
02:11:20,856 --> 02:11:25,897
but this check is a 16, two-byte, wait
但这个检查是 16 位的 两个字节 等等

2798
02:11:25,969 --> 02:11:26,657
did I say 32?
我说的是 32 吗？

2799
02:11:26,769 --> 02:11:28,198
Yeah, 32 and 16-bit.
是的 32 位和 16 位

2800
02:11:28,198 --> 02:11:29,238
So if we can pass them
所以如果我们能通过这些检查

2801
02:11:29,238 --> 02:11:30,571
and this happens all the time
这种情况经常发生

2802
02:11:30,596 --> 02:11:32,618
and it is very helpful
这会非常有帮助

2803
02:11:33,129 --> 02:11:36,080
if you have like a multiply that causes an integer overflow
如果乘法导致整数溢出

2804
02:11:36,080 --> 02:11:36,920
you need to make sure that
你需要确保

2805
02:11:36,920 --> 02:11:40,210
those two numbers that you're giving are in the right proper thing.
这两个数字在正确的范围内

2806
02:11:40,261 --> 02:11:41,256
So making sure that
因此要确保

2807
02:11:41,280 --> 02:11:45,147
it's right within that range of like larger than this but smaller than this
它在大于这个，但小于这个值的范围内

2808
02:11:47,229 --> 02:11:48,794
So 10,000 hex
所以0x10,000

2809
02:11:49,261 --> 02:11:52,734
And yeah, so I will just do a quick man
我快速查看一下手册

2810
02:11:53,761 --> 02:11:56,169
because especially in honor of Rob since he's here
既然 Rob 在这里，我就借此向他致敬

2811
02:11:56,560 --> 02:11:58,501
we'll read the man page of atoi.
我们来阅读 atoi 的手册页

2812
02:12:01,983 --> 02:12:03,801
We will search through the man page.
我们在手册页中搜索一下

2813
02:12:06,056 --> 02:12:06,746
Ah, there we go.
啊 找到了

2814
02:12:07,787 --> 02:12:12,987
No, because the behavior is the same as strtol, null pointer 10.
因为它的行为和strtol(nptr, NULL, 10)一样

2815
02:12:13,012 --> 02:12:13,870
So string to long is
字符串转长整型

2816
02:12:13,870 --> 02:12:15,196
where you can specify the base.
你可以指定基数

2817
02:12:16,076 --> 02:12:21,092
So now our theory that we have developed as a group, what was it?
那么整体来看，推导出了什么呢

2818
02:12:21,092 --> 02:12:22,050
Hello.
你好

2819
02:12:22,433 --> 02:12:23,876
We pass in hello
我们传入“hello”

2820
02:12:23,956 --> 02:12:28,762
and we pass in 65536.
再传入 65536

2821
02:12:32,146 --> 02:12:32,840
Look at that.
看看

2822
02:12:33,620 --> 02:12:34,335
A whole bunch of hackers.
一堆黑客

2823
02:12:34,335 --> 02:12:35,335
How many people are in this room?
这个房间里有多少人？

2824
02:12:35,335 --> 02:12:35,975
Like 20 something?
大概 20 人？

2825
02:12:37,056 --> 02:12:37,546
Look at that.
你们看

2826
02:12:37,646 --> 02:12:38,000
Okay.
行

2827
02:12:38,656 --> 02:12:39,160
Help

2828
02:12:40,366 --> 02:12:41,906
I need somebody.
我需要个人

2829
02:12:42,277 --> 02:12:43,076
This is actually kind of fun.
这还挺有趣的

2830
02:12:44,469 --> 02:12:45,675
I don't know if you're having fun
我不知道你们觉得有趣吗

2831
02:12:46,575 --> 02:12:47,983
but the question is, do I care?
但我在乎吗？

2832
02:12:48,056 --> 02:12:48,576
Okay.
行

2833
02:12:50,064 --> 02:12:51,070
Attack overflow.
进行溢出攻击

2834
02:12:51,165 --> 02:12:52,763
Do we want to try to overflow things?
我们要不要试试溢出？

2835
02:12:54,195 --> 02:12:55,102
Like overflowing things?
就是溢出？

2836
02:12:55,127 --> 02:12:55,473
Okay.
好的

2837
02:12:55,567 --> 02:12:57,160
Username and password.
用户名和密码

2838
02:13:04,886 --> 02:13:06,273
Username, password.
用户名 密码

2839
02:13:08,533 --> 02:13:12,599
If. verify user, username is not equal to one, return zero.
如果用户名验证结果不等于 1 就返回 0

2840
02:13:12,599 --> 02:13:15,645
Okay, so there's some check. It's gonna check the input of username.
好的 这里有个检查，它会检查用户名

2841
02:13:15,940 --> 02:13:19,668
And again, this is where I like to not go too deep
这里正好对应前面说的不用看太深

2842
02:13:19,692 --> 02:13:22,093
and be like, oh yeah, well, what's that function?
不用像，哦，这个函数是干啥的？

2843
02:13:22,183 --> 02:13:23,043
What's that function?
那个函数是干啥的？

2844
02:13:23,146 --> 02:13:24,604
Verify user calls something else.
哦，verify_user 又调用了别的

2845
02:13:24,604 --> 02:13:26,865
It's like, you can just look at it as like, okay
就是，知道个轮廓就好

2846
02:13:26,865 --> 02:13:28,486
there's some check, obviously
显然有检查

2847
02:13:28,486 --> 02:13:29,826
because there's some if condition here.
因为这里有个 if 条件

2848
02:13:30,753 --> 02:13:32,801
Copy onto v4 funny,
先复制 funny 到 v4

2849
02:13:32,825 --> 02:13:37,980
then copy onto the second argument password onto v5.
再复制第二个参数 passwd 到 v5

2850
02:13:38,929 --> 02:13:45,936
And then, shouldn't this be a character pointer?
这应该是字符指针吧？

2851
02:13:49,756 --> 02:13:53,229
估计是rob问ida快捷键

2852
02:13:57,066 --> 02:13:59,008
I was just like, what you get asked in class
感觉像，课堂上别人问你的

2853
02:13:59,008 --> 02:14:01,512
and now you're reflecting it back on me?
现在你又把问题抛给我了？

2854
02:14:02,372 --> 02:14:03,632
Yeah.
嗯

2855
02:14:04,806 --> 02:14:08,675
it's like asking me what emacs shortcuts i do to do things
就像问我在 Emacs 上，用了哪些快捷键

2856
02:14:08,675 --> 02:14:10,659
it's like built in my brain  but yes i can
这些快捷键已经刻在脑子里了，但我可以

2857
02:14:15,071 --> 02:14:18,823
okay so um uh
嗯……

2858
02:14:18,823 --> 02:14:22,526
let's see n is to change variable names
我们看看 按 n 是用来更改变量名的

2859
02:14:22,526 --> 02:14:24,906
so you hit n you can change the variable name
所以你按 n 就可以更改变量名

2860
02:14:25,048 --> 02:14:27,293
hit y and you can change the type
按 y 更改变量类型

2861
02:14:27,505 --> 02:14:30,206
The thing that will drive me crazy is why people develop tools
让我抓狂的是 为什么这个工具

2862
02:14:30,206 --> 02:14:32,127
where you can change the type that has the name in it
改类型的时候，输入框里有名字

2863
02:14:32,127 --> 02:14:33,731
but if you change this name, nothing happens.
但如果你在这里改名字，不会生效

2864
02:14:33,807 --> 02:14:36,640
It's the most insane thing that anyone's ever developed this system
这是我见过最疯狂的系统

2865
02:14:36,773 --> 02:14:37,629
that shows you this.
它都展示了这个名字

2866
02:14:37,629 --> 02:14:38,409
They should be one thing.
他们应该是一回事

2867
02:14:38,409 --> 02:14:39,710
You can change the type and the name
你可以更改类型和名称

2868
02:14:39,710 --> 02:14:40,510
and it should just change.
它也应该随之改变

2869
02:14:42,617 --> 02:14:43,371
Anyways, okay.
总之 行吧

2870
02:14:44,452 --> 02:14:48,057
And then I think the only other ones I've been using...
另外 我觉得我常用的只有这些...

2871
02:14:48,731 --> 02:14:49,411
Oh, let's see
哦 看看...

2872
02:14:50,692 --> 02:14:54,637
function F5 to make it try to re-decompile.
Fn + F5 用于尝试重新反编译

2873
02:14:54,893 --> 02:14:57,834
Tab is the really important one to switch easily
Tab 键非常重要 可以轻松地

2874
02:14:57,834 --> 02:15:01,523
between decompilation view here and then the
往返于反编译视图与...

2875
02:15:02,275 --> 02:15:04,036
so like clicking on verify_user
比如说 点击verify_user

2876
02:15:04,036 --> 02:15:05,156
this means when I press tab
当我按下 Tab 键

2877
02:15:05,181 --> 02:15:07,754
it should be synced with that code here.
它应该和这里的代码同步

2878
02:15:08,097 --> 02:15:12,582
And so I should see a BL Z11verify_userPC.
所以 我应该看到 BL Z11verify_userPC.

2879
02:15:12,749 --> 02:15:14,279
Oh, it does demangle it. That's kind of cool.
哦 它确实解析了 这挺酷的

2880
02:15:14,279 --> 02:15:15,062
Is this a new thing?
这是新功能吗？

2881
02:15:16,219 --> 02:15:16,915
It always did it.
总是这样

2882
02:15:19,749 --> 02:15:20,483
Oh, okay.
哦 明白了

2883
02:15:21,563 --> 02:15:22,509
The free one.
免费版

2884
02:15:23,944 --> 02:15:26,030
Okay, funny over here.
好的 funny 这里

2885
02:15:26,798 --> 02:15:28,745
And then the other one is escape.
另一个是Esc

2886
02:15:28,918 --> 02:15:30,731
So escape goes backwards.
Esc会退回去

2887
02:15:32,107 --> 02:15:33,358
I don't know how to go forwards.
我不知道怎么前进

2888
02:15:36,068 --> 02:15:37,674
Is there a way for it? There must be, right?
有办法吗？肯定有办法吧？

2889
02:15:39,309 --> 02:15:40,334
Can you not go forward?
你不能前进吗？

2890
02:15:40,450 --> 02:15:41,121
What?
什么？

2891
02:15:42,281 --> 02:15:43,881
Are you defending Ida?
你是在给IDA辩护吗？

2892
02:15:44,731 --> 02:15:46,912
If you press escape and look in, like
你按Esc 看着 就像

2893
02:15:47,666 --> 02:15:48,963
There's two arrows.
有两个箭头

2894
02:15:50,431 --> 02:15:51,531
Jump to next position.
跳到下一个位置

2895
02:15:53,023 --> 02:15:53,970
Or, yeah.
 嗯

2896
02:15:55,393 --> 02:15:56,493
Jump to next position.
跳到下个位置

2897
02:15:56,493 --> 02:15:56,853
Oh, wait.
等一下

2898
02:15:58,632 --> 02:16:00,114
Yeah, but what's the keyboard shortcut?
对 但快捷键是什么？

2899
02:16:00,114 --> 02:16:00,434
Anyways.
总之

2900
02:16:03,055 --> 02:16:07,216
Okay, so copy V4, funny V4 password.
好 复制funny到 V4，密码

2901
02:16:07,535 --> 02:16:08,797
Some strlen.
某种strlen函数

2902
02:16:08,797 --> 02:16:10,058
Why is it strlen_0?
为什么是strlen_0？

2903
02:16:10,058 --> 02:16:11,701
Is that like C++ stuff?
看着像C++代码

2904
02:16:12,040 --> 02:16:14,879
String length on zero.
将v5在v4长度位置的字节置0

2905
02:16:16,512 --> 02:16:17,593
What is this doing?
这是在做什么？

2906
02:16:17,593 --> 02:16:19,334
Probably checking the end of the string or something?
可能是检查字符串的结尾？

2907
02:16:20,775 --> 02:16:22,040
This must be a buffer, right?
这应该是缓冲区 对吧？

2908
02:16:22,136 --> 02:16:23,999
This is clearly a type.
这显然是个char数组

2909
02:16:24,258 --> 02:16:25,120
Yeah.
嗯

2910
02:16:28,820 --> 02:16:29,542
Right, okay.
好的 知道了

2911
02:16:29,542 --> 02:16:31,224
And then the other thing that's...
然后还有个……

2912
02:16:31,224 --> 02:16:32,400
Wait, but why?
等等 为什么？

2913
02:16:39,485 --> 02:16:40,736
Okay, first...
好的 首先...

2914
02:16:42,010 --> 02:16:44,659
Other thing we can do is the strcmp, right?
然后进行字符串比较 对吧？

2915
02:16:44,659 --> 02:16:46,399
So we have strcmp v4, v5.
会比较 v4 和 v5

2916
02:16:47,753 --> 02:16:51,503
we strcmp always takes two character pointers.
strcmp需要两个字符指针

2917
02:16:51,703 --> 02:16:56,103
So it's passing in the address of v5
所以它传入了 v5 的地址

2918
02:16:56,103 --> 02:16:58,384
which means v5 must be a buffer, right?
这意味着 v5 必须是一个缓冲区 对吧？

2919
02:16:58,384 --> 02:16:59,066
It's not a
它不是一个

2920
02:16:59,119 --> 02:17:00,604
so the type here is wrong.
所以这里自动识别的类型错了

2921
02:17:00,604 --> 02:17:02,085
It's saying that it's a 64 bit.
它说这是 64 位的

2922
02:17:02,085 --> 02:17:08,116
So it's what 64 bit would be character or the eight bytes.
所这个 64 位应该是char[8]

2923
02:17:11,348 --> 02:17:12,016
Is that right?
没错吧？

2924
02:17:12,132 --> 02:17:12,540
Yeah.
对

2925
02:17:14,813 --> 02:17:16,374
So that makes that look better.
这样一来就更好了

2926
02:17:16,374 --> 02:17:18,995
It makes this look worse, which is weird, but okay.
这让这个看起来更糟 虽然奇怪 但好吧

2927
02:17:20,806 --> 02:17:21,917
Oh, see, and then,
哦 你看 接下来

2928
02:17:21,917 --> 02:17:24,878
yeah, this is how you can tell that your decompilation is getting
是的 这就是反编译越来越准确的迹象

2929
02:17:24,878 --> 02:17:27,720
your reversing is better as the decompilation gets better.
反编译越准 逆向的也越好

2930
02:17:27,720 --> 02:17:31,342
So doing this, so calling strlen on v4
所以 对 v4 调用 strlen 函数

2931
02:17:31,342 --> 02:17:33,593
so however many characters v4 is
无论 v4 有多少字符

2932
02:17:33,699 --> 02:17:36,826
it's been nulling that byte of v5.
它都会把 v5 第v4长度的那个字节 置零

2933
02:17:36,933 --> 02:17:37,593
Is that right?
对吗？

2934
02:17:37,985 --> 02:17:39,873
So the string length is two.
所以字符串长度是 2

2935
02:17:40,578 --> 02:17:41,903
Yeah, 0, 1, 2
嗯 0, 1, 2

2936
02:17:41,979 --> 02:17:45,136
so that that way the resulting string is going to be the same length.
这样结果字符串的长度就会一致

2937
02:17:45,600 --> 02:17:46,136
Cool.
酷

2938
02:17:46,586 --> 02:17:47,096
Okay.
好的

2939
02:17:48,263 --> 02:17:52,303
And then if v4 is not funny, then...
然后如果 v5 不是funny 那么...

2940
02:17:53,863 --> 02:17:56,704
So the password, the idea is checking that it's funny.
所以就是检查passwd是不是funny

2941
02:17:56,704 --> 02:17:57,544
Why doesn't funny work?
为什么funny不行？

2942
02:17:58,544 --> 02:17:59,845
So just pass in funny and that work?
所只要输入funny就行吗

2943
02:18:05,757 --> 02:18:07,784
Oh, login succeeded, but you still failed.
哦 登录成功了， 但还是不行

2944
02:18:07,860 --> 02:18:08,870
Login failed.
登录失败

2945
02:18:10,952 --> 02:18:12,250
Let's go to verify user.
我们去验证一下用户

2946
02:18:14,460 --> 02:18:15,895
Okay, pressing N for username.
好的 按 N 输入用户名

2947
02:18:20,046 --> 02:18:21,230
It's not doing dictation.
不用语音输入

2948
02:18:22,056 --> 02:18:23,943
Okay, username.
好的 输入用户名

2949
02:18:23,968 --> 02:18:28,341
So similar thing, there's a V2, copy admin under there.
类似的，这里有个 V2，把admin拷贝到这里

2950
02:18:28,341 --> 02:18:29,428
Well, this is like the same thing.
嗯 基本完全一样

2951
02:18:29,453 --> 02:18:33,774
If only we had a way to like detect macros and common inline functions.
如果我们有一种方法能检测宏和常见的内联函数就好了

2952
02:18:34,785 --> 02:18:38,354
On V3, so I will go ahead and press Y
选中V3，然后按Y

2953
02:18:38,379 --> 02:18:39,593
to call this a
叫它

2954
02:18:41,207 --> 02:18:42,300
char

2955
02:18:44,840 --> 02:18:45,907
[8]

2956
02:18:48,760 --> 02:18:52,469
return one if it's not comparable to admin
如果不匹配admin 返回 1

2957
02:18:52,494 --> 02:18:55,119
and then login failed but
然后登录失败了 但是

2958
02:18:55,144 --> 02:18:56,946
where do you get the flag
你从哪里获取flag

2959
02:18:58,013 --> 02:18:59,915
oh yeah
哦 对了

2960
02:18:59,915 --> 02:19:05,218
that's funny so there's this nice uh function called stack overflow uh
挺有意思的 这个函数叫栈溢出

2961
02:19:05,218 --> 02:19:07,319
which should have been a hint i don't know why i wasn't thinking about that
这本该是个提示 不知道为什么我没想起来

2962
02:19:07,319 --> 02:19:08,820
but uh cool
不过 挺酷的

2963
02:19:08,820 --> 02:19:09,175
okay
好的

2964
02:19:11,856 --> 02:19:13,116
All right, should we overflow this?
好的 我们要让它溢出吗？

2965
02:19:15,397 --> 02:19:16,770
Yeah, maybe?
嗯 可以试试？

2966
02:19:17,163 --> 02:19:18,270
No, you don't want to?
不行 你不想？

2967
02:19:18,766 --> 02:19:19,290
Okay.
行

2968
02:19:19,759 --> 02:19:22,870
So we're strcopying into v3 here, the username.
所以我们把用户名复制到 v3

2969
02:19:23,156 --> 02:19:25,623
I guess we can technically choose whichever one we want.
我们技术上可以选任何一个

2970
02:19:27,549 --> 02:19:30,403
So let's help...
那我们help...

2971
02:19:31,263 --> 02:19:32,216
Let's see.
看看

2972
02:19:32,304 --> 02:19:34,585
So admin funny.

2973
02:19:36,466 --> 02:19:37,786
Login succeeded, but we still failed.
登录成功了 但还是失败了

2974
02:19:37,786 --> 02:19:39,799
Okay, so we do know the stuff that it wanted,
好的 我们清楚它需要什么

2975
02:19:40,146 --> 02:19:44,199
So if we did a bunch of A's, this is
所以如果输入一大串 A 会怎么样

2976
02:19:44,395 --> 02:19:45,155
I think this is
我觉得就是这样

2977
02:19:45,155 --> 02:19:46,473
you should all know this.
你们应该都懂这个

2978
02:19:47,416 --> 02:19:50,180
Bus error, core dumped, awesome.
总线错误 核心转储 真酷

2979
02:19:50,433 --> 02:19:53,220
Okay, so we exploited it.
好的 我们已经利用了

2980
02:19:53,253 --> 02:19:54,926
Now what do we wanna do?
现在该怎么办？

2981
02:19:55,480 --> 02:19:56,419
Or we haven't exploited it.
哦，我们还没利用它

2982
02:19:56,444 --> 02:19:58,861
We've proved that there's likely a vulnerability
我们已经证明这里很可能有漏洞

2983
02:19:58,861 --> 02:20:00,679
because we caused some weird stack behavior here.
因为我们这里引发了异常的栈行为

2984
02:20:04,463 --> 02:20:06,243
Wait, somebody says they didn't know tab syncs it.
等等 有人说不知道tab会同步？

2985
02:20:06,268 --> 02:20:08,125
Oh man, okay, I guess Rob was right.
哦 好吧 看来Rob说的对

2986
02:20:09,444 --> 02:20:10,490
I hate it when Rob's right.
我不喜欢Rob对的时候

2987
02:20:12,285 --> 02:20:14,966
Okay, so we are copying into
好的 我们在复制到

2988
02:20:14,966 --> 02:20:17,166
this is where I don't trust Ida, but okay
这里我不太信任 IDA 但就算了

2989
02:20:17,166 --> 02:20:18,413
this is our string copy.
这是我们的strcpy

2990
02:20:18,567 --> 02:20:19,967
So if we're using string copy
如果我们使用strcpy

2991
02:20:19,967 --> 02:20:20,806
what does that mean?
这意味着什么？

2992
02:20:23,573 --> 02:20:24,167
What was it?
什么？

2993
02:20:25,649 --> 02:20:27,870
Yeah, it doesn't, it implicitly checks.
对 它不直接 但会隐式检查

2994
02:20:27,870 --> 02:20:29,670
It means our payload can't have any null bytes
这意味着载荷不能包含空字节

2995
02:20:29,670 --> 02:20:32,750
which is a massive pain, right?
这真是个大麻烦 对吧？

2996
02:20:32,811 --> 02:20:34,432
So this is always, I think
所以 我认为

2997
02:20:35,932 --> 02:20:37,609
pwn college can do a lot of
pwn.college 做了很多

2998
02:20:37,650 --> 02:20:39,114
especially even in the challenges we're giving,
尤其是在我们提供的挑战中

2999
02:20:39,114 --> 02:20:42,556
a lot of hand-holding by using the read function
通过用read函数，降低了难度

3000
02:20:42,556 --> 02:20:44,217
which accepts any number of bytes.
它可以接受任意字节

3001
02:20:44,217 --> 02:20:48,319
And so it's really important on a real target to understand
所以 利用实际目标时，要明白这点

3002
02:20:48,319 --> 02:20:50,080
and take that next step and be like, okay
然后进行下一步时，要注意

3003
02:20:50,080 --> 02:20:53,437
but how is it reading in and what constraints is there, right?
它是如何读入数据的，有什么限制

3004
02:20:53,603 --> 02:20:55,403
Is it a scanf
它是用 scanf 吗？

3005
02:20:55,403 --> 02:20:59,166
which means no spaces and new lines and other things?
意味着 不能用空格、换行符这些东西？

3006
02:20:59,166 --> 02:21:03,246
Is it a strcpy of how it's getting passed around, which means...
是通过 strcpy 传递的吗 意味着……

3007
02:21:03,400 --> 02:21:05,690
strcpy will keep copying up to a null byte
strcpy 遇到空字节 会停止拷贝

3008
02:21:05,690 --> 02:21:07,439
which is going to be a pain for you.
这会给你带来麻烦

3009
02:21:08,346 --> 02:21:12,493
So yeah, this is definitely something to remember here.
所以 这个一定要记住

3010
02:21:14,454 --> 02:21:15,633
So then where are we going?
那接下来我们做什么

3011
02:21:20,137 --> 02:21:20,933
Yeah.
对

3012
02:21:22,426 --> 02:21:23,173
So...
所以……

3013
02:21:25,470 --> 02:21:28,956
Okay, so then what we're looking for is something like a win function.
我们找的是类似win函数的东西

3014
02:21:29,090 --> 02:21:31,503
That's our next intuition here.
这是我们的下一个想法

3015
02:21:31,856 --> 02:21:33,496
So the way I would look
我通常这么看

3016
02:21:33,546 --> 02:21:36,523
there's a nice handy dandy sub view.
有个很方便的子视图

3017
02:21:36,726 --> 02:21:39,953
I almost always run strings on the binaries.
我基本上都会用strings命令，过一下二进制文件

3018
02:21:39,979 --> 02:21:43,153
So it'd be hard here
所以这里会有点难

3019
02:21:43,153 --> 02:21:44,934
because there's like 15 different levels in here
因为这里有 15 个不同的级别

3020
02:21:44,934 --> 02:21:47,216
but strings would at least tell us all the strings
但strings命令能显示所有字符串

3021
02:21:47,216 --> 02:21:49,833
so we can look for like flag.
我们就能找到"flag"

3022
02:21:51,579 --> 02:21:53,973
Well, we actually need the next level's password.
这里我们需要的，其实是下一级的密码

3023
02:21:58,205 --> 02:22:00,446
Yeah, we want level two password.
对 我们要第二级的密码（口误，实际是第三关）

3024
02:22:04,300 --> 02:22:05,160
we do
确实需要

3025
02:22:10,873 --> 02:22:11,553
Where?
在哪？

3026
02:22:20,686 --> 02:22:21,800
Oh, perfect. Okay.
哦 太好了

3027
02:22:21,869 --> 02:22:23,006
Level two password.
第二关的密码

3028
02:22:23,908 --> 02:22:25,240
Where is it? Okay, yeah, great.
在哪？ 好的 太棒了

3029
02:22:25,265 --> 02:22:25,913
So I don't...
我不会...

3030
02:22:27,286 --> 02:22:28,866
I'm like terrible at IDA.
我对 IDA 一窍不通

3031
02:22:28,892 --> 02:22:31,913
so this is very weird to... People think that I'm actually good at this.
就很奇怪，人们竟然都认为我擅长IDA

3032
02:22:32,573 --> 02:22:33,153
Okay.
好的

3033
02:22:33,153 --> 02:22:34,074
So level two password
所以 第2关密码

3034
02:22:34,074 --> 02:22:35,272
we found out where it prints it.
我们找到了打印它的位置

3035
02:22:35,297 --> 02:22:35,852
Awesome.
太棒了

3036
02:22:36,275 --> 02:22:37,506
We double click that.
我们双击它

3037
02:22:37,556 --> 02:22:38,716
That takes us to
这会带我们进入...

3038
02:22:38,796 --> 02:22:40,642
now we're in the pseudocode view.
现在我们在伪代码视图

3039
02:22:40,777 --> 02:22:41,978
We're in read-only data.
我们在查看只读数据

3040
02:22:41,978 --> 02:22:45,456
So this is data that's in the binary at this address.
这些数据在二进制文件的这个地址

3041
02:22:46,220 --> 02:22:47,521
I didn't do checksec on it
我没有对它执行checksec

3042
02:22:47,521 --> 02:22:49,882
but I assume that this is gonna be non-PIE.
但我觉得这应该是非 PIE 的

3043
02:22:49,882 --> 02:22:51,380
So these will be at fixed locations.
所以这些数据在固定地址

3044
02:22:53,280 --> 02:22:55,606
And then level two password.
然后是第二关密码

3045
02:22:55,740 --> 02:23:00,473
So then I'm gonna hit the X button to do, Cross references.
然后我按 X 键进行交叉引用

3046
02:23:00,583 --> 02:23:02,765
So this shows you what other parts of the code
这会显示代码的其他部分

3047
02:23:02,765 --> 02:23:05,467
that this is analyzed that reference this specific thing.
哪些地方引用了这个特定内容

3048
02:23:06,627 --> 02:23:07,408
You have to be very careful.
你得注意

3049
02:23:07,408 --> 02:23:08,569
This is not the ground truth.
这并非完全准确

3050
02:23:08,569 --> 02:23:10,791
This only does like a direct reference.
这只能显示直接引用

3051
02:23:10,791 --> 02:23:13,873
So when the code like says, hey, load that address there.
当代码说 加载那个地址时，才会显示出来

3052
02:23:13,873 --> 02:23:17,146
But if it's part of like an array
但如果它是数组的一部分

3053
02:23:17,540 --> 02:23:20,338
if you X ref like the third or fourth array element
如果你查看第三或第四个数组元素的交叉引用

3054
02:23:20,338 --> 02:23:22,526
but it only accesses it over an iterator
但只通过迭代器访问它

3055
02:23:22,580 --> 02:23:25,862
it will not like the decompiler can't know that it actually accesses it.
反编译器不知道代码实际上访问了它

3056
02:23:25,862 --> 02:23:28,003
So this is only like direct access.
所以IDA只记录直接访问

3057
02:23:28,003 --> 02:23:28,966
So you do have to remember that.
所以你得记住这点

3058
02:23:29,779 --> 02:23:30,240
Okay.
好的

3059
02:23:32,632 --> 02:23:34,052
So now I double clicked on that.
现在我双击了它

3060
02:23:34,052 --> 02:23:38,606
That takes us now to the IDA view of where we are in here.
这带我们进入了 IDA 视图 显示我们当前的位置

3061
02:23:38,835 --> 02:23:40,759
And then I'm going to hit tab to decompile it.
然后我按 Tab 键来反编译

3062
02:23:47,519 --> 02:23:48,950
We want the level three password.
我们要的是第三关密码

3063
02:23:50,410 --> 02:23:52,279
All right.
好的

3064
02:23:53,876 --> 02:23:54,349
Okay.
好的

3065
02:23:54,423 --> 02:23:56,551
Well, we have level one password, level two.
我们已经有了第一级和第二级的密码

3066
02:23:57,076 --> 02:23:59,443
So I hit slash.
我按了 /

3067
02:23:59,894 --> 02:24:02,280
To then search, you can see the slash at the bottom.
来搜索 你可以看到底部的斜杠

3068
02:24:02,846 --> 02:24:04,633
And I'm going to type in level.
我输入“级别”

3069
02:24:06,733 --> 02:24:09,633
what if I really remind by telling you could do ctrl F
也可以按ctrl+f

3070
02:24:09,710 --> 02:24:10,813
That was going to be my next one.
这是我的下一步

3071
02:24:11,046 --> 02:24:17,013
I think slash, though, does like incremental search, just like in less.
我觉得 / 可以进行增量搜索 就像在 less 里一样

3072
02:24:21,706 --> 02:24:22,506
Yeah, there we go.
好

3073
02:24:22,826 --> 02:24:23,187
Okay.
好的

3074
02:24:24,773 --> 02:24:25,866
Level.
级别

3075
02:24:26,488 --> 02:24:27,129
We want the level.
我们需要关卡

3076
02:24:27,129 --> 02:24:29,412
Wait, what is this Level 2 not synchronize?
等等 这个关卡2不同步是什么？

3077
02:24:32,759 --> 02:24:33,958
Level three password.
关卡3密码

3078
02:24:33,958 --> 02:24:34,679
There we go, boom.
成了 搞定

3079
02:24:40,701 --> 02:24:41,722
So we do have our target.
目标找到了

3080
02:24:41,722 --> 02:24:42,596
Okay, great.
好的 太好了

3081
02:24:43,002 --> 02:24:45,283
So we have our target is level three password.
目标是level3password

3082
02:24:45,983 --> 02:24:47,816
Oh no, I don't have it set up.
哦不 我还没有设置好

3083
02:24:47,841 --> 02:24:48,616
Usually,
通常

3084
02:24:49,534 --> 02:24:51,534
well, I guess I go
嗯 我得

3085
02:24:52,507 --> 02:24:54,927
I go back and forth on if I have the addresses on here
我会反复检查这里是否有地址

3086
02:24:54,927 --> 02:24:56,407
but you can see the address is here.
不过你能看到地址在这儿

3087
02:24:56,407 --> 02:24:58,540
It's 401178.
是 401178

3088
02:24:58,660 --> 02:25:00,467
So we want to overwrite.
所以我们需要覆盖它

3089
02:25:00,727 --> 02:25:03,160
And, okay, so we have our target here.
好的 目标就在这里

3090
02:25:05,239 --> 02:25:07,073
Okay, this is where I should start.
好的 从这里开始

3091
02:25:13,720 --> 02:25:15,720
Okay, this is where I'm just going to take notes here.
好的 这里开始我得做笔记了

3092
02:25:15,998 --> 02:25:22,593
Let's do 401178.
我们输入 401178

3093
02:25:24,646 --> 02:25:25,146
Okay.
好的

3094
02:25:26,681 --> 02:25:28,902
40, well, we already know the password
40 哦，已经看到密码了

3095
02:25:28,902 --> 02:25:29,922
but this is cheating.
但这样是作弊

3096
02:25:29,922 --> 02:25:30,626
Don't look at the password.
不要看密码

3097
02:25:31,582 --> 02:25:35,286
um okay four zero one one seven eight
嗯 好的 401178

3098
02:25:35,485 --> 02:25:36,293
and now we need to go back
现在我们需要回去

3099
02:25:36,318 --> 02:25:37,258
so i'm going to hit
我要点

3100
02:25:37,944 --> 02:25:40,737
this is the other thing i really don't like about ida is like
我对 IDA 的另一个不满是

3101
02:25:40,844 --> 02:25:43,751
the ida view and the pseudocode view the backs are different
ida视图和伪代码视图的返回功能不同

3102
02:25:43,751 --> 02:25:46,933
and so what i mentally wanted to do was to go back
我想要回到

3103
02:25:46,933 --> 02:25:49,345
to that original decompilation view that we were looking at
之前看的那个原始的反编译视图

3104
02:25:49,390 --> 02:25:53,466
of the level two of the stack overflow function um
第二关的stack_overflow函数的反编译

3105
02:25:53,818 --> 02:25:56,882
but If I kept pressing back here I don't know that I would get to that
但如果一直在这儿后退，我不知道能不能回到那里

3106
02:25:56,882 --> 02:25:58,823
because it's a different backwards and forwards thing.
因为这俩像在不同的前进后退序列中

3107
02:25:58,823 --> 02:26:01,925
This is why your brain gets melted by the tools that you use.
这就是为什么 越用这个工具，大脑越乱

3108
02:26:01,925 --> 02:26:03,026
Like nobody should think about that.
谁都不应该考虑这些

3109
02:26:03,026 --> 02:26:05,569
You should just be able to go back and forward just like a web browser.
你应该像在网页浏览器里一样，前进后退

3110
02:26:05,636 --> 02:26:07,028
Anyways, okay.
好了 算了

3111
02:26:08,598 --> 02:26:09,905
Nope, that was the wrong one.
不对 这个错了

3112
02:26:09,930 --> 02:26:11,349
That will let us down.
那样会让我们失望

3113
02:26:11,843 --> 02:26:12,910
Stack overflow.
栈溢出

3114
02:26:13,673 --> 02:26:14,550
Great, okay.
好的 没问题

3115
02:26:14,916 --> 02:26:17,055
And we want, so we're in verify user.
我们在verify_user中

3116
02:26:17,055 --> 02:26:19,036
So now let's look at the binary code.
现在看看二进制代码

3117
02:26:19,343 --> 02:26:22,238
So, okay, the way this is working is
所以 是这样的

3118
02:26:25,780 --> 02:26:26,926
So 30
30

3119
02:26:26,951 --> 02:26:27,794
if I remember correctly
如果我没记错的话

3120
02:26:27,794 --> 02:26:29,108
when it does var underscore 30
在 var_30 中

3121
02:26:29,133 --> 02:26:30,740
this means 30 hex.
这个 30 是十六进制的

3122
02:26:31,006 --> 02:26:31,614
Is that right?
对吗？

3123
02:26:31,655 --> 02:26:36,690
So store pair 29 and 30 at the stack pointer
所以 将 X29 和 X30 存储到SP指向的栈地址中

3124
02:26:36,714 --> 02:26:37,988
first decrement
先减小SP

3125
02:26:38,037 --> 02:26:39,501
or for increment the stack.
或增加SP

3126
02:26:39,577 --> 02:26:40,355
That doesn't make sense.
这听起来不对

3127
02:26:40,438 --> 02:26:41,378
Should be decrement, right?
应该是减小 对吧？

3128
02:26:41,378 --> 02:26:42,488
So it should be minus 30.
所以_30应该是-30

3129
02:26:45,296 --> 02:26:46,740
I actually find IDA very poor.
我觉得 IDA 很不好用

3130
02:26:46,740 --> 02:26:49,160
Like I actually like objdump, but yes.
我实际更喜欢 objdump

3131
02:26:49,160 --> 02:26:51,443
Okay, so minus 30 hex is...
好的 -0x30是

3132
02:26:53,536 --> 02:26:54,823
I think if you double click this
如果你双击这个

3133
02:26:54,848 --> 02:26:56,050
it will show you,
它会显示出来

3134
02:26:56,390 --> 02:27:00,496
oh yeah, var 30.
哦 对 var_30

3135
02:27:00,830 --> 02:27:02,810
Yeah, so this is minus
对 这是减号

3136
02:27:03,076 --> 02:27:04,769
this actually does mean minus right on the left.
左边这个确实是减号

3137
02:27:04,837 --> 02:27:07,330
This is the view of the stack layout.
这是栈布局的视图

3138
02:27:07,583 --> 02:27:11,579
When you double click on a variable in the disassembly view
当你在反汇编视图中双击变量时

3139
02:27:11,579 --> 02:27:12,436
takes you to this.
会带你到这里

3140
02:27:13,222 --> 02:27:15,342
And then if I escape
然后按 Esc 键

3141
02:27:15,400 --> 02:27:16,626
does bring me back here.
会带我回来

3142
02:27:16,806 --> 02:27:20,326
So, okay, so decrement the stack pointer by 30 hex.
所以 把栈指针减去 0x30

3143
02:27:20,583 --> 02:27:25,920
and then copy at that location 29 and 30, 30 there
然后在这里保存一下x29和x30

3144
02:27:27,289 --> 02:27:29,744
set this all up, and then,
设置好后

3145
02:27:30,662 --> 02:27:31,984
yeah, load pair,
LDP

3146
02:27:31,984 --> 02:27:36,853
again, exactly the same thing, stack pointer plus 30 minus 30.
栈指针加 30 减 30

3147
02:27:37,480 --> 02:27:40,580
Okay, so we should be able to...
好的 我们应该能……

3148
02:27:42,828 --> 02:27:46,016
Okay, I wanna do this in a very silly way.
好的 我打算用一种非常蠢的办法来做

3149
02:27:52,429 --> 02:27:54,349
I want to do like a whole PwnTools thing.
我想完全用 PwnTools 实现

3150
02:27:54,950 --> 02:27:58,535
You guys will be okay if I just do really crappy code, right?
如果我只写一些烂代码 大家没问题吧？

3151
02:28:02,420 --> 02:28:04,669
The difference is if you choose to do it.
区别在于你们是否愿意去做

3152
02:28:06,016 --> 02:28:06,381
Okay.
好的

3153
02:28:09,236 --> 02:28:12,756
Oh no, there's going to be a pain because of the bytes, isn't it?
哦不 字节问题会很麻烦 对吧？

3154
02:28:13,324 --> 02:28:14,365
God, I hate Python.
天啊 我最烦 Python 了

3155
02:28:14,365 --> 02:28:15,456
Why do people do this?
大家为啥要这么做？

3156
02:28:16,709 --> 02:28:17,093
fine
好吧

3157
02:28:18,399 --> 02:28:20,772
okay where where i refuse
好吧 但我拒绝

3158
02:28:21,393 --> 02:28:21,692
okay
好的

3159
02:28:28,897 --> 02:28:29,443
okay
行

3160
02:28:29,810 --> 02:28:31,490
echo b
显示 b

3161
02:28:31,583 --> 02:28:32,303
no e
不对，e

3162
02:28:33,840 --> 02:28:35,233
okay we want
我们希望溢出的

3163
02:28:36,040 --> 02:28:38,028
so our buffer is
目标缓冲区是

3164
02:28:38,052 --> 02:28:39,206
if we look at this
如果我们看一下这个

3165
02:28:43,793 --> 02:28:51,772
our buffer is on v3 and v...
我们的缓冲区在 v3

3166
02:28:55,410 --> 02:29:00,803
Okay, so this is the first strcpy is admin.
好的 第一个 strcpy 拷贝的是 admin

3167
02:29:00,995 --> 02:29:02,203
We want the second.
我们需要第二个

3168
02:29:02,536 --> 02:29:03,796
Wait, where's the other strcpy?
等等 另一个 strcpy 呢？

3169
02:29:04,670 --> 02:29:05,576
Oh, is this an...
哦 这是个...

3170
02:29:08,623 --> 02:29:10,890
It's an inline strcpy
这是个内联的 strcpy

3171
02:29:10,959 --> 02:29:12,076
because it's a constant value.
因为它是一个常量

3172
02:29:12,223 --> 02:29:14,740
Okay, don't want to reverse that.
好的 我们可不想逆向它

3173
02:29:16,394 --> 02:29:19,155
Oh, you can see the admin and then the n
哦 你可以看到 admin 里的 n

3174
02:29:19,155 --> 02:29:20,555
it has to get the N in there.
得把 n 放进去

3175
02:29:21,408 --> 02:29:22,701
That's what this one is.
就是这个

3176
02:29:23,596 --> 02:29:24,876
Yeah, because it's doing four bytes.
是的 因为它一次处理四个字节

3177
02:29:24,876 --> 02:29:28,228
It's doing the A-D-M-I-N and then the N.
它在处理 A-D-M-I 再加上 N

3178
02:29:29,418 --> 02:29:33,698
Okay, so strcpy the first argument is the destination, right?
好的 strcpy 的第一个参数是目标 对吧？

3179
02:29:33,723 --> 02:29:34,631
Stack pointer.
栈指针

3180
02:29:35,578 --> 02:29:36,540
Okay, I hate this.
好吧 我真讨厌这个

3181
02:29:36,540 --> 02:29:36,760
Okay.
好的

3182
02:29:38,680 --> 02:29:39,689
So stack.
栈

3183
02:29:40,501 --> 02:29:41,541
So this is eight.
这有 8 个

3184
02:29:41,541 --> 02:29:42,730
Let's do...
我们来试试...

3185
02:29:45,668 --> 02:29:47,596
How many A's do we all think we need?
大家觉得需要多少个 A？

3186
02:29:52,310 --> 02:29:53,077
20个？

3187
02:29:58,617 --> 02:29:59,310
28个？

3188
02:30:05,556 --> 02:30:05,983
Yeah.
嗯

3189
02:30:07,332 --> 02:30:11,485
So I like to do that plus B.
我喜欢这样做 加上 B

3190
02:30:11,540 --> 02:30:12,512
So I just like to I don't know.
我喜欢

3191
02:30:12,538 --> 02:30:16,301
You can use, I'm sure you all are very good using cyclic call
你们可以用 我相信你们都很擅长用cyclic

3192
02:30:16,301 --> 02:30:18,141
and doing all that to find out that stuff.  I don't know.
来弄清楚需要几个字节来覆盖缓冲区

3193
02:30:18,141 --> 02:30:19,391
That's all new things and stuff.
这些都是新事物

3194
02:30:19,681 --> 02:30:23,658
For me, I like a good old fashioned, just print out the stuff.
我个人更喜欢传统的方法 直接把东西打印出来

3195
02:30:26,502 --> 02:30:27,122
Bus error.
总线错误

3196
02:30:27,122 --> 02:30:27,976
Okay, great.
好的 太棒了

3197
02:30:28,644 --> 02:30:29,743
We can GDB.
我们可以用 GDB 来调试

3198
02:30:31,523 --> 02:30:33,944
Again, I can do this because this is an ARM system.
同样 我能这么做是因为这是个 ARM 系统

3199
02:30:33,944 --> 02:30:35,736
You will not have that funny, that...
此时这个funny没啥用

3200
02:30:36,754 --> 02:30:37,536
That use.
那种用法

3201
02:30:41,203 --> 02:30:41,922
Incorrect.
错了

3202
02:30:43,765 --> 02:30:45,323
These are A's, not B's.
这些是 A 不是 B

3203
02:30:46,990 --> 02:30:47,471
Yeah.
对

3204
02:30:49,135 --> 02:30:50,356
Hire good people.
招好人

3205
02:31:06,831 --> 02:31:08,763
It's probably the point where we should debug this.
估计得调试一下

3206
02:31:15,520 --> 02:31:18,002
Just randomly trying stuff in front of people is good.
当着大家的面随机试试也挺好

3207
02:31:22,386 --> 02:31:23,740
I think it's 8
我觉得是8

3208
02:31:26,930 --> 02:31:30,470
Oh, duh, because there's two 8-byte buffers.
哦 对了 有两个 8 字节的缓冲区

3209
02:31:40,676 --> 02:31:42,303
So it wasn't eight, it was 16.
所以不是 8 是 16

3210
02:31:45,360 --> 02:31:46,133
Okay.
行

3211
02:31:50,604 --> 02:31:52,126
Yep, okay, so great.
好的 太棒了

3212
02:31:52,126 --> 02:31:52,806
Now we got there
我们现在到了

3213
02:31:52,806 --> 02:31:54,127
and now we, let's see
现在我们来看看

3214
02:31:54,127 --> 02:31:55,260
where do we want to go?
我们想去哪儿？

3215
02:31:55,573 --> 02:32:10,130
We want to go slash X. I put it here, 78, 11, 40.
我们要去 \x78, \x11, \x40

3216
02:32:10,403 --> 02:32:13,923
I shouldn't probably have to change the 40. I'm just going to do this.
我应该不需要改 40， 这样就行

3217
02:32:26,612 --> 02:32:27,750
Look at that.
看看这个

3218
02:32:27,827 --> 02:32:29,092
And why are we looping forever?
我们为什么一直在循环？

3219
02:32:31,652 --> 02:32:32,250
Exactly.
对

3220
02:32:32,250 --> 02:32:33,451
So let's do
那我们来

3221
02:32:34,750 --> 02:32:37,016
what's 8 plus C.
8加4是多少？ C 。

3222
02:32:37,683 --> 02:32:40,010
Oh, I did that.Can you believe that?  I did.
哦 我成功了 你敢信？我做到了

3223
02:32:40,796 --> 02:32:41,876
Hex plus four.
十六进制的加四

3224
02:32:42,192 --> 02:32:42,656
All right.
好的

3225
02:32:42,749 --> 02:32:43,191
So look at that.
看 就是这个

3226
02:32:43,216 --> 02:32:43,730
We did that.
我们做到了

3227
02:32:44,237 --> 02:32:44,918
You guys all did it.
你们都做到了

3228
02:32:44,918 --> 02:32:45,946
You can do it on the homework.
你们在作业中也能做到

3229
02:32:45,971 --> 02:32:48,246
It'll open in 50 minutes.
50 分钟后会开放

3230
02:32:48,367 --> 02:32:49,360
So good luck.
祝你们好运

