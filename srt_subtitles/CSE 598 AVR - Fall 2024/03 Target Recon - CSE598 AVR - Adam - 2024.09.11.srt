1
00:00:00,069 --> 00:00:00,873
Hey, everyone.
大家好

2
00:00:01,109 --> 00:00:03,093
Sorry, starting slightly late.
抱歉 稍微迟到了

3
00:00:04,073 --> 00:00:06,451
Had to run from one meeting to the other.
我得从一个会赶到另一个会

4
00:00:06,451 --> 00:00:08,053
Let me get on Twitch on my laptop
我在这台笔记本上登录 Twitch

5
00:00:08,078 --> 00:00:12,340
so I can see all the great comments that are going to come in.
这样我就能看到大家的精彩评论了

6
00:00:18,575 --> 00:00:19,216
I hate Twitch.
我讨厌 Twitch

7
00:00:19,216 --> 00:00:19,756
Okay.
好的

8
00:00:19,756 --> 00:00:20,976
pwn college.
pwn学院

9
00:00:20,976 --> 00:00:21,636
pwn college.
pwn学院

10
00:00:24,037 --> 00:00:24,317
All right.
好的

11
00:00:24,317 --> 00:00:24,858
We are live.
我们直播开始啦

12
00:00:26,618 --> 00:00:26,982
Cool.
酷！

13
00:00:27,122 --> 00:00:27,576
All right.
好的

14
00:00:28,616 --> 00:00:29,296
So...
所以……

15
00:00:29,991 --> 00:00:31,692
Who's finished all of the ARM-ROP challenges?
谁完成了全部的ARM-ROP挑战？

16
00:00:36,117 --> 00:00:37,324
No, none of you?
没有人完成吗？

17
00:00:37,854 --> 00:00:38,535
They can't see.
他们看不见

18
00:00:38,535 --> 00:00:39,224
Two of you.
两个人

19
00:00:39,995 --> 00:00:41,604
Is that actually true, the two of you?
真的只有你们两个完成了？

20
00:00:46,939 --> 00:00:47,443
What?
什么？

21
00:00:51,841 --> 00:00:52,141
I don't know.
我不知道

22
00:00:52,141 --> 00:00:53,763
It says only one solve right here.
这里写着只有一个人解决了

23
00:00:53,882 --> 00:00:55,823
So it sounds like not all of you have done it.
看来你们两个不是都完成了

24
00:00:56,523 --> 00:00:57,140
Some of you?
有些人完成了吗？

25
00:00:57,736 --> 00:00:59,416
I've done a bunch.
我做了不少

26
00:00:59,500 --> 00:01:01,276
Yeah, but all of them.
对 但我说的是全部

27
00:01:01,441 --> 00:01:02,490
Is a bunch all?
很多是全部吗？

28
00:01:04,602 --> 00:01:06,293
That's what I was asking.
我就是想问这个

29
00:01:09,140 --> 00:01:10,564
I create the challenges.
我负责设计挑战

30
00:01:10,564 --> 00:01:12,040
I do not need to solve them.
我不需要解决它们

31
00:01:15,653 --> 00:01:16,041
Cool.
行

32
00:01:16,066 --> 00:01:19,546
Okay, so what we're going to do for 3-1-a, oh
好的 接下来我们来看看 3-1-a

33
00:01:19,608 --> 00:01:22,346
so there are some questions about the static binary ROP.
有人问静态二进制 ROP

34
00:01:23,462 --> 00:01:25,724
This is, there's fundamentally, I think
我觉得

35
00:01:25,724 --> 00:01:27,546
no unintended ways of solving this.
没有其他意料外的解法

36
00:01:27,626 --> 00:01:29,167
So you can solve stat
你可以

37
00:01:29,167 --> 00:01:32,806
like the idea is you have all of libc statically linked into your binary.
二进制文件中静态链接了整个 libc

38
00:01:33,031 --> 00:01:35,917
There's absolutely, I didn't even bother looking at is this solvable
我都不用看，这题绝对能解

39
00:01:35,944 --> 00:01:37,974
because it's clearly solvable.
因为很明显是可解的

40
00:01:37,974 --> 00:01:39,376
There's like so many gadgets in there
里面有很多 gadgets

41
00:01:39,376 --> 00:01:42,199
and there's so many functions in libc that you can reuse.
而且 libc 中有许多可以重用的函数

42
00:01:42,199 --> 00:01:45,021
So you have like a ret to libc style thing
当你有 ret2libc 这样的方法

43
00:01:45,021 --> 00:01:47,670
that's absolutely totally awesome.
那真是太爽了

44
00:01:47,870 --> 00:01:49,210
So don't feel like
别觉得

45
00:01:49,705 --> 00:01:50,583
like as long as
只要

46
00:01:51,291 --> 00:01:54,143
there's not a way to completely bypass the challenge and just get a flag.
没有办法绕过题目，拿到flag

47
00:01:54,412 --> 00:01:57,025
That would be the only unintended solution for this one.
那将是唯一的意外解法

48
00:01:57,072 --> 00:01:59,518
There's literally so many ways you could pop that challenge.
除此之外，有许多方法能解决这题

49
00:02:00,013 --> 00:02:05,894
And then, so what we'll do with level-3-1-a-gcc
接下来 我们来做一下 3-1-a-gcc

50
00:02:05,894 --> 00:02:07,599
which is now very clear that it's hard
很明显难度很大

51
00:02:07,894 --> 00:02:09,206
because it says it in the name.
因为名子已经说明了

52
00:02:09,928 --> 00:02:12,075
What we'll do here is I will relax.
我们这里会放松一些

53
00:02:12,254 --> 00:02:14,876
So I extended this a week so you have another week to work on this
我把这个延了一周 你们有更多时间来完成它

54
00:02:14,876 --> 00:02:16,563
because I thought it was actually great of like
我觉得这样挺好

55
00:02:16,956 --> 00:02:19,609
Seeing these challenges that are accidentally hard
这些题不小心弄的挺难

56
00:02:19,793 --> 00:02:21,636
like I didn't intend for them to be hard
我原本没打算让它们这么难

57
00:02:21,774 --> 00:02:23,869
but it turns out they're hard but not impossible.
但它们确实很难 不过并非不可能

58
00:02:23,976 --> 00:02:26,276
So you have to actually learn things by applying them
所以你们需要通过实践来学习

59
00:02:26,276 --> 00:02:29,322
and this happens all the time when finding vulnerabilities in real stuff.
在真实系统中找漏洞时  这种情况经常出现

60
00:02:29,419 --> 00:02:33,699
Guess what? There's not somebody that conveniently puts little gadgets in for you to use.
没人会为你准备好现成的gadget

61
00:02:34,522 --> 00:02:36,422
You have whatever is there.
你得有什么就用什么

62
00:02:36,883 --> 00:02:39,265
So I extended it a week so you can work on it more.
所以我把期限延长了一周 给你们更多时间研究

63
00:02:39,265 --> 00:02:40,903
The other thing I'm going to do
另外 我会

64
00:02:40,936 --> 00:02:47,083
is relax the academic integrity policy for this challenge.
放宽题目的学术诚信要求

65
00:02:47,316 --> 00:02:48,555
So feel free.
所以不要拘束

66
00:02:48,555 --> 00:02:54,351
I'll also let Zolotol on the Discord act as an unofficial TA
我还会让 Discord 上的 Zolotol 作为非正式助教

67
00:02:54,376 --> 00:02:56,178
so he can drop hints
给大家提供提示

68
00:02:56,178 --> 00:02:59,363
and guide people as breadcrumbs through this
引导大家

69
00:03:02,070 --> 00:03:05,076
so that that way you can kind of we'll solve it together.
算是我们一起来解决它

70
00:03:05,260 --> 00:03:06,540
And then as the outcome of this
这样最终结果是

71
00:03:06,540 --> 00:03:08,386
what I'd like is for you all to discuss.
希望你们能一起讨论

72
00:03:09,326 --> 00:03:10,313
Once we've solved it
等我们解决了题目

73
00:03:10,377 --> 00:03:12,366
what's a good hint that we can put in the description
找到一个能放到描述里的好的提示

74
00:03:12,393 --> 00:03:14,281
to help guide people to the solution
能引导大家找到解题方法

75
00:03:14,281 --> 00:03:17,260
but not necessarily give things away?
但又不至于直接透露答案

76
00:03:17,538 --> 00:03:20,580
I think for my own hint of talking to Zolotol, it's...
我和 Zolotol聊时，的提示是

77
00:03:20,605 --> 00:03:21,713
Is everybody pronouncing that right?
读对了吗？

78
00:03:22,988 --> 00:03:24,046
Zolotol.
Zolotol

79
00:03:24,128 --> 00:03:25,146
Okay, that was just from memory.
好的 这完全是凭记忆的

80
00:03:26,573 --> 00:03:29,693
Basically, if you can pwn this static binary ROP
如果你能攻破这个静态二进制 ROP

81
00:03:29,693 --> 00:03:32,060
you can definitely pwn this.
你肯定也能攻破

82
00:03:32,100 --> 00:03:34,393
So if you think about how can I...
所以你想想我怎么能

83
00:03:35,470 --> 00:03:38,950
get information like I have in static, the static binary ROP.
获取类似静态二进制 ROP 中的信息

84
00:03:38,950 --> 00:03:40,691
You have libc built into the binary
静态二进制文件中内置了 libc

85
00:03:40,691 --> 00:03:41,989
so you know where all the gadgets are.
所以你知道所有 gadgets 的位置

86
00:03:42,411 --> 00:03:44,352
But if you can find out where libc is
但如果你能找到 libc 的地址

87
00:03:44,352 --> 00:03:46,583
you can also use all the stuff that's in libc.
你也可以使用 libc 中的所有功能

88
00:03:46,632 --> 00:03:49,372
So I think from there you can start with that.
所以你可以从这里开始

89
00:03:49,372 --> 00:03:50,393
Let's chat about it online.
我们在线上讨论吧

90
00:03:50,393 --> 00:03:51,372
We can talk about it there.
我们可以在那里讨论

91
00:03:51,372 --> 00:03:53,934
I'm confident that as a group you will find a path forward.
我相信 作为团队 你们会找到前进的方向

92
00:03:54,818 --> 00:03:55,578
Does that sound good?
这听起来怎么样？

93
00:03:55,994 --> 00:03:57,234
No riots on the
这边没有抗议吧

94
00:03:57,474 --> 00:03:59,435
they're threatening to riot on Twitch
他们在 Twitch 上扬言要抗议

95
00:03:59,435 --> 00:04:02,256
but I can't tell if that's one of you in class
我不知道有没有教室里的人

96
00:04:02,256 --> 00:04:05,240
and this was your secret way of... voicing your opinion.
这是你们秘密表达意见的方式

97
00:04:08,860 --> 00:04:09,282
No, no, no.
不 不 不

98
00:04:09,282 --> 00:04:10,143
I'm not touching the binary.
我不碰那个二进制

99
00:04:10,143 --> 00:04:10,586
It's salt.
它是

100
00:04:10,626 --> 00:04:12,633
So the idea is solve it.
所以关键是，要解决它

101
00:04:12,686 --> 00:04:14,786
And it doesn't have to be the one way.
不一定只有一种方法

102
00:04:14,786 --> 00:04:15,746
I'm actually, as I was talking
事实上 在我说的时候

103
00:04:15,746 --> 00:04:17,399
I think there's multiple ways of approaching it.
我觉得有多种方法可以解决

104
00:04:17,906 --> 00:04:20,286
I think the general approach that Zolotol took
我觉得 Zolotol 用的方法

105
00:04:20,311 --> 00:04:22,299
is one that you can apply as well.
你也可以试试

106
00:04:25,771 --> 00:04:28,452
So yeah, but no, we're not relaxing anything.
是的，不过 我们不会放松要求

107
00:04:31,134 --> 00:04:31,544
Cool.
好的

108
00:04:31,837 --> 00:04:32,154
Okay.
行

109
00:04:35,777 --> 00:04:39,889
Okay, the next thing we're going to do, so we are, that hint sucks.
好吧 接下来我们要做的 这个提示真烂

110
00:04:39,889 --> 00:04:41,310
Leaking libc is the hard part.
泄露 libc 是最难的

111
00:04:41,310 --> 00:04:41,783
Is it though?
是吗？

112
00:04:42,423 --> 00:04:42,831
I don't know.
我不知道

113
00:04:42,831 --> 00:04:44,050
People can do it. is it hard?
有人能做到。 难吗？

114
00:04:48,031 --> 00:04:48,613
Yeah, see?
对吧？

115
00:04:48,646 --> 00:04:50,300
Anyways, you can figure it out.
总之 你能想出来的

116
00:04:50,736 --> 00:04:52,989
You strong apes strong together.
猩猩们，团结就是力量（猩球崛起）

117
00:04:53,976 --> 00:04:55,072
You can do it.
你们能做到

118
00:04:55,072 --> 00:04:56,574
I guarantee it.
我保证

119
00:04:58,949 --> 00:05:01,375
And actually, honestly, this is a pretty good...
说实话 这相当不错...

120
00:05:04,120 --> 00:05:06,461
simulation of what it's like working on a team
模拟了团队合作的感觉

121
00:05:06,461 --> 00:05:07,846
when you're trying to exploit something.
当你试图利用某些东西时

122
00:05:09,283 --> 00:05:12,874
Feel free, completely talk about hard level-3-1-a-gcc.
随意些 聊聊 hard-3-1-a-gcc

123
00:05:13,586 --> 00:05:18,250
We'll use the applied vulnerability research channel.
我们用应用漏洞研究频道交流

124
00:05:18,250 --> 00:05:19,951
You don't have to do it in the class one
你不必在第一节课上完成

125
00:05:19,951 --> 00:05:22,516
because there's other people online that are also struggling with this.
因为网上也有其他人卡在这里

126
00:05:23,452 --> 00:05:25,250
In the applied vulnerability research channel
在应用漏洞研究频道

127
00:05:25,310 --> 00:05:26,555
all bets are off on that one.
打开了所有限制

128
00:05:26,555 --> 00:05:28,883
Feel free, brainstorm ideas.
随意些 集思广益

129
00:05:28,956 --> 00:05:31,272
Let's collaboratively work towards something there.
让我们在那里合作 共同完成任务

130
00:05:31,297 --> 00:05:33,053
I think together you can figure it out.
我相信，一起能找到解决办法

131
00:05:33,078 --> 00:05:33,978
I am confident.
我有信心

132
00:05:34,906 --> 00:05:36,693
Okay, that's great.
好的 太好了

133
00:05:36,851 --> 00:05:39,031
And then the next thing I was going to do, what I realized
接下来我打算做的是 我意识到

134
00:05:39,031 --> 00:05:40,673
so it's taking a little bit
这需要一点时间

135
00:05:40,673 --> 00:05:44,056
so to update you on where we are infrastructure-wise
更新一下我们的基础设施情况

136
00:05:44,090 --> 00:05:49,203
so I want you to be able to run and hack stuff without needing a Mac.
我希望大家能在不需要 Mac 的情况下，对mac进行黑客行为

137
00:05:49,240 --> 00:05:55,444
It turns out the state of emulation and virtualization of Mac hardware on non-Mac hardware
结果发现，目前针对在非mac硬件下的，mac硬件仿真

138
00:05:55,444 --> 00:05:56,906
is not what I thought it was.
并不如我想象的那样

139
00:05:56,906 --> 00:06:01,660
There was some nice proof of concept GitHub repos out there that you can find
github上有一些不错的相关概念验证项目

140
00:06:01,889 --> 00:06:06,961
but these... don't work well when you deviate from what they do.
但当你和给定步骤不一致时，效果就不太好

141
00:06:06,961 --> 00:06:10,521
They basically have gotten a Mac OS kernel to boot up and run Bash
基本上，他们会启动一个 Mac OS 内核并运行 Bash

142
00:06:10,961 --> 00:06:12,442
but when you try to run anything else
但当你尝试运行

143
00:06:12,442 --> 00:06:14,103
that's not what they already have installed.
他们没安装的程序时

144
00:06:14,103 --> 00:06:16,644
Like, I'm sure you guys want to compile things with Clang
比如说 你们肯定想用 Clang 编译程序

145
00:06:16,644 --> 00:06:18,064
and debug things with LLDB.
用 LLDB 调试

146
00:06:19,141 --> 00:06:21,221
It causes a kernel infinite loop
这会导致内核无限循环

147
00:06:21,247 --> 00:06:23,324
and I'm not going to debug why this is happening
我不会去调试为什么会发生这种情况

148
00:06:23,324 --> 00:06:24,404
because that would be insane
因为这会让人疯掉

149
00:06:24,404 --> 00:06:25,665
because even if you fix that one thing
因为即使你解决了这个问题

150
00:06:25,665 --> 00:06:27,183
there'll be a thousand other things.
还会有成千上万的其他问题

151
00:06:27,326 --> 00:06:28,446
So the...
所以 这...

152
00:06:30,666 --> 00:06:32,470
What's going on there?
那边出了什么事？

153
00:06:33,735 --> 00:06:34,755
held for aggression.
直播被暂停

154
00:06:34,755 --> 00:06:35,456
What does this even mean?
这到底是什么意思啊？

155
00:06:37,238 --> 00:06:39,436
Sorry, I don't understand Twitch moderation.
抱歉我不懂 Twitch 审核机制

156
00:06:40,115 --> 00:06:45,401
So that, I think we will launch on Wednesday with a thing
所以 我觉得我们会在周三推出这个东西

157
00:06:45,401 --> 00:06:48,124
but it's going to require actual physical ARM
这需要 ARM 物理设备

158
00:06:48,124 --> 00:06:50,045
like Apple Silicon devices
比如 苹果芯片设备

159
00:06:50,045 --> 00:06:52,894
that we will set up in an environment
我们会设置好一个环境

160
00:06:53,091 --> 00:06:54,928
 that hopefully will be transparent to you
希望能让你们无感

161
00:06:54,928 --> 00:06:56,428
and you'll just be able to use pwn college
你们直接能在pwn college上用

162
00:06:56,428 --> 00:06:57,829
and you'll get dropped into an ARM
然后直接接入 ARM 环境

163
00:06:57,829 --> 00:07:01,018
into a Mac thing when you're doing this XNU stuff.
接入一个 Mac设备，在黑 XNU 内核时

164
00:07:02,116 --> 00:07:04,238
We'll see.  I'll hopefully show that on Wednesday
到时自见分晓，我希望能在周三展示给大家

165
00:07:04,238 --> 00:07:06,003
or show how close we're getting there.
或者展示我们已经接近完成了

166
00:07:07,262 --> 00:07:08,603
But in the meantime
与此同时

167
00:07:08,762 --> 00:07:11,875
what I realize is one of the things that would be fun is looking at
我意识到，这样可能会很有趣

168
00:07:12,582 --> 00:07:16,375
popping and exploiting other targets that are more real world.
就是，攻击利用更贴近现实世界中的目标

169
00:07:16,408 --> 00:07:22,180
So going beyond kind of what you've been doing in Pwn College,
所以 我们要超越在 Pwn College 里做的

170
00:07:22,274 --> 00:07:26,536
going a little bit closer towards specifically like CTF style challenges
更接近 CTF 风格的挑战

171
00:07:26,536 --> 00:07:28,493
or maybe even real world software
或者甚至是现实世界的软件

172
00:07:28,579 --> 00:07:31,153
kind of like what real world CTF does if you've ever done that.
就像实际的 CTF 比赛一样 如果你参加过的话

173
00:07:32,413 --> 00:07:33,872
It is currently not...
它现在还没有……

174
00:07:33,872 --> 00:07:35,646
I don't think it's quite working yet
我觉得它还不是很好用

175
00:07:35,735 --> 00:07:39,872
but I have a challenge that I ported from...
但我准备了一个题目 它来自……

176
00:07:41,645 --> 00:07:42,178
Where is it?
它在哪里？

177
00:07:42,203 --> 00:07:43,145
CTF Archive.
CTF 档案

178
00:07:43,540 --> 00:07:46,218
From DEF CON 2018.
来自 2018 年的 DEF CON

179
00:07:47,543 --> 00:07:48,503
I'm not logged in.
我没有登录

180
00:07:52,950 --> 00:07:53,436
What?
什么？

181
00:07:55,750 --> 00:07:56,510
Oh, man.
哎呀 糟糕

182
00:07:57,083 --> 00:07:58,400
Somebody should file a bug report.
有人得报个 bug

183
00:08:01,014 --> 00:08:02,994
So This will be live in the AVR thing
这个会放在 AVR 里

184
00:08:02,994 --> 00:08:04,227
so you won't have to find it in here.
所以你不用在这里找了

185
00:08:04,475 --> 00:08:05,755
It's a prior CTF challenge
这是个之前的 CTF 挑战题目

186
00:08:05,755 --> 00:08:07,014
so it makes sense to live in here.
所以放在这里挺合理的

187
00:08:07,177 --> 00:08:13,648
So I created a challenge back in 2018 called www
2018 年我创建了一个叫 www 的挑战

188
00:08:14,283 --> 00:08:17,266
and let's start it
我们开始吧

189
00:08:17,266 --> 00:08:18,676
and just kind of show you.
我来给你演示一下

190
00:08:25,869 --> 00:08:29,126
Okay, so did that work?
好的 这样行吗？

191
00:08:33,526 --> 00:08:35,846
So this is basically a crazy challenge.
这可以说是一个疯狂的挑战

192
00:08:41,573 --> 00:08:43,193
Yeah, anyways, I'm just going to run it.
嗯 不管怎样 我来运行一下

193
00:08:45,506 --> 00:08:46,340
That's not right.
这不对

194
00:08:46,548 --> 00:08:47,960
Oh, you may not be able to read that.
哦 你可能看不到

195
00:08:49,721 --> 00:08:50,093
Okay.
好的

196
00:08:51,029 --> 00:08:52,373
You have to give it a URL.
你得给它一个网址

197
00:08:52,850 --> 00:08:54,250
You actually don't have internet access
环境里没有网络

198
00:08:54,250 --> 00:08:56,211
so I wouldn't put it in an actual URL.
所以我不会放进真正的 URL

199
00:08:58,192 --> 00:09:00,593
And this was a challenge that we...
这是我设计的一个挑战……

200
00:09:01,052 --> 00:09:04,418
yeah, that I created for DEF CON Qualls 2018.
是的 我为 2018 年的 DEF CON 资格赛创建的挑战

201
00:09:04,832 --> 00:09:07,515
The teams hit it over a socket
各团队通过socket连接访问它

202
00:09:07,515 --> 00:09:08,765
so it was a socket connection
是一个socket连接

203
00:09:08,912 --> 00:09:10,378
and then after that
然后

204
00:09:10,618 --> 00:09:12,658
this is the only output that they saw.
这就是他们看到的唯一输出

205
00:09:14,385 --> 00:09:17,403
And you just get cryptic things like booting up
你只会看到类似启动这样的神秘信息

206
00:09:19,264 --> 00:09:20,085
and it takes a while.
它需要一点时间

207
00:09:20,085 --> 00:09:21,990
This is a, I'll just like talk for a while.
那我就聊一会

208
00:09:23,310 --> 00:09:25,164
I don't want to give a ton of the fun away
不想把所有好玩的都剧透了

209
00:09:25,207 --> 00:09:26,908
but then you'll get messages
然后你会收到一些信息

210
00:09:26,908 --> 00:09:30,302
where it's storing screenshots into the tmp directory.
显示它正在将截图保存到/tmp目录

211
00:09:30,302 --> 00:09:33,043
So this is for you to actually know what's going on.
这样你就能知道发生了什么

212
00:09:33,164 --> 00:09:35,407
So if we rsync
我们用 rsync

213
00:09:35,407 --> 00:09:36,643
since I got that working.
因为我跑通了这个

214
00:09:42,356 --> 00:09:43,634
Okay, that's some other file.
好的 这是一些其他的文件

215
00:09:44,995 --> 00:09:45,836
Okay, so open.
好的 打开

216
00:09:48,949 --> 00:09:51,623
So you start seeing stuff like this.
你能看到类似的内容

217
00:09:54,229 --> 00:09:55,683
And I guess it's the same stuff.
我想这是同样的内容

218
00:09:56,076 --> 00:09:57,496
All right, we'll let it boot up.
好的 我们让它慢慢启动

219
00:09:57,866 --> 00:09:59,688
So in the actual challenge
在实际挑战中

220
00:09:59,688 --> 00:10:01,830
because obviously I can't just drop stuff
因为显然我不能直接丢东西进去

221
00:10:01,830 --> 00:10:04,613
you would get base64 encoded things that you had to decode
你会收到Base64编码的东西，然后你要解码

222
00:10:04,613 --> 00:10:06,490
and then realize it was a PNG.
然后你才会意识到那是个 PNG 文件

223
00:10:06,543 --> 00:10:08,130
As you look at it more and more
随着你深入了解

224
00:10:08,156 --> 00:10:09,336
you will find out...
你会发现……

225
00:10:13,080 --> 00:10:13,760
Let's see.
我们来看看

226
00:10:17,903 --> 00:10:19,144
Yeah, so let's see.
嗯 我们来看看

227
00:10:19,193 --> 00:10:21,760
We can dig into this a little bit.
我们可以深入研究一下

228
00:10:21,913 --> 00:10:24,149
This actually feeds in a little bit of what we're going to do today.
这其实和我们今天要做的有点关系

229
00:10:25,721 --> 00:10:31,023
So we see the NeXT Mach operating system, NeXT Mach 3.3,
我们看到NeXT Mach操作系统，NeXT Mach 3.3

230
00:10:31,834 --> 00:10:34,087
information on physical memory,
关于物理内存的信息

231
00:10:34,394 --> 00:10:39,265
yada, yada, yada, Ethernet devices, checking disks.
等等 以太网设备 检查磁盘

232
00:10:39,265 --> 00:10:40,883
What does this look like to you all?
大家觉得这看起来像什么？

233
00:10:44,005 --> 00:10:44,907
Some kind of what?
是什么？

234
00:10:46,307 --> 00:10:47,958
Yeah, some kind of OS is booting up
是的 某个操作系统正在启动

235
00:10:48,008 --> 00:10:49,368
and it's just outputting data, right?
它会输出数据 对吧？

236
00:10:49,368 --> 00:10:51,808
This is every time you run your Linux thing
每次你启动 Linux 时都是这样

237
00:10:51,808 --> 00:10:54,561
and it's just like, Starting some services.
就像这样 启动一些服务

238
00:10:54,561 --> 00:10:56,363
This is what takes a while.
这会花点时间

239
00:10:57,436 --> 00:10:58,543
So it's going to do that.
所以它会做这个

240
00:10:59,586 --> 00:11:00,486
It'll give us some output.
它会输出一些信息

241
00:11:00,486 --> 00:11:01,443
It's still booting.
它还在启动中

242
00:11:09,266 --> 00:11:10,513
I should have preloaded this.
我应该提前加载好这个

243
00:11:11,439 --> 00:11:12,373
Actually, I think I did.
实际上，我加载过了

244
00:11:12,560 --> 00:11:14,420
No, I just deleted all those screenshots.
不 我刚刚删了那些截图

245
00:11:14,581 --> 00:11:15,086
That was silly.
真傻

246
00:11:21,544 --> 00:11:22,958
Sometimes this kind of doesn't work
有时候它会失败

247
00:11:22,958 --> 00:11:24,678
but I'll explain it in a second about why.
但我一会儿解释为什么

248
00:11:26,379 --> 00:11:26,659
Okay.
好的

249
00:11:31,283 --> 00:11:32,222
This is a good reminder.
这是个很好的提醒

250
00:11:32,222 --> 00:11:34,803
Whenever you run a demo live, you should pre-cache the data
现场演示时 最好预先缓存数据

251
00:11:34,803 --> 00:11:35,745
so you don't have to do this
就不会像现在这样了

252
00:11:35,745 --> 00:11:39,206
and you could just go to things instead of making up stuff.
你可以直接演示 而不是临时编造

253
00:11:43,583 --> 00:11:44,803
rsync again.
再试一次

254
00:11:48,903 --> 00:11:49,656
That's scary.
真吓人

255
00:11:49,772 --> 00:11:50,371
That was nothing.
那不算什么

256
00:11:52,782 --> 00:11:53,863
Okay, same image.
好的 同样的图像

257
00:11:54,996 --> 00:11:55,582
Yeah, there we go.
对 就是这样

258
00:11:55,655 --> 00:11:56,103
Okay.
行

259
00:11:56,462 --> 00:11:58,650
Finally booted, waiting to log in.
终于启动了 等着登录

260
00:12:04,004 --> 00:12:04,690
Yeah, cool.
好吧 挺酷的

261
00:12:04,724 --> 00:12:05,930
So then you see this.
然后你就能看到这个

262
00:12:06,177 --> 00:12:08,144
You get to the login screen.
你到了登录界面

263
00:12:08,350 --> 00:12:10,384
anybody know what next step is.
有人知道next step是什么

264
00:12:16,028 --> 00:12:17,807
Yeah, so what was the story there?
对 那里有什么故事？

265
00:12:17,807 --> 00:12:18,890
Do you know the story?
你知道这个故事吗？

266
00:12:18,936 --> 00:12:19,970
Why is there a next?
为什么会有下一步？

267
00:12:29,330 --> 00:12:30,123
Very close.
很接近了

268
00:12:31,591 --> 00:12:33,079
Oh no, it's not going to be able to log in.
糟了 登不上了

269
00:12:37,615 --> 00:12:38,236
Well, this is annoying.
真烦

270
00:12:39,506 --> 00:12:41,226
Anyways, we can run it again in a second.
没关系 我们可以再试一次

271
00:12:42,056 --> 00:12:44,682
So, but how could Steve Jobs create a company?
乔布斯是怎么创建公司的？

272
00:12:44,682 --> 00:12:46,093
He created Apple, right?
他创立了苹果 是吧？

273
00:12:46,118 --> 00:12:47,569
In a garage with Steve Wozniak.
和Steve Wozniak在车库里创建的

274
00:12:49,173 --> 00:12:50,961
Yeah, he got fired from Apple. Doesn't that suck?
是的，他被苹果解雇了。 很恶心

275
00:12:50,961 --> 00:12:52,102
You created this company
你创建了这家公司

276
00:12:52,102 --> 00:12:53,523
built it from nothing in your garage
在自己的车库里从零打造了它

277
00:12:53,523 --> 00:12:56,345
and then you get ousted and fired from the board.
然后你被排挤出董事会 甚至被开除了

278
00:12:59,626 --> 00:13:00,366
So that's a whole story.
这就是整个故事

279
00:13:00,366 --> 00:13:01,048
You can read about it.
你可以读到这个故事

280
00:13:01,048 --> 00:13:03,349
I think there's probably movies about it, too, and stuff.
好像还被拍成了电影 还有其他的东西

281
00:13:03,349 --> 00:13:04,140
So...
所以...

282
00:13:04,952 --> 00:13:05,685
Ah, damn.
啊 真糟糕

283
00:13:06,112 --> 00:13:06,532
Okay.
好吧

284
00:13:06,739 --> 00:13:08,193
What it's doing now, basically there's
它现在基本上是在...

285
00:13:08,366 --> 00:13:08,932
it's trying to do...
尝试...

286
00:13:08,932 --> 00:13:12,413
This is my very stupid thing of doing screenshot comparison
这是我的笨办法 比较截图

287
00:13:12,413 --> 00:13:15,355
because this has to run an emulator in a virtual environment
因为这需要在虚拟环境中运行模拟器

288
00:13:15,355 --> 00:13:16,753
and then interact with it.
还要进行交互

289
00:13:17,760 --> 00:13:19,339
Sometimes it gets stuck in a state like this
有时候会卡在这种状态

290
00:13:19,339 --> 00:13:22,240
where it's waiting to see the login screen
等着登录界面出现

291
00:13:22,240 --> 00:13:23,081
and it clearly can
会出现

292
00:13:23,081 --> 00:13:25,302
but something is slightly different than what it expects
但稍微和预期不太一样

293
00:13:25,302 --> 00:13:27,490
and it just hangs here.
结果就卡在这里了

294
00:13:35,246 --> 00:13:36,859
So anyways, we can try that again.
所以 我们再试一次吧

295
00:13:36,913 --> 00:13:39,831
It should take roughly about 12 or 13.
应该需要 12 或 13 秒

296
00:13:39,831 --> 00:13:40,857
We should be able to see some stuff.
应该能看到些东西

297
00:13:41,953 --> 00:13:42,571
Anyways, okay,
总之 好的

298
00:13:42,571 --> 00:13:43,523
so yeah, so this was
所以 这就是

299
00:13:43,550 --> 00:13:47,553
so the story was Steve Jobs left, created this company called Next,
史蒂夫·乔布斯离开苹果后 创立了 Next 公司

300
00:13:47,553 --> 00:13:48,673
N-E-X-T
Next

301
00:13:48,673 --> 00:13:51,794
which created this computer called the Next Step,
这家公司开发了一台名为 Next Step 的计算机

302
00:13:51,794 --> 00:13:53,866
which was, I think, hardware and software
包括硬件和软件

303
00:13:54,115 --> 00:13:57,346
which included a new, brand new operating system.
其中包含了一个全新的操作系统

304
00:13:58,133 --> 00:14:00,960
And eventually that company was bought by Apple
后来这家公司被苹果收购了

305
00:14:00,960 --> 00:14:02,600
so Steve Jobs came back to Apple
所以史蒂夫·乔布斯回到了苹果

306
00:14:02,600 --> 00:14:05,861
and then ran the whole thing until he didn't anymore.
然后一直掌管着苹果 直到他不再掌管

307
00:14:08,096 --> 00:14:08,810
And...
接着...

308
00:14:11,263 --> 00:14:13,576
And what's fascinating
最有趣的是

309
00:14:13,601 --> 00:14:16,596
and why what we'll get into here is
我们将要探讨的是

310
00:14:16,676 --> 00:14:24,876
basically your goal is you need to pop this software through this interface.
你的目标是通过这个接口攻击这个软件

311
00:14:24,901 --> 00:14:28,463
So you have to pop software that's running on the Next OS.
所以你需要攻击运行在 Next 操作系统上的这个软件

312
00:14:29,550 --> 00:14:30,557
I think it's Next.
我觉得是 Next

313
00:14:30,557 --> 00:14:31,836
I can't remember the exact version.
我记不清具体的版本了

314
00:14:31,836 --> 00:14:32,910
We'll see it in a second.
我们一会儿就会看到

315
00:14:33,156 --> 00:14:35,696
And specifically, the software that it's running
具体来说 运行的软件是

316
00:14:35,721 --> 00:14:38,339
is the original World Wide Web browser
是最早的www浏览器

317
00:14:38,339 --> 00:14:40,923
that Tim Berners-Lee wrote in 1993.
这是蒂姆·伯纳斯 - 李在 1993 年编写的

318
00:14:41,224 --> 00:14:44,479
or 1994, which is the original.
还是1994 年， 最初的版本

319
00:14:44,479 --> 00:14:46,100
And I'll show you the screenshot.
我来展示一下截图

320
00:14:46,100 --> 00:14:46,966
It's actually running.
它正在运行

321
00:14:47,400 --> 00:14:49,046
Actually, maybe I can show you ...
或许我可以展示

322
00:14:54,365 --> 00:14:55,140
Yeah, I can.
可以

323
00:15:00,703 --> 00:15:02,523
Okay, there's definitely a PNG in here
好的 这里确实有一个 PNG 文件

324
00:15:02,548 --> 00:15:05,093
but one of them, let's talk.
我们来谈谈其中一个吧

325
00:15:05,525 --> 00:15:08,638
Yeah, so what you eventually see is something like this.
最终你会看到这样的

326
00:15:08,985 --> 00:15:11,725
So you see, and you can actually like play with this
你看 你可以实际操作一下

327
00:15:11,726 --> 00:15:13,478
and run this stuff in an emulator.
在模拟器中运行这些东西

328
00:15:13,687 --> 00:15:15,465
It's actually really cool because you can
真的很酷 因为你可以

329
00:15:15,828 --> 00:15:16,568
if you use a Mac
如果你用的是 Mac

330
00:15:16,569 --> 00:15:19,249
you can see that like the stuff that they still have there
你可以看到 有些东西

331
00:15:19,250 --> 00:15:22,676
is still interaction paradigms that exist today.
至今仍在使用

332
00:15:24,796 --> 00:15:27,556
So there's the www app.
有一个 www 应用

333
00:15:27,557 --> 00:15:30,390
And then you'll notice in this is slash me.
然后你会发现这里有个 /me

334
00:15:30,499 --> 00:15:32,979
So before, like, cause it wasn't multi-user systems
以前还没有多用户系统

335
00:15:32,980 --> 00:15:34,280
there was just slash me.
当时只有 /me 这样的目录

336
00:15:34,538 --> 00:15:37,313
/me/flag That is your goal to get that file.
/me/flag 就是目标文件

337
00:15:39,513 --> 00:15:42,205
And eventually I think that other, let's see
后来我觉得还有其他的东西 让我看看

338
00:15:42,206 --> 00:15:43,873
where's the other PNG.
其他 PNG 文件在哪

339
00:15:47,686 --> 00:15:48,189
Ready.
准备好了

340
00:15:48,189 --> 00:15:48,766
Good.
很好

341
00:15:48,826 --> 00:15:49,173
Yeah.
嗯

342
00:15:50,431 --> 00:15:52,300
So this is the.
所以这就是

343
00:15:53,376 --> 00:15:56,277
Yeah, the World Wide Web app that's running here.
这里是运行的www应用

344
00:15:56,278 --> 00:15:58,460
This is where it says overview of the web.
这里是对万维网的简要介绍

345
00:16:04,410 --> 00:16:05,443
This is that that's running.
这就是正在运行的应用

346
00:16:05,444 --> 00:16:14,890
So your goal is to pop this World Wide Web app through just giving it a URL
所以你的目标是通过提供一个 URL 来攻击这个万维网应用

347
00:16:14,891 --> 00:16:16,936
and you'll be able to see how it gets through there.
你马上会知道如何实现

348
00:16:17,513 --> 00:16:19,203
And to make things easier, of course, well
为了降低难度，当然

349
00:16:19,373 --> 00:16:20,570
maybe not of course
也不一定降低了

350
00:16:20,856 --> 00:16:24,763
if you've Maybe you're not used to things being easier.
如果你不太习惯事情变得简单

351
00:16:25,030 --> 00:16:27,210
There's a tar file with the exact source code.
这里有一个包含源代码的 tar 文件

352
00:16:27,211 --> 00:16:28,529
So you can read through the source code
因此你可以阅读源代码

353
00:16:28,530 --> 00:16:29,919
figure out what's happening there.
搞清楚那里发生了什么

354
00:16:31,093 --> 00:16:39,160
You can also copy everything in opt www.
你也可以把/opt/www 目录下的所有内容都复制过来

355
00:16:39,453 --> 00:16:41,980
Is everything that's in there that you need to run this
那里有你需要运行这个的所有东西

356
00:16:42,039 --> 00:16:43,000
So there's...
所以这里有...

357
00:16:44,200 --> 00:16:48,580
This is like the disk drive that's actually running the next OS
可以说这个磁盘里面运行着NeXT操作系统

358
00:16:48,606 --> 00:16:49,753
that has everything on it.
有这个系统的所有东西

359
00:16:49,886 --> 00:16:50,979
I can't remember what these bins are.
我不记得这些 bin 文件是什么了

360
00:16:51,026 --> 00:16:53,559
I think these are different OS boots or something like that.
我觉得这些是不同的操作系统启动文件之类的

361
00:16:53,606 --> 00:17:01,966
And I have instructions of how you should be able to run this as a user on the desktop.
我有如何用桌面用户运行这个的说明

362
00:17:02,472 --> 00:17:06,634
The current problem is that I think this...
目前的问题是 我觉得这个...

363
00:17:06,635 --> 00:17:08,318
So previous is the name of this emulator.
所以这个模拟器的名字叫 previous

364
00:17:08,343 --> 00:17:09,938
And I think previous is...
我记得previous……

365
00:17:09,978 --> 00:17:13,081
having problems with the X that's running in your desktop container
与你机器上容器里运行的X，交互时有问题

366
00:17:13,082 --> 00:17:14,781
but I'm trying to figure out a better way to do this.
但我正在找更好的解决方法

367
00:17:14,782 --> 00:17:18,316
So you can actually like see what's going on when you run this easier.
这样你运行时就能更清楚地看到发生了什么

368
00:17:20,648 --> 00:17:24,270
So this will launch tonight, later tonight
今晚稍后会启动

369
00:17:24,271 --> 00:17:25,376
I guess I didn't set that up.
我还没设置好

370
00:17:26,290 --> 00:17:27,750
And then, so what we'll do is
接下来 我们会

371
00:17:27,775 --> 00:17:31,536
this will be a new module of like real world CTF challenges
它将是一个新的模块 包含真实的 CTF 挑战

372
00:17:31,596 --> 00:17:34,860
and you'll have the whole rest of the semester to do that.
你有整个学期剩余的时间来完成这些挑战

373
00:17:34,861 --> 00:17:39,047
So there'll just be a few to kind of not a ton
所以只有几个 不会太多

374
00:17:39,048 --> 00:17:40,808
I won't like throw 10 at you at the last minute
不会在最后一刻一口气给你 10 个任务

375
00:17:40,809 --> 00:17:44,090
but the idea is like actually apply what you learned to real world stuff.
重点是把学到的东西用到实际中

376
00:17:44,169 --> 00:17:45,090
The other thing I'll say
还有一点我要说

377
00:17:45,091 --> 00:17:48,790
because these are CTF challenges, there are write-ups where you can go look
因为这些是 CTF 挑战 所以能查到详细的writeup

378
00:17:48,791 --> 00:17:50,329
and read exactly how to do this.
并了解具体的解决方法

379
00:17:50,330 --> 00:17:51,311
I encourage you not to do that.
我不建议你们这么做

380
00:17:51,312 --> 00:17:52,784
I can't prevent you from doing that.
我无法阻止你们

381
00:17:54,431 --> 00:17:59,033
So, you know, use your good judgment and all that stuff
所以 要多用用自己的判断力 懂的都懂

382
00:17:59,506 --> 00:18:02,746
and please don't do that unless you absolutely need to,
除非万不得已 否则不要这么做

383
00:18:02,915 --> 00:18:03,853
in which case, whatever
实在需要就随你们了

384
00:18:03,980 --> 00:18:04,695
I kind of don't care.
我其实不太在乎

385
00:18:04,696 --> 00:18:09,735
This is, my goal is to point you at stuff to like, pop and study
我的目标是给你们推荐一些东西 你们可以去探索和学习

386
00:18:09,736 --> 00:18:11,670
and that's the important part.
这才是关键的部分

387
00:18:11,918 --> 00:18:12,623
Questions?
有问题吗？

388
00:18:16,099 --> 00:18:16,503
Yeah.
说吧

389
00:18:19,322 --> 00:18:19,890
Nope.
没有

390
00:18:20,022 --> 00:18:21,604
This is not using QEMU.
这个没用 QEMU

391
00:18:21,629 --> 00:18:22,522
It's using a custom.
它用的是自定义的

392
00:18:22,522 --> 00:18:23,156
I don't know.
我不知道

393
00:18:23,303 --> 00:18:24,003
I didn't write it
不是我写的

394
00:18:24,004 --> 00:18:28,469
but this is an emulator for the Next OS specifically
但这是专门为 Next OS 设计的模拟器

395
00:18:28,889 --> 00:18:29,949
and I think it's
我觉得这是

396
00:18:31,056 --> 00:18:34,029
I think the architecture is some Motorola something something.
我觉得架构是摩托罗拉的

397
00:18:35,842 --> 00:18:37,023
Yeah, so you don't have any nice
没错 你没有什么好的

398
00:18:37,024 --> 00:18:37,723
it's not like QEMU
不像 QEMU 那样

399
00:18:37,724 --> 00:18:40,340
you don't have any nice stuff you have
你没有其他好东西

400
00:18:40,466 --> 00:18:42,567
but I will say once you get this environment to boot
但一旦这个环境启动了

401
00:18:42,568 --> 00:18:44,907
you can poke around and do stuff.
你就可以随便看看 做点事

402
00:18:45,020 --> 00:18:46,911
See, I don't know why this didn't work either
我也不明白为什么这个失败了

403
00:18:46,937 --> 00:18:49,384
but now I'm upset because this was working.
但现在我很难受 因为它之前是没问题的

404
00:18:53,016 --> 00:18:54,196
Anyways, I'll fix it.
不管怎样 我会修好的

405
00:18:54,197 --> 00:18:54,557
It'll work.
它肯定能行

406
00:18:54,558 --> 00:18:55,738
It worked for an entire CTF
它在 CTF 比赛中没出问题

407
00:18:55,739 --> 00:18:57,619
so it definitely does work
所以肯定行

408
00:18:57,620 --> 00:19:04,096
but This was done six years ago, so this stuff kind of breaks
但这是六年前做的 所以有些问题

409
00:19:04,097 --> 00:19:05,419
and then you have to update it.
然后需要更新一下

410
00:19:05,878 --> 00:19:15,524
If anybody saw, this front-end code that you talked to
如果有人看过 你与之交互的前端代码

411
00:19:15,550 --> 00:19:17,025
is all Python 2 as well.
全是 Python 2

412
00:19:17,026 --> 00:19:19,366
So we're living in the past.
现在都过时了

413
00:19:19,528 --> 00:19:21,794
This is a well way in the past.
这已经非常过时了

414
00:19:22,711 --> 00:19:23,141
Cool.
好的

415
00:19:23,211 --> 00:19:24,288
Any other questions?
还有其他问题吗？

416
00:19:29,866 --> 00:19:30,454
All right.
好吧

417
00:19:31,172 --> 00:19:33,605
Yeah, curse of the demo in true Apple fashion.
典型的苹果风格 演示时总是出问题

418
00:19:33,606 --> 00:19:34,647
Very, very true.
确实没错

419
00:19:36,186 --> 00:19:37,607
I swear this was working at one point.
我保证这东西之前还能用

420
00:19:37,608 --> 00:19:38,826
I did get screenshots.
我截了图

421
00:19:38,879 --> 00:19:40,987
It got to the point where it was loading the ...
它那时已经在加载 ...

422
00:19:40,988 --> 00:19:42,848
Actually, what's very funny
其实 有趣的是

423
00:19:42,849 --> 00:19:44,359
does anybody know the first website?
有人知道第一个网站是什么吗？

424
00:19:49,029 --> 00:19:52,286
You think the web just sprung out of existence?
你以为网站是一下子就有的吗？

425
00:19:59,238 --> 00:20:00,286
No.
不

426
00:20:04,453 --> 00:20:05,333
Ah, info.
啊 信息

427
00:20:09,307 --> 00:20:09,940
Yeah.
好

428
00:20:10,168 --> 00:20:13,886
So this was the first website, info.cern.ch.
这就是第一个网站 info.cern.ch

429
00:20:16,506 --> 00:20:19,129
I mean, anybody know why the web was created?
有人知道为什么要创建互联网吗？

430
00:20:22,462 --> 00:20:23,876
You use it every single day.
你们每天都在用

431
00:20:23,942 --> 00:20:25,262
You never thought where did this come from?
没想过 这东西是从哪儿来的？

432
00:20:26,439 --> 00:20:31,549
Wasn't it an alternative form of like, Communication for the military.
难道它不是一种军事通讯的替代形式？

433
00:20:31,742 --> 00:20:35,936
No, you're thinking of the internet and the ARPANET.
不是 你说的是互联网和阿帕网

434
00:20:36,143 --> 00:20:38,044
So the ARPANET is the internet, right?
阿帕网就是互联网前身

435
00:20:38,045 --> 00:20:41,050
That's how packets move around, TCP, IP, all of that.
这就是数据包的传输方式 TCP、IP 等

436
00:20:41,345 --> 00:20:42,603
But before the web
但在网站出现之前

437
00:20:43,586 --> 00:20:44,723
you still had what?
你们还有哪些东西？

438
00:20:44,987 --> 00:20:46,103
What's not web?
有哪些不是web的服务？

439
00:20:46,536 --> 00:20:47,143
Mail.
电子邮件

440
00:20:47,449 --> 00:20:50,820
Yeah, mail, email, SMTP, POP, IMAP.
对 电子邮件、SMTP、POP、IMAP

441
00:20:51,231 --> 00:20:51,960
What else?
还有什么？

442
00:20:53,757 --> 00:20:54,380
Telnet.

443
00:20:54,692 --> 00:20:55,120
What was it?
什么？

444
00:20:55,600 --> 00:20:56,460
Telnet, yep.
Telnet 对

445
00:20:57,652 --> 00:20:58,673
What else?
还有呢？

446
00:20:59,803 --> 00:21:01,093
How'd you move files around?
你们怎么传输文件的？

447
00:21:02,120 --> 00:21:04,163
FTP predates the web.
FTP 比web还早

448
00:21:06,616 --> 00:21:07,747
Use groups, I think
用群组吧 我觉得

449
00:21:07,748 --> 00:21:08,867
but I don't really
但我不太确定

450
00:21:08,868 --> 00:21:10,047
that's way predates my time.
那早在我那个年代之前了

451
00:21:10,048 --> 00:21:12,249
I don't quite understand how they actually function
我不太明白它们是怎么运作的

452
00:21:12,250 --> 00:21:15,458
but people have got like BBSs and all kinds of stuff.
但人们已经有 BBS 和各种各样的东西了

453
00:21:19,085 --> 00:21:20,413
so the web, right?
所以 web

454
00:21:20,414 --> 00:21:24,715
The web is like web browser plus HTML plus the concept of hyperlinks.
web就像是web浏览器加上超文本标记语言（HTML）和超链接的概念

455
00:21:24,716 --> 00:21:27,198
So you can click on a document to go to the next document.
你可以点击一个文档转到下一个文档

456
00:21:27,632 --> 00:21:30,055
These were things that were kind of in the air at the time.
这些想法在当时都很流行

457
00:21:30,056 --> 00:21:32,238
People were proposing this like, wow
人们提出这个想法时 都觉得太棒了

458
00:21:32,239 --> 00:21:35,000
wouldn't it be crazy if you like had a document on your computer
如果你的电脑上有文档

459
00:21:35,001 --> 00:21:37,803
and then that document had links to other documents
这些文档又链接到其他文档

460
00:21:37,804 --> 00:21:40,316
and those documents had links to other documents.
这些文档又链接到更多文档

461
00:21:40,462 --> 00:21:44,171
And what Tim Berners-Lee was a researcher who was working at CERN.
蒂姆·伯纳斯 - 李是欧洲核子研究组织的研究员

462
00:21:44,172 --> 00:21:45,686
So what does CERN do?
那么 欧洲核子研究组织是做什么的？

463
00:21:48,826 --> 00:21:50,457
Yeah, the particle accelerator.
对 就是粒子加速器

464
00:21:50,458 --> 00:21:51,858
I just think of like big circle, right?
我总是想到一个大环

465
00:21:51,859 --> 00:21:54,438
So they like spin stuff around and hit things
他们喜欢让粒子旋转然后互相撞击

466
00:21:54,439 --> 00:21:55,020
and I don't know
具体的我也不太清楚

467
00:21:55,021 --> 00:21:58,019
do stuff that I don't, whatever, whatever they do
做一些我不知道的实验

468
00:21:58,020 --> 00:22:01,396
the physicists do when they hit things at high speeds.
物理学家做的一些对高速撞击的记录计算

469
00:22:02,143 --> 00:22:04,161
But he was there and you have this problem at CERN
他在那里时，欧洲核子研究组织面临这个问题

470
00:22:04,162 --> 00:22:07,301
that you had too many people coming and leaving all the time.
人员流动非常频繁

471
00:22:07,302 --> 00:22:09,984
So you didn't know who was there or where they were.
所以你根本不知道谁在哪里

472
00:22:09,985 --> 00:22:12,903
And so what he really wanted was a better directory for CERN.
所以他真正想要的是一个更好的 CERN 人员目录

473
00:22:13,026 --> 00:22:14,956
Like who does what kind of research
比如谁在做哪方面的研究

474
00:22:15,116 --> 00:22:16,186
and what's their phone number
以及他们的电话号码是多少

475
00:22:16,187 --> 00:22:18,363
and office number that you can go contact them.
以及可以联系他们的办公室电话

476
00:22:18,598 --> 00:22:24,879
So he created the worldwide web browser using a next step physical machine
因此他用 NextStep 系统的机器，创建了web浏览器

477
00:22:24,880 --> 00:22:28,302
that's what he was developing on, to create HTTP,
他用的这台机器做开发，创建了 HTTP（超文本传输协议）

478
00:22:28,303 --> 00:22:31,910
the communication protocol of requesting an hypertext document,
这是一种请求超文本文档的通信协议

479
00:22:31,983 --> 00:22:36,044
HTML, and like URIs and URLs
超文本标记语言（HTML）、统一资源标识符（URI）和统一资源定位符（URL）

480
00:22:36,045 --> 00:22:37,304
and defining that whole concept.
并定义了整个概念

481
00:22:37,305 --> 00:22:39,366
So he created that in
他创建了这些

482
00:22:39,367 --> 00:22:41,525
I believe it was, let's see
我记得是在

483
00:22:41,526 --> 00:22:43,199
I believe it was like 92
我记得是 1992 年

484
00:22:47,459 --> 00:22:51,373
Let's see, the birth of the web. 1989.
看一下， web诞生的年份  1989 年

485
00:22:52,270 --> 00:22:54,083
Interesting, that seems a little early.
有趣 这似乎有点早

486
00:22:54,171 --> 00:22:55,983
But look, you can see, look at this picture.
但是看看这张图片

487
00:22:56,553 --> 00:22:58,216
Anybody recognize this?
有人认出这个了吗？

488
00:22:58,815 --> 00:23:01,636
This is like exactly what we were just looking at of this,
这正是我们刚才看到的

489
00:23:01,683 --> 00:23:03,903
the next cube in the upper right.
右上角的NeXT立方体

490
00:23:04,018 --> 00:23:05,896
You have the World Wide Web thing here.
这里是www的一些东西

491
00:23:05,979 --> 00:23:08,750
This is 100% like the same thing.
这完全一样

492
00:23:11,024 --> 00:23:12,553
Yeah, here's the...
是的 这里就是……

493
00:23:16,330 --> 00:23:17,806
And then let's go back
然后我们回来……

494
00:23:18,291 --> 00:23:20,291
and then browse the first website.
浏览一下首个网站

495
00:23:20,292 --> 00:23:22,380
So this was the first website of like, because
所以这就是第一个网站

496
00:23:23,040 --> 00:23:25,056
anyways the whole reason I started talking about this is like
我之所以提到这个是因为……

497
00:23:26,037 --> 00:23:27,543
you think of like now
你现在会想到

498
00:23:27,709 --> 00:23:29,738
you open up a browser
你打开浏览器

499
00:23:29,739 --> 00:23:30,836
where do you want it to take you?
你希望它带你去哪里？

500
00:23:33,783 --> 00:23:36,283
Like your homepage, but the internet didn't
大概是主页 但当时互联网还没...

501
00:23:36,284 --> 00:23:38,065
there wasn't a, sorry, the internet existed
当时有互联网

502
00:23:38,066 --> 00:23:39,263
but there wasn't a web.
但还没有网站

503
00:23:39,587 --> 00:23:41,857
So what is the
那么问题来了

504
00:23:41,984 --> 00:23:43,024
where do you send people?
人们都上网看什么

505
00:23:43,064 --> 00:23:44,304
So you had to have a site
所以需要一个引导网站

506
00:23:44,775 --> 00:23:47,370
And that was this info.cern.ch.
这个网站就是 info.cern.ch

507
00:23:47,538 --> 00:23:49,570
Although this version I have, for some reason
这个版本不知为何

508
00:23:49,658 --> 00:23:54,823
tries to talk to this cernvax.cern.ch.
总是尝试与 cernvax.cern.ch 通信

509
00:23:54,922 --> 00:23:57,083
And it tries to connect to it every time.
每次都会尝试连接

510
00:23:57,084 --> 00:24:00,216
And if it can't get the DNS address to talk to it
如果获取不到 DNS 地址

511
00:24:00,385 --> 00:24:03,146
it pops up a little alert dialog that you have to click OK for.
会弹出一个警告对话框 需要点击确定

512
00:24:03,147 --> 00:24:04,044
So I'm trying to...
所以我尝试……

513
00:24:04,264 --> 00:24:06,544
Anyways, the thing I was debugging is that
总之 我在调试时

514
00:24:06,837 --> 00:24:09,490
running my own DNS server to respond and be like
运行自己的 DNS 服务器来响应

515
00:24:09,630 --> 00:24:11,311
this is at 127.0.0.1
告诉它地址在 127.0.0.1

516
00:24:11,312 --> 00:24:13,290
Just, like, fetch something and go away.
获取点东西 然后别弹窗

517
00:24:13,374 --> 00:24:14,017
And...
然后...

518
00:24:14,517 --> 00:24:15,777
Anyways, to make that go away.
总之 想办法不让他弹窗

519
00:24:16,300 --> 00:24:17,798
Maybe I should just figure out how to click on it
或许我该弄清怎么点击它

520
00:24:17,799 --> 00:24:19,561
but I don't like the idea of clicking on things.
但我不是很喜欢点击东西

521
00:24:19,639 --> 00:24:22,000
It's way more brittle than typing things.
这比打字麻烦多了

522
00:24:22,423 --> 00:24:23,700
So, anyways.
所以 总之

523
00:24:23,804 --> 00:24:25,105
Okay, that was a long diversion
好吧 离题了

524
00:24:25,146 --> 00:24:29,029
but this is the history of the web.
但这就是web的历史

525
00:24:33,676 --> 00:24:35,310
Yeah, get the code.
对 获取代码

526
00:24:36,573 --> 00:24:38,236
Yeah, of the www browser.
对 www 浏览器的代码

527
00:24:38,336 --> 00:24:39,583
So, yeah.
是的 就是这样

528
00:24:39,717 --> 00:24:41,223
So this is the exact...
这就是……

529
00:24:43,070 --> 00:24:44,528
And the other interesting thing
还有一个有趣的是

530
00:24:44,529 --> 00:24:45,451
as you poke around with it
使用它的时候

531
00:24:45,452 --> 00:24:48,009
you can actually browse the internet.
你可以用它浏览网页

532
00:24:48,010 --> 00:24:52,356
It looks really weird because the thing doesn't recognize JavaScript.
看起来很奇怪 因为它不识别 JavaScript

533
00:24:52,402 --> 00:24:53,471
So you can see all the JavaScript.
会显示 js代码

534
00:24:53,529 --> 00:24:55,149
You can actually load real websites
你能访问真实的网站

535
00:24:55,216 --> 00:24:57,966
into this browser from like the early 90s.
用这个90 年代初的浏览器

536
00:24:59,835 --> 00:25:00,693
Kind of.
有点儿

537
00:25:02,828 --> 00:25:06,148
Yeah, and the other super important thing in here is this editor part.
是的 另一个非常重要的部分是这个编辑器

538
00:25:06,190 --> 00:25:08,971
So actually the vision of the web was a WYSIWYG
实际上 Web的愿景是WYSIWYG

539
00:25:08,972 --> 00:25:10,848
like what you see is what you get, editor.
即，所见即所得的编辑器

540
00:25:11,008 --> 00:25:12,612
So you can not only browse websites
因此 你不仅可以浏览网站

541
00:25:12,648 --> 00:25:14,173
but also edit them through the browser
还能通过浏览器编辑它们

542
00:25:14,241 --> 00:25:18,176
and save them and serialize the HTML back to the server.
并保存编辑内容 将 HTML 数据传回服务器

543
00:25:18,536 --> 00:25:20,190
That was like the original concept.
这是最初的设想

544
00:25:20,857 --> 00:25:23,130
Part of the problem though, at least historically is that
然而，问题在于，至少是当时的问题

545
00:25:23,263 --> 00:25:26,156
 this browser was so tied to Next Step
这个浏览器与 NextStep 系统紧密耦合

546
00:25:26,283 --> 00:25:28,376
because it only ran there, that...
因为只能在那个系统上运行

547
00:25:30,143 --> 00:25:31,582
They didn't have enough
它们缺乏足够的

548
00:25:31,583 --> 00:25:34,083
or there wasn't enough market share that it didn't spread
或者因为市场太小 没能普及开来

549
00:25:34,084 --> 00:25:36,429
but other people used the protocols
但其他人使用这些协议

550
00:25:36,546 --> 00:25:39,823
and wrote web servers and different browsers.
开发了web服务器和各种浏览器

551
00:25:39,848 --> 00:25:43,588
So Mosaic was the first browser that was super popular.
Mosaic 是第一个特别流行的浏览器

552
00:25:43,620 --> 00:25:45,468
And then you had Netscape and all this other stuff,
接着有 Netscape 和其他各种产品

553
00:25:45,469 --> 00:25:47,590
Internet Explorer, everything there.
IE等

554
00:25:49,511 --> 00:25:51,345
So anyways, I really like this.
总之 我真的很喜欢这东西

555
00:25:51,370 --> 00:25:52,570
I think this is a cool first challenge
用它做第一题，很棒

556
00:25:52,595 --> 00:25:56,192
because A you'll have to read real source code to find this bug.
因为首先你得阅读真实源代码，才能找到这个 bug

557
00:25:56,193 --> 00:26:02,823
And it's easier because you don't have to decompile this Motorola,whatever.
并且它简单 因为不必反编译这个 Motorola xxx

558
00:26:02,863 --> 00:26:05,976
I mean, maybe you actually will need to to figure out offsets and whatnot
你可能需要确定些偏移量之类的

559
00:26:06,662 --> 00:26:08,582
but you can have the source code to read through
但你能读到源代码

560
00:26:08,583 --> 00:26:10,583
which is exactly the problem we're going to.
这正是我们要解决的问题

561
00:26:10,584 --> 00:26:11,363
You have the system
当你有系统

562
00:26:11,363 --> 00:26:12,223
you have source code
有源代码

563
00:26:12,224 --> 00:26:13,603
you have the binary.
有二进制文件

564
00:26:13,604 --> 00:26:16,766
How do you actually try to find the bugs and vulnerabilities there?
你该如何找到其中的安全漏洞？

565
00:26:21,008 --> 00:26:21,360
Cool.
酷

566
00:26:23,470 --> 00:26:24,803
All right.
好吧

567
00:26:24,970 --> 00:26:27,929
And then writing shell code for another language is fun
还有给另一种语言写 shellcode 很有趣

568
00:26:27,930 --> 00:26:31,451
especially because this is in the 90s, so Like, they're like, ASLR
特别是在 90 年代 ASLR？

569
00:26:31,452 --> 00:26:33,892
that doesn't even make that's not even a word yet.
那时候听都没听过

570
00:26:33,893 --> 00:26:35,919
And like, executable stack what do you mean?
还有可执行栈 什么意思？

571
00:26:36,066 --> 00:26:37,854
All memory is readable, writable, and executable.
所有内存都可读、可写、可执行

572
00:26:37,855 --> 00:26:39,619
Like, this is just concepts that don't make sense.
这些保护机制概念都没道理

573
00:26:39,706 --> 00:26:41,326
So the actual exploitation is easy.
所以漏洞利用简单

574
00:26:41,379 --> 00:26:43,913
It's just like fitting this model of what you know how to do
就像把你的技能和知识

575
00:26:43,938 --> 00:26:45,065
into a new system
应用在一个新系统上

576
00:26:45,138 --> 00:26:46,779
is, I think, interesting and fun.
我觉得挺有趣 也很好玩

577
00:26:48,901 --> 00:26:51,599
Yeah, so 93 is when it was released to the public.
是的 93 年它对公众发布了

578
00:26:51,682 --> 00:26:52,958
That's why I have 93 in there.
所以我在里面加了 93

579
00:26:54,283 --> 00:26:54,684
Cool.
酷

580
00:26:54,685 --> 00:26:56,923
Any other questions, historical or otherwise?
还有其他问题吗？历史或其他方面的

581
00:27:01,136 --> 00:27:02,744
All right, this still didn't work, did it?
好吧 这还是没成功 对吧？

582
00:27:03,883 --> 00:27:04,485
Oh, it did.
噢 成功了

583
00:27:04,485 --> 00:27:05,510
Oh, look at that.
哦 瞧

584
00:27:06,486 --> 00:27:08,472
So you talk long enough and eventually
只要讲得足够久，最终

585
00:27:10,791 --> 00:27:11,659
wait what am I doing?
等等 我在做什么？

586
00:27:15,726 --> 00:27:16,974
Why am I in there multiple times?
为啥我反复出现？

587
00:27:16,975 --> 00:27:17,766
What's going on here?
这是怎么回事？

588
00:27:18,966 --> 00:27:19,498
Okay.
行

589
00:27:23,760 --> 00:27:25,300
And let's see, 19.
来看看 截图19

590
00:27:26,199 --> 00:27:28,303
Yeah, so there's that alert that I was talking about.
这就是我之前说的那个警告

591
00:27:28,328 --> 00:27:29,266
That's super annoying.
它很烦

592
00:27:31,227 --> 00:27:38,030
But it did, no, let's see, 13.
但 我们来看看 截图13

593
00:27:42,215 --> 00:27:45,401
Yeah, so it is able to start
对 它可以启动了

594
00:27:45,426 --> 00:27:47,678
oh this is the app, worldwideweb.app.
哦 这是 worldwideweb.app 应用

595
00:27:48,838 --> 00:27:50,548
And just like, so if you use a Mac
如果你用 Mac

596
00:27:50,821 --> 00:27:54,976
everything that you have in applications is actually called like a .app
应用文件夹里的所有内容其实都是 .app 文件

597
00:27:55,223 --> 00:27:56,731
and they're not an executable
它们不是可执行的

598
00:27:56,756 --> 00:27:59,076
it's a directory with a specific structure.
而是一个有着特定结构的文件夹

599
00:27:59,204 --> 00:28:00,696
The structure is almost the same now.
和现在的结构差不多

600
00:28:01,663 --> 00:28:07,196
And does anybody do any Mac OS, like user space coding,
有人在 Mac OS 上做过用户空间编程吗

601
00:28:07,197 --> 00:28:08,756
like code apps or something?
比如写应用之类的？

602
00:28:10,720 --> 00:28:11,679
Everybody's shaking their head.
大家都在摇头

603
00:28:11,680 --> 00:28:13,103
I guess that's why you're taking this class.
我想这就是你们选这门课的原因

604
00:28:13,843 --> 00:28:17,903
Anyways, all of the, almost all of the, not internal
总之 几乎所有 非系统内部

605
00:28:17,904 --> 00:28:21,303
but like the system level stuff begins with capital NS.
而是系统级别的内容，都以大写的 NS 开头

606
00:28:21,953 --> 00:28:23,487
And that stands for next step.
NS 代表 NextStep

607
00:28:23,512 --> 00:28:26,006
So like there's NS string is like
NS 字符串就是这样

608
00:28:26,086 --> 00:28:28,980
I think it's like cocoa or whatever their objective C.
感觉像 cocoa 或 Objective-C

609
00:28:29,146 --> 00:28:31,386
like all of their frameworks start with ...
他们的框架开头都是...

610
00:28:31,413 --> 00:28:33,146
and almost everything starts with NS
几乎所有的都以 NS 开头

611
00:28:33,171 --> 00:28:34,851
because it comes all the way from next step
因为这都源自 NextStep

612
00:28:34,906 --> 00:28:37,206
and they've like carried that all the way through.
他们一直沿用至今

613
00:28:37,333 --> 00:28:38,606
So you can see things like that.
所以你会看到类似的东西

614
00:28:40,875 --> 00:28:41,413
Kind of,
有点像

615
00:28:41,536 --> 00:28:42,835
yeah, yeah, exactly.
是的 是的 完全正确

616
00:28:42,836 --> 00:28:45,515
Like kind of like the NT kernel, but basically
有点像 NT 内核 但基本上

617
00:28:45,516 --> 00:28:48,237
but the crazy thing for me is it came from this other company that they acquired
但最让我惊讶的是 这东西来自他们收购的公司

618
00:28:48,238 --> 00:28:51,918
and then like they threw out their operating system that they had at the time
然后他们把当时自己的操作系统扔了

619
00:28:51,919 --> 00:28:53,123
and like use this.
改用了这个

620
00:28:54,500 --> 00:28:56,285
Cool, okay, so I think this will be really fun
酷 我觉得这会非常有趣

621
00:28:59,029 --> 00:29:02,812
Yeah, and there's also an exit patch if you get stuck.
对 如果你卡住了 还有退出补丁

622
00:29:04,113 --> 00:29:04,435
Okay.
好的

623
00:29:06,136 --> 00:29:07,723
So enough about, yeah
不说这个了

624
00:29:07,870 --> 00:29:08,778
this does not work yet
这个还不能用

625
00:29:08,779 --> 00:29:10,110
but it will eventually.
但最终会能用的

626
00:29:10,450 --> 00:29:11,931
Okay, so enough about this.
好吧 不聊这个了

627
00:29:11,956 --> 00:29:13,223
What time is it, five?
现在几点了？五点了吗？

628
00:29:13,629 --> 00:29:15,023
All right, let me set a timer.
好的 我来设个定时器

629
00:29:15,250 --> 00:29:17,126
Set a timer for 25 minutes, please.
请设个 25 分钟的定时器

630
00:29:19,133 --> 00:29:20,069
Okay.
好的

631
00:29:22,070 --> 00:29:23,546
All right, now we're going to do
好的 现在我们来

632
00:29:26,483 --> 00:29:28,611
turn our attention to the operating system.
注意力转向操作系统

633
00:29:28,612 --> 00:29:34,852
So I talked a lot last week about how to approach a target, right,
上周我详细讲了如何接近目标 对吧？

634
00:29:34,853 --> 00:29:38,665
or how to even select a target, so the first step of approaching a target.
或者说如何选择目标 这是接近目标的第一步

635
00:29:38,834 --> 00:29:40,294
Now that we've chosen a target
既然选定了目标

636
00:29:40,295 --> 00:29:42,986
we want to do reconnaissance on that target.
我们需要对这个目标进行侦察

637
00:29:43,675 --> 00:29:45,493
Why is reconnaissance important?
为什么侦察如此重要？

638
00:29:51,006 --> 00:29:52,766
To understand attack vectors
为了了解攻击途径

639
00:29:52,858 --> 00:29:54,246
which is why is that important.
这就是为什么这很重要

640
00:29:58,096 --> 00:29:58,960
Say it again.
再说一遍

641
00:30:02,203 --> 00:30:04,736
Yeah, I would say that how do you know
嗯 怎么判断呢

642
00:30:04,804 --> 00:30:06,433
it's more about vulnerabilities, right?
主要是漏洞 对吧？

643
00:30:06,486 --> 00:30:11,228
So how can I influence the application by knowing what input I can feed in
了解了可输入内容后 我该如何影响这个应用

644
00:30:11,253 --> 00:30:12,786
what are the attack factors, right?
以及攻击途径有哪些 对吧？

645
00:30:12,908 --> 00:30:15,733
So understanding the system, super important.
所以 了解系统非常重要

646
00:30:15,830 --> 00:30:17,810
So we're going to dig in today
所以今天我们深入探讨一下

647
00:30:17,811 --> 00:30:21,080
and I have some fun ideas planned
我准备了一些有趣的点子

648
00:30:21,105 --> 00:30:22,735
that we're going to read a lot of source code
我们会读很多源代码

649
00:30:22,760 --> 00:30:25,113
and dig in through this beast.
并深入这个系统

650
00:30:25,114 --> 00:30:28,379
So, okay, I guess before I start
在我开始之前

651
00:30:29,840 --> 00:30:33,471
I meant to contact some of my friends who work at Apple.
我打算联系一些在苹果工作的朋友

652
00:30:33,496 --> 00:30:34,671
I don't actually know how to pronounce.
我其实不知道该怎么读

653
00:30:34,696 --> 00:30:36,256
I don't know if it's like X-NU.
我不确定是不是读作 X-new

654
00:30:36,330 --> 00:30:37,163
I don't think anyone does that
我觉得没有人这么读

655
00:30:37,203 --> 00:30:38,363
but I always say X-N-U
但我一直读 X-N-U

656
00:30:38,396 --> 00:30:40,678
but I don't know how people pronounce this
但我不知道大家怎么读

657
00:30:40,703 --> 00:30:42,296
so I apologize in advance if
所以我提前道个歉

658
00:30:42,616 --> 00:30:44,726
you've learned something from me that people are like, what an idiot.
万一你学了我的，别人说你

659
00:30:44,727 --> 00:30:46,449
Why would you say things like that?
“说的什么玩意这是”

660
00:30:46,787 --> 00:30:48,129
So X-N-U.
所以 X-N-U

661
00:30:48,848 --> 00:30:54,722
It stands for X is Not Unix, like a classic old school acronym.
它代表 X 不是 Unix ，一个经典的老式缩写

662
00:30:55,196 --> 00:30:57,046
And it is...
而且 它就是……

663
00:30:57,466 --> 00:30:59,736
Like we said, originally developed for Next Step.
正如我们所说 最初是为 Next Step 开发的

664
00:30:59,768 --> 00:31:01,356
So this is what's really cool.
所以 这才是最酷的地方

665
00:31:01,636 --> 00:31:06,711
You're going to be popping a user space application for the Next Step OS.
后面会攻击一个 NextStep 操作系统上的用户空间程序

666
00:31:06,776 --> 00:31:08,896
Well, that would be a fun follow-on challenge.
想到一个有趣的后续挑战

667
00:31:09,632 --> 00:31:14,469
Pop a kernel, find some bug in the kernel and pop that.
攻击内核 找到内核中的漏洞并利用它

668
00:31:14,876 --> 00:31:16,218
That could be a cool challenge.
那会是一个很酷的挑战

669
00:31:16,243 --> 00:31:16,793
All right.
好的

670
00:31:21,926 --> 00:31:23,541
So this ties in really nicely
这一切都紧密相连

671
00:31:23,566 --> 00:31:24,400
like we said that.
正如我们所说

672
00:31:24,446 --> 00:31:27,296
So the stuff that you are seeing
你看到的内容

673
00:31:27,602 --> 00:31:29,836
You will see how it's been carried forward.
你会看到它是如何传承的

674
00:31:29,983 --> 00:31:31,663
XNU is also the kernel.
XNU 也是内核

675
00:31:31,756 --> 00:31:33,825
There's this very confusing thing
有件挺让人困惑的事

676
00:31:33,850 --> 00:31:40,488
that the operating system is called Darwin in Mac land
在 Mac 系统中 操作系统叫 Darwin

677
00:31:40,520 --> 00:31:42,440
but the kernel is XNU
但内核是 XNU

678
00:31:42,530 --> 00:31:46,483
and the kernel is also used on almost all Apple stuff, so
而且内核也被用于几乎所有苹果设备

679
00:31:46,672 --> 00:31:52,393
Macs, iPhones, tablets, probably HomePods too, I would assume
Mac、iPhone、平板电脑 可能还有 HomePod

680
00:31:52,394 --> 00:31:54,883
and every device that I think is slightly smart.
以及我认为稍微智能的设备

681
00:31:54,977 --> 00:31:57,570
I don't know about the headphones and stuff
耳机那块我不太清楚

682
00:31:57,656 --> 00:31:58,938
because they have something on there.
因为里面有些东西

683
00:31:58,963 --> 00:32:00,883
There's some chip in there, the H-something.
里面有个 H开头的芯片

684
00:32:02,001 --> 00:32:03,440
I don't know exactly what's in there.
具体是什么我也不清楚

685
00:32:03,570 --> 00:32:05,176
There's also the other crazy thing.
还有个更疯狂的

686
00:32:05,662 --> 00:32:07,146
Who actually has a Mac?
谁有 Mac ？

687
00:32:07,322 --> 00:32:08,306
First question.
第一个问题

688
00:32:08,723 --> 00:32:09,924
Two?  I see two in this room.
两个？我在这儿看到两个

689
00:32:09,924 --> 00:32:11,060
Is there any more?
还有没有？

690
00:32:12,545 --> 00:32:15,926
You're all Linux people or Windows people?
你们用的是 Linux 还是 Windows？

691
00:32:16,953 --> 00:32:17,986
Wow, okay.
哇 行

692
00:32:18,188 --> 00:32:19,743
That'll make my next thing sad.
那我的下一件事就尴尬了

693
00:32:21,300 --> 00:32:22,026
Anyways,
不管怎样

694
00:32:22,271 --> 00:32:23,513
the...
这……

695
00:32:33,573 --> 00:32:43,686
This guy, $90 dongle, USB-C to power HDMI and USB-A adapter.
这个 $90 的 USB-C 转 HDMI 和 USB-A 适配器

696
00:32:44,348 --> 00:32:46,590
I bought this for the thing
我买这个是为了

697
00:32:46,635 --> 00:32:49,217
because this was before they had the HDMI adapters built in
因为在那之前还没有内置的 HDMI 适配器

698
00:32:49,242 --> 00:32:50,875
which is a very nice feature.
这真是个很棒的功能

699
00:32:51,307 --> 00:32:52,177
But before you had that
但在那之前

700
00:32:52,202 --> 00:32:53,747
you had to have a dongle like this.
你得用这样一个转接头

701
00:32:53,822 --> 00:32:55,889
I plugged it in and the computer said
我插上后 电脑提示

702
00:32:56,042 --> 00:32:58,660
do you want to update the firmware of your dongle?
“要更新转接头的固件吗？”

703
00:32:59,013 --> 00:33:01,006
And of course, as a security person, I said yes.
当然 作为安全人员 我选了“是”

704
00:33:01,080 --> 00:33:04,060
But then my second thought as a security person is
但作为安全人员 我立刻想

705
00:33:04,093 --> 00:33:06,386
why in the world is there software running on this device?
这设备上怎么会有软件运行？

706
00:33:06,442 --> 00:33:10,546
So there is something running on here that maybe you can hack.
所以这里运行着些东西 可能能被黑

707
00:33:10,573 --> 00:33:11,720
I have absolutely no idea.
我完全不清楚

708
00:33:11,766 --> 00:33:14,873
But that would be a very interesting attack surface of
但这将是一个很有趣的攻击面

709
00:33:14,926 --> 00:33:16,573
like, popping the dongle
比如攻击这个转接头

710
00:33:16,598 --> 00:33:20,613
through either HDMI input or USB input or something like that.
通过 HDMI 输入或 USB 输入之类的

711
00:33:20,690 --> 00:33:22,564
I assume it's got to be very simple.
我觉得它应该很简单

712
00:33:22,591 --> 00:33:24,527
Like, it cannot be that complicated of, like
它不可能太复杂

713
00:33:24,552 --> 00:33:26,544
it's just got to shunt things around for, like
它只是需要转发数据

714
00:33:27,391 --> 00:33:28,498
If you have to update it
既然需要更新

715
00:33:28,499 --> 00:33:30,360
there must have been some bug that they needed to fix.
肯定有需要修复的错误

716
00:33:30,361 --> 00:33:31,828
Hopefully it was not a security bug
希望不是安全漏洞

717
00:33:31,853 --> 00:33:32,906
but I have no idea.
但我也不知道

718
00:33:32,966 --> 00:33:35,713
But anyways, that would be super cool if anybody could do that.
但不管怎样 如果有人能做到就太酷了

719
00:33:39,128 --> 00:33:41,186
Maybe, but it should just pass through, right?
也许吧 但它应该只是简单通过 对吗？

720
00:33:41,226 --> 00:33:43,161
Because, like, you have USB.
因为 你有 USB 接口

721
00:33:43,186 --> 00:33:44,391
I have, okay, so.
我有 所以呢

722
00:33:48,453 --> 00:33:49,266
Yeah, but, like.
是啊 不过

723
00:33:52,715 --> 00:33:53,555
Yeah.
嗯

724
00:33:54,326 --> 00:33:56,866
Like, yeah, here's, like, a USB-A to USB-C adapter.
这是个 USB-A 转 USB-C 的转换器

725
00:33:56,912 --> 00:33:58,439
Like, I would be shocked
我会感到很震惊

726
00:33:58,464 --> 00:34:01,527
if there's, like complex software running on here that needs updates
如果这里，运行着需要更新的复杂程序

727
00:34:01,552 --> 00:34:04,294
or that there was even any way to update whatever's on here.
甚至，竟然有方法更新这里的东西

728
00:34:04,470 --> 00:34:06,417
It's, like, a $5 thing, like, throw it away, I guess.
这东西也就几美元 干脆扔了算了

729
00:34:07,540 --> 00:34:09,341
Anyways, also the displays.
还有 显示器

730
00:34:09,437 --> 00:34:13,443
So the, like, Mac Studio and the other Apple displays, like
像 Mac Studio 还有其他 Apple 显示器

731
00:34:13,476 --> 00:34:14,364
when you plug them in
一插上电脑

732
00:34:14,389 --> 00:34:16,305
you can also update the firmware, like
你还能更新上面的固件

733
00:34:16,330 --> 00:34:17,384
the stuff that's running on there.
运行在上面的系统

734
00:34:17,409 --> 00:34:19,936
I don't know if that's a pared-down version of XNU, but...
不确定这是否是 XNU 的简化版 不过……

735
00:34:20,109 --> 00:34:22,949
Basically, they've shown that almost every device they use
他们几乎所有的设备

736
00:34:22,950 --> 00:34:24,989
has XNU as the kernel
都用了 XNU 内核

737
00:34:25,690 --> 00:34:26,796
which is pretty cool.
真的挺酷的

738
00:34:27,192 --> 00:34:30,271
It was initially released in 1996
它在1996 年首次发布

739
00:34:30,296 --> 00:34:31,171
which is kind of cool.
还挺酷的

740
00:34:31,196 --> 00:34:32,343
It's very, very old.
算得上非常老了

741
00:34:32,693 --> 00:34:35,191
The other crazy thing is it was open source in 2000.
另一件疯狂的事 它在 2000 年开源了

742
00:34:35,216 --> 00:34:37,618
And I think I lied a little bit at the beginning of the class
我想我在课上说错了一点

743
00:34:37,643 --> 00:34:39,093
of why it's open source.
关于它为什么开源的原因

744
00:34:39,139 --> 00:34:42,219
I thought it was because it came from the
我以为是因为它来源于

745
00:34:42,275 --> 00:34:46,055
as we'll see, used BSD stuff and this other mach kernel.
它使用了 BSD 组件和mach微内核

746
00:34:46,056 --> 00:34:50,846
But I don't think those were copy left operating systems.
但我不认为那些是 copyleft 操作系统

747
00:34:50,923 --> 00:34:54,463
they could have just completely used them and never done anything
他们完全可以，不做任何改动地，使用这些系统

748
00:34:54,772 --> 00:34:58,551
but apparently there's this apple public source license
但显然有一个苹果公共源代码许可证

749
00:34:58,576 --> 00:35:00,430
that they license everything under
他们所有的东西都在这个许可下发布

750
00:35:00,938 --> 00:35:06,176
and um well that's not my password that'd be weird password
而且 那不是我的密码 太奇怪了

751
00:35:07,609 --> 00:35:12,231
and uh it is a i'm not a lawyer
而且 我不是律师

752
00:35:12,256 --> 00:35:15,743
so please for the love of god don't like take anything i say  to court or whatever
所以拜托，上法庭之类的，别用我的这些话

753
00:35:15,744 --> 00:35:19,384
But this is a verified open source license.
但这确实是一个经过验证的开源许可

754
00:35:19,437 --> 00:35:21,945
I don't know the differences between this and other licenses
我不知道这个许可和其他许可有什么区别

755
00:35:21,970 --> 00:35:25,790
but it's kind of crazy that they just decided to open source their kernel.
但他们决定开源他们的内核，这确实有点疯狂

756
00:35:27,091 --> 00:35:31,393
Some theories that I read people hypothesize is that like at the time
我读到的一些理论认为 当时

757
00:35:31,394 --> 00:35:33,553
they had such little market share that that was a way
他们的市场份额非常小，这样可以

758
00:35:33,607 --> 00:35:36,776
plus they were replacing their old OS kernel
另外他们还在用 Next Step 的新 XNU 内核

759
00:35:36,777 --> 00:35:38,922
with this new XNU stuff from Next Step.
替换旧的操作系统内核

760
00:35:38,947 --> 00:35:43,367
And so they wanted to try to convince people that it was more reliable
他们想靠这个，说服大家这更可靠

761
00:35:43,402 --> 00:35:45,747
because they could go read the source.
因为人们可以阅读源代码

762
00:35:46,046 --> 00:35:47,640
Maybe it was like a marketing ploy
也许这是一种营销策略

763
00:35:47,666 --> 00:35:49,308
because then you wouldn't be tied into their stuff
这样你就不会被绑定在他们的系统上

764
00:35:49,333 --> 00:35:50,209
and you could just take it.
你可以直接使用

765
00:35:50,319 --> 00:35:51,151
I have absolutely no idea.
我完全不知道

766
00:35:51,152 --> 00:35:55,441
But yeah, it's pretty crazy that they still do this
但确实很疯狂 他们至今还在这么做

767
00:35:55,500 --> 00:35:57,706
because I guess at any point they could just not do this
因为他们随时可以停止这么做

768
00:35:57,753 --> 00:35:58,979
and they would be fine.
也不会有影响

769
00:35:59,059 --> 00:36:00,666
They wouldn't be violating licenses.
他们不会违规

770
00:36:01,718 --> 00:36:02,406
I don't know.
我不知道

771
00:36:02,538 --> 00:36:03,153
It's crazy.
这真疯狂

772
00:36:05,540 --> 00:36:05,860
Okay.
行

773
00:36:09,744 --> 00:36:10,459
Cool.
挺好的

774
00:36:10,706 --> 00:36:13,746
So XNU is crazy.
所以 XNU 真是太疯狂了

775
00:36:13,839 --> 00:36:15,373
And I think I mentioned this before.
我想我之前提到过

776
00:36:15,759 --> 00:36:21,306
Uh, it is a amalgamation of various components and parts
呃 它由各种组件组成

777
00:36:21,793 --> 00:36:26,056
kind of glued together over the years and grown very organically.
这些组件粘在一起，多年来，形成了有机结合

778
00:36:26,057 --> 00:36:28,353
I think that's natural of any operating system, right?
我认为任何操作系统都是这样 对吧？

779
00:36:28,426 --> 00:36:29,674
They have to evolve over time.
它们必须随着时间演变

780
00:36:29,699 --> 00:36:32,193
You don't just like sit down and design it from scratch
你不会一开始，就能从头设计它

781
00:36:32,643 --> 00:36:35,310
but it is a
但它是一个……

782
00:36:35,526 --> 00:36:38,856
we think of as like a hybrid kernel with a split personality
我们认为它是一个具有双重性格的混合内核

783
00:36:38,983 --> 00:36:40,896
meaning there are two different worlds.
这意味着有两个不同的世界

784
00:36:40,976 --> 00:36:42,451
There's the BSD world.
一个是 BSD 的世界

785
00:36:42,476 --> 00:36:43,710
So there's a kernel.
所以有一个内核

786
00:36:43,711 --> 00:36:50,043
that they basically took from a BSD 4.3, which actually
这个内核基本上取自 BSD 4.3

787
00:36:50,303 --> 00:36:52,942
I think I already have an idea of the next real world thing
我认为我已经想好了，下一个要攻击的目标

788
00:36:52,996 --> 00:36:56,002
is gonna be software that runs on BSD 4.3,
那将是运行在 BSD 4.3 上的软件

789
00:36:56,249 --> 00:36:57,564
which is actually, again
这又是一个

790
00:36:57,589 --> 00:37:00,989
another great connection to what we're doing and looking at history.
很好的结合了我们所学的和历史的例子

791
00:37:03,580 --> 00:37:05,728
So this was released in 1986
这个版本发布于 1986 年

792
00:37:05,753 --> 00:37:08,313
kind of giving you a timeline of where we are.
这有助于我们了解所处的时间线

793
00:37:08,366 --> 00:37:11,399
A lot of things in BSD ended up in current kernels,
BSD 中的许多功能最终都集成到现代内核中

794
00:37:11,684 --> 00:37:13,948
especially like the TCP IP stack.
尤其是 TCP/IP 栈

795
00:37:13,972 --> 00:37:19,560
This was one of the first major implementations of the TCP IP stack that then got used
这是最早的 后来被广泛采用的 TCP/IP 栈实现之一

796
00:37:19,633 --> 00:37:21,288
because BSD has a very permissive license.
因为 BSD 的许可证非常宽松

797
00:37:21,313 --> 00:37:24,206
People just yanked it and used it in their OS kernels.
人们直接将其用在了自己的操作系统内核中

798
00:37:25,576 --> 00:37:26,497
And the interesting thing is
有趣的是

799
00:37:26,498 --> 00:37:28,873
so they started with this 4.3 BSD
他们从 4.3 BSD 开始

800
00:37:28,898 --> 00:37:31,251
and BSD kind of kept evolving, right?
BSD 一直在发展 对吧？

801
00:37:31,284 --> 00:37:33,093
But they, as we'll see
但正如我们看到的

802
00:37:33,138 --> 00:37:35,251
because they had this like Frankenstein monster,
他们的这个像个弗兰克斯坦怪人一样，

803
00:37:35,276 --> 00:37:37,686
this other part, they modified things
这部分进行了很多修改

804
00:37:37,711 --> 00:37:41,184
but they kind of kept up and shared code with FreeBSD.
但他们算是跟上FreeBSD 并与之共享代码

805
00:37:41,211 --> 00:37:42,724
So as FreeBSD evolved
因此 随着 FreeBSD 的发展

806
00:37:42,844 --> 00:37:45,231
Apple would take some patches from FreeBSD
苹果会从 FreeBSD 获取一些补丁

807
00:37:45,257 --> 00:37:50,986
and they would also ship patches back to and upstream them to FreeBSD from XNU.
还会将XNU中FreeBSD补丁回馈给FreeBSD

808
00:37:51,144 --> 00:37:51,539
I don't know
我不知道

809
00:37:51,564 --> 00:37:53,484
I think that's kind of interesting to look at, like, this,
我觉得这挺有趣的

810
00:37:53,910 --> 00:37:56,359
like, weird co-evolution here.
一种奇怪的共同进化

811
00:37:57,247 --> 00:38:00,626
Actually, the fun fact is during my sabbatical
有趣的是 在我休假期间

812
00:38:00,627 --> 00:38:04,009
one of the bugs I found was the oldest bug
我发现的一个最老的漏洞

813
00:38:04,010 --> 00:38:10,006
because it dated back to, I think, either 4.3, like, BSD kernel.
因为它可以追溯到 4.3 版的 BSD 内核

814
00:38:10,259 --> 00:38:13,439
I was able to trace that that bug was actually still present here,
我追查到这个漏洞仍然存在

815
00:38:13,553 --> 00:38:14,366
but it...
但...

816
00:38:14,529 --> 00:38:15,354
I guess I shouldn't say this
我大概不该说这个

817
00:38:15,379 --> 00:38:16,528
because it says how old I am
因为这暴露了我的年龄

818
00:38:16,572 --> 00:38:17,890
but it's still not older than me.
但还是没有我年纪大

819
00:38:17,946 --> 00:38:19,786
I wanted to find a bug that was older than I was
我想找一个比我还大的漏洞

820
00:38:19,859 --> 00:38:20,474
and that was not it.
但它不是

821
00:38:20,475 --> 00:38:21,803
It was very close, though.
不过很接近了

822
00:38:22,669 --> 00:38:25,278
The other side is a mach kernel.
另一个是mach微内核

823
00:38:25,303 --> 00:38:29,184
So the mach kernel was, again, created around the same time, 1985.
mach 是在 1985 年左右创建的

824
00:38:29,209 --> 00:38:30,149
You can kind of see
你可以看出

825
00:38:31,016 --> 00:38:33,031
especially if you read papers from this area
特别是如果你读过这方面的论文

826
00:38:33,056 --> 00:38:34,411
or look at the research that's been done
或者看看相关的研究

827
00:38:34,436 --> 00:38:37,500
you can kind of see that there was, like, this explosion of different, like
你能看出，此时涌现出了

828
00:38:38,642 --> 00:38:40,296
operating system ideas
不同的操作系统理念

829
00:38:40,321 --> 00:38:41,833
of like, oh, no this is how we should do a kernel
就像，应该这样制作内核

830
00:38:41,881 --> 00:38:43,488
or this is how we should do a kernel.
不，这才是内核的制作方法

831
00:38:43,661 --> 00:38:45,774
When was Linux released?
Linux 是什么时候发布的？

832
00:38:45,887 --> 00:38:46,807
My Linux heads.
我的 Linux 粉丝们

833
00:38:47,915 --> 00:38:49,113
You do this stuff all the time.
你们总用它

834
00:38:49,114 --> 00:38:50,602
You don't know when it came out.
不知道它的发布时间？

835
00:38:50,627 --> 00:38:51,807
History is important.
历史很重要

836
00:38:53,095 --> 00:38:53,946
You're just making stuff up.
你们是在胡编乱造

837
00:38:54,006 --> 00:38:54,526
Can somebody look?
有人能查一下吗？

838
00:38:57,637 --> 00:38:59,266
79?
79？

839
00:39:03,242 --> 00:39:05,460
The radio was in the 30s.
无线电是在 30 年代

840
00:39:05,485 --> 00:39:06,793
Oh, my God. What?
天啊 什么？

841
00:39:09,058 --> 00:39:09,953
91 年？

842
00:39:10,026 --> 00:39:11,218
Thank you. Yes, 91.
谢谢 对 91 年

843
00:39:11,243 --> 00:39:14,533
That makes sense because they had FTP and stuff and the internet.
这说得通 因为那时已经有 FTP 和互联网了

844
00:39:14,589 --> 00:39:15,766
Like it can't have...
它不可能有……

845
00:39:16,050 --> 00:39:16,853
Anyways.
总之

846
00:39:17,471 --> 00:39:18,153
Okay.
好的

847
00:39:18,913 --> 00:39:19,846
Around this time.
大约这个时候

848
00:39:19,895 --> 00:39:21,679
So like in a similar timeframe, right?
差不多同一时期 对吧？

849
00:39:21,753 --> 00:39:23,100
Late 80s, early 90s.
80 年代末 90 年代初

850
00:39:23,218 --> 00:39:26,266
There's a lot of exploration and experimentation in this stuff.
当时对这个有很多探索和实验

851
00:39:26,420 --> 00:39:29,039
And the cool thing was the mach kernel was developed at CMU.
最酷的是 mach是在卡内基梅隆大学开发的

852
00:39:29,064 --> 00:39:30,280
So it was a research project.
所以 这是一个研究项目

853
00:39:30,343 --> 00:39:31,953
This actually is...
这实际上是...

854
00:39:33,520 --> 00:39:35,446
I can't remember who did it, but...
我不记得是谁做的 不过...

855
00:39:36,666 --> 00:39:39,713
One of the Project Zero people, it was probably
可能是 Project Zero 的某个人

856
00:39:40,099 --> 00:39:44,066
I don't know if it was Brandon while he was there, Brandon Azad or Ian Beer
不确定是 Brandon Azad 还是 Ian Beer

857
00:39:44,148 --> 00:39:45,253
or maybe it was Ned
或者可能是 Ned

858
00:39:45,286 --> 00:39:48,160
but they wrote a Project Zero blog post
但他们写了一篇 Project Zero 的博客文章

859
00:39:48,193 --> 00:39:54,209
about exploiting bugs in the memory mapping and allocation in modern day XNU.
详细介绍了如何利用，现代 XNU 内存映射与分配的漏洞

860
00:39:54,210 --> 00:39:56,310
And to understand the allocator
为了理解这个分配器

861
00:39:56,311 --> 00:40:02,244
they went back to papers that were published in like the late 80s early 90s about mach
他们查阅了，80 年代末90 年代初发表的，关于mach的论文

862
00:40:02,771 --> 00:40:05,964
because it still has those features today.
因为这些设计沿用至今

863
00:40:06,207 --> 00:40:09,119
And so it actually helped him understand that system
通过阅读这些非常古老的论文

864
00:40:09,144 --> 00:40:10,507
by reading these super old papers.
让他更好地理解了这个系统

865
00:40:10,556 --> 00:40:12,378
This is also why history is important.
这也是为什么历史如此重要

866
00:40:12,403 --> 00:40:15,216
You should know when things came from and how old they are.
你应该了解技术的起源和它的历史

867
00:40:15,330 --> 00:40:20,330
Are they 100 years old or 30 years old?
是 100 年前的 还是 30 年前的？

868
00:40:21,303 --> 00:40:24,993
34, 35, 36? 33
34 年、35 年、36 年？33 年

869
00:40:25,070 --> 00:40:25,969
Okay.
好的

870
00:40:26,029 --> 00:40:27,303
I was going the wrong direction.
我弄错方向了

871
00:40:28,994 --> 00:40:31,364
And initially, so the mach kernel
一开始 mach内核

872
00:40:31,389 --> 00:40:34,293
and this was a big fight, just like...
有一个激烈冲突，就像

873
00:40:34,619 --> 00:40:39,893
I hoped people would argue about the RISC versus CISC debate in the 90s.
我希望人们能像 90 年代那样争论 RISC 和 CISC

874
00:40:40,941 --> 00:40:43,175
Similar debates in operating system kernels were
操作系统内核中的类似争论是

875
00:40:43,200 --> 00:40:45,153
monolithic kernels versus microkernels.
单内核vs微内核

876
00:40:45,200 --> 00:40:46,015
So what's the difference?
那么 它们有什么区别？

877
00:40:46,040 --> 00:40:47,026
Somebody tell me.
有人告诉我吗？

878
00:41:01,856 --> 00:41:05,843
Yeah, so the idea is like monolithic kernel, big kernel, lots of stuff
对 单内核就是 内核大 功能多

879
00:41:05,876 --> 00:41:07,549
like everything's in
所有功能都在一起

880
00:41:07,796 --> 00:41:09,323
you can think of it as one address space.
你可以认为它在同一个地址空间内

881
00:41:09,350 --> 00:41:10,610
The real downside is
缺点是

882
00:41:10,663 --> 00:41:12,230
basically one failure mode.
基本上只要一个错误

883
00:41:12,263 --> 00:41:17,151
So any seg fault or something in any kernel code
内核代码中任何段错误之类的

884
00:41:17,175 --> 00:41:18,796
the entire kernel crashes.
都会导致整个内核崩溃

885
00:41:19,547 --> 00:41:21,856
Also from a vulnerability perspective, right?
从安全漏洞的角度来看 也一样

886
00:41:21,916 --> 00:41:22,568
You pop the kernel
一旦你攻破了内核

887
00:41:22,620 --> 00:41:25,126
you own everything and it doesn't, nothing else matters.
你就掌控了一切 其他都不重要了

888
00:41:26,417 --> 00:41:28,728
However, with a microkernel design
然而 采用微内核设计

889
00:41:28,753 --> 00:41:32,626
the idea was separate the functionality of the kernel into little pieces
它将内核功能分解成小部分

890
00:41:32,841 --> 00:41:35,473
and that way an individual piece could crash
这样 即使某一部分崩溃

891
00:41:35,553 --> 00:41:39,973
and that would be fine. The rest of the operating system would still survive and go on.
问题也不大，其余部分依然可以继续运行

892
00:41:40,292 --> 00:41:42,886
I guess you have to restart that part
我想你必须重启那部分

893
00:41:42,913 --> 00:41:44,333
and that's why you have all these debates over like
所以会争论

894
00:41:44,393 --> 00:41:45,499
is that actually useful?
这到底有没有用？

895
00:41:45,553 --> 00:41:47,013
But then you have this mechanism of like, okay
但后来有了这种机制

896
00:41:47,014 --> 00:41:48,574
but you need to talk to other things.
你需要与其它部分通信

897
00:41:48,659 --> 00:41:50,773
And so how do you do that in an efficient manner?
那你如何高效实现呢？

898
00:41:50,937 --> 00:41:56,268
Like in a mono... what does it say monolithic kernel
在单内核中

899
00:41:56,293 --> 00:41:59,497
how would you call functionality from another component
如何调用其他组件的功能？

900
00:42:03,352 --> 00:42:04,695
yeah just a function call
对 就是函数调用

901
00:42:04,720 --> 00:42:05,932
right you just call
对 你直接调用

902
00:42:05,985 --> 00:42:08,665
and then boom you're there get the code code back
然后 你就到需要的代码了

903
00:42:08,690 --> 00:42:12,205
 you can call any function anywhere in the kernel it's great um
你可以在代码中，调用内核中的任何函数 很方便

904
00:42:12,621 --> 00:42:13,852
but you can have problems
但你可能会遇到问题

905
00:42:13,878 --> 00:42:17,004
and you can that can cause massive problems so um
这可能会导致严重的问题

906
00:42:17,824 --> 00:42:19,958
That's where mach came from was this idea of
在mach 出现时，有这么一个想法

907
00:42:19,983 --> 00:42:22,666
how do we design a microkernel with message passing
如何设计带有消息传递的微内核

908
00:42:22,691 --> 00:42:24,988
and the message passing is very efficient
并且消息传递要非常高效

909
00:42:24,989 --> 00:42:28,170
because that's the downside if you have message passing components.
因为这是用消息传递组件的缺点

910
00:42:30,330 --> 00:42:31,597
The cool thing is
酷的是

911
00:42:31,812 --> 00:42:37,189
so which design won out in the operating system wars?
那么在操作系统大战中 哪种设计胜出了？

912
00:42:41,293 --> 00:42:43,990
Yeah, Linux is monolithic, Windows is monolithic
是的 Linux 是单内核 Windows 也是单内核

913
00:42:44,076 --> 00:42:46,071
XMU is actually monolithic
XMU 实际上是单内核的

914
00:42:46,096 --> 00:42:48,149
even though it has this stuff that like
尽管它有类似微内核的特性

915
00:42:48,176 --> 00:42:49,900
it's kind of microkernel.
有点像微内核

916
00:42:49,950 --> 00:42:52,729
And you can actually see the trend of like
你可以看到这种趋势

917
00:42:52,763 --> 00:42:54,430
a lot of operating systems
许多操作系统

918
00:42:55,967 --> 00:42:58,827
are trying to move more stuff into user space
都在尝试将更多功能移到用户空间

919
00:42:58,851 --> 00:43:04,259
or like give reduce the need for companies or users to write kernel extensions
尽量让用户，无需编写内核扩展

920
00:43:04,284 --> 00:43:05,994
because that gets now part of your
因为这成了

921
00:43:05,995 --> 00:43:09,337
this is exactly the CloudStrike problem, if anybody remembers, right?
这就是 CloudStrike 问题 如果还有人记得的话 对吧？

922
00:43:09,411 --> 00:43:15,339
There's a kernel extension that had a bug that blue screened the computer on every boot
 有个内核扩展有漏洞，能让电脑每次启动时蓝屏

923
00:43:15,533 --> 00:43:18,352
Whereas if they had APIs of doing what they wanted
但如果让用户使用内核API实现所需功能

924
00:43:18,353 --> 00:43:20,104
that user space process would crash
那么用户进程可能崩溃

925
00:43:20,151 --> 00:43:21,586
and the rest of the kernel would be fine.
但内核的其他部分，不会有事

926
00:43:21,959 --> 00:43:22,951
So you can see that.
所以你看

927
00:43:23,014 --> 00:43:25,021
So monolithic kernels won out
所以 单内核当时胜出

928
00:43:25,046 --> 00:43:26,994
probably at the time, I would say, due to performance.
主要是因为性能优势

929
00:43:27,019 --> 00:43:29,586
Nobody wants to take a 10%, 20% performance hit on stuff.
没人希望性能下降 10% 到 20%

930
00:43:29,626 --> 00:43:31,955
You're just like, hey, your kernel crashed. Fix your stupid kernel bug
一般就 “嘿，你内核崩了，赶紧修一下bug”

931
00:43:31,956 --> 00:43:33,200
which is what they did over the years.
这正是内核开发者一直做的

932
00:43:33,225 --> 00:43:36,105
It became more resilient.
这让内核变得更健壮了

933
00:43:37,177 --> 00:43:37,992
But...
但是...

934
00:43:38,107 --> 00:43:39,779
This idea wasn't dead
这个想法没有消亡

935
00:43:39,805 --> 00:43:41,323
and this is what I think is super important
这正是我认为很重要的一点

936
00:43:41,389 --> 00:43:43,308
of looking at these things historically,
从历史角度看

937
00:43:43,309 --> 00:43:44,315
of being like, well
也就是说

938
00:43:44,340 --> 00:43:47,380
they did all this research into microkernels.
他们对微内核进行了大量研究

939
00:43:47,512 --> 00:43:48,773
Was this wasted?
这些研究是浪费了吗

940
00:43:49,740 --> 00:43:50,807
The idea is no.
不是的

941
00:43:50,860 --> 00:43:53,373
So what's a modern piece of software
有哪些现代软件

942
00:43:53,398 --> 00:43:57,656
that I guarantee you 80% of this room uses every day
我敢保证在座的 80% 每天都用到

943
00:43:57,959 --> 00:44:00,073
that has a microkernel-like design?
它们有类似微内核的设计

944
00:44:07,268 --> 00:44:08,493
Yeah, what browser?
什么浏览器？

945
00:44:09,539 --> 00:44:10,599
Chrome.

946
00:44:10,799 --> 00:44:15,351
Yes, Chrome, for security reasons, has a ton of different sandboxes.
没错 Chrome 为了安全 设计了多种沙箱

947
00:44:15,376 --> 00:44:16,483
You have the render in it.
渲染也在其中

948
00:44:16,593 --> 00:44:18,079
They created a model
他们创建了一个模型

949
00:44:18,104 --> 00:44:20,734
where they separated each thing into a different process, right?
将每个部分隔离在不同的进程中 对吧？

950
00:44:20,759 --> 00:44:24,979
Just like a microkernel has separate components running in isolated spaces.
就像微内核将不同组件运行在隔离的空间中

951
00:44:25,760 --> 00:44:31,038
Chrome used different processes to do that same isolation
Chrome 也通过不同的进程来实现这种隔离

952
00:44:31,063 --> 00:44:33,280
but they need a mechanism to talk to each other.
但它们需要一种机制来互相通信

953
00:44:33,463 --> 00:44:35,740
So they had to create mechanisms to do this.
因此 他们创建了相应机制实现这个

954
00:44:35,806 --> 00:44:38,426
And so you could see that
你可以把这个

955
00:44:38,459 --> 00:44:43,145
as like those ideas or the evolution of the microkernel design philosophy
看做微内核设计理念

956
00:44:43,146 --> 00:44:46,072
influencing modern day software that you use all the time.
影响着我们日常使用的软件

957
00:44:48,996 --> 00:44:50,798
Oh, and I highlighted message passing
哦 我还特别标注了消息传递

958
00:44:50,823 --> 00:44:55,383
because this will technology gods willing that
因为如果一切顺利的话

959
00:44:56,043 --> 00:44:57,145
this will be our first thing
这将是我们的首个目标

960
00:44:57,170 --> 00:45:01,065
that we'll actually get to play with the message passing part of mach
我们会玩一玩mach的消息传递部分

961
00:45:01,090 --> 00:45:03,086
and be able to use it to talk to different
用它与其他组件通信

962
00:45:03,087 --> 00:45:06,059
use it to really understand the IPC design there.
用它来深入理解mach的进程间通信设计

963
00:45:08,211 --> 00:45:11,059
This is kind of a weird thing that I only include here.
有个奇怪的事，我只在这里提了

964
00:45:11,084 --> 00:45:17,484
So they initially took this like version 2.5 of mach for the original XNU with Nextstep.
他们最初在NextStep的XNU， 用的 2.5 版本的 mach

965
00:45:17,677 --> 00:45:18,745
Then when they merged it in
他们将其合并进去时

966
00:45:18,770 --> 00:45:23,876
there's apparently this open source foundation mach kernel OS FMK.
有一个名为 OSFMK 的开源 mach 内核操作系统

967
00:45:23,916 --> 00:45:25,471
The only reason why I'm talking about this is
我之所以提到这个

968
00:45:25,496 --> 00:45:27,543
because this is the directory you are looking for
因为这就是你要找的目录

969
00:45:27,570 --> 00:45:29,103
when you're looking for mach stuff.
当你查找 mach 相关内容时

970
00:45:29,191 --> 00:45:30,283
And I always forget that.
我总是忘了这一点

971
00:45:30,356 --> 00:45:32,984
And I always never remember what the heck this thing means.
我总忘这个OSFMK是什么意思

972
00:45:33,009 --> 00:45:35,589
And I just like create acronyms in my head of like
我总爱在脑袋里编一些缩写

973
00:45:35,614 --> 00:45:39,144
something make is always what I think of because of the MK
总让我想起来xxx制造，因为这个mk

974
00:45:39,169 --> 00:45:40,211
but it's not
但其实不是

975
00:45:40,236 --> 00:45:41,716
it's the mach kernel.
mk 是 mach 内核

976
00:45:43,579 --> 00:45:47,166
So yeah, they, which includes parts of like mach three
它包括了部分 mach 3

977
00:45:47,191 --> 00:45:49,594
and some forks and all of their stuff.
和一些fork的，和之类的内容

978
00:45:49,619 --> 00:45:52,937
Anyways, it kind of was a conglomeration of everything.
总之 算是一个大杂烩

979
00:45:53,945 --> 00:45:54,669
So.
所以

980
00:45:55,400 --> 00:45:57,260
Just like every operating system
就像每个操作系统一样

981
00:45:57,377 --> 00:45:58,805
this is taken from Wikipedia
这是从维基百科摘来的

982
00:45:58,830 --> 00:46:01,330
so I apologize for the very terrible graphic
所以 抱歉 这张图很烂

983
00:46:02,916 --> 00:46:05,922
that I didn't create So I guess it's either my fault or not my fault
它不是我做的，我猜，这是也不是我的错

984
00:46:06,082 --> 00:46:07,482
depending on how you look at it.
这看你怎么想了

985
00:46:07,589 --> 00:46:08,551
So like every kernel
就像每个内核一样

986
00:46:08,576 --> 00:46:14,242
there is a differentiation between user mode and user space and the kernel itself.
用户空间和内核之间有区别

987
00:46:14,896 --> 00:46:15,856
I mean, simple question
问一个简单问题

988
00:46:15,857 --> 00:46:17,602
why do we have that differentiation?
为什么要有区别？

989
00:46:22,709 --> 00:46:24,189
For task, what's a task?
为了任务 什么是任务？

990
00:46:27,646 --> 00:46:31,038
Yeah, so every, like, the operating system, like,
是的，操作系统

991
00:46:31,063 --> 00:46:32,966
the goal of the operating system in the kernel, right
操作系统内核的目的是

992
00:46:32,967 --> 00:46:37,443
is to make sure that user space programs can do whatever they need to do
确保用户空间程序，能实现他们想做的

993
00:46:37,570 --> 00:46:39,240
without harming each other
而且不会互相干扰

994
00:46:39,369 --> 00:46:43,640
and dealing with access to hardware and everything because you, I mean
并处理硬件访问等所有事务。

995
00:46:44,060 --> 00:46:45,089
back in the DOS days
在 DOS 时代

996
00:46:45,129 --> 00:46:45,955
if I remember correctly
如果我没记错的话

997
00:46:45,980 --> 00:46:48,500
each application just used whatever memory it needed
应用可以直接用他们所需的内存

998
00:46:48,560 --> 00:46:50,260
had full access to everything.
并且可以访问所有资源

999
00:46:50,467 --> 00:46:53,340
And so you just couldn't run two applications at once.
所以你不能同时运行两个应用程序

1000
00:46:53,409 --> 00:46:54,426
This is like, I don't know
这就像 我不知道

1001
00:46:55,309 --> 00:46:57,153
maybe to people that think
可能对于那些

1002
00:46:57,373 --> 00:46:59,346
that radio was invented in the 70s
认为收音机是在 70 年代发明的人来说

1003
00:46:59,509 --> 00:47:01,150
it may seem like a shock
这可能会让他们感到惊讶

1004
00:47:01,226 --> 00:47:06,266
that a big evolution was running two programs at once instead of just one.
从一次运行1个程序，到2个，竟是一个大进步

1005
00:47:07,432 --> 00:47:09,492
Yeah, the telegraph what?
对 电报什么？

1006
00:47:10,733 --> 00:47:12,038
This is too much of a setup.
这简直是预设好的

1007
00:47:14,852 --> 00:47:16,265
But you know the telegraph.
但你知道电报

1008
00:47:16,714 --> 00:47:18,212
Do you know Morse code?
你知道摩尔斯电码吗？

1009
00:47:19,907 --> 00:47:20,730
Man, there you go.
666

1010
00:47:21,534 --> 00:47:23,149
I mean, you know what it is.
我意思，你知道它是什么意思

1011
00:47:23,174 --> 00:47:24,860
I don't know actual Morse code.
我不懂摩尔斯电码

1012
00:47:25,029 --> 00:47:25,654
That's pretty cool.
这挺酷的

1013
00:47:25,747 --> 00:47:28,338
But anyways, so you want this.
不过 想要

1014
00:47:28,363 --> 00:47:32,064
The idea was, hey, let, you have different implementations
这个想法是，让，这有不同的实现

1015
00:47:32,089 --> 00:47:34,906
but let each user space process
让每个用户空间进程

1016
00:47:35,573 --> 00:47:39,466
have access to what it thinks is all of the memory that it needs.
让它以为，能访问到所需的全部内存

1017
00:47:39,569 --> 00:47:41,883
But the operating system manages this lie
但操作系统会管好这个‘错觉’

1018
00:47:41,908 --> 00:47:45,132
so that two different processes can each access
让两个不同的进程，都能访问

1019
00:47:45,133 --> 00:47:47,313
what they think is the exact same memory
它们认为的同一块内存

1020
00:47:47,373 --> 00:47:49,180
but they never touch and never see anything.
但它们 互不干扰

1021
00:47:49,226 --> 00:47:52,844
So the The job of the kernel is to support this.
所以内核的工作就是实现这个

1022
00:47:52,869 --> 00:47:54,135
So this is why
这就是为什么

1023
00:47:54,329 --> 00:47:57,578
what we're absolutely not focusing on in this class is
本课程中，完全不会涉及

1024
00:47:57,615 --> 00:48:00,855
any like how to write a Mac app,
比如如何编写 Mac 应用

1025
00:48:00,935 --> 00:48:02,469
how to write an iPhone app
如何编写 iPhone 应用

1026
00:48:02,502 --> 00:48:05,655
how to write any kind of app that runs on this operating system.
如何编写，运行在这个操作系统上的任何应用

1027
00:48:05,695 --> 00:48:08,388
Because fundamentally, we don't care about all of this.
因为我们根本不关心这些

1028
00:48:08,568 --> 00:48:12,055
The only thing we care about is how to talk to the operating system.
我们唯一关心的是如何与操作系统通信

1029
00:48:12,715 --> 00:48:13,043
Right.
对

1030
00:48:13,068 --> 00:48:16,121
And that's through just like most things it's through a system call.
和大多数操作系统一样，通过系统调用

1031
00:48:16,221 --> 00:48:18,501
So we call into the operating system.
所以我们通过调用进入操作系统

1032
00:48:18,591 --> 00:48:21,556
because that is the interface between user space and kernel
因为这就是用户空间和内核之间的接口

1033
00:48:21,581 --> 00:48:23,032
where the process can say
进程可以要求

1034
00:48:23,033 --> 00:48:25,197
do something for me, right?
给我做点事 对吧？

1035
00:48:25,231 --> 00:48:26,917
And then like Justin was saying
就像贾斯汀说的那样

1036
00:48:26,977 --> 00:48:27,879
so on the kernel side
在内核这边

1037
00:48:27,904 --> 00:48:29,732
the kernel needs to manage all these different things.
内核需要管理这些不同的事务

1038
00:48:29,757 --> 00:48:32,438
The kernel also has its own stuff that it's doing.
内核也有自己的事要做

1039
00:48:32,463 --> 00:48:34,763
So it thinks about it in the form of a task.
它也是以任务的形式来处理

1040
00:48:35,098 --> 00:48:37,325
So you have different tasks that are doing different things.
所以有不同的任务在处理不同的事情

1041
00:48:37,350 --> 00:48:39,158
They get, I don't know
它们会……我也不清楚

1042
00:48:39,183 --> 00:48:40,564
have you guys taken like operating systems?
你们学过操作系统这门课吗？

1043
00:48:40,589 --> 00:48:42,319
So you know about like preempting
所以你们知道抢占

1044
00:48:42,363 --> 00:48:44,569
and like sharing resources and stuff, right?
还有资源共享之类的 对吧？

1045
00:48:44,629 --> 00:48:47,133
To make sure you don't deadlock, all this cool stuff.
确保不会死锁 这些事

1046
00:48:49,413 --> 00:48:51,579
But like I said, this Frankenstein thing
但就像我说的 这个拼凑怪物

1047
00:48:51,733 --> 00:48:53,501
rather than just saying, well, this is beautiful.
它没有直观的美

1048
00:48:53,526 --> 00:48:55,959
Like Linux, you could just say like Linux is the kernel
像 Linux 你可以直接说 Linux 就是内核

1049
00:48:56,237 --> 00:48:57,768
and it sure it has different components
当然 它有不同的组件

1050
00:48:57,793 --> 00:49:01,011
but it says one box, like Linux syscalls. When you look at the thing, right?
但它们可被视为一类 比如 Linux 系统调用 对吧？

1051
00:49:01,099 --> 00:49:02,666
You can see all the syscalls.
你能看到所有的系统调用

1052
00:49:02,820 --> 00:49:03,899
Here they're
这里

1053
00:49:04,026 --> 00:49:08,979
the BSD system calls and the mach system calls are completely different.
BSD 系统调用和 mach 系统调用 完全不同

1054
00:49:09,223 --> 00:49:12,056
And the way to think about it is the
理解这一点的关键是

1055
00:49:13,265 --> 00:49:14,403
it's not like a
这并不是说

1056
00:49:15,314 --> 00:49:16,034
what is it called
怎么说来着

1057
00:49:16,196 --> 00:49:17,762
like first among equals
平等中的首位（群龙之首）

1058
00:49:17,787 --> 00:49:20,354
or like where they're actually like at the same level.
他们实际在同一层级

1059
00:49:20,607 --> 00:49:22,408
Like one has to subsume the other
但一个必须包含另一个

1060
00:49:22,433 --> 00:49:25,379
which is the mach kernel is kind of like the real core.
这让 mach 内核更像是真正的核心

1061
00:49:25,467 --> 00:49:29,084
So because in like BSD, just like Linux
在 BSD 中跟 Linux 一样

1062
00:49:29,109 --> 00:49:30,763
you have the concept of like a task
有一个类似任务的概念

1063
00:49:30,836 --> 00:49:32,769
I can't remember if they call it a thread or something
我不记得他们是不是叫它线程了

1064
00:49:33,243 --> 00:49:35,591
but that just calls into the mach part
但它会调用进入mach

1065
00:49:35,616 --> 00:49:38,496
to be like what's the current thread and like passes it back.
当前的线程是什么 并将其返回

1066
00:49:38,794 --> 00:49:39,796
So it doesn't keep
所以它不会保留

1067
00:49:39,850 --> 00:49:42,205
because if you think about it, this makes sense, right?
因为仔细想想 这是有道理的 对吧？

1068
00:49:42,230 --> 00:49:44,110
You don't want to keep two different notions of like
你不想在内核中保留两种不同的概念

1069
00:49:44,216 --> 00:49:47,316
what is a process in two different places in your operating system kernel?
当一个进程出现在内核的2个不同地方，会是个什么情况

1070
00:49:47,378 --> 00:49:49,163
Because if you ever get them desynced
因为如果它们不同步了

1071
00:49:49,203 --> 00:49:50,943
you'll have absolute like calamity.
你会遇到大麻烦

1072
00:49:50,990 --> 00:49:54,199
So the source of truth is the mach kernel.
所以 mach 内核

1073
00:49:54,200 --> 00:49:56,163
It mainly handles like IPC
它主要负责进程间通信

1074
00:49:56,188 --> 00:50:00,526
like we talked about and we're going to get into next week of communication there.
像我们说过的，且下周会进一步讨论

1075
00:50:01,265 --> 00:50:03,117
Also does all the virtual memory.
它还负责虚拟内存

1076
00:50:03,142 --> 00:50:05,288
So this is why it's a super important part.
这就是为什么它非常重要

1077
00:50:05,426 --> 00:50:08,248
Protected memory, scheduling, preempting
保护内存、调度和抢占

1078
00:50:08,712 --> 00:50:10,818
I guess console IO
还有控制台的输入输出

1079
00:50:10,993 --> 00:50:14,198
whereas the BSD side does a lot more stuff that you're familiar with,
而 BSD 这边则负责你熟悉的许多其他功能

1080
00:50:14,418 --> 00:50:17,053
like file systems, networking
如文件系统和网络

1081
00:50:17,078 --> 00:50:20,612
the whole TCP IP stack is in here.
整个 TCP/IP 栈都在这里

1082
00:50:22,435 --> 00:50:25,649
BSD sockets, libraries, POSIX stuff
BSD 套接字、库和 POSIX 内容

1083
00:50:25,897 --> 00:50:27,463
I don't know, anything in there.
我不知道里面还有什么内容

1084
00:50:27,716 --> 00:50:29,263
So questions on this?
所以对此有什么问题吗？

1085
00:50:29,957 --> 00:50:30,509
Yeah.
问吧

1086
00:50:33,878 --> 00:50:34,676
Say it louder.
大声点说

1087
00:50:39,395 --> 00:50:39,916
yeah
嗯

1088
00:50:39,993 --> 00:50:42,153
so you will find out next week
下周就知道了

1089
00:50:43,006 --> 00:50:44,986
i don't want to yeah give it away
我不想提前透露

1090
00:50:45,093 --> 00:50:46,495
i mean we'll get into it
我们会深入讨论的

1091
00:50:46,520 --> 00:50:47,646
but there actually are
但实际上

1092
00:50:47,736 --> 00:50:50,437
what's interesting is there are fundamental differences
有趣的是，有一些根本上的差异

1093
00:50:50,438 --> 00:50:54,386
in how in what types of ipc they allow
在它们允许的进程间通信类型

1094
00:50:54,618 --> 00:51:00,473
so there's things that you can do with um uh port
你可以用 mach 端口做一些事

1095
00:51:00,498 --> 00:51:02,524
i think it's mach ports is what they're called
我记得 它们被称为 mach 端口

1096
00:51:02,978 --> 00:51:04,679
uh essentially the core difference
核心差异

1097
00:51:04,704 --> 00:51:10,197
which i'll is uh they are unidirectional not bi-directional
它们是单向的 而不是双向的

1098
00:51:10,430 --> 00:51:15,844
so you can have a port that only allows you to send or only allows you to receive
所以你可以拿到一个端口，它只能发，或者收

1099
00:51:16,031 --> 00:51:19,116
and so you can do interesting things with that
你可以用这种方式做很多有趣的事情

1100
00:51:19,171 --> 00:51:21,217
that you can't necessarily do with sockets
这些你可以不用socket实现

1101
00:51:21,971 --> 00:51:23,651
i don't know if there's like a practical difference
我不知道这有没有实际意义的区别

1102
00:51:23,677 --> 00:51:25,131
but it's interesting um
但确实很有趣

1103
00:51:26,354 --> 00:51:28,217
and you can also it has the uh
它还有

1104
00:51:29,709 --> 00:51:34,550
It has the concepts of privileges to it and also the ability
它有特权级的概念，还有

1105
00:51:34,682 --> 00:51:37,060
because the operating system controls all the ports
因为操作系统控制所有端口

1106
00:51:37,373 --> 00:51:39,875
so you can share that port
所以你可以共享这个端口

1107
00:51:40,053 --> 00:51:41,848
and delegate it to another process
并委托给另一个进程

1108
00:51:41,875 --> 00:51:44,299
and now it has those same rights that you had.
现在它有和你相同的权限

1109
00:51:44,813 --> 00:51:47,048
You can also give somebody a port with a right
你还可以，将要分享端口的权限

1110
00:51:47,073 --> 00:51:50,239
that says don't allow them to pass it on to anyone else.
设置成不许传递给别人

1111
00:51:51,027 --> 00:51:52,449
So this is how I
这就是

1112
00:51:52,450 --> 00:51:54,482
this is actually like these ports and this concept is
实际上

1113
00:51:54,507 --> 00:51:56,916
how the operating system allows you to do debugging
操作系统就是按照这个概念，让你进行调试

1114
00:51:56,941 --> 00:51:59,958
and get super privileged access to things.
和获得超级权限，访问东西的

1115
00:51:59,983 --> 00:52:01,598
So it actually, I mean
所以说 我意思是

1116
00:52:01,623 --> 00:52:01,998
I don't know.
我也不知道

1117
00:52:02,023 --> 00:52:02,716
Why am I talking about this?
我为什么说到这个？

1118
00:52:02,763 --> 00:52:03,629
We'll talk about this next week.
我们下星期再讲

1119
00:52:03,839 --> 00:52:05,083
Anyways, okay.
好吧 不管怎样

1120
00:52:05,243 --> 00:52:06,163
Other questions about this?
还有其他问题吗？

1121
00:52:06,216 --> 00:52:06,656
Sorry.
对不起

1122
00:52:12,176 --> 00:52:13,289
What do you mean by stable?
你说的稳定是什么意思？

1123
00:52:19,531 --> 00:52:20,136
Hmm.
嗯

1124
00:52:21,995 --> 00:52:22,956
Great question.
好问题

1125
00:52:23,996 --> 00:52:25,138
Our goal today is
我们今天的目标是

1126
00:52:25,163 --> 00:52:28,290
we're going to walk through and figure out exactly what happens on a syscall.
弄清楚系统调用具体是怎么回事

1127
00:52:28,798 --> 00:52:31,023
But that won't answer your question of if it's stable or not
但这无法回答它是否稳定的问题

1128
00:52:31,048 --> 00:52:33,283
 until you diff it over multiple versions.
除非你在多个版本之间进行对比

1129
00:52:34,859 --> 00:52:36,049
It's stable-ish.
还算挺稳定的

1130
00:52:36,183 --> 00:52:40,743
I think like as a, it is because
我觉得 这是因为

1131
00:52:40,810 --> 00:52:43,176
so I think the way to think about those things, right
我觉得 应该这样想

1132
00:52:43,216 --> 00:52:45,796
is on Windows you're not really supposed to directly
在windows上，你不应该直接

1133
00:52:45,836 --> 00:52:48,759
like a user space app is not supposed to call a system call.
用户空间的应用不该直接调用系统调用

1134
00:52:49,326 --> 00:52:52,663
There's the, what's the library? Win32 DLL or Win64 DLL.
 有个什么库来着？Win32 DLL 还是 Win64 DLL

1135
00:52:52,833 --> 00:52:56,628
There's a user space DLL that on Windows you are supposed to call this DLL
在windows上，你应该调用一个在用户空间的dll

1136
00:52:56,653 --> 00:52:58,591
or NT32DLL.
还是 NTDLL.dll

1137
00:52:58,685 --> 00:52:59,333
What is it?
是什么呢？

1138
00:53:00,133 --> 00:53:02,023
Yeah. Kernel 32 DLL or whatever it is.
对 Kernel32.DLL 或别的，不管了

1139
00:53:02,056 --> 00:53:03,218
Anyways, there's a DLL
总之 有个 DLL

1140
00:53:03,243 --> 00:53:05,318
which is a user space library that you call.
一个你可以调用的用户空间库

1141
00:53:05,343 --> 00:53:07,696
It's basically like a libC for the kernel.
它就像是内核的 libC

1142
00:53:07,818 --> 00:53:08,958
Like you call into there
你调用进入它

1143
00:53:09,009 --> 00:53:10,584
and then it translates whatever you're doing
然后它将你的操作

1144
00:53:10,609 --> 00:53:12,503
into a system call that the kernel does
转换成内核执行的系统调用

1145
00:53:12,536 --> 00:53:14,508
and it sends it back and that translates it back.
等内核将结果发回，它再转换回来

1146
00:53:14,533 --> 00:53:16,522
So this way, as long as
所以这样 只要

1147
00:53:16,942 --> 00:53:19,916
Microsoft knows that all the user space apps
微软知道 这样对于用户空间应用

1148
00:53:20,005 --> 00:53:22,124
that they're not going to break compatibility go through there.
不会破坏兼容性

1149
00:53:22,149 --> 00:53:24,382
They can do all kinds of crazy, clever stuff in there
微软可以在kernel32.dll中做修改

1150
00:53:24,467 --> 00:53:26,338
to deal with different OS versions
以应对不同操作系统版本

1151
00:53:26,363 --> 00:53:27,883
and the OS can change.
就可以放心改操作系统了

1152
00:53:28,043 --> 00:53:33,756
Whereas on Linux, the boundary is on the system call layer.
而在 Linux 上 做了系统调用分层

1153
00:53:33,923 --> 00:53:39,229
So if you want to be able to run an app always from an old version of Linux to a new version
如果你想让一个程序能兼容新老linux版本

1154
00:53:39,230 --> 00:53:41,499
the system call numbers have to remain constant.
那么系统调用号需保持不变

1155
00:53:41,730 --> 00:53:44,926
So Apple is much more in that camp, I would say, where they...
所以我认为苹果在这方面更为慎重 他们......

1156
00:53:45,859 --> 00:53:51,733
The interface is between the user space app and the system call interface is the AVI.
用户应用和系统调用之间的接口是AVI

1157
00:53:52,024 --> 00:53:57,090
But the caveat and the ish is that unlike Windows
但是与 Windows 不同的是

1158
00:53:57,117 --> 00:54:01,078
which prides itself on being able to take an app from Windows 95.
Windows 以能够支持从 Windows 95 时代的应用而自豪

1159
00:54:01,143 --> 00:54:04,654
Have you guys heard the stories about Windows where like they add
你们听过 Windows 会添加

1160
00:54:04,655 --> 00:54:08,577
there are literal shims in either the operating system or this DLL that say
操作系统或 DLL 中有修补代码

1161
00:54:08,578 --> 00:54:14,946
if your application is SimCity, then... and it's targeting Windows 95
如果你的应用是《模拟城市》 并且系统是 Windows 95

1162
00:54:15,059 --> 00:54:17,563
then do this behavior that it's expecting
那么就执行这个操作

1163
00:54:17,655 --> 00:54:19,811
but that's wrong and incorrect behavior
但这种行为是错的，是不对的

1164
00:54:19,836 --> 00:54:23,863
because they tried to take the operating system
因为他们试图修改操作系统

1165
00:54:24,403 --> 00:54:25,724
they upgraded the operating system
他们升级了操作系统

1166
00:54:25,725 --> 00:54:26,958
realized that the app fails
发现应用程序无法运行

1167
00:54:26,983 --> 00:54:29,844
they would add in app-specific shims in the OS
他们会在系统中，添加特定应用的兼容代码

1168
00:54:29,869 --> 00:54:31,475
to support those applications.
来支持这些应用

1169
00:54:31,613 --> 00:54:35,426
So Windows has prided themselves on this backwards compatibility.
所以 Windows 一直以向后兼容性为荣

1170
00:54:35,475 --> 00:54:36,753
Apple does not have that at all.
Apple 完全不会这样做

1171
00:54:36,813 --> 00:54:38,274
So there's absolutely no guarantee
所以完全不能保证

1172
00:54:38,299 --> 00:54:40,766
that your app that worked on this thing will work on the next thing.
能在这个系统运行的应用，也能在后面的运行

1173
00:54:40,799 --> 00:54:42,813
They'll just be like, yeah you're just going to have to recompile it.
他们会说，你只需要重新编译就行

1174
00:54:42,866 --> 00:54:43,865
Like, tough.
没办法 就是这么严苛

1175
00:54:44,179 --> 00:54:45,201
So that, I think
所以 我觉得

1176
00:54:45,379 --> 00:54:48,672
they don't force themselves into having that compatibility.
他们不会硬生生地实现那种兼容性

1177
00:54:49,364 --> 00:54:50,619
But it's pretty stable, I think.
但我觉得它很稳定

1178
00:54:50,712 --> 00:54:53,732
And maybe we can look at, like the Git history and see how often it changes.
我们可以看看 Git 历史记录 看看它多久改一次

1179
00:54:53,778 --> 00:54:54,738
I think not very often.
我觉得不会经常改

1180
00:54:55,930 --> 00:54:56,540
Cool. All right.
酷，好的

1181
00:54:56,565 --> 00:54:57,642
In fact, it's 5.30.
现在 5 点 30 了

1182
00:54:57,667 --> 00:54:58,770
Let's take a five-minute break.
我们休息五分钟

1183
00:54:59,971 --> 00:55:00,800
And then we'll get back to it.
然后继续

1184
00:55:00,825 --> 00:55:01,752
And then we'll...
接下来我们...

1185
00:55:01,866 --> 00:55:02,845
Read the source.
看一下代码

1186
00:55:09,121 --> 00:55:10,856
All right, Twitch, we're taking a break.
好了 Twitch 咱们休息一下

1187
00:55:11,403 --> 00:55:12,891
Go turn on the TV
去把电视打开

1188
00:55:12,916 --> 00:55:13,970
and watch an ad or something.
看看广告之类的

1189
01:04:27,856 --> 01:04:31,417
Okay, we're about to come back.
好的 我们马上回来

1190
01:04:31,418 --> 01:04:33,656
We're just testing that these changes worked.
我们正在测试这些改动是否有效

1191
01:04:33,702 --> 01:04:35,569
I'm feeling pretty confident about it.
我对此很有信心

1192
01:04:36,142 --> 01:04:37,149
The audience is not.
观众却不这样认为

1193
01:04:37,236 --> 01:04:42,042
They're booing and they were hissing when the audio was off.
禁音时，他们都在嘘

1194
01:04:42,127 --> 01:04:47,479
so hopefully we can prove them incorrect with this.
希望能证明他们是错的

1195
01:04:49,626 --> 01:04:51,446
I don't want to wait like five minutes.  Okay.
我不想等五分钟 好吧

1196
01:04:54,949 --> 01:04:55,568
This is the other thing.
这是另一点

1197
01:04:55,569 --> 01:04:57,106
So taking, this does take a long time.
这需要很长时间

1198
01:04:57,131 --> 01:05:00,417
So yanking the files to your local machine and getting it to run locally will be
把文件拉到本地机器上运行

1199
01:05:00,531 --> 01:05:01,897
you'll be much better.
会好很多

1200
01:05:02,257 --> 01:05:03,330
And you should be able to
你应该能

1201
01:05:03,373 --> 01:05:05,279
this previous emulator is also open source.
这个previous模拟器也是开源的

1202
01:05:05,304 --> 01:05:08,217
So you should be able to compile it on your own system and get it to run.
所以你可以在自己的系统上编译并运行它

1203
01:05:08,346 --> 01:05:09,253
Since you all run Linux
因为你们都用 Linux

1204
01:05:09,253 --> 01:05:10,226
this should be very easy
这应该很简单

1205
01:05:10,251 --> 01:05:12,866
because it just needs an X server to run.
因为它只需要一个 X 服务器就能运行

1206
01:05:17,933 --> 01:05:18,600
Okay.
好的

1207
01:05:20,856 --> 01:05:22,999
This actually gets to a good point of,
这引出一个好的点

1208
01:05:25,279 --> 01:05:29,939
any kind of thing when doing development or vulnerability analysis or exploitation
无论是在程序开发、漏洞分析还是漏洞利用开发时

1209
01:05:30,080 --> 01:05:35,392
the shorter you can make your test, make a change, test it, loop
测试、修改、再测试的循环越短

1210
01:05:35,541 --> 01:05:37,365
the happier you will be as a person.
你的心情就会越好

1211
01:05:37,483 --> 01:05:39,586
Sitting here waiting for this stupid thing to just do this
坐等这破事

1212
01:05:39,803 --> 01:05:40,764
can drive you crazy
会让人抓狂

1213
01:05:40,816 --> 01:05:43,724
so have other ways of doing it
用别的方法做这个

1214
01:05:44,523 --> 01:05:45,843
I would recommend...
我推荐

1215
01:05:46,429 --> 01:05:48,109
Okay, so as this is going
好的 让它在这跑着

1216
01:05:48,143 --> 01:05:52,939
we can go back and start talking about the source.
我们回过头来谈谈源代码

1217
01:05:53,058 --> 01:05:54,278
So since they have source
既然有源代码

1218
01:05:54,279 --> 01:05:55,079
we should use it.
我们就可以用它

1219
01:05:55,080 --> 01:05:56,775
We should not be silly and not use it.
我们可不能傻到不用它

1220
01:05:56,820 --> 01:05:58,662
That would be not cool.
那就不酷了

1221
01:05:58,700 --> 01:06:00,343
So, oh, no, why would you go there?
所以 哦，怎么跑这来了？

1222
01:06:02,123 --> 01:06:02,950
Well, because you're...
嗯 因为你……

1223
01:06:05,410 --> 01:06:06,903
So once I find it.
所以 等我找到它

1224
01:06:08,567 --> 01:06:10,736
Okay, so you can actually go.
好的 你可以开始了

1225
01:06:10,763 --> 01:06:13,156
Apple has a whole open source Apple thing.
苹果有一整套开源项目

1226
01:06:14,630 --> 01:06:16,309
You can see all the open source stuff.
你可以看到所有开源的内容

1227
01:06:16,310 --> 01:06:18,591
There are stuff that we are absolutely not gonna talk about.
有些我们肯定不会讨论

1228
01:06:18,592 --> 01:06:20,113
Why aren't we gonna talk about Swift?
为什么我们不讨论 Swift？

1229
01:06:23,997 --> 01:06:25,196
That may not be true. I don't know.
那可能不对 我不清楚

1230
01:06:25,221 --> 01:06:26,266
I've heard good things.
我听到了些好的回答

1231
01:06:29,216 --> 01:06:31,550
Yeah, Swift is for making user mode programs.
是的 Swift 用于编写用户模式程序

1232
01:06:31,743 --> 01:06:34,470
And Swift, if you make a user mode program in Swift
如果你用 Swift 编写用户模式程序

1233
01:06:34,517 --> 01:06:37,340
it has to talk to the kernel and eventually it will need to make a syscall
它需要与内核通信，最终它会进行系统调用

1234
01:06:37,442 --> 01:06:40,702
and so you can all do that in C. You don't need Swift to do any of that.
你用 C 语言也可以做这些 不需要用 Swift

1235
01:06:42,123 --> 01:06:42,423
I don't know.
我不知道

1236
01:06:42,476 --> 01:06:44,029
I guess if somebody's really crazy
如果有人足够疯狂

1237
01:06:44,082 --> 01:06:46,122
they can write their exploits in Swift
他们可以用 Swift 写漏洞利用程序

1238
01:06:46,216 --> 01:06:47,649
but I would absolutely not recommend it.
但我绝对不建议这样做

1239
01:06:47,822 --> 01:06:50,749
You should be doing your stuff in C when you're talking to the kernel.
当程序要与内核交互时，你应该用 C 编写

1240
01:06:51,846 --> 01:06:53,422
They also do Kubernetes.
他们还有 Kubernetes 相关的

1241
01:06:53,707 --> 01:06:56,149
They also create WebKit.
他们还开发了 WebKit 浏览器引擎

1242
01:06:56,196 --> 01:06:58,909
So WebKit is an open source.
WebKit 是一个开源的

1243
01:06:59,108 --> 01:07:03,411
I believe it's like the content engine of like parsing HTML and doing all this stuff.
我记得，它主要用于解析和处理HTML相关功能

1244
01:07:03,748 --> 01:07:04,348
So you can actually
所以你可以

1245
01:07:04,414 --> 01:07:05,910
which is used in a ton of places.
它广泛应用于各种场景

1246
01:07:05,911 --> 01:07:09,861
Like WebKit is actually used in a lot of browsing engines.
WebKit 实际上被用在很多浏览器引擎里

1247
01:07:10,733 --> 01:07:14,019
And so you can kind of see this cool, like almost cycle of life, right?
这几乎是一个生态圈，对吧

1248
01:07:14,126 --> 01:07:18,879
Where like next XNU was on next and.
XNU 内核在NextStep机器上

1249
01:07:19,686 --> 01:07:21,021
That created the web
用它创建了web

1250
01:07:21,022 --> 01:07:24,823
and then eventually the people that made that created WebKit
然后那些人又创建了 WebKit

1251
01:07:24,824 --> 01:07:26,343
this open browser engine
这个开源的浏览器引擎

1252
01:07:26,344 --> 01:07:27,205
and then gave it back.
然后再把它贡献回去

1253
01:07:27,250 --> 01:07:28,570
So I think that's kind of cool.
我觉得这挺酷的

1254
01:07:30,670 --> 01:07:33,690
There's a lot of projects that they have that are open source.
他们有很多项目都是开源的

1255
01:07:33,890 --> 01:07:34,668
I don't know what this is.
我不知道这是什么

1256
01:07:34,669 --> 01:07:37,590
FoundationDB, MLX, CareKit, ResearchKit.

1257
01:07:37,731 --> 01:07:39,631
maybe some of you all need this.
也许你们有些人用得上这个

1258
01:07:39,964 --> 01:07:41,517
Oh, Medical Research.
哦 医学研究

1259
01:07:41,574 --> 01:07:41,971
Okay.
好的

1260
01:07:42,854 --> 01:07:44,284
Password Manager Researches.
密码资源管理器

1261
01:07:44,354 --> 01:07:45,417
Interesting.
真有趣

1262
01:07:48,812 --> 01:07:50,391
Oh, interesting, that they participate in.
哦有趣 他们参与了

1263
01:07:50,392 --> 01:07:52,312
So they're big in LLVM and Clang.
他们在 LLVM 和 Clang 很活跃

1264
01:07:52,372 --> 01:07:54,285
Clang is the default compiler that they use.
Clang 是他们默认的编译器

1265
01:07:58,445 --> 01:08:01,836
Anyways, so let's see what are all the C?
好的，看看有哪些 C 开发的？

1266
01:08:03,689 --> 01:08:05,862
Okay, so that's everything that's on there.
这就是上面所有的内容

1267
01:08:05,923 --> 01:08:07,229
If you wanted to poke around it
如果你想深入了解一下

1268
01:08:07,683 --> 01:08:10,045
they used to just distribute like tarballs.
他们以前都是直接分发 tarball 文件

1269
01:08:10,046 --> 01:08:12,547
So there would just be a massive list
所以会有个长长的列表

1270
01:08:12,548 --> 01:08:15,319
with all of these tarballs of their source releases.
包含所有发布的源码 tarball

1271
01:08:16,120 --> 01:08:19,380
Ironically, they now have everything on, GitHub
讽刺的是 他们现在把所有东西都放在了 GitHub 上

1272
01:08:19,452 --> 01:08:22,328
and the reason I say ironically is because GitHub is owned by Microsoft
我说讽刺，是因为 GitHub 是微软的

1273
01:08:22,353 --> 01:08:29,064
so the fact that the company that they were fighting for so long
他们曾经长期对抗的公司

1274
01:08:29,065 --> 01:08:30,048
now they rely on them
现在却依赖这家公司

1275
01:08:30,049 --> 01:08:33,553
for distributing their own code is very bizarre to me.
来分发自己的代码 这感觉很奇怪

1276
01:08:35,883 --> 01:08:36,802
And so you can see
你可以看到

1277
01:08:36,803 --> 01:08:38,396
you can get very lost in here.
这里很容易让人迷失方向

1278
01:08:38,483 --> 01:08:40,444
I mean, you can poke around all you want
你可以随便逛逛

1279
01:08:40,445 --> 01:08:43,123
but there's like 509 repositories in here.
这里有 509 个仓库

1280
01:08:44,147 --> 01:08:46,670
The pinned repositories are probably where you all want to start.
这些置顶的项目，你们大概率想从这里开始

1281
01:08:46,743 --> 01:08:48,903
I was actually talking to somebody, some people here.
我跟这里的一些人聊过

1282
01:08:49,255 --> 01:08:51,108
I don't know when this was last updated, but
我不知道最后一次更新是什么时候

1283
01:08:51,133 --> 01:08:52,133
yeah, three years ago.
三年前

1284
01:08:52,639 --> 01:08:57,839
Actually, so Apple did sell like an OS X server.
其实 苹果确实出售过 OS X 服务器

1285
01:08:57,946 --> 01:09:02,083
So like a server version of their whole operating system.
他们服务器的操作系统

1286
01:09:04,628 --> 01:09:05,990
I don't think anyone uses this.
我觉得没人用了

1287
01:09:05,991 --> 01:09:08,411
This is like a super out-of-date thing
这东西已经过时了

1288
01:09:08,412 --> 01:09:10,815
and I don't even think they support it or sell it now or anything.
他们现在好像也不支持，不卖了

1289
01:09:12,136 --> 01:09:16,203
But you can find Mac OS, the iOS
但你还能找到 Mac OS 和 iOS

1290
01:09:16,249 --> 01:09:18,216
and I don't know what this developer's tools thing is.
还有这个，我不太清楚的 开发者工具

1291
01:09:19,729 --> 01:09:21,096
And clicking on here
点击进入这里

1292
01:09:23,965 --> 01:09:26,776
they're basically using Git submodules
他们基本上是使用 Git 子模块

1293
01:09:26,849 --> 01:09:30,723
in order to point to other commits in the other repositories.
来指向其他仓库中的提交

1294
01:09:31,963 --> 01:09:33,370
And the other tricky thing here is
另一个问题是

1295
01:09:33,395 --> 01:09:34,867
you'd see like, oh, main.
一看到  main

1296
01:09:34,868 --> 01:09:36,888
Yes, Mac OS 14.0.
Mac OS 14.0

1297
01:09:36,930 --> 01:09:39,556
Great. This is where we absolutely are.
好的 我们现在肯定在这里

1298
01:09:41,270 --> 01:09:43,074
I don't know that that's the latest.
不确定这是否是最新版

1299
01:09:43,075 --> 01:09:45,801
You have to either go to branches or tags.
你可以去分支或标签

1300
01:09:46,098 --> 01:09:46,890
Tags, yeah.
标签 没错

1301
01:09:46,998 --> 01:09:47,891
So tags is a better thing.
所以看标签更好

1302
01:09:47,916 --> 01:09:52,569
You can see they actually just pushed a release three weeks ago for Mac OS 14.6
你可以看到 他们三周前发布了 Mac OS 14.6

1303
01:09:53,636 --> 01:09:54,905
which actually is a pretty good...
这个版本其实挺不错的……

1304
01:09:59,256 --> 01:09:59,969
Let's see.
我们来看看

1305
01:10:01,857 --> 01:10:05,288
This was in July, so July, August, September.
这是在七月发布的 七月、八月、九月（视频录制月份）

1306
01:10:05,313 --> 01:10:07,613
Yeah, two-month gap before releasing it.
发布前确实隔了两个月

1307
01:10:07,873 --> 01:10:08,693
It's pretty good.
还不错

1308
01:10:10,161 --> 01:10:13,966
But the other thing you'll notice is
还有

1309
01:10:14,025 --> 01:10:16,564
so you want to use the tags.
所以要看Tags标签

1310
01:10:16,614 --> 01:10:18,727
The tags are absolutely how they do all this thing.
标签是他们处理这一切的关键

1311
01:10:19,068 --> 01:10:22,868
And then, wait, no I don't want the commit.
我不想看commit记录

1312
01:10:22,869 --> 01:10:25,816
I want to browse the tag.
我想看看标签

1313
01:10:25,992 --> 01:10:29,594
So they have a bunch of directories in here.
这里有好几个目录

1314
01:10:29,634 --> 01:10:31,906
Each of these is
这里的每一个都是

1315
01:10:32,116 --> 01:10:34,455
its own project that's basically now pinned to that version
它们自己项目的一个固定版本

1316
01:10:34,456 --> 01:10:38,213
that works with that distribution of the entire operating system.
放在这个操作系统版本发布

1317
01:10:38,259 --> 01:10:39,699
So for this purposes
为此

1318
01:10:39,700 --> 01:10:42,920
we'll call like operating system kind of everything, all this junk.
这一大堆东西我们也称为操作系统

1319
01:10:42,921 --> 01:10:46,164
And then we'll talk about XNU is like the kernel that we'll actually focus on.
之后我们会讨论XNU，它是我们实际关注的内核

1320
01:10:47,425 --> 01:10:49,634
So I have absolutely no idea what all this stuff is.
所以我完全不知道这些东西是什么

1321
01:10:49,667 --> 01:10:51,486
Some of the stuff I kind of have a rough idea
有些东西我大概有点概念

1322
01:10:51,487 --> 01:10:52,646
but other stuff I don't.
但其他的我就不知道了

1323
01:10:52,687 --> 01:10:55,081
Some of it is user space things like...
有些是用户空间的东西 比如...

1324
01:10:57,747 --> 01:10:59,536
Like, oh, there's, was there libc?
比如 这里有 libc 吗？

1325
01:10:59,588 --> 01:11:01,467
Yeah, there libc is open source
有，libc 是开源的

1326
01:11:01,468 --> 01:11:03,669
that you can just go check out that runs in user space
你可以看看，它运行在用户空间

1327
01:11:03,670 --> 01:11:05,376
and that the user space programs use.
并被用户空间程序使用

1328
01:11:05,400 --> 01:11:10,263
I bet you could find in there one of the big things they did within the last year was
我肯定你能找到，去年他们做的最大的修改之一，

1329
01:11:11,394 --> 01:11:15,694
the user space allocator always zeros pages, like user,
用户空间的内存分配器 总会清零 内存页面

1330
01:11:15,695 --> 01:11:18,883
sorry, not pages, but zeros memory on a free.
抱歉 不是内存页面 而是在释放内存时清零

1331
01:11:19,218 --> 01:11:22,458
So to reduce the chances of a use after free or other weird stuff,
这样可以减少释放后再使用或出现其他奇怪问题的几率

1332
01:11:22,459 --> 01:11:24,779
it just like every time you free memory, it gets zeroed.
每次释放内存时，它都会被清零

1333
01:11:24,780 --> 01:11:25,365
And so...
所以......

1334
01:11:25,784 --> 01:11:27,045
I thought that's pretty interesting.
我觉得这挺有意思的

1335
01:11:27,072 --> 01:11:28,598
I bet that logic is in there.
我相信它里面有这个机制

1336
01:11:30,987 --> 01:11:33,225
WebKit, like we said, so the version of WebKit.
WebKit 我们之前说的，这是他的版本

1337
01:11:33,289 --> 01:11:35,409
Apache, this is kind of weird that they do this
Apache，放它进来做挺奇怪的

1338
01:11:35,410 --> 01:11:36,392
but things like Bash
但像 Bash 这样的

1339
01:11:36,432 --> 01:11:40,723
even like I know some of you know, well
像，我知道你们有人知道

1340
01:11:41,013 --> 01:11:43,138
I guess fake Adam that was here the first day loves Bash
第一天的那个假Adam（Yan），特别喜欢 Bash

1341
01:11:43,163 --> 01:11:46,096
and so maybe you can troll him
也许你们可以戏弄一下他

1342
01:11:46,121 --> 01:11:49,679
by finding subtle differences that Apple has made in this version of Bash
找一个苹果改过的，与原版有微妙差异的bash

1343
01:11:49,680 --> 01:11:50,980
which is the version that they ship
就是这里他们发的版本

1344
01:11:50,981 --> 01:11:57,124
that maybe makes some of the Linux Luminarium problems even crazier or not as useful
放到linux上 可能会让一些 Linux 问题更严重  或不好用

1345
01:11:57,461 --> 01:11:59,461
so there's a lot of like user space apps
这里有许多用户空间的应用程序

1346
01:11:59,508 --> 01:12:05,123
and a bunch of junk in here curl file anyways
还有很多其他的工具 比如 curl、file

1347
01:12:06,082 --> 01:12:07,876
so you can explore this your heart's content
所以你可以尽情探索这些库

1348
01:12:08,003 --> 01:12:12,083
libraries a ton of libraries libxml2
有很多库 比如 libxml2

1349
01:12:12,123 --> 01:12:13,680
this is one if you wanted to look for bugs
如果想找漏洞 这是个好地方

1350
01:12:13,705 --> 01:12:16,482
this would be a great place to look for it in an xml parser
XML 解析器是个好目标

1351
01:12:17,088 --> 01:12:18,822
people have found cool bugs in there
人们在那里，发现了一些很酷的漏洞

1352
01:12:20,362 --> 01:12:22,763
let's see python
再看看， Python

1353
01:12:22,810 --> 01:12:24,917
even the python version that they ship is
他们提供的 Python 版本

1354
01:12:25,757 --> 01:12:28,512
I actually don't know if it's customized or they've forked it completely.
我不知道是定制化过的，还是完全拷过去的

1355
01:12:28,513 --> 01:12:31,276
I've never done like a diff to see what's what.
我没用diff看过两者差异

1356
01:12:31,476 --> 01:12:32,949
Ruby, rsync.

1357
01:12:33,597 --> 01:12:35,849
And then I'm just naming things.
我就说说名字

1358
01:12:35,938 --> 01:12:37,117
Vim, if you like Vim.
Vim 如果你喜欢Vim的话

1359
01:12:38,062 --> 01:12:40,369
And then all the way at the bottom, you have XNU.
然后最底部是 XNU

1360
01:12:40,402 --> 01:12:43,649
So this is where the heart of everything is.
这里就是一切的核心

1361
01:12:44,268 --> 01:12:45,489
You go in here.
你进到这里

1362
01:12:48,697 --> 01:12:50,519
Now this is the
现在这是

1363
01:12:50,878 --> 01:12:52,358
and this should be tagged.
标签应该是

1364
01:12:52,546 --> 01:12:54,766
Yeah, so what's this? 14...
嗯 这个版本是  14...

1365
01:12:55,452 --> 01:12:56,499
10... Wow.
10... 哇

1366
01:12:57,285 --> 01:12:58,865
So the other super annoying thing is
另一件特别让人头疼的是

1367
01:12:58,866 --> 01:13:00,539
that there's different version numbers.
版本号各不相同

1368
01:13:00,566 --> 01:13:03,399
So there's some chart.
这里有个表格

1369
01:13:12,949 --> 01:13:14,213
I think it's in here.
应该就在这

1370
01:13:18,175 --> 01:13:18,926
Yeah.
嗯

1371
01:13:19,232 --> 01:13:22,410
So there's like, oh, no, that's, oh, see, HomePod software.
哦 看 HomePod 软件

1372
01:13:22,832 --> 01:13:23,526
So they...
所以他们……

1373
01:13:24,096 --> 01:13:26,683
Anyway, so there's versions that you may be used to thinking about,
有你可能比较熟悉的版本

1374
01:13:26,716 --> 01:13:28,005
like your Mac OS version.
比如 MacOS 版本

1375
01:13:28,006 --> 01:13:35,639
Like, let's see this Mac is probably running Sonoma, which is 14.6.1.
比如说，这台 Mac 运行的是 Sonoma 即 14.6.1

1376
01:13:36,151 --> 01:13:38,097
Important thing here is that
这里重要的是

1377
01:13:38,151 --> 01:13:41,652
this other thing is like a unique hash or part of a unique identifier
这个东西像个唯一的哈希 或是唯一标识符的一部分

1378
01:13:41,676 --> 01:13:44,437
that identifies usually this specific...
通常用于识别...

1379
01:13:45,097 --> 01:13:47,157
I think it goes back to the kernel.
我认为这个标识内核

1380
01:13:49,078 --> 01:13:51,893
And your iPhone, so you have iOS. I don't know what version is it on?
还有 iPhone， iOS  多少多少

1381
01:13:51,918 --> 01:13:55,062
 16, 17, 18, something, a version number.
16、17、18 某一个版本号

1382
01:13:55,063 --> 01:13:56,102
But then you have that.
然后是

1383
01:13:56,103 --> 01:13:57,603
You have Darwin numbers.
Darwin 版本号

1384
01:13:57,604 --> 01:13:58,944
Darwin has different numbers
Darwin 有不同的版本号

1385
01:13:58,945 --> 01:14:00,229
which is like the whole thing.
这就像整个系统

1386
01:14:00,429 --> 01:14:02,747
And then you have the actual XNU numbers
然后是实际的 XNU 版本号

1387
01:14:02,748 --> 01:14:06,396
which is what we looked at in here.
就是我们这里看到的

1388
01:14:06,671 --> 01:14:09,090
Like these are all different XNU numbers.
这些都是不同的 XNU 版本号

1389
01:14:09,128 --> 01:14:12,043
I don't know exactly what they mean or how to parse them.
我不知道它们具体代表什么，或该怎么解析

1390
01:14:12,097 --> 01:14:13,650
You can think of them just as opaque.
你可以认为它们是不透明的

1391
01:14:14,559 --> 01:14:16,403
But you should always be able to do...
但你应该能...

1392
01:14:16,503 --> 01:14:17,210
I'm not here.
我不在

1393
01:14:19,553 --> 01:14:21,063
Wait, did it not work?
等等 静音时的修改失败了吗？

1394
01:14:23,256 --> 01:14:24,997
Sorry, we have to check if it works.
抱歉 我们得检查一下

1395
01:14:26,218 --> 01:14:27,123
This is critical.
这太关键了

1396
01:14:29,959 --> 01:14:31,163
Where's my thing?
我的东西呢？

1397
01:14:43,843 --> 01:14:44,743
That seems bad.
这不太妙

1398
01:14:49,906 --> 01:14:51,233
I know.  Okay.
我知道 好的

1399
01:14:51,326 --> 01:14:52,546
I don't care that much.
我没那么在乎

1400
01:14:52,813 --> 01:14:54,599
I mean, except for the fact that this is insane.
我是说 这太怪了

1401
01:14:54,716 --> 01:14:55,746
I am control d.
我按了ctrl d

1402
01:14:56,358 --> 01:14:57,400
That's how I exit.
这就是我退出的方法

1403
01:14:58,696 --> 01:14:59,322
All right.
好吧

1404
01:15:11,860 --> 01:15:13,053
what?
什么

1405
01:15:22,200 --> 01:15:24,056
It's supposed to do...
他本应...

1406
01:15:37,087 --> 01:15:38,669
Where's the stupid thing?
那玩意儿在哪儿？

1407
01:15:43,463 --> 01:15:45,549
Searching for open was a bad idea.
查找 open 真是个糟糕的主意

1408
01:15:50,108 --> 01:15:55,013
W orld W ide W eb.app.

1409
01:16:00,726 --> 01:16:01,500
Yeah.
嗯

1410
01:16:02,553 --> 01:16:03,966
The keystroke missed there.
那儿的按键没打到

1411
01:16:04,553 --> 01:16:05,773
That's so annoying.
真烦人

1412
01:16:06,915 --> 01:16:08,394
Well, all right.
好吧 行

1413
01:16:08,395 --> 01:16:10,733
I'll figure out what I can do to make this run better.
我会想出办法让这运行得更好

1414
01:16:11,931 --> 01:16:14,866
Can you write it to a script and execute the script?
你能把它写成脚本然后执行吗？

1415
01:16:17,796 --> 01:16:21,093
You still need to type in stuff to execute it is the problem.
你还需要输入字符来执行 这就是问题所在

1416
01:16:23,981 --> 01:16:25,321
The other thing is this is all super brittle
另外 这一切都非常脆弱

1417
01:16:25,380 --> 01:16:26,786
because it was written a long time ago
因为这代码是很久以前写的

1418
01:16:26,820 --> 01:16:28,763
and the more I mess with it
而且我改的越多

1419
01:16:28,764 --> 01:16:30,766
the more I'm likely to just absolutely mess things up.
就越容易彻底搞砸

1420
01:16:31,947 --> 01:16:33,493
Okay, let's go back.
好了 我们回去

1421
01:16:34,951 --> 01:16:36,051
Version numbers, great.
版本号 很好

1422
01:16:38,493 --> 01:16:41,096
You can see, yeah, anyways.
你能看到 总之

1423
01:16:41,376 --> 01:16:42,271
All the stuff in here.
这里所有的东西

1424
01:16:42,272 --> 01:16:43,912
Oh, that's why I was getting to a terminal.
哦 这就是我为什么要进终端

1425
01:16:43,913 --> 01:16:45,196
So I could show you terminal.
我可以给你演示下终端

1426
01:16:45,533 --> 01:16:47,136
And I could show you.
也可以给你看看

1427
01:16:51,583 --> 01:16:52,951
Yeah, so in the uname
嗯 在 uname 中

1428
01:16:52,976 --> 01:16:56,696
you can see the Darwin version, 23.6.
你可以看到 Darwin 23.6

1429
01:16:57,110 --> 01:17:01,583
And then you can see the XNU version.
还能看到 XNU 版本

1430
01:17:03,240 --> 01:17:06,520
And then it's the release kernel on ARM64.
接着是 说该内核运行在ARM64上

1431
01:17:06,521 --> 01:17:11,036
This last one is like the machine, like specific to, there's
最后的这个 是特定于某台机器的 比如

1432
01:17:12,649 --> 01:17:14,248
because if you think about it
因为你想一下

1433
01:17:14,249 --> 01:17:17,830
so there's like release, there's ARM64 that could apply to a Mac
ARM64 芯片有的用在 Mac

1434
01:17:17,831 --> 01:17:19,711
or it could apply to an iPhone or something.
或用在iPhone之类的

1435
01:17:19,712 --> 01:17:22,253
So there's different targets in here
这里有不同的目标（T...）

1436
01:17:22,373 --> 01:17:24,400
of what actual specific machine to target.
指具体的机器类别

1437
01:17:25,313 --> 01:17:26,314
And I'm not sure what this part is.
我不确定这一部分是什么

1438
01:17:27,653 --> 01:17:29,593
So anyways, this is how you can figure out where you are.
总之 这是确定版本的方法

1439
01:17:29,594 --> 01:17:32,854
And then if we wanted to find this exact kernel version
然后 如果我们想找到这个具体的内核版本

1440
01:17:32,879 --> 01:17:34,335
we'd look at like
我们看

1441
01:17:34,336 --> 01:17:35,679
this is actually probably it.
这应该就是了

1442
01:17:39,057 --> 01:17:40,564
No. because this is .2
不是这个 因为是 .2 版本

1443
01:17:40,565 --> 01:17:42,005
so it hasn't been open sourced yet.
它还没开源

1444
01:17:42,006 --> 01:17:44,166
This is probably something that's slightly,
这可能有些不同

1445
01:17:44,372 --> 01:17:47,288
I think if, let's see if we looked at about this Mac
我们来看看这台 Mac

1446
01:17:47,289 --> 01:17:49,950
what did we say? It was 14.6.1
之前说是多少？14.6.1

1447
01:17:49,974 --> 01:17:53,099
and this I would guess is 14.6.
我猜这个是 14.6

1448
01:17:53,200 --> 01:17:53,826
Yeah, which makes sense.
没错 这说得通

1449
01:17:53,851 --> 01:17:54,832
That's how we got here, right?
我们就是这样来的 对吧？

1450
01:17:54,833 --> 01:17:57,753
Through the distribution link.
通过这个链接

1451
01:18:00,053 --> 01:18:01,853
Mac OS, 14.6.
Mac OS 14.6

1452
01:18:01,878 --> 01:18:02,540
This is 14.
这个是 14

1453
01:18:02,565 --> 01:18:03,627
I'm running 14.6.1.
我用的是 14.6.1

1454
01:18:03,949 --> 01:18:05,098
which is not open source yet.
它还没有开源

1455
01:18:06,191 --> 01:18:07,890
If you really spend a lot of time doing this
如果你花了很多时间在这上

1456
01:18:07,971 --> 01:18:10,492
you will be live and die by these releases
你的命运就系在这些版本发布上了

1457
01:18:10,493 --> 01:18:14,533
because you want to see if they're killing one of your bugs or not killing your bugs.
因为你想知道你找到的bug有没有被修复

1458
01:18:14,534 --> 01:18:16,761
But sometimes they release them
但有时候他们会发布

1459
01:18:16,786 --> 01:18:17,646
sometimes they don't.
有时不发

1460
01:18:17,679 --> 01:18:19,094
Sometimes the person doing it forgets
有时候负责的人会忘了

1461
01:18:19,095 --> 01:18:19,935
and just doesn't do it.
然后就不发了

1462
01:18:19,936 --> 01:18:22,586
I don't know what their internal criteria is.
我不知道他们内部的标准是什么

1463
01:18:22,777 --> 01:18:24,720
So good luck.
所以祝你好运

1464
01:18:27,918 --> 01:18:28,219
Okay.
好的

1465
01:18:31,680 --> 01:18:32,306
Cool.
好的

1466
01:18:33,550 --> 01:18:35,300
And theoretically, I guess you can
理论上 你可以

1467
01:18:35,351 --> 01:18:37,910
pull down all of that entire distribution.
下载整个发布包

1468
01:18:37,911 --> 01:18:38,786
I think I've tried that once
我试过一次

1469
01:18:38,811 --> 01:18:41,896
but it takes up like a ton of room of like all those different directories.
但它会占用大量空间 一堆不同的项目目录

1470
01:18:43,635 --> 01:18:46,597
So we have that directory.
我们有那个目录

1471
01:18:47,250 --> 01:18:50,283
And so now we will start exploring that directory.
现在我们来探索这个目录

1472
01:18:50,517 --> 01:18:53,116
We were in here, 14.1.
我们在 14.1

1473
01:18:53,738 --> 01:18:55,509
Let's browse there.
我们去看看

1474
01:18:56,516 --> 01:18:59,996
So you would think, well, this is great.
你可能会觉得 这太棒了

1475
01:19:00,963 --> 01:19:02,542
Just like any good software system
就像任何好的软件系统一样

1476
01:19:02,543 --> 01:19:03,440
there's a how to build.
有一个构建指南

1477
01:19:04,567 --> 01:19:07,460
Have any of you taken software from GitHub
你们有没有从 GitHub 下载过软件？

1478
01:19:07,486 --> 01:19:10,306
and you followed the README and tried to build it?
然后按照 README 尝试构建？

1479
01:19:10,930 --> 01:19:12,540
What would you say your success rate is?
你们的成功率大概是多少？

1480
01:19:15,393 --> 01:19:16,629
What was it, 15?
15% 吗？

1481
01:19:17,723 --> 01:19:18,896
I think that's pretty good, yeah.
我觉得这已经很不错了

1482
01:19:19,276 --> 01:19:21,669
Like maybe 50-ish percent.
大概 50%

1483
01:19:22,157 --> 01:19:24,956
All depends on how important the thing is that you're targeting.
这全看你的目标有多重要

1484
01:19:27,893 --> 01:19:30,833
And so similar things apply here.
所以这里也一样

1485
01:19:31,573 --> 01:19:34,240
So maybe they're late for their test next one.
下次考试说不定他们也会迟到

1486
01:19:37,066 --> 01:19:37,547
What are you doing?
你在做什么？

1487
01:19:37,547 --> 01:19:37,980
Stop.
停

1488
01:19:40,660 --> 01:19:41,726
So that's why people write
所以人们会写

1489
01:19:41,769 --> 01:19:44,871
especially when there was the change from Intel to Apple Silicon.
尤其是在从 Intel 切换到 Apple Silicon 的时候

1490
01:19:44,872 --> 01:19:45,991
I'll talk about this a little bit
我会简要讲一下

1491
01:19:45,992 --> 01:19:51,754
but there are people that write entire blog posts
有些人会专门写博客

1492
01:19:51,755 --> 01:19:53,837
of how to actually compile the kernel
讲解如何编译内核

1493
01:19:54,976 --> 01:19:57,870
because it doesn't always cleanly just build.
因为编译并不总是那么顺利

1494
01:19:58,962 --> 01:20:00,102
And you have to install
而且你还需要安装

1495
01:20:00,103 --> 01:20:03,003
so Xcode is the development environment.
Xcode 是开发环境

1496
01:20:03,028 --> 01:20:06,826
Ooh, 5% online that they said their thing does.
哦 线上有人说成功率 5%

1497
01:20:06,999 --> 01:20:08,526
So you have to install the right version.
所以你得安装正确的版本

1498
01:20:08,566 --> 01:20:12,672
You have to download a kernel development kit
你需要下载内核开发套件

1499
01:20:12,706 --> 01:20:15,212
if you're building on Apple Silicon Macs.
如果你是在 Apple Silicon 的 Mac 上开发

1500
01:20:15,351 --> 01:20:17,792
Or sorry, if you're building an ARM target.
抱歉 如果你编译的目标是 ARM架构

1501
01:20:18,134 --> 01:20:19,753
The kernel development kit.
内核开发套件

1502
01:20:23,030 --> 01:20:24,023
What was it?
什么？

1503
01:20:24,533 --> 01:20:25,966
Oh, you guys want to see stuff?
哦 你们想看看吗？

1504
01:20:28,099 --> 01:20:29,893
Wow. You don't just trust me when I say things?
哇。你们不相信我说的吗？

1505
01:20:31,334 --> 01:20:31,933
Okay.
好的

1506
01:20:32,203 --> 01:20:34,420
So anyways, this is a giant blog post.
所以 总之这是一篇很长的博客

1507
01:20:34,513 --> 01:20:38,306
It's all about how to actually build this version of 11.2.
主要是讲如何实际构建 11.2 版本

1508
01:20:38,926 --> 01:20:42,660
And then when version 12 came out
然后 12 版本出来后

1509
01:20:43,051 --> 01:20:44,093
this did not work anymore.
这篇就不行了

1510
01:20:45,212 --> 01:20:47,036
And I know because I've tried to build 12
我知道 因为我试过构建 12 版本

1511
01:20:47,163 --> 01:20:48,593
and I have a way of doing it
而且我有个成功的方法

1512
01:20:48,636 --> 01:20:49,935
but I'll share with you in a second.
等会儿我就和你们分享

1513
01:20:53,259 --> 01:20:55,496
Yeah, you should be able to...
是的 你应该能做到……

1514
01:20:56,702 --> 01:20:58,081
I still don't 100% know.
我还不是完全确定

1515
01:20:58,082 --> 01:21:01,744
And if somebody can verify this for me, there is an
如果有人能帮我核实一下

1516
01:21:01,745 --> 01:21:03,804
so there's an Apple developer website
所以有一个苹果开发者网站

1517
01:21:03,805 --> 01:21:05,265
which is what we're looking at here.
就是我们现在看到的

1518
01:21:09,258 --> 01:21:10,141
Where's my phone?
我的手机呢？

1519
01:21:13,091 --> 01:21:14,213
Oh, security.
哦 安全啊

1520
01:21:14,304 --> 01:21:15,166
It's too secure.
太安全了

1521
01:21:24,357 --> 01:21:25,470
Where's my two-factor?
我的双因子验证呢

1522
01:21:26,136 --> 01:21:27,234
Oh, because I don't have one.
哦 因为我没有

1523
01:21:27,723 --> 01:21:28,450
Yeah, that's right.
是的

1524
01:21:29,116 --> 01:21:31,450
Sorry, this is a different account than the one I use.
抱歉 这不是我常用的账号

1525
01:21:34,176 --> 01:21:35,796
I actually don't have any Apple devices
我手头没有苹果设备

1526
01:21:36,450 --> 01:21:37,558
in case you can't see.
你可能没看到

1527
01:21:39,163 --> 01:21:41,249
Okay, cool.
好的 没问题

1528
01:21:41,361 --> 01:21:43,636
I guess nobody can actually do anything with this.
我猜没人能利用这个验证码

1529
01:21:43,701 --> 01:21:46,196
This is the beauty of one-time passwords.
这就是一次性密码的妙处

1530
01:21:47,703 --> 01:21:49,346
Trust, but it doesn't matter.
坚持访问 没事

1531
01:21:49,371 --> 01:21:50,506
It's private browsing.
这是隐私模式浏览

1532
01:21:50,993 --> 01:21:53,039
Okay, so I think...
好 我感觉...

1533
01:21:53,361 --> 01:21:54,661
Theoretically, you should be able to
理论上 你可以

1534
01:21:54,686 --> 01:21:57,413
create an Apple developer account without paying
免费创建苹果开发者账户

1535
01:21:57,966 --> 01:22:01,308
because you can pay to like launch apps on the app store.
因为你可以付费 上架应用 到谷歌应用商店

1536
01:22:01,309 --> 01:22:04,012
You have to pay like $100 with a developer account.
你需要用开发者账户支付，好像，100 美元

1537
01:22:04,013 --> 01:22:06,779
I think you can just create a development account and then.
我觉得你可以直接创建一个开发账户

1538
01:22:09,686 --> 01:22:12,406
Yeah, so this is where all the kernel debug kits are.
所有内核调试工具包都在这

1539
01:22:12,664 --> 01:22:14,264
This is a big
这可是个大文件

1540
01:22:14,265 --> 01:22:16,546
I think it's like a 12 gig download
大概有 12GB

1541
01:22:16,547 --> 01:22:21,428
that has the release kernel, a development kernel, and a KASAN kernel.
包含了发布内核、开发内核和 KASAN 内核

1542
01:22:21,429 --> 01:22:23,550
So KASAN is like user space ASAN
KASAN 就像用户空间的 ASAN 一样

1543
01:22:23,551 --> 01:22:26,793
but in the kernel it can detect use after frees,
但在内核中，它可以检查UAF

1544
01:22:26,794 --> 01:22:28,794
writing out of bounds writes, these kinds of things.
越界写入等类似问题

1545
01:22:30,015 --> 01:22:32,377
And so what you need to do is find the exact
你需要找到确切的

1546
01:22:32,378 --> 01:22:35,200
so this is that hash that I was talking about here.
这就是我之前提到的哈希值

1547
01:22:35,299 --> 01:22:38,221
That's like what you need to find to get your version.
这就是你需要找的 以便获取你的版本

1548
01:22:38,246 --> 01:22:39,902
We're definitely not going to find ours here
这里肯定找不到我们要找的

1549
01:22:39,952 --> 01:22:42,085
but we can at least look.
但我们至少可以看一看

1550
01:22:48,606 --> 01:22:49,686
Oh, it is. Okay.
哦 还真有 好的

1551
01:22:49,808 --> 01:22:51,980
Yeah, so I have the 14.6.1 build.
是的 我用的是 14.6.1 版本

1552
01:22:52,127 --> 01:22:53,753
It also has symbols in here
这里面有内核符号

1553
01:22:53,778 --> 01:22:58,881
and there's LLDB macros that help with debugging the kernel.
还有 LLDB 宏 能帮助调试内核

1554
01:22:58,906 --> 01:22:59,690
It's actually really cool.
这真的很赞

1555
01:23:00,299 --> 01:23:03,691
The output, I think, in some cases, can be even better than GDB
某些情况下 输出甚至比 GDB 还好

1556
01:23:03,692 --> 01:23:07,532
but to build the stuff
但要编译构建这个

1557
01:23:07,533 --> 01:23:11,760
you have to have that on your machine and installed to actually do it.
你需要在你的电脑上装好这个

1558
01:23:14,212 --> 01:23:16,006
On the target machines
在目标环境上

1559
01:23:16,079 --> 01:23:16,980
when you need it
当你需要时

1560
01:23:16,981 --> 01:23:18,219
I think this will already be installed
那时应该已经装好了

1561
01:23:18,259 --> 01:23:19,720
so it shouldn't be an issue
所以应该没问题

1562
01:23:19,721 --> 01:23:21,705
and you won't have to think about it, hopefully.
希望你不需要再操心这个

1563
01:23:21,880 --> 01:23:22,725
But we'll see.
不过到时候再说

1564
01:23:25,581 --> 01:23:26,625
Okay, yeah.
好的 嗯

1565
01:23:26,682 --> 01:23:29,958
So KDK package, you need to install it, yada, yada, yada.
所以 KDK 包 你得装上 等等

1566
01:23:29,983 --> 01:23:31,682
The version number needs to be right.
版本号一定要对

1567
01:23:31,762 --> 01:23:32,484
It's also insane
还有一点很疯狂

1568
01:23:32,485 --> 01:23:36,695
there are sometimes different builds for the exact same version number.
有时候不同的构建，会有同一个版本号

1569
01:23:36,825 --> 01:23:38,444
And sometimes you'll get into situations
有时候还会遇到这样的情况

1570
01:23:38,445 --> 01:23:43,614
where You will have the source version of a 12-point whatever
你有某个 12.几 版本的源码

1571
01:23:43,615 --> 01:23:45,476
but not the KDK version
但没有对应的 KDK 版本

1572
01:23:45,477 --> 01:23:46,677
so you can't even build it
所以你根本编译构建不了

1573
01:23:46,678 --> 01:23:48,326
because it doesn't have the right things.
因为它缺少对应的东西

1574
01:23:48,940 --> 01:23:51,580
I think there's something in here that they link to for ARM
我觉得 这里链接的 有些运行在ARM上的东西

1575
01:23:51,581 --> 01:23:54,422
that's part of the boot process that is not open source
是启动过程的一部分 不是开源的

1576
01:23:54,423 --> 01:23:56,104
and that's what it needs for the ARM part
这是使用 ARM 组件的要求

1577
01:23:56,133 --> 01:23:57,765
but I haven't dug into it a ton.
但我没深入研究过

1578
01:24:00,373 --> 01:24:04,890
So, yeah, this is, I guess
这个是

1579
01:24:05,503 --> 01:24:06,771
I can't make this an assignment
我不能把它留作作业

1580
01:24:06,772 --> 01:24:07,572
because this doesn't make sense
这不合理

1581
01:24:07,573 --> 01:24:09,856
because not all of you have Apple devices.
不是每个人都有苹果设备

1582
01:24:10,116 --> 01:24:12,510
But one of the things I did as part of preparing for this class
但我为这门课做的一个准备是

1583
01:24:12,550 --> 01:24:17,690
is try to get build scripts working for different versions.
尝试用脚本成功构建不同版本

1584
01:24:17,769 --> 01:24:20,490
So I have one for 11.2.
所以我有一个编译 11.2 版本的

1585
01:24:20,630 --> 01:24:21,551
So these are make files.
这些都是 make 文件

1586
01:24:21,576 --> 01:24:22,472
You just run make
你只需要运行 make 就行了

1587
01:24:22,473 --> 01:24:24,292
and it builds the whole thing for you.
它会帮你构建整个项目

1588
01:24:24,330 --> 01:24:26,056
Let's test it out.
我们来测试一下

1589
01:24:29,374 --> 01:24:31,906
Which one do we want to build, 11.2 or 12.5?
我们构建哪个版本 11.2 还是 12.5？

1590
01:24:33,379 --> 01:24:35,799
12.5, just because the number's higher?
12.5 就因为版本号更高吗？

1591
01:24:45,047 --> 01:24:46,466
And you can see these patches.
你可以看到这些补丁

1592
01:24:46,500 --> 01:24:47,766
So I had to patch.
我必须打补丁

1593
01:24:47,909 --> 01:24:53,293
This one wasn't the OS so much as like the build environment needed to be patched.
这个问题不是出在操作系统，而是构建环境需要打补丁

1594
01:24:53,294 --> 01:24:56,449
Oh, wait, wait. I didn't read the readme.
等一下 我还没看README

1595
01:24:56,616 --> 01:24:59,189
This requires the KDK
这需要 KDK

1596
01:24:59,214 --> 01:25:00,227
which I already have installed.
我已经安装了

1597
01:25:00,252 --> 01:25:01,674
So I will do it like this.
所以我这样做

1598
01:25:01,707 --> 01:25:03,294
We pass this environment variable.
传入这个环境变量

1599
01:25:05,076 --> 01:25:06,823
So I've obviously already set up all that stuff
这些我已经设置好了

1600
01:25:06,824 --> 01:25:07,961
but it has to like
但它必须

1601
01:25:07,962 --> 01:25:11,276
There's pre stuff that it needs to compile to build tools
有一些前置的工具需要编译

1602
01:25:11,416 --> 01:25:15,263
that then it uses while building the kernel and it uses those tools.
构建内核时，会用到这些工具

1603
01:25:15,465 --> 01:25:18,633
And like it, the kernel, the code
代码是这样

1604
01:25:18,719 --> 01:25:19,605
I don't know if the kernel,
内核 我不确定

1605
01:25:19,646 --> 01:25:23,927
but the code in the repo, like hard codes them to specific directories.
但仓库中的代码，硬编码了特定的目录

1606
01:25:23,928 --> 01:25:28,099
So I patched them so that they look at this local bin folder that gets created.
所以我对它们进行了修补，让它们去到刚创建的bin目录

1607
01:25:29,850 --> 01:25:31,308
And so anyways,
总之

1608
01:25:31,309 --> 01:25:33,750
my ask is what would be great is if
我希望

1609
01:25:33,774 --> 01:25:35,473
this is an open source thing
这是开源的

1610
01:25:35,572 --> 01:25:36,635
like it's public
是公开的

1611
01:25:36,670 --> 01:25:38,396
And we're just building open source stuff.
我们构建了一个开源项目

1612
01:25:38,452 --> 01:25:42,471
So if you all who have access to a Mac
所以 如果有 Mac 的朋友

1613
01:25:42,472 --> 01:25:45,312
if you want to expand this by adding new versions
如果你想扩展这个项目 增加新内核版本构建支持

1614
01:25:45,313 --> 01:25:47,676
I think the community would really benefit because
我认为社区会因此受益

1615
01:25:49,450 --> 01:25:53,631
basically this last blog post was one of the latest ones that I saw of
这是我最近看到的一篇博客文章

1616
01:25:53,656 --> 01:25:55,154
like, here's how to compile this thing.
内容主要讲如何编译这个东西

1617
01:25:55,155 --> 01:25:56,156
And I'm like, great.
我觉得 太好了

1618
01:25:56,818 --> 01:25:57,910
We have a script for 11.
我们有针对 11 的脚本了

1619
01:25:57,958 --> 01:25:59,309
It should be easy of 12.
改一个 12 的版本应该很容易

1620
01:25:59,576 --> 01:26:01,103
And 12.5...
还有 12.5...

1621
01:26:06,737 --> 01:26:07,497
Let's see, what was that?
等等 那是什么？

1622
01:26:07,498 --> 01:26:13,618
This was 12.5 was, yeah, July 20th, 2022.
12.5 版本是在 2022 年 7 月 20 日发布的

1623
01:26:13,643 --> 01:26:17,707
So this is the one I'm targeting for the physical devices
我准备用这个版本

1624
01:26:17,708 --> 01:26:19,024
because I know I can build it
因为我能构建它

1625
01:26:19,228 --> 01:26:21,130
and I know I have the KDK for it
而且我有它的 KDK

1626
01:26:21,223 --> 01:26:22,903
and I think I can
还能

1627
01:26:23,053 --> 01:26:25,976
that that will work and we can just study that.
这样就行了 然后我们可以直接研究

1628
01:26:27,776 --> 01:26:29,273
So anyways, I think it'd be cool.
总之 我觉得它很不错

1629
01:26:29,346 --> 01:26:31,039
Oh no, what?
哦 不！ 什么？

1630
01:26:34,854 --> 01:26:37,696
Oh, I must have some other diffs that I didn't actually do.
哦 我肯定还有一些没做的改动

1631
01:26:40,698 --> 01:26:42,697
How do I diff two directories?
怎么比较两个目录？

1632
01:26:42,698 --> 01:26:43,553
Anybody know?
有谁知道吗？

1633
01:26:44,138 --> 01:26:44,738
Like this?
这样对吗？

1634
01:26:44,738 --> 01:26:45,640
git diff -r?

1635
01:26:49,675 --> 01:26:50,606
I don't think that's right.
我觉得不太对

1636
01:26:51,059 --> 01:26:51,813
It's like this.
应该是这样

1637
01:26:51,839 --> 01:26:52,742
Naur, right?
Naur 对吧？

1638
01:26:52,926 --> 01:26:53,479
Yeah.
对

1639
01:27:18,946 --> 01:27:20,099
Ah, see?
啊 看到没？

1640
01:27:20,477 --> 01:27:22,820
I have uncommitted changes that I need to patch.
我的补丁有未提交的更改

1641
01:27:23,493 --> 01:27:25,900
Oh yeah, this was an insane bug, where somehow
哦 对了 这是个诡异的 bug 也不知道为什么

1642
01:27:25,901 --> 01:27:27,700
I think it's because we're using a newer compiler
可能是因为我们用了新版的编译器

1643
01:27:27,725 --> 01:27:32,566
and null is macroed to something else that's not, I think to zero
null 被宏定义成了其他东西 好像变成0了

1644
01:27:32,826 --> 01:27:35,228
but this function returns booleans
但这个函数要返回布尔类型值

1645
01:27:35,280 --> 01:27:37,526
and so it has to return false or true
所以它必须返回 false 或 true

1646
01:27:37,830 --> 01:27:40,228
and the I don't know if this ever compiled.
我不知道这是否编译通过过

1647
01:27:40,229 --> 01:27:42,870
This doesn't make sense that this compiled, but anyways, yes
很难相信 它编译通过过 不过 好吧

1648
01:27:42,871 --> 01:27:44,310
I do recall doing this, but okay.
我记得我这么做过 不过就这样吧

1649
01:27:44,311 --> 01:27:45,093
So this is a good thing.
这是件好事

1650
01:27:45,094 --> 01:27:46,780
I need to fix this because this doesn't work.
我需要修复这个问题 因为它不起作用

1651
01:27:47,333 --> 01:27:49,635
So thanks for making a demo on the one that doesn't work.
多谢 做了这个不能用的示例

1652
01:27:49,636 --> 01:27:51,280
Random student in the audience.
的观众中的某位同学

1653
01:27:53,459 --> 01:27:55,593
Yeah, cool.
好的 真酷！

1654
01:27:56,066 --> 01:27:57,126
Okay, so anyways,
好的 总之

1655
01:27:57,160 --> 01:27:58,641
I think that'd be a cool outcome of this course
这门课一定会很有意义

1656
01:27:58,642 --> 01:28:00,160
if we can help the community.
如果我们能帮到社区

1657
01:28:00,546 --> 01:28:04,680
I will say if anybody tries the latest, latest versions, like 14
如果有人尝试最新版本 比如 14

1658
01:28:04,706 --> 01:28:07,493
I absolutely cannot get them to compile because...
我根本编译不了 因为……

1659
01:28:09,214 --> 01:28:10,620
As we'll learn next week
下周我们会学到

1660
01:28:10,715 --> 01:28:14,017
there's the raw message passing IPC
在原始的消息传递 IPC 上

1661
01:28:14,053 --> 01:28:17,266
but then Apple has built another layer on top of that
苹果在其上又加了一层

1662
01:28:17,320 --> 01:28:21,606
where they define messages to call to other,
在这层中 他们定义了用于调用其他进程的消息

1663
01:28:21,785 --> 01:28:25,449
basically like an inter-procedure language that you can define interfaces
基本上就像一种可以定义接口的跨进程语言

1664
01:28:25,568 --> 01:28:29,048
and that way you can automatically compile code from there
这样就可以从那里自动编译代码

1665
01:28:29,154 --> 01:28:32,528
for the server and the client to do that communication and parsing and everything.
完成服务端与调用端通信，和解析等任务

1666
01:28:35,162 --> 01:28:36,502
They created some new format
他们开发了一种新的格式

1667
01:28:36,503 --> 01:28:39,404
and that's not in the version of Clang that I'm using.
它不在我用的 Clang 版本里

1668
01:28:39,405 --> 01:28:40,431
I don't know where this is.
我不知道这在哪

1669
01:28:40,456 --> 01:28:42,676
It's like using some option of Clang to compile these.
像是用了 Clang 的某些选项来编译这些

1670
01:28:43,646 --> 01:28:46,730
I think they're like MIG2 or MIGMach2.
我觉得它们可能是 MIG2 或 MIGMach2（不知道）

1671
01:28:46,783 --> 01:28:48,360
Anyways, I got into this thing
总之 我遇到了这个问题

1672
01:28:48,385 --> 01:28:49,748
but if we can solve that problem that'd be great.
如果我们能解决这个问题  那很好

1673
01:28:49,749 --> 01:28:52,448
There are a lot of people that would be very thankful
很多人会非常感谢

1674
01:28:52,449 --> 01:28:53,968
that we can solve this thing.
咱们解决这个问题

1675
01:28:53,969 --> 01:28:56,091
I think it'd be a fun project to extend this out
我觉得把这个项目扩展一下会很有趣

1676
01:28:56,950 --> 01:28:58,131
and it'd help you get familiar with it.
这也有助于你熟悉这东西

1677
01:28:58,212 --> 01:28:58,818
cause honestly
因为

1678
01:28:59,825 --> 01:29:01,025
when you're doing this real world stuff,
当你处理这些实际问题时

1679
01:29:01,026 --> 01:29:05,019
especially on, like we said, 15, 5% of things actually compile
尤其是像我们说的 只有 15%或5% 的概率能编译通过

1680
01:29:05,067 --> 01:29:06,667
but you still got to find bugs in them.
但你还得找里面的bug

1681
01:29:06,668 --> 01:29:08,128
So like get it to compile.
所以先让它能编译

1682
01:29:08,129 --> 01:29:10,519
Like that's like the first step of this stuff
漏洞挖掘第一步就是

1683
01:29:10,546 --> 01:29:12,128
is actually getting it to compile.
让代码能编译

1684
01:29:12,192 --> 01:29:15,311
And so, you know you can't just be like, well it doesn't work.
所以你不能上来就 “不行 跑不起来”

1685
01:29:15,312 --> 01:29:18,911
Like, I don't know, patch it, fix it, find the dependencies.
想办法解决它，比如，打补丁，修改它，找依赖

1686
01:29:18,912 --> 01:29:21,425
Like there was,
比如说 有个问题

1687
01:29:22,331 --> 01:29:25,517
oh yeah, the other the latest ones are missing header files
对了 有个问题是 新版本缺少头文件

1688
01:29:25,542 --> 01:29:28,733
that exist in earlier versions but don't exist in that version.
老版本有但在新版本中没了

1689
01:29:28,804 --> 01:29:30,776
And like, Is that good, bad?
这样是好是坏？

1690
01:29:30,777 --> 01:29:32,551
Can I just copy the old ones over?
我能直接复制旧的过来吗？

1691
01:29:32,618 --> 01:29:36,179
I don't know, that seems wrong, but weird.
不知道 这样做好像不对 但也挺 怪的

1692
01:29:38,580 --> 01:29:41,542
But you can learn a lot of things about software by making it build and work.
通过尝试编译软件，你能学到不少

1693
01:29:43,601 --> 01:29:44,562
Cool, okay.
好的 了解

1694
01:29:45,643 --> 01:29:46,523
So in the source
在源码中

1695
01:29:46,523 --> 01:29:47,566
we're already looking at it.
我们已经在看了

1696
01:29:48,523 --> 01:29:54,143
We can just go to the right back here.
我们直接回到这里

1697
01:29:54,867 --> 01:29:58,187
Cool, so now we're at the repo.
好的 现在我们到了仓库

1698
01:30:00,694 --> 01:30:01,655
And the other thing I think people
还有一件事 我觉得很多人

1699
01:30:02,290 --> 01:30:03,194
a lot of people
很多人都会

1700
01:30:03,195 --> 01:30:05,447
especially we think about doing, oh
特别是当我们考虑要

1701
01:30:06,107 --> 01:30:08,237
the latest come in the Clang repost from three years ago.
这里最新的clang是三年前的

1702
01:30:08,238 --> 01:30:09,510
Yeah, that seems wrong.
看着不对劲

1703
01:30:09,758 --> 01:30:12,303
Although maybe there's a tag that is latest
也可能是tag标的“最新”

1704
01:30:12,400 --> 01:30:14,019
that I don't have yet
但我还没看到

1705
01:30:14,020 --> 01:30:19,099
but I was using the Clang that ships with Xcode, the latest one.
但我用的是随 Xcode 一起发布的最新 Clang

1706
01:30:20,023 --> 01:30:22,403
A lot of mistakes that people make is either just diving into the code
很多人犯的错误是直接跳进代码

1707
01:30:22,404 --> 01:30:24,985
and not reading the documentation that is right there in front of you
而不去读眼前的文档

1708
01:30:24,986 --> 01:30:27,086
because you don't want to do that
因为你不愿意做这个

1709
01:30:27,087 --> 01:30:28,646
but you can learn a ton.
但你能学到很多

1710
01:30:28,647 --> 01:30:30,385
There's already so much stuff in here
这里已经有很多东西了

1711
01:30:30,386 --> 01:30:34,456
Although, I will warn you, does documentation compile?
不过我要提醒你 文档会参与编译吗？

1712
01:30:39,009 --> 01:30:40,315
What docs compile?
哪些文档会参与编译？

1713
01:30:42,343 --> 01:30:43,750
There's one software, I think.
应该是有一个软件

1714
01:30:45,083 --> 01:30:45,742
Huh?
啊？

1715
01:30:46,029 --> 01:30:47,876
Yeah, tech, I think.
对 应该是tech（不清楚，欢迎补充）

1716
01:30:48,075 --> 01:30:49,415
But it's more like a readable thing
但更像是个可读的东西

1717
01:30:49,443 --> 01:30:51,076
and I don't know that the docs actually compile
我不知道文档真会被编译吗

1718
01:30:51,077 --> 01:30:52,410
but they're part of the source code.
但它们是源代码的一部分

1719
01:30:54,738 --> 01:30:55,879
No newer branches.
没有新的分支

1720
01:30:56,019 --> 01:30:58,160
Thank you, JWU01.
谢谢 JWU01

1721
01:31:00,175 --> 01:31:03,135
So yeah, the docs can be out of date, right?
所以 文档可能会过时

1722
01:31:03,136 --> 01:31:04,836
The fundamental thing of they don't compile means
他们不参与编译

1723
01:31:04,837 --> 01:31:08,661
that like nobody's checking that it's actually maps to reality.
导致大概率没有人去检查它

1724
01:31:08,878 --> 01:31:12,379
So some of this stuff kind of maybe works.
所以这些内容可能有些管用

1725
01:31:12,380 --> 01:31:14,160
I don't know. It's like a good starting point.
不清楚，但它是一个很好的起点

1726
01:31:14,161 --> 01:31:15,940
You have to read this like an archeologist.
你要像考古学家一样，读这些

1727
01:31:15,965 --> 01:31:18,080
Like at one point people thought this
之前人们是这么想的

1728
01:31:18,542 --> 01:31:21,862
like that may not be what reality is in this software
但这可能不符合该软件现在的情况

1729
01:31:21,863 --> 01:31:22,844
but at least I know
但至少我知道

1730
01:31:22,845 --> 01:31:24,582
that at a certain point people thought this
之前有人这样想

1731
01:31:24,583 --> 01:31:25,963
and I can start from there.
我可以从这里开始

1732
01:31:29,077 --> 01:31:30,676
Yeah, so we are, okay.
好的 我们

1733
01:31:31,318 --> 01:31:34,780
Like I think all this stuff about like building kernel caches and booting it
我觉得 这些都是讲构建内核cache并启动它的

1734
01:31:34,824 --> 01:31:37,540
I think this is old stuff for older versions
这些应该是老版本的东西

1735
01:31:37,598 --> 01:31:39,858
but I would love to be proved wrong.
但我很愿意被证明是错的

1736
01:31:40,021 --> 01:31:41,718
Anyways, there's like a ton of stuff in here.
总之 这里有很多东西

1737
01:31:41,883 --> 01:31:45,563
What we are looking for is I think right at the top that I missed.
我们要找的 应该在最上面 但我漏掉了

1738
01:31:47,425 --> 01:31:48,116
Yeah.
嗯

1739
01:31:48,346 --> 01:31:49,549
So where is everything?
东西都在哪儿？

1740
01:31:49,586 --> 01:31:54,040
So we got this giant directory, external headers, setup, BSD, config, doc,
我们有一个大目录 包括外部头文件、设置、BSD、配置和文档

1741
01:31:54,065 --> 01:31:56,028
IO kit, blah, blah, blah, blah, blah, blah, blah, blah, blah.
IO 套件，等等

1742
01:31:58,082 --> 01:31:59,302
Where is anything, right?
东西都在哪儿？

1743
01:31:59,303 --> 01:32:01,282
That's like one of the key things you need to understand
这是需要理解的一个关键点

1744
01:32:01,283 --> 01:32:02,842
as you start poking around things.
在探索这些文件的时候

1745
01:32:02,843 --> 01:32:05,256
This is kind of thinking of it as like
你可以这样理解 就像是

1746
01:32:05,636 --> 01:32:08,405
it'd be like going for a hike without having a map, right?
否则 就像没带地图去远足一样 对吧？

1747
01:32:08,406 --> 01:32:09,746
You're just like kind of poking around
你就像在随便摸索一样

1748
01:32:09,771 --> 01:32:11,264
and you can get pretty far
倒也能探索很远

1749
01:32:11,311 --> 01:32:13,829
just repping for things that you're interested in and reading code
只看你感兴趣的，读读代码

1750
01:32:13,830 --> 01:32:17,050
but ultimately it's better to kind of know
但最终 最好大致知道

1751
01:32:17,151 --> 01:32:18,851
roughly if I'm looking for this thing
如果你要找一个东西

1752
01:32:18,852 --> 01:32:22,393
where do I think it's going to be in this source code repository?
能大概知道它在代码仓库的什么位置

1753
01:32:23,400 --> 01:32:24,733
So such as you can look at this stuff.
比如 你看这个

1754
01:32:24,773 --> 01:32:28,593
So config, Configurations
所以 配置

1755
01:32:28,618 --> 01:32:30,960
this is where I think you can configure the version number.
估计你可以在这里配置版本号

1756
01:32:31,375 --> 01:32:33,406
Some tools that are used to set up.
一些用于设置的工具

1757
01:32:33,780 --> 01:32:35,299
External headers are very important.
外部头文件非常重要

1758
01:32:37,086 --> 01:32:38,516
These are used while building.
这些在编译构建时会用到

1759
01:32:38,901 --> 01:32:40,500
There's, we probably won't get into it
我们可能不会深入讨论IOKit

1760
01:32:40,536 --> 01:32:48,483
but Iokit is a C++ library to define drivers and kext
它是一个C++ 库 用于定义驱动程序和Kext

1761
01:32:49,466 --> 01:32:50,736
I always say kernel extensions
我通常会说内核扩展

1762
01:32:50,761 --> 01:32:53,527
but kx I don't know if that's how somebody says that
我不知道有没有人叫他kx

1763
01:32:53,528 --> 01:32:55,270
but I guess you could do it either way.
我估计怎么说都行

1764
01:32:55,703 --> 01:32:56,736
Kernel extensions.
内核扩展

1765
01:32:57,190 --> 01:32:59,963
Um, so as we, I mean
嗯 我是说

1766
01:33:00,010 --> 01:33:01,210
we will get to the point
我们会讲到这个

1767
01:33:01,478 --> 01:33:05,656
hopefully that you are popping kernel, uh, extensions.
希望你们正在攻击内核扩展

1768
01:33:05,730 --> 01:33:09,302
So under this may be of understanding how to
所以 为了理解如何

1769
01:33:09,303 --> 01:33:10,463
but this should all be documented.
这些应该有文档记录

1770
01:33:10,556 --> 01:33:12,650
So you probably don't need to look at this code necessarily.
所以你们可能不需要特意读这段代码

1771
01:33:14,890 --> 01:33:17,387
libsa bootstrap code for startup.
libsa 用于启动的引导代码

1772
01:33:17,388 --> 01:33:21,641
That would be kind of interesting to look at if you're looking for like pre-boot vulnerabilities
如果你们要找启动前的漏洞，会对这里感兴趣

1773
01:33:21,666 --> 01:33:23,494
uh, jailbreaking kind of things.
越狱之类的

1774
01:33:25,541 --> 01:33:27,419
libsyscall, this is super interesting.
libsyscall 这个非常有趣

1775
01:33:27,420 --> 01:33:28,941
I don't think I've ever looked in here.
我没看过这里面的内容

1776
01:33:29,023 --> 01:33:30,524
This is maybe where you'd think
你可能会以为

1777
01:33:30,525 --> 01:33:32,946
where you'd go of like this is where system calls go.
这里是系统调用的实现

1778
01:33:32,983 --> 01:33:34,989
But I think that's the opposite way.
但我记得恰恰相反

1779
01:33:35,530 --> 01:33:38,209
It's a library to be used for user space programs.
它是给用户空间程序用的库

1780
01:33:39,256 --> 01:33:40,183
So not fun.
所以不感兴趣

1781
01:33:41,077 --> 01:33:42,377
libkdd.

1782
01:33:43,883 --> 01:33:45,807
Uh, parsing kernel data.
解析内核数据

1783
01:33:45,808 --> 01:33:47,917
I have no idea where this is used or what it is.
我不知道这个库用在哪 也不清楚它是什么

1784
01:33:48,210 --> 01:33:56,406
Um, our good friend, osfmk, uh, open source foundation mach kernel.
嗯 我们的老朋友 osfmk 开源基金会的mach内核

1785
01:33:57,242 --> 01:33:59,192
Uh, so this is where everything like
这里汇集了

1786
01:33:59,217 --> 01:34:01,959
this is where virtual memory management, task management
这里涉及虚拟内存管理、任务管理

1787
01:34:01,960 --> 01:34:03,633
super important stuff is that like
都是很重要的东西

1788
01:34:03,700 --> 01:34:07,286
this is a critical part of the kernel that we absolutely will need to know.
这是内核中一个至关重要的部分 我们必须知道

1789
01:34:09,206 --> 01:34:14,498
pexpert platform, uh, Interrupt handling, atomics.
Pexpert 中断处理和原子操作

1790
01:34:14,938 --> 01:34:16,358
Maybe if we get curious about that
如果我们对这些感兴趣的话

1791
01:34:16,359 --> 01:34:17,531
we can dig in there.
我们可以深入研究一下

1792
01:34:17,960 --> 01:34:18,884
Security.
安全

1793
01:34:18,922 --> 01:34:20,262
This seems kind of interesting.
这看起来挺有趣的

1794
01:34:20,263 --> 01:34:22,082
Like, as a security person
作为一名安全人员

1795
01:34:22,083 --> 01:34:24,907
this is something that I'd be like, boop, that's, like somewhere I'd want to look.
这东西会让我，一下子引起探究的兴趣

1796
01:34:24,908 --> 01:34:29,849
But, like, I can't remember all of what's in here
不过 这里面具体有些什么 我还真记不起来了

1797
01:34:29,850 --> 01:34:32,489
but I think it's, like, checks of...
但我觉得应该是些检查……

1798
01:34:34,254 --> 01:34:36,580
Yeah, like, security checks and...
对 像是安全检查之类的……

1799
01:34:37,460 --> 01:34:42,219
There's ways to specify only binaries that are of a certain hash can get executed
有办法让 只有特定hash值的二进制程序执行

1800
01:34:42,220 --> 01:34:44,079
and things like this. There's all kinds of crazy checks
之类的 有各种检查

1801
01:34:44,080 --> 01:34:46,380
although I'm not sure if those happen in drivers or not.
但我不确定 在驱动中 是否也会检查

1802
01:34:46,381 --> 01:34:47,693
And then our good friend BSD.
还有我们的老朋友 BSD

1803
01:34:47,733 --> 01:34:49,066
So then there's a directory
有个bsd目录

1804
01:34:49,091 --> 01:34:52,406
in BSD that's the whole half of that BSD kernel.
在这里 几乎包含了 BSD 内核的一半

1805
01:34:53,503 --> 01:34:57,906
And then tools, which the interesting thing is here
还有工具目录 这里有趣的是

1806
01:34:58,965 --> 01:35:04,836
there's the surprising thing in here is that there are test cases.
这里有一些测试用例

1807
01:35:05,323 --> 01:35:08,496
like user space programs that use different system calls and stuff.
比如使用不同系统调用的用户空间程序

1808
01:35:08,587 --> 01:35:11,368
So these can be actually a great source for understanding how
因此 这些测试用例是了解如何

1809
01:35:11,369 --> 01:35:14,769
do I write some C code that talks to this system call
编写与这些系统调用交互的 C 代码

1810
01:35:14,770 --> 01:35:16,969
because you have a test case that literally does that.
因为你有一个实际这样做的测试用例

1811
01:35:17,152 --> 01:35:20,194
And so you can yank code from there and actually use that code.
因此 你可以从那里拷贝代码并直接使用

1812
01:35:20,195 --> 01:35:21,116
So that's super useful.
真是太有用了

1813
01:35:23,378 --> 01:35:27,159
But you will probably spend most of your time in these two directories,
但你大部分时间会在这两个目录里

1814
01:35:27,160 --> 01:35:29,973
the BSD side and the OSFMK side.
BSD 部分和 OSFMK 部分

1815
01:35:30,495 --> 01:35:33,041
Okay, so we've looked at this.
好的 我们看了这个

1816
01:35:35,434 --> 01:35:37,353
We want to understand how system calls work.
我们想了解系统调用的工作原理

1817
01:35:37,814 --> 01:35:38,500
What do we do?
我们该怎么做？

1818
01:35:42,338 --> 01:35:43,098
What was that?
什么？

1819
01:35:43,610 --> 01:35:44,591
Read source.
看看源代码

1820
01:35:44,680 --> 01:35:47,391
So we like, let's like click here.
所以 我们点击这里

1821
01:35:49,422 --> 01:35:50,617
Find a C file.
找到一个 C 文件

1822
01:35:51,684 --> 01:35:52,831
Ooh, there's a man page.
哦 这里有个man文档

1823
01:35:53,858 --> 01:35:54,845
Actually, this is interesting.
其实很有意思

1824
01:35:56,818 --> 01:35:57,893
Getting ahead of myself.
嘴比脑袋快了

1825
01:35:58,407 --> 01:36:00,746
Trying to remember where everything is, but console.
我想想 控制台

1826
01:36:01,513 --> 01:36:02,829
I don't know, serial general.
串行接口

1827
01:36:02,830 --> 01:36:03,860
Now I'm reading code.
现在我在读代码

1828
01:36:06,770 --> 01:36:08,380
Keyboard, starting a keyboard.
键盘 开始启动键盘

1829
01:36:12,353 --> 01:36:13,212
Am I gonna I don't know
我会

1830
01:36:13,213 --> 01:36:15,799
am I gonna find out where system calls go?
我会找到系统调用的地方吗？

1831
01:36:18,075 --> 01:36:19,880
Eventually, I will get
最终 我会

1832
01:36:19,905 --> 01:36:22,980
I will read all of the code in some order.
我会按照某种顺序读完所有代码

1833
01:36:23,106 --> 01:36:24,636
Eventually, I will make it there.
最终 我会找到

1834
01:36:29,059 --> 01:36:30,980
Is that an efficient way of operating?
这样操作高效吗？

1835
01:36:31,986 --> 01:36:32,639
No?
不是吧？

1836
01:36:34,140 --> 01:36:34,860
What was that?
什么？

1837
01:36:35,732 --> 01:36:36,715
Is there a README?
有 README 文件吗？

1838
01:36:36,766 --> 01:36:38,253
Ooh, what a good question.
咦 好问题

1839
01:36:38,411 --> 01:36:39,152
All right.
好的

1840
01:36:42,826 --> 01:36:44,340
Yeah, so first thing
嗯 首先

1841
01:36:44,390 --> 01:36:46,786
we need to leverage the tools that we have available.
我们要充分利用现有的工具

1842
01:36:48,373 --> 01:36:51,819
I'm not saying my workflow is the best possible workflow.
我不是说我的工作流程是最好的

1843
01:36:51,820 --> 01:36:54,599
I think you need to find a workflow that works for you.
我觉得你需要找到适合自己的工作流程

1844
01:36:54,722 --> 01:36:56,708
But what you need to be thinking about is
但你需要考虑的是

1845
01:36:56,733 --> 01:37:00,362
how easy is it for me to find files of a certain type?
如何轻松找到特定类型的文件？

1846
01:37:00,395 --> 01:37:06,455
Or how easy is it for me to search through the source code of looking for a certain thing?
或者说 如何轻松在源代码中找到特定东西？

1847
01:37:09,030 --> 01:37:11,580
I don't know if you load this up in Visual Studio Code
我不知道 如果你在 VS Code 里加载这些

1848
01:37:11,605 --> 01:37:17,123
if it will work and actually have all the stuff.
是否能正常工作并包含所有内容

1849
01:37:17,265 --> 01:37:18,825
Also, because it doesn't know how to compile it
另外 因为它不知如何编译

1850
01:37:18,826 --> 01:37:20,507
and you probably can't compile it on your own system
而且你在自己的系统上也很难编译

1851
01:37:20,508 --> 01:37:23,248
you don't get any of the nice language server features
所以你用不了一些服务功能

1852
01:37:23,249 --> 01:37:25,590
of jumping to definitions and stuff.
如跳到定义处 之类的

1853
01:37:26,681 --> 01:37:30,890
I basically, I don't know if you've been able to tell
我不知道你们能不能看出来

1854
01:37:30,891 --> 01:37:34,490
but I'm basically more old school in the sense that I
我这块儿比较传统

1855
01:37:34,590 --> 01:37:36,496
we'll start with this version, 12.5
我们将从 12.5 版本开始

1856
01:37:36,530 --> 01:37:38,376
because I think that's going to be our target for the semester.
因为我认为这将是本学期的目标

1857
01:37:39,037 --> 01:37:41,391
I use either a combination of just the editor
我通常组合使用一些编辑器

1858
01:37:41,416 --> 01:37:45,349
or the editor and a terminal to grep for things.
编辑器+在终端用grep查找

1859
01:37:45,782 --> 01:37:46,856
So if I wanted to know
如果我想知道

1860
01:37:46,881 --> 01:37:48,402
are there any readmes?
有没有 README 文件？

1861
01:37:54,516 --> 01:37:56,529
I would remember how to do it correctly.
我能想起来怎么弄

1862
01:37:56,869 --> 01:37:58,909
And then I would say, okay
然后我会说 好的

1863
01:37:58,910 --> 01:38:03,253
there's a readme in ./tools/tests/MPMMTest.
在 ./tools/tests/MPMMTest 里有一个 README

1864
01:38:03,326 --> 01:38:07,094
And this is, I think, another thing of, oh, the question is
哦 有人问

1865
01:38:07,095 --> 01:38:08,235
is XNU open source?
XNU 是开源的吗？

1866
01:38:08,279 --> 01:38:13,292
Yes, you can find everything at
是的 你可以在

1867
01:38:14,352 --> 01:38:18,156
https://github.com/apple-oss-distributions/XNU.
这里找到xnu的全部内容

1868
01:38:19,196 --> 01:38:21,129
Yeah, good. Look at that question online.
看一下网上的问题

1869
01:38:21,289 --> 01:38:21,976
Awesome.
真好

1870
01:38:22,117 --> 01:38:26,489
So this is part of, I think, understanding things, being comfortable.
我觉得 逐渐理解未知事物 适应它

1871
01:38:26,681 --> 01:38:29,120
You have to fundamentally be okay with not knowing everything.
你要能接受 有不清楚的

1872
01:38:29,121 --> 01:38:30,923
Like I look at this, I see, hmm
比如 我看着这个 心想 嗯

1873
01:38:30,924 --> 01:38:33,677
should I look up what the acronym MPMM is?
要不要查一下 MPMM 是什么？

1874
01:38:34,936 --> 01:38:37,197
No, because I don't care what it is.
不 我不在乎

1875
01:38:37,378 --> 01:38:39,557
So I have absolutely no idea what this thing is testing
我完全不知道这东西在测什么

1876
01:38:39,558 --> 01:38:40,519
but I don't really care.
但我不在乎

1877
01:38:40,520 --> 01:38:42,439
But I've just seen this acronym.
但我看到这个缩写了

1878
01:38:42,440 --> 01:38:43,520
Maybe it'll come up later.
也许后面会提到

1879
01:38:43,545 --> 01:38:45,193
Like it kind of lodges in your brain, but
有个印象

1880
01:38:45,616 --> 01:38:47,406
like, don't worry of like
不用担心

1881
01:38:47,560 --> 01:38:52,340
perf index Is it testing the performance of the indexing engine or is it
perf index？ 它是测试 索引引擎 的性能 还是……

1882
01:38:52,365 --> 01:38:53,024
I don't care.
我管它呢

1883
01:38:53,024 --> 01:38:54,800
I'm just trying to find out where the readmes are.
我只是想搞清楚 README 文件在哪里

1884
01:38:55,046 --> 01:38:59,237
to look for Are there any readmes that are trying to get me to the system call stuff?
找一找 有没有 README 文件能帮我找到系统调用的内容？

1885
01:39:00,144 --> 01:39:02,290
Tools, LLDB macros.
工具和 LLDB 宏

1886
01:39:02,464 --> 01:39:04,161
That sounds interesting because Adam did mention
听起来挺有意思的 亚当提过……

1887
01:39:04,162 --> 01:39:07,383
that they have great plugins and macros for LLDB.
他们有很多优秀的 LLDB 插件和宏

1888
01:39:07,384 --> 01:39:08,926
Those are actually in there. It is awesome.
那些插件和宏都在里面 很棒

1889
01:39:09,697 --> 01:39:12,576
README.DEBUG-kernel.txt

1890
01:39:12,648 --> 01:39:17,228
That could be interesting if we're like how do we suppose to do this?
如果是告诉我们怎么调试内核的，那会很有趣

1891
01:39:21,041 --> 01:39:22,687
Wait, that can't be right.
（回复评论）等下 这太假了

1892
01:39:22,814 --> 01:39:23,954
Is that a fake thing?
假的吧

1893
01:39:23,955 --> 01:39:25,634
Multi-Processor of Multi-Mushroom.
多蘑菇 的 多处理器 (MPMM)

1894
01:39:25,635 --> 01:39:26,641
That can't be.
这不可能

1895
01:39:26,797 --> 01:39:29,061
The multi-processor, I believe.
多处理器 我还能信

1896
01:39:29,118 --> 01:39:30,341
I don't know about the MM.
MM 是什么我就不知道了

1897
01:39:30,860 --> 01:39:32,335
libkdd

1898
01:39:32,939 --> 01:39:33,648
Readme.
说明文件

1899
01:39:33,913 --> 01:39:35,668
We could go back and look at the thing and be like
我们可以回头看看这个 想到

1900
01:39:35,692 --> 01:39:37,456
okay, what is libkdd?
libkdd 是什么？

1901
01:39:37,611 --> 01:39:41,686
OSMFK/tests/readme, libkern/zlib/readme

1902
01:39:41,802 --> 01:39:43,631
So you're out of luck in your readmes.
所以 很不幸 readme 里没想要的

1903
01:39:45,263 --> 01:39:47,125
You've readme failed, I think.
readme这招失败了

1904
01:39:49,023 --> 01:39:49,738
What was it?
什么？

1905
01:39:51,504 --> 01:39:52,576
Oh, with an iname?
哦 试一下 iname？

1906
01:39:52,623 --> 01:39:55,683
Okay, so iname being case independent.
好的 iname 表示 不区分大小写

1907
01:39:57,436 --> 01:39:58,766
No, because they're sane people.
不行 因为他们是正常人

1908
01:39:58,767 --> 01:40:01,156
They don't have readmes as undercase.
他们不会把说明文件设置成小写

1909
01:40:03,423 --> 01:40:04,476
Oh, you're just guessing. Okay.
哦 你猜的  行吧

1910
01:40:04,516 --> 01:40:05,909
Macintosh Page Memory Management.
Macintosh 分页 内存 管理

1911
01:40:06,022 --> 01:40:06,683
That could be.
可能是

1912
01:40:09,704 --> 01:40:12,109
I'm responding to Twitch like a good streamer.
我在回应 Twitch，像一个好主播一样

1913
01:40:14,923 --> 01:40:16,776
So now what? We just quit?
然后怎么办？放弃了？

1914
01:40:19,696 --> 01:40:21,263
Ah, Google.
啊 谷歌

1915
01:40:21,676 --> 01:40:23,450
We have everything here. The source is here.
都在这里 源代码在这儿

1916
01:40:25,646 --> 01:40:26,299
Isn't it?
是吗？

1917
01:40:27,571 --> 01:40:28,719
I read one command.
我看了个命令

1918
01:40:29,051 --> 01:40:29,486
Boom.

1919
01:40:29,773 --> 01:40:30,633
grep for syscall.
grep 查 syscall

1920
01:40:31,374 --> 01:40:32,633
grep for syscall.
grep 查 syscall

1921
01:40:36,422 --> 01:40:37,440
Sorry, am I in front of a class?
我是在课堂上吗？

1922
01:40:37,441 --> 01:40:38,422
Yes, I'm in front of a class
是的 我在课堂上

1923
01:40:38,423 --> 01:40:41,954
but I can't show you because the class is stuff.
但我不能给你们看 因为课堂规定

1924
01:40:42,064 --> 01:40:43,427
No, no, you're fine. You're not distracting.
不不 没事 不打扰

1925
01:40:43,487 --> 01:40:45,039
We are streaming. This is what we do.
我们在直播 这很正常

1926
01:40:47,284 --> 01:40:52,073
Okay, so building up a grep can be a pain.
好的 写一个 grep 命令可能很烦

1927
01:40:52,106 --> 01:40:53,636
So what do we want to do?
怎么做？

1928
01:40:54,339 --> 01:40:58,559
-R *, so –R recursive, star everything in the current thing.
 -R 表示递归  * 代表当前目录下所有内容

1929
01:40:58,648 --> 01:40:59,753
I'm in the root here.
我在根目录

1930
01:41:00,408 --> 01:41:03,266
I do this, and it's going to be all hell will break loose, right?
执行它 肯定会乱成一团 对吧？

1931
01:41:03,330 --> 01:41:04,799
Why is all hell breaking loose?
为什么会乱成这样？

1932
01:41:07,960 --> 01:41:09,094
Yeah, lots of files
是的 有很多文件

1933
01:41:09,140 --> 01:41:11,955
but also lots of stuff I don't care about,
同时有许多我不关心的内容

1934
01:41:11,956 --> 01:41:15,374
like things in, for instance, all the things at the start.
比如 一开始的所有这些东西

1935
01:41:15,660 --> 01:41:19,434
Do I care that build/dst/usr/include/mach?
我关心这个吗？

1936
01:41:19,581 --> 01:41:21,863
We didn't see build in that list, but if we...
我们在列表里没看到 build 不过……

1937
01:41:26,003 --> 01:41:27,205
Do I actually have a clean?
我有实现 clean 吗

1938
01:41:27,206 --> 01:41:28,043
That's interesting.
挺有意思的

1939
01:41:29,896 --> 01:41:30,825
Yeah, now it's not in there.
对 现在没有了

1940
01:41:32,505 --> 01:41:37,153
But the build directory is where everything gets built when I do make.
运行 make 时 所有东西都在BUILD目录里构建

1941
01:41:37,193 --> 01:41:39,868
So it's saying, like, binary things match.
所以它会匹配一些二进制程序

1942
01:41:39,869 --> 01:41:41,969
Like, of course. Like, we're compiling a bunch of things
当然了，因为我们要编译很多东西

1943
01:41:41,970 --> 01:41:43,930
and a bunch of object files and linking them together.
还有很多object文件 然后把它们链接在一起

1944
01:41:43,931 --> 01:41:46,000
syscall will be absolutely all over the place.
syscall会遍布各处

1945
01:41:47,072 --> 01:41:48,874
Okay, so I can grep for syscall.
好的 我可以查找syscall

1946
01:41:51,134 --> 01:41:51,952
Cool.
不错

1947
01:41:53,445 --> 01:41:55,134
And so I deleted the build directory.
我删掉了BUILD目录

1948
01:41:55,135 --> 01:41:56,505
You can also...
你还可以……

1949
01:41:57,897 --> 01:42:00,037
There's ways, I can't remember it.
有办法 但我忘了

1950
01:42:00,551 --> 01:42:02,306
Maybe I should just search for this.
也许我该查一下

1951
01:42:07,883 --> 01:42:12,226
Isn't there a way to exclude a directory?
有没有办法排除一个目录？

1952
01:42:14,869 --> 01:42:16,570
Yeah, --exclude-dir.
对 用排除 目录

1953
01:42:25,129 --> 01:42:27,302
Okay, cool, so we can do that.
好的 这样也行

1954
01:42:29,242 --> 01:42:32,822
Probably don't care about the tools directory either or the tests.
tools和tests目录也不重要

1955
01:42:34,256 --> 01:42:34,762
I don't know
我也不清楚

1956
01:42:34,763 --> 01:42:35,849
do I really care about that?
我真的需要管那个吗？

1957
01:42:43,326 --> 01:42:44,866
Or tests.
或者tests

1958
01:42:50,589 --> 01:42:52,493
Look at this, I'm so much faster than Googling.
看 比谷歌快多了

1959
01:42:52,729 --> 01:42:53,099
Okay.
好的

1960
01:42:58,512 --> 01:42:59,533
Now I have a bunch of stuff.
现在有很多线索

1961
01:42:59,566 --> 01:43:02,593
So I have stuff in
有的在

1962
01:43:02,733 --> 01:43:04,873
because I'm looking at this here, just the left-hand side.
我在看左边这部分

1963
01:43:04,874 --> 01:43:06,313
I have stuff in BSD.
在 BSD 目录里

1964
01:43:07,019 --> 01:43:08,846
I have stuff, oh
还有

1965
01:43:10,746 --> 01:43:11,715
I may have gone too fast.
翻得可能太快了

1966
01:43:12,139 --> 01:43:13,513
I have stuff in security.
在 security 里也有

1967
01:43:13,757 --> 01:43:16,556
So of these directories we're looking at
所以 这些目录中

1968
01:43:16,557 --> 01:43:18,776
based on what we just read from the README
根据 README 里的内容

1969
01:43:18,999 --> 01:43:21,923
which of these are more likely to have the thing that we're looking for?
哪些更可能包含我们要找的东西？

1970
01:43:24,636 --> 01:43:26,596
OSFMK and what else?
OSFMK 还有呢？

1971
01:43:27,594 --> 01:43:28,276
BSD.

1972
01:43:29,230 --> 01:43:30,456
Yeah, I'd probably
嗯 我大概会

1973
01:43:32,876 --> 01:43:34,263
can you do it like that? Yeah.
你能这样做吗？ 没问题

1974
01:43:34,653 --> 01:43:37,310
So I'd probably look at those as a starting point
所以我大概会从这些开始看

1975
01:43:37,392 --> 01:43:39,411
because those are kind of the core things.
因为这些算是核心的东西

1976
01:43:39,412 --> 01:43:44,669
Now it could be, oh, ah, well, that's nice.
哦 啊 这挺好的

1977
01:43:46,013 --> 01:43:47,956
So somebody has a much better approach.
有人有个更好的方法

1978
01:43:49,815 --> 01:43:51,296
So here we have interesting things.
这里有些有意思的东西

1979
01:43:51,336 --> 01:43:52,736
So we have BSD.
我们有 BSD

1980
01:43:52,936 --> 01:43:55,075
BSD apparently has its own conf directory.
BSD 有自己的配置目录

1981
01:43:55,103 --> 01:43:57,696
So maybe we'd want to look in there and see what, Like
也许我们可以进去看看 比如

1982
01:43:58,556 --> 01:44:00,343
if this is something we should be ignored.
看看这是否需要忽略

1983
01:44:00,581 --> 01:44:02,956
We have nfs_syscalls.c.
我们有 nfs_syscalls.c

1984
01:44:03,464 --> 01:44:04,409
There.
就这儿

1985
01:44:08,206 --> 01:44:08,726
Let's see.
我们看看

1986
01:44:08,727 --> 01:44:09,753
skip_syscall.

1987
01:44:09,793 --> 01:44:10,973
Oh, well, this looks nice.
哦 这个看起来不错

1988
01:44:11,048 --> 01:44:13,660
bsd/dev/arm/systemcalls.c.

1989
01:44:14,211 --> 01:44:15,111
Should we look there?
要看看吗

1990
01:44:16,112 --> 01:44:17,564
Yeah, that looks pretty good.
嗯 这看起来不错

1991
01:44:17,717 --> 01:44:20,223
Okay, because I'm not a monster I'm going to use my editor.
我不傻 我会用编辑器看代码

1992
01:44:23,176 --> 01:44:24,762
Now, how do I...
现在 我该怎么

1993
01:44:24,956 --> 01:44:26,676
No, I want to change the text's.
不 我想改文字的

1994
01:44:27,082 --> 01:44:28,396
Sorry, I always have to look this up.
对不起 我总得查这个

1995
01:44:28,930 --> 01:44:33,796
Emacs change font size all frames.
Emacs 调整所有窗口的字体大小

1996
01:44:50,201 --> 01:44:51,653
Changing font size.
调整字体大小

1997
01:44:52,843 --> 01:44:54,633
Current buffer, but I want all buffers.
当前缓冲区 但我希望调整所有的

1998
01:44:59,283 --> 01:45:01,240
change font size all buffers
修改所有缓冲区字体大小

1999
01:45:05,971 --> 01:45:07,464
Control X, Control Plus.
Control X, Control +

2000
01:45:08,213 --> 01:45:09,304
That's what I do.
我就是这样做的

2001
01:45:10,875 --> 01:45:11,710
All right, fine.
好吧 行

2002
01:45:11,976 --> 01:45:13,317
For you all, I will do it.
为了你们 我会做

2003
01:45:15,258 --> 01:45:15,670
Okay.
好的

2004
01:45:16,505 --> 01:45:20,632
Okay, so we were looking at tmp/building-xnu
好的 我们要看 tmp/building-xnu

2005
01:45:23,385 --> 01:45:24,612
12, wait, wait.
12 等等

2006
01:45:25,006 --> 01:45:25,525
What?
什么？

2007
01:45:26,548 --> 01:45:27,692
No, that's my own thing.
不 那是我自己的东西

2008
01:45:28,029 --> 01:45:28,792
That's funny.
真有意思

2009
01:45:29,256 --> 01:45:29,766
Okay.
好吧

2010
01:45:30,146 --> 01:45:31,933
We're in here, we were in
我们在这里，我们之前在

2011
01:45:32,046 --> 01:45:36,926
and we saw a file in, what is it, bsd/dev/arm/systemcalls.c
我们之前看到一个文件，bsd/dev/arm/systemcalls.c

2012
01:45:36,951 --> 01:45:44,330
Okay, so BSD, 12.5, XNU, BSD, dev, arm.
好的  BSD 12.5 XNU dev arm

2013
01:45:44,430 --> 01:45:45,749
Let's look at arm 64
我们看 arm 64的

2014
01:45:45,750 --> 01:45:46,849
because that's what we're using
因为我们用的这个

2015
01:45:46,903 --> 01:45:49,850
and so if we're gonna go to an architecture specific file
所以我们要查看架构特定的文件

2016
01:45:49,883 --> 01:45:51,603
we might as well go to the one that, ah
那我们就看那个

2017
01:45:51,656 --> 01:45:52,963
but maybe it's not here.
可能它不在这里

2018
01:45:57,016 --> 01:46:04,443
Okay, so, But this seems interesting, SYSCTL_INT.
好的 这个看起来挺有意思的 SYSCTL_INT

2019
01:46:05,723 --> 01:46:08,405
Oh no, that's, anyways
哦 不管了

2020
01:46:08,406 --> 01:46:10,286
we could dig in and look up this.
我们可以深入研究一下

2021
01:46:10,287 --> 01:46:14,750
This is like a key value store to like specify
这存着一个键值对 用来指定

2022
01:46:14,775 --> 01:46:17,033
things that an admin can change, like
管理员可以更改的项目

2023
01:46:17,093 --> 01:46:20,708
and root can change, like variables directly in the kernel.
还有root可以更改的 内核中变量

2024
01:46:20,709 --> 01:46:23,509
Anyways, this is, we could dig in and figure that out
总之 这个我们能搞明白

2025
01:46:23,510 --> 01:46:25,590
but we're trying to dig in and figure out something else.
但我们正在尝试弄清楚其他的东西

2026
01:46:32,216 --> 01:46:33,132
Yeah, I'm in the wrong file
是的 我进错文件了

2027
01:46:33,133 --> 01:46:35,463
because there is no system calls.
因为这里没有系统调用

2028
01:46:36,730 --> 01:46:38,863
So I'd go arm64.
所以我要去 arm64

2029
01:46:44,210 --> 01:46:47,045
When I grep for syscalls in here.
我在这搜索一下syscall

2030
01:46:47,070 --> 01:46:48,070
There's none in here.
这里没有

2031
01:46:48,216 --> 01:46:49,103
So, okay.
好吧

2032
01:46:49,384 --> 01:46:53,086
Let's briefly scan through systemcalls.c in ARM.
我们快速看看 ARM 目录里的 systemcalls.c

2033
01:46:53,116 --> 01:46:55,110
Maybe it gives us something interesting.
也许会有一些有趣的东西

2034
01:46:57,149 --> 01:46:58,626
I'll just kind of vaguely...
我随便看看……

2035
01:46:59,031 --> 01:46:59,706
Okay.
好的

2036
01:47:00,073 --> 01:47:01,233
I already see something interesting.
我已经发现一些有趣的东西了

2037
01:47:01,234 --> 01:47:02,860
Does anybody else see something interesting here?
有人看到吗

2038
01:47:04,257 --> 01:47:04,900
What was it?
是什么？

2039
01:47:08,482 --> 01:47:09,783
syscall.h.

2040
01:47:10,363 --> 01:47:11,837
Yeah, that seems interesting.
是的 这挺有意思的

2041
01:47:15,067 --> 01:47:17,609
Now, we'd have to look up the exact compilation.
现在 我们得查一下具体的编译原理

2042
01:47:17,610 --> 01:47:18,654
I can't remember.
我想不起来

2043
01:47:19,158 --> 01:47:20,438
I mean, the...
我是说 这个……

2044
01:47:22,728 --> 01:47:26,514
Having the angular brackets around this means it's a library function
用尖括号括起来 表示这是一个库函数

2045
01:47:26,515 --> 01:47:31,595
that the compiler searches certain paths
编译器会搜索特定路径

2046
01:47:31,596 --> 01:47:33,743
of figuring out where this file is.
来找到这个文件

2047
01:47:33,888 --> 01:47:35,894
Whatever, I'm just going to search for it.
不管了 先找一下syscall.h

2048
01:47:40,702 --> 01:47:41,506
And I will fail.
还没找到

2049
01:47:42,721 --> 01:47:44,363
Oh, I actually do know why.
哦 我知道为什么

2050
01:47:45,404 --> 01:47:46,445
Why is it failing?
为什么会失败？

2051
01:47:51,166 --> 01:47:51,652
What?
什么？

2052
01:47:53,194 --> 01:47:54,852
I'm in this directory.
我在这个目录里

2053
01:47:55,248 --> 01:47:56,468
This is the kernel.
这是内核

2054
01:47:56,469 --> 01:47:58,409
We can't have external dependencies, otherwise we're...
我们不能有外部依赖 否则就……

2055
01:48:07,436 --> 01:48:07,929
Hmm?
嗯？

2056
01:48:11,243 --> 01:48:12,269
Say it again?
再说一遍？

2057
01:48:14,243 --> 01:48:15,243
I can't hear you.
我听不见

2058
01:48:19,574 --> 01:48:21,483
Yeah, so...
嗯 所以……

2059
01:48:26,035 --> 01:48:27,135
So the file, okay
这个文件

2060
01:48:27,136 --> 01:48:28,796
so we know two things.
我们知道两点

2061
01:48:28,797 --> 01:48:32,636
We know this file has to exist for that thing to compile.
这个文件必须存在 才能编译

2062
01:48:32,863 --> 01:48:35,021
I guess we've technically never seen this kernel compile
准确来说 我们还没看到 这个内核成功编译

2063
01:48:35,022 --> 01:48:36,862
but we can switch to the version that does work
但我们可以切换到可以工作的版本

2064
01:48:36,863 --> 01:48:38,690
or I can port those changes over very quickly
或快速移植这些改动

2065
01:48:38,825 --> 01:48:40,783
and we can prove that this kernel does compile.
我们能证明这个内核可以编译

2066
01:48:40,946 --> 01:48:43,149
But this file does not exist in the source.
但在源码中没有这个文件

2067
01:48:43,629 --> 01:48:44,709
Is it auto-generated?
它是自动生成的吗？

2068
01:48:44,883 --> 01:48:46,209
It must be.
是的

2069
01:48:46,332 --> 01:48:48,909
The compilation process must be auto-generated it
编译时 肯定会 自动生成它

2070
01:48:48,993 --> 01:48:50,070
and why can't we find it?
为什么找不到它呢？

2071
01:48:51,076 --> 01:48:53,150
Because we haven't tried to generate it.
因为我们还没生成它

2072
01:48:53,373 --> 01:48:54,552
No, we did try to generate it
不 我们试过生成它

2073
01:48:54,583 --> 01:48:55,334
but then I cleaned it
但之后我清理了它

2074
01:48:55,335 --> 01:48:57,536
and deleted everything to make it easier.
全删了 方便筛选

2075
01:48:58,096 --> 01:49:00,309
So, let's rebuild it and see what happens.
所以 我们重构建一下看看

2076
01:49:01,259 --> 01:49:01,578
Okay.
好的

2077
01:49:03,166 --> 01:49:04,641
ah it still won't work because it doesn't build.
它还是不行 因为编译不了

2078
01:49:04,693 --> 01:49:05,903
Awesome, awesome, awesome.
太棒了 太棒了 太棒了

2079
01:49:08,124 --> 01:49:08,545
What?
什么？

2080
01:49:14,340 --> 01:49:15,736
Wait, wait, sorry, what? Say that again?
等一下 抱歉 什么？再说一遍？

2081
01:49:22,843 --> 01:49:24,463
It has its own kernel headers in there.
里面有自己的内核头文件

2082
01:49:25,733 --> 01:49:26,253
Yeah.
嗯

2083
01:49:26,519 --> 01:49:30,137
So the problem was I was running make inside of the XNU thing
问题是 我是在 XNU 里面运行 make

2084
01:49:30,138 --> 01:49:31,238
which is running their make
它也在运行 make

2085
01:49:31,285 --> 01:49:35,418
but I needed to go out one more to run mine make that does everything that it needs to do.
但我需要到外面一层 运行我的 会执行它需要的全部的那个

2086
01:49:37,971 --> 01:49:39,736
I really hope this is the reason this will be silly.
希望就是这个原因 不然我就搞笑了

2087
01:49:45,139 --> 01:49:46,146
Computer's getting hot.
电脑变热了

2088
01:50:01,276 --> 01:50:03,952
I mean, you get into like the bootstrapping paradox problem,
我是说 虽然会遇到引导悖论这样的问题

2089
01:50:03,953 --> 01:50:06,296
but fundamentally, no.
但其实不会

2090
01:50:07,434 --> 01:50:08,916
Boom, there we go.
好了 搞定了

2091
01:50:09,275 --> 01:50:10,594
See, and everything's in build
你看 都在build里

2092
01:50:10,595 --> 01:50:11,610
so this makes sense.
这说的通了

2093
01:50:11,737 --> 01:50:14,156
So what this tells us is there must be some process
所以 构建时 一定有一个过程

2094
01:50:14,297 --> 01:50:16,359
that like as a pre-compilation step,
就像一个预编译步骤

2095
01:50:16,360 --> 01:50:17,459
and which kind of makes sense, right?
这合情合理 对吧？

2096
01:50:17,460 --> 01:50:21,510
Probably you want system calls defined maybe where they're necessary.
可能想 只定义必要的系统调用

2097
01:50:21,681 --> 01:50:23,806
and then collating them all from the whole kernel
然后从整个内核中汇总所有调用

2098
01:50:23,862 --> 01:50:27,660
and creating one syscall.h that everyone else can include.
创建一个 syscall.h 供其他部分引入

2099
01:50:30,165 --> 01:50:32,036
I don't know if it's actually done like that, but
我不知道是不是真的这样做 不过

2100
01:50:32,991 --> 01:50:33,443
yeah.
嗯

2101
01:50:33,968 --> 01:50:35,736
So let's look at
那么我们来看看

2102
01:50:36,768 --> 01:50:38,467
so now we do need that build file
所以我们需要BUILD里的文件

2103
01:50:38,468 --> 01:50:39,769
so I was incorrect.
我之前错了

2104
01:50:39,869 --> 01:50:41,203
So we need build
所以我们需要build

2105
01:50:41,670 --> 01:50:49,576
我们去 dst/usr/include/sys 里面看看

2106
01:50:54,776 --> 01:50:56,123
Okay, cool.
好的 不错

2107
01:51:01,643 --> 01:51:04,347
These make sense because we know BSD is very similar to Linux.
有道理 因为 BSD 和 Linux 很相似

2108
01:51:04,348 --> 01:51:07,363
We're very, we know a lot of the Linux system calls.
我们对很多 Linux 系统调用都很熟悉

2109
01:51:07,803 --> 01:51:11,230
Link, unlink, we can just kind of scroll through these.
链接、取消链接 我们可以快速浏览

2110
01:51:18,746 --> 01:51:19,630
Oh, interesting.
哦 有趣

2111
01:51:21,673 --> 01:51:24,469
Oh, so there's a macro so you can know the maximum sys call.
哦 原来还有个宏 可以让你知道最大的系统调用

2112
01:51:27,148 --> 01:51:27,656
Cool.
不错

2113
01:51:27,889 --> 01:51:30,829
And apparently some of these system calls you used to actually be able to call.
显然 这里有些你熟悉的 确实能调用

2114
01:51:30,983 --> 01:51:32,050
You can read the book.
你可以读书

2115
01:51:32,051 --> 01:51:33,971
The guy talks about these different things.
书里谈到了这些内容

2116
01:51:33,972 --> 01:51:34,516
But okay.
好的

2117
01:51:34,933 --> 01:51:37,243
So let's say we want to go to
比如 我们想去

2118
01:51:37,473 --> 01:51:39,116
there must be like a sysopen.
肯定有个类似 sys open 的东西

2119
01:51:39,473 --> 01:51:42,055
So okay, we want to go to sysopen, right?
我们要看 SYS_open 对吧？

2120
01:51:42,056 --> 01:51:43,183
We know this macro.
我们知道这个宏

2121
01:51:54,686 --> 01:51:56,493
I hope too. It didn't, but...
它没如我所愿

2122
01:52:22,507 --> 01:52:23,920
Well, this may be too much, but...
嗯 这可能会太多了 但……

2123
01:52:25,353 --> 01:52:28,326
I mean, I know this should be in BSD or not.
应该就在 BSD  也许不是

2124
01:52:31,276 --> 01:52:35,906
Oh, interesting.
哦 有意思

2125
01:52:36,397 --> 01:52:37,333
Okay.
好的

2126
01:52:42,360 --> 01:52:43,973
That's going to take longer than I thought.
这比我想象的要费时间

2127
01:52:57,631 --> 01:52:58,451
Telemetry?
远测？

2128
01:52:58,476 --> 01:52:59,200
Yeah.
嗯

2129
01:53:19,417 --> 01:53:20,713
Okay, this is weird.
这太奇怪了

2130
01:53:28,983 --> 01:53:29,803
Okay.
好的

2131
01:53:32,383 --> 01:53:35,343
So four, five, one, wow, random hashes.
451 哇 随机哈希

2132
01:53:35,344 --> 01:53:38,782
That doesn't seem fill me with confidence.
这似乎没怎么增加我的信心

2133
01:53:40,347 --> 01:53:40,806
Okay.
好的

2134
01:53:48,596 --> 01:53:50,203
Oh, oh, there we go.
哦 有了

2135
01:53:50,889 --> 01:53:53,569
Okay, so we got a hit, right?
好，我们找到了一个线索

2136
01:53:53,570 --> 01:53:57,033
So at least the four, five, one.
至少 这个451

2137
01:53:57,401 --> 01:53:59,462
The intuition was
想法是

2138
01:54:01,268 --> 01:54:02,290
 if we search
如果我们搜索

2139
01:54:02,563 --> 01:54:07,506
the 451 is not something that just like randomly occurs as you're coding,
451 编码时 不是瞎写的

2140
01:54:07,584 --> 01:54:09,030
except in these hashes, right?
除非它是hash出来的

2141
01:54:09,305 --> 01:54:10,305
So the intuition was, okay
所以直觉是

2142
01:54:10,330 --> 01:54:11,386
if we look for that
如果我们查找它

2143
01:54:11,387 --> 01:54:13,306
maybe that will give us some clue
也许那能给我们一些线索

2144
01:54:13,307 --> 01:54:15,328
and we see something with telemetry.
然后通过 telemetry 我们发现了些线索

2145
01:54:15,329 --> 01:54:20,236
So we at least see, okay there's this init sysent.
我们找到了 init sysent.c

2146
01:54:22,451 --> 01:54:23,852
And what's this in?
它在哪个目录？

2147
01:54:23,853 --> 01:54:25,290
Build/obj

2148
01:54:41,315 --> 01:54:42,336
Okay.
行

2149
01:54:42,575 --> 01:54:44,463
So this includes some stuff.
所以这里引入了一些东西

2150
01:54:45,315 --> 01:54:47,616
The casts are bogus but we'll do for now.
"这些类型转换不对劲 但先这样用"

2151
01:54:47,936 --> 01:54:50,929
I don't, what is that? Like, you know, who needs ...
我不，谁需要

2152
01:54:52,402 --> 01:54:53,438
structs Okay.
一些结构体 好的

2153
01:54:55,531 --> 01:54:57,089
Aha. Okay. So this is cool.
啊哈 好的 这很酷

2154
01:54:57,116 --> 01:55:03,203
So now we get the zero, the one, the exit, the fork, the read, the write, the open.
现在我们找到了0、1 退出、fork、read、write、open

2155
01:55:03,358 --> 01:55:17,289
And now we can maybe look at this as like sy_call_t * ... 12
我们可以把这个 (sy_call_t *) open...12  看作 open

2156
01:55:17,436 --> 01:55:19,390
no idea what this is but
完全不知道这是什么 但

2157
01:55:23,183 --> 01:55:24,096
what's this called?
这叫什么？

2158
01:55:24,121 --> 01:55:26,834
Requires, oh, interesting.
需要这个 哦 有趣

2159
01:55:29,060 --> 01:55:31,323
So where does this open come from then?
那这个 open 是从哪里来的？

2160
01:55:34,099 --> 01:55:35,603
Okay. Do we want to find telemetry?
我们要找 telemetry 吗？

2161
01:55:35,604 --> 01:55:37,285
I feel like this will be way easier to find.
我觉得这个会更容易找到

2162
01:55:37,286 --> 01:55:37,690
Okay.
好的

2163
01:55:38,747 --> 01:55:43,933
See, I think what this is doing without digging in is that like
还没深入看它，它的功能看着像是

2164
01:55:47,160 --> 01:55:47,853
no I don't know.
我不知道

2165
01:55:50,720 --> 01:55:51,626
I think it's like
我觉得可能是

2166
01:55:51,983 --> 01:55:54,745
it may need to work with 32 bits
它可能需要 32 位的数据

2167
01:55:54,746 --> 01:55:56,755
and require weird system call stuff.
并且需要一些特殊的系统调用

2168
01:55:56,795 --> 01:55:58,947
So the system calls are different on different things
所以不同架构上的系统调用不一样

2169
01:55:58,948 --> 01:56:01,387
and you need different like handlers,
需要不同的处理程序

2170
01:56:01,388 --> 01:56:04,586
but yeah, you could definitely.
不过确实 你肯定能

2171
01:56:10,340 --> 01:56:10,815
Yeah.
嗯

2172
01:56:17,378 --> 01:56:17,984
Okay.
行

2173
01:56:18,438 --> 01:56:21,220
So I had another trick that I've forgotten.
我还有一个技巧忘记了

2174
01:56:31,872 --> 01:56:33,569
Ah, there we're looking somewhere.
啊 找到了一些

2175
01:56:33,802 --> 01:56:37,075
Okay, so I looked for just the telemetry we were interested in
我只找了感兴趣的telemetry

2176
01:56:37,102 --> 01:56:38,507
because we know that's some function.
因为它肯定是个函数

2177
01:56:38,548 --> 01:56:41,561
So the way I always think about this, right this guy's like this.
我是这样想的

2178
01:56:42,710 --> 01:56:45,731
If we have this .c file, this telemetry pointer
这个文件里的telemetry 指针

2179
01:56:45,732 --> 01:56:48,950
which is probably the exact function we want to call on this system call,
很可能是 使用这个系统调用时 要调用的函数

2180
01:56:50,025 --> 01:56:54,612
is... defined somewhere in here, right?
应该是在这里的某个位置 定义的 对吧？

2181
01:56:54,658 --> 01:56:56,010
Somebody is defining this thing
有人在这里定义了这个东西

2182
01:56:56,011 --> 01:56:57,371
but I don't know exactly where.
但我不知道具体在哪里

2183
01:56:57,411 --> 01:56:59,271
And I also don't necessarily want to go to the definition
而且我也不一定非得去看函数声明

2184
01:56:59,272 --> 01:57:00,585
because if I go to the definition
因为就算看了函数声明

2185
01:57:00,632 --> 01:57:02,355
I also want to go to the actual implementation.
还是要看函数实现

2186
01:57:02,393 --> 01:57:04,133
I'm more interested in reading the implementation.
我对实现更感兴趣

2187
01:57:06,143 --> 01:57:08,623
So one trick is to do like
所以一个技巧是

2188
01:57:09,055 --> 01:57:13,016
like look for something that looks like a function definition
比如说 找看着像 函数声明 的

2189
01:57:13,017 --> 01:57:14,823
or at least the call to the function.
或像 函数调用

2190
01:57:15,929 --> 01:57:20,103
And so we see this nice, let's see.
于是我们看到了这个

2191
01:57:20,487 --> 01:57:22,847
Yeah, I think it's the syscalls.master.
我觉得它是 syscalls.master

2192
01:57:22,848 --> 01:57:25,907
Did we look for anything with the name of syscalls in it?
我们有没有找过文件名里有 syscalls 的

2193
01:57:26,233 --> 01:57:27,583
I don't think so.
我觉得没有

2194
01:57:33,323 --> 01:57:34,530
what was it?
你说什么

2195
01:57:34,747 --> 01:57:37,220
kern/syscalls.master

2196
01:57:37,873 --> 01:57:40,120
but them in bsd. you forgot to say bsd
在bsd里，你忘了说bsd

2197
01:57:50,636 --> 01:57:52,990
Ah, and, anybody see this?
啊 还有 有人看到这个了吗？

2198
01:57:53,116 --> 01:57:54,370
makesyscalls.sh

2199
01:57:55,642 --> 01:57:56,882
So our first thing was we didn't
首先 刚刚我们没有

2200
01:57:56,922 --> 01:58:00,950
grep for just anything with any file with the name system call in it.
直接查找文件名中包含 syscall 的

2201
01:58:01,023 --> 01:58:04,186
That would have, we would have definitely found that here.
那样的话 当时就能找到这个

2202
01:58:05,982 --> 01:58:07,122
Yeah, so this is interesting.
是的 这很有意思

2203
01:58:07,147 --> 01:58:07,855
This is,
这个是

2204
01:58:08,367 --> 01:58:11,183
you could probably look over this of how they actually generate things.
看这个，你们能大概知道他们是怎么生成这些的

2205
01:58:11,228 --> 01:58:13,600
I don't care about it so much.
我不太在意这个

2206
01:58:15,290 --> 01:58:17,227
Wait, that's not what I want.
等等 这不是我要的

2207
01:58:17,350 --> 01:58:18,773
No, that's definitely not what I want.
这个更不是

2208
01:58:22,283 --> 01:58:25,110
Um, so then you can look for this of like their formats
通过这个 能知道他们的格式

2209
01:58:25,150 --> 01:58:27,122
um how they create this.
知道它们的生成方法

2210
01:58:27,123 --> 01:58:27,522
Yeah.
对

2211
01:58:27,523 --> 01:58:31,611
So, so telemetry is a function that
所以 telemetry 函数

2212
01:58:31,635 --> 01:58:35,853
takes in a command, a deadline, an interval, a leeway
接受参数有：cmd、deadline、interval、leeway

2213
01:58:36,004 --> 01:58:38,820
and maybe an arg4 an arg5.
可能还有 arg4 arg5

2214
01:58:38,965 --> 01:58:42,159
This no syscall stub though. Looks, uh, suspicious.
不过这个 NO_SYSCALL_STUB 看起来有点奇怪

2215
01:58:44,046 --> 01:58:46,253
So I don't know what that's going to do, but, uh,
我不知道这有嘛用 但

2216
01:58:47,468 --> 01:58:49,480
seems to be not great.
似乎不太对劲

2217
01:58:50,289 --> 01:58:51,760
Oh, microstackshot.
哦 微栈快照

2218
01:58:51,954 --> 01:58:55,059
Oh, I think I did look up this micro stack shot
哦 我查过这个微栈快照

2219
01:58:55,416 --> 01:59:00,428
of like taking a shot of the stack of a process while it's running or something
就是捕获进程运行时的栈状态

2220
01:59:00,453 --> 01:59:03,519
to like get telemetry debug information about what's going on.
用来获取调试数据信息 了解发生了什么

2221
01:59:05,786 --> 01:59:08,839
Okay, and we have this UIPC syscalls.
好吧 还有 UIPC 系统调用

2222
01:59:17,903 --> 01:59:18,610
Interesting.
有趣

2223
01:59:18,724 --> 01:59:20,016
Okay, but where, so
好吧 但是在哪里？

2224
01:59:21,032 --> 01:59:22,312
Let's at least look at this telemetry
我们先看看这个telemetry

2225
01:59:22,313 --> 01:59:24,083
and see if there's anything else interesting
看看有没有其他有趣的

2226
01:59:24,233 --> 01:59:26,443
of like an actual implementation of that function.
比如 这个函数的实现

2227
01:59:28,887 --> 01:59:29,543
Okay.
好的

2228
01:59:32,175 --> 01:59:33,517
I think that's us right there, right?
这个就是我们之前看的，对吧

2229
01:59:35,343 --> 01:59:35,729
Yeah.
是的

2230
01:59:45,140 --> 01:59:45,586
Ooh.
哦

2231
01:59:45,753 --> 01:59:46,939
Oh, this is the other trick.
哦 另一个诀窍是

2232
01:59:46,940 --> 01:59:48,359
I just remembered by looking at this.
看到这个 才想起来

2233
01:59:48,579 --> 01:59:51,787
The other thing you can do in grepping for a function definition is
找函数声明时，你还可以

2234
01:59:51,812 --> 01:59:55,252
for whatever reason this is like Apple style for almost all of their things.
不知什么原因 几乎所有苹果产品 都遵守一个风格

2235
01:59:55,382 --> 01:59:59,861
So if you look for the thing you're interested in, like telemetry, parentheses,
当你想查找感兴趣的 比如 "telemetry("

2236
01:59:59,974 --> 02:00:04,374
but at the start character so it's at the start of the line you'll often find the definition.
它通常在行首

2237
02:00:04,770 --> 02:00:06,742
And that is very helpful.
这非常有帮助

2238
02:00:09,353 --> 02:00:10,915
And then we can see
接着我们可以看到

2239
02:00:11,094 --> 02:00:16,973
so this takes in a proc pointer p,
这里接收一个proc指针 P

2240
02:00:17,097 --> 02:00:22,819
telemetry_args args, ret value, some return value.
遥测参数 args, retval 返回值

2241
02:00:22,820 --> 02:00:24,440
So at least just looking at this
所以至少从这里看

2242
02:00:24,441 --> 02:00:26,370
this is very weird that these are both unused.
这两个参数都没用到 非常奇怪

2243
02:00:27,642 --> 02:00:29,334
Why would it not return anything?
为什么它不返回任何东西？

2244
02:00:29,760 --> 02:00:38,033
But so we could at least look at this and say, okay, args command
看到这个 我们知道 这个args->cmd

2245
02:00:38,104 --> 02:00:39,366
without even looking at the struct
不用看结构体

2246
02:00:39,393 --> 02:00:42,945
we know at least from the documentation that we saw of the system call interface
从系统调用接口的文档中 我们知道

2247
02:00:42,946 --> 02:00:45,319
that the first argument was cmd command.
第一个参数是 cmd 命令

2248
02:00:46,159 --> 02:00:48,601
Another interesting thing, there's an if def here.
还有一个有趣的是 这里有一个 #if

2249
02:00:48,626 --> 02:00:51,670
So depending on how our OS, how...
所以 取决于我们操作系统的设置

2250
02:00:53,344 --> 02:00:55,143
We may or may not compile this
我们可能会，也可能不会编译这部分

2251
02:00:55,144 --> 02:00:56,884
but then we could also look at the kernel
但我们也可以看看内核

2252
02:00:56,885 --> 02:00:59,024
and have to find this telemetry function
找找这个telemetry函数

2253
02:00:59,025 --> 02:01:01,337
and maybe see if we even have telemetry.
看看是否有telemetry

2254
02:01:01,833 --> 02:01:04,950
So there's these different commands, TELEMETRY_CMD_TIMER_EVENT.
这里有各种命令 比如TELEMETRY_CMD_TIMER_EVENT

2255
02:01:05,226 --> 02:01:07,624
This is when I see something like this that's very unique
看到这种非常独特的东西时

2256
02:01:07,767 --> 02:01:10,890
I'll know that I can very easily find this header file.
就知道这个头文件很容易找到

2257
02:01:11,208 --> 02:01:13,147
If we look at these header files
如果我们看看这些头文件

2258
02:01:13,148 --> 02:01:13,930
I don't know if...
不确定...

2259
02:01:15,163 --> 02:01:17,723
Oh, kern/telemetry.h is where I guess...
哦 我猜是 kern/telemetry.h

2260
02:01:19,893 --> 02:01:21,493
And that's going to be in
它应该在

2261
02:01:21,494 --> 02:01:22,993
and I always have to find these.
我总得找一下

2262
02:01:23,033 --> 02:01:24,666
I think this is back in our
我觉得是在

2263
02:01:27,412 --> 02:01:32,760
in our object dst/usr/include/kern.

2264
02:01:33,463 --> 02:01:36,677
No, I'm trying not to swear.
不 我尽量不说脏话

2265
02:01:39,618 --> 02:01:43,218
Telemetry.h, OSMFK kern.
Telemetry.h 哦 在 osfmk/kern/

2266
02:01:43,219 --> 02:01:44,364
Wow, that's super annoying.
哇 真够烦的

2267
02:01:45,279 --> 02:01:49,252
This is the problem when you have these two like I said, the two different worlds.
正如我说的 当有2个内核，就会有这样的问题

2268
02:01:56,342 --> 02:01:59,603
Yeah, so this is like a BSD system call interface that's giving you access,
对 这是一个 BSD 系统调用接口 能让你访问

2269
02:01:59,604 --> 02:02:02,895
it looks like, to the OS FMK telemetry stuff.
OSFMK 的 telemetry

2270
02:02:05,991 --> 02:02:07,195
So what were we looking at?
我们要找什么来着

2271
02:02:08,295 --> 02:02:11,219
We were here, we looked here.
刚刚在这，看了这里

2272
02:02:12,381 --> 02:02:13,556
Ah, sorry.
啊 抱歉

2273
02:02:22,429 --> 02:02:23,643
There we go, okay.
好了

2274
02:02:25,217 --> 02:02:27,730
So I just want to see where this thing is defined.
我就想看看这个东西 是在哪里定义的

2275
02:02:27,759 --> 02:02:28,523
There we go.
好的 找到了

2276
02:02:28,622 --> 02:02:30,500
So this is where things are defined.
他们定义在这里

2277
02:02:30,501 --> 02:02:33,464
So we have these telemetry command timer event.
这里有 这些 TELEMETRY_CMD_TIMER_EVENT 之类的

2278
02:02:33,465 --> 02:02:37,581
Other question, is this is user space going to be able to access this header file?
还有个问题 用户空间能访问这个头文件吗？

2279
02:02:50,820 --> 02:02:54,126
uh no usually so the idea is like
嗯 通常不行 是这样的

2280
02:02:54,127 --> 02:02:55,966
you need from user space to be able to call this
你需要 用户空间能调用这个

2281
02:02:55,967 --> 02:02:58,148
so there must like these commands and these arguments
所以这些 命令 和 参数

2282
02:02:58,173 --> 02:03:00,268
have to be defined somewhere that user space can find them
必须定义在 用户空间能找到它们 的地方

2283
02:03:00,269 --> 02:03:02,910
and oftentimes it's like exactly these files um
很多时候就是这些文件

2284
02:03:04,229 --> 02:03:06,370
yeah it was kind of a trick ish question
嗯 这其实是一个有点搞的问题

2285
02:03:07,129 --> 02:03:09,290
but the anyways the point is
但重点是

2286
02:03:09,291 --> 02:03:12,145
because if we call a command to the kernel
如果我们对内核调用一个命令

2287
02:03:12,170 --> 02:03:13,213
we need to know what these
我们要知道

2288
02:03:13,238 --> 02:03:16,230
 arguments are going to be that we're passing in as command
我们作为命令传入 的参数是什么

2289
02:03:17,402 --> 02:03:21,178
And this, so there's an enum of telemetry PMI.
这有个枚举类型 telemetry_pmi

2290
02:03:21,663 --> 02:03:24,840
There's, now this stuff I think gets yanked out.
我估计 这部分会被去除

2291
02:03:24,884 --> 02:03:28,826
I think this is part of the compilation process when creating header files,
我估计 这是生成头文件时 编译过程的一部分

2292
02:03:28,827 --> 02:03:30,166
this XNU kernel private.
这个 XNU 内核私有

2293
02:03:30,167 --> 02:03:31,386
This stuff all gets redacted
这些内容都会被删除

2294
02:03:31,387 --> 02:03:34,860
when it makes a public kernel thing.
等它变成一个公共的内核时

2295
02:03:35,169 --> 02:03:36,668
But obviously since we're in the kernel
但显然 因为我们在内核里面

2296
02:03:36,669 --> 02:03:38,615
we need to see these files.
我们会看到这些文件

2297
02:03:40,991 --> 02:03:43,191
telemetry_ast, that seems very interesting.
telemetry_ast 看起来很有趣

2298
02:03:44,184 --> 02:03:45,637
I would guess there's bugs in here.
我猜这里有些 bug

2299
02:03:45,768 --> 02:03:46,608
just from looking at this
光是看看这里

2300
02:03:46,608 --> 02:03:47,984
this seems very complicated.
这看起来很复杂

2301
02:03:52,410 --> 02:03:54,389
Yeah, so telemetry timer event
遥测计时器事件

2302
02:03:54,390 --> 02:03:56,363
and I bet there would be since we're in kern
我们已经在kern里了，我猜

2303
02:03:56,551 --> 02:03:57,778
we're already in telemetry.h
我们已经在 telemetry.h 里了

2304
02:03:57,803 --> 02:03:59,116
there's a telemetry.c.
肯定有一个 telemetry.c

2305
02:04:01,052 --> 02:04:06,154
So this is literally just taking the arguments from the args,
这就是从args中提取参数

2306
02:04:06,155 --> 02:04:08,033
the deadline, the interval, the leeway
截止时间、间隔和容差

2307
02:04:08,034 --> 02:04:13,306
which I think we saw in our syscall master.
我觉得我们在syscall.master中见过这些

2308
02:04:14,417 --> 02:04:16,686
Deadline, interval, leeway.
截止时间、间隔、容差

2309
02:04:20,721 --> 02:04:23,826
Yeah, not only complicated, but maybe also under executed.
复杂 但可能调用不到

2310
02:04:24,103 --> 02:04:25,780
Yeah, yeah. Who's calling this stuff?
是的 要看谁在调用这些？

2311
02:04:26,045 --> 02:04:27,525
The tricky thing, of course, to like
关键在于

2312
02:04:27,526 --> 02:04:29,506
this is why you have to be very careful being like
这就是为什么你必须非常小心

2313
02:04:29,507 --> 02:04:31,919
I'm going to study this code and then find a bug and get rich.
我研究一下这段代码 找个漏洞 然后变富

2314
02:04:32,129 --> 02:04:33,562
Then you find it and then you realize like
等找到漏洞了 才发现

2315
02:04:33,587 --> 02:04:35,562
oh actually there's a policy in place that like
有机制确保

2316
02:04:35,587 --> 02:04:38,882
only root processes can talk to the syscall, which happens.
只有root进程才能和这个syscall交互，这完全有可能

2317
02:04:38,929 --> 02:04:40,472
So you have to be careful.
所以要小心

2318
02:04:40,473 --> 02:04:41,902
You want to test it.
你要测试一下

2319
02:04:42,213 --> 02:04:44,355
that you can actually call this from user space.
确保你能在用户空间调用这个syscall

2320
02:04:44,475 --> 02:04:48,516
This is why it's super important to verify your assumptions before diving in too much
所以 在深入研究前 先验证你的假设 十分重要

2321
02:04:48,568 --> 02:04:52,755
and being like this code looks sus as the kids say.
这段代码看着很, 以年轻人口吻说, 可疑

2322
02:04:53,762 --> 02:04:54,301
Okay.
好的

2323
02:04:54,743 --> 02:04:57,461
Where was that C code we were looking at in BSD?
我们刚看的那段 BSD 里的 C 代码在哪儿？

2324
02:04:57,545 --> 02:04:59,425
Was that sysgeneric? Yeah.
是 sys_generic.c 吗？对

2325
02:04:59,527 --> 02:05:01,280
So that's the telemetry interface.
这就是telemetry接口

2326
02:05:01,408 --> 02:05:03,448
Well, I think this is every system call.
我觉得 这是每个系统调用

2327
02:05:03,449 --> 02:05:04,373
This is why it's unused.
所以不用它

2328
02:05:04,398 --> 02:05:06,431
I think their system call interface
我认为他们的 系统调用 接口

2329
02:05:06,432 --> 02:05:10,434
basically always gets the current proc struct in there.
总会获取当前的proc结构体

2330
02:05:12,302 --> 02:05:15,940
and then passes the arguments as a pointer in the second arguments.
然后将第二个参数里的指针 作为参数传递下去

2331
02:05:16,575 --> 02:05:19,642
So yeah, we can look at this telemetry timer event,
我们可以看一下这个telemetry_timer_event

2332
02:05:20,275 --> 02:05:22,495
a deadline, an interval, and a leeway
包括截止时间、间隔和容差

2333
02:05:22,528 --> 02:05:23,727
all of which are unused.
这些都没有使用

2334
02:05:23,781 --> 02:05:24,768
That seems very weird.
这看起来很奇怪

2335
02:05:24,828 --> 02:05:30,961
Why do you have code that has functions that get passed in that are never used?
为什么会有这样的代码 接收参数 却全都不用

2336
02:05:31,014 --> 02:05:37,455
So if telemetry needs timer arming record is true
如果 telemetry_needs_timer_arming_record 为真

2337
02:05:37,481 --> 02:05:39,096
then set it to be false.
就将其设置为假

2338
02:05:39,399 --> 02:05:41,496
Take some sample of the current thread
从当前线程中取样

2339
02:05:42,463 --> 02:05:45,943
and do this and then return zero.
执行这个操作并返回零

2340
02:05:48,245 --> 02:05:48,950
Interesting.
有趣

2341
02:05:50,608 --> 02:05:51,336
What was that?
什么？

2342
02:05:55,235 --> 02:05:56,461
pmi_setup

2343
02:05:56,675 --> 02:06:00,148
pmi_ctr、period（传入的interval）

2344
02:06:03,101 --> 02:06:04,527
Yeah, another if def
又一个 #if

2345
02:06:04,528 --> 02:06:05,641
so you've got to be careful.
所以要小心

2346
02:06:05,666 --> 02:06:08,169
Remember, again, the configuration thing.
再提醒一下 要看配置

2347
02:06:08,170 --> 02:06:11,371
It's like every time you look at some configuration thing
每次看到要看配置的

2348
02:06:11,372 --> 02:06:13,631
before getting excited that you found a bug
在激动 自己找到 bug 前

2349
02:06:13,632 --> 02:06:15,525
you need to double check and verify these things.
你需要再次检查一下 这些东西

2350
02:06:16,374 --> 02:06:17,365
This is interesting.
真有意思

2351
02:06:17,475 --> 02:06:20,406
Well, it's a const, but a character pointer.
嗯 它是 const 的一个字符指针

2352
02:06:20,516 --> 02:06:21,460
Those always are...
这些总是

2353
02:06:23,006 --> 02:06:25,936
Okay, so pmi_ctr.
好的 pmi_ctr

2354
02:06:25,937 --> 02:06:29,646
So there's another command inside here, it looks like, that we can...
这里又有命令，看起来我们可以

2355
02:06:30,538 --> 02:06:32,326
This is coming from args-deadline
这个来自 args->deadline

2356
02:06:32,377 --> 02:06:34,118
which is then a switch statement on there
这里用了一个 switch 语句

2357
02:06:34,119 --> 02:06:37,733
which tells me that there's some other functionality we can target through here.
这说明 能在这里 追踪到别的功能实现

2358
02:06:41,120 --> 02:06:44,825
We need this, sample_all_...
我们需要这个。 sample_all_...

2359
02:06:45,414 --> 02:06:47,741
MT, oh yeah, it is this microstack shot.
mt 哦 对了 这是微栈快照

2360
02:06:56,002 --> 02:06:58,342
The name, so it's setting up some name
名字 它在设置某个东西的名字

2361
02:06:58,343 --> 02:06:59,963
and this seems weird.
这看起来有点奇怪

2362
02:07:00,756 --> 02:07:02,343
Can name come from us? No.
名字可以由用户提供吗？ 不能

2363
02:07:02,466 --> 02:07:03,209
It's either...
要么……

2364
02:07:07,509 --> 02:07:08,109
Okay.
好的

2365
02:07:09,492 --> 02:07:12,456
So, yeah, this is some micro stack shot thing.
所以 这是一个微栈快照

2366
02:07:19,600 --> 02:07:20,120
Interesting.
有意思

2367
02:07:20,176 --> 02:07:22,036
Telemetry PMI unlock.

2368
02:07:22,101 --> 02:07:24,123
That would be another thing to...
它又是

2369
02:07:25,626 --> 02:07:27,506
Okay, so there's some mutex here.
好的 这里有个互斥锁

2370
02:07:33,699 --> 02:07:34,480
Yeah, I don't know.
是啊 我也不知道

2371
02:07:34,480 --> 02:07:36,300
You always think like could you mess with that?
你们总是会想 能搞搞它吗？

2372
02:07:38,286 --> 02:07:38,981
don't know.
不知道

2373
02:07:38,982 --> 02:07:41,382
But anyways, okay, so we at least found we found a system call.
但总之 我们至少找到了一个系统调用

2374
02:07:41,412 --> 02:07:43,242
We found like the entry point.
我们找到了入口点

2375
02:07:44,704 --> 02:07:47,775
We figured out how to get there.
我们知道了如何到那里

2376
02:07:50,047 --> 02:07:52,133
Did we learn anything about the kernel here?
对于内核 我们有学到什么吗？

2377
02:07:54,908 --> 02:07:55,740
It sus.
可能有洞

2378
02:07:57,080 --> 02:08:00,446
Every, all code, all code is sus.
所有代码都可能有漏洞

2379
02:08:01,971 --> 02:08:02,446
Yeah.
嗯

2380
02:08:03,372 --> 02:08:04,796
But now that we know this, and so like
不过现在我们知道这些了

2381
02:08:04,856 --> 02:08:08,618
if we were doing this as a target, right
如果把这个作为目标

2382
02:08:08,776 --> 02:08:11,402
taking notes on this I'd be like, oh, great
知道这些后 我会想 太好了

2383
02:08:11,579 --> 02:08:15,662
syscalls.master has like the list of all the system call numbers
syscalls.master 里有所有系统调用的编号

2384
02:08:15,687 --> 02:08:17,042
and the functions
和函数

2385
02:08:17,043 --> 02:08:22,726
and then you'd probably say most of these UIPC, right?
你大概会说 大部分这些 UIPC

2386
02:08:22,788 --> 02:08:25,786
This was where, wait, it wasn't.
这里 等等 不是这里

2387
02:08:30,535 --> 02:08:31,783
Where was the telemetry?
telemetry在哪儿？

2388
02:08:33,004 --> 02:08:34,163
sys_generic.c.

2389
02:08:34,299 --> 02:08:37,841
Yeah, sys_generic.c was in where that telemetry is in
对 telemetry 在 sys_generic.c 里

2390
02:08:41,328 --> 02:08:43,110
in bsd/kern.
它在 bsd/kern中

2391
02:08:44,734 --> 02:08:47,954
So probably other things are in here.
这里可能还有其他东西

2392
02:08:50,147 --> 02:08:51,321
Like ledger.
比如ledger

2393
02:08:53,953 --> 02:08:57,007
Omnibus system call for ledger operations.
用于ledger（分类账）操作的一个综合系统调用

2394
02:08:57,129 --> 02:08:58,329
See, that's also seems sus.
这也有可能有洞

2395
02:08:58,393 --> 02:09:00,659
Like who's doing these ledger operations?
谁在进行这些账本操作？

2396
02:09:00,811 --> 02:09:02,709
But the double sus means to me that like
但 更让我怀疑的是

2397
02:09:03,561 --> 02:09:05,322
that somebody else has learned that like
可能其他人也发现了这一点

2398
02:09:05,522 --> 02:09:07,089
it's just not used.
只是它没被用

2399
02:09:09,744 --> 02:09:11,420
So anyways, that's interesting.
总之 这挺有意思的

2400
02:09:13,265 --> 02:09:15,494
See, it's like if defs of debug, like
看，#ifdef 调试语句

2401
02:09:15,647 --> 02:09:17,846
so you think like you leave debug statements in your code
你可能会在代码中留下调试语句

2402
02:09:17,847 --> 02:09:22,400
they leave if defs of debug structs definitions in their code
他们在代码中用#ifdef 留下调试结构体

2403
02:09:22,490 --> 02:09:23,889
which probably are not
这些可能

2404
02:09:25,796 --> 02:09:32,429
ah, interesting. So copyin, this is, we should
有趣 copyin 这是 我们应该

2405
02:09:33,274 --> 02:09:35,134
Since we're digging in we can look at this.
既然在深入研究 我们可以看看这个

2406
02:09:35,135 --> 02:09:38,855
 I think we can already, where?
我觉得我们现在可以

2407
02:09:41,537 --> 02:09:43,997
It's exactly like copy_from_user in Linux
这和 Linux 里的 copy_from_user 一样

2408
02:09:44,040 --> 02:09:48,330
but I do not recall the semantics.
但我记不清它的细节了

2409
02:09:48,879 --> 02:09:49,318
I think,
我觉得

2410
02:09:49,319 --> 02:09:50,883
yeah, so len is an int
对 len 是一个整型

2411
02:09:51,125 --> 02:09:54,100
and sizeof(len) from arg3.
然后 从 arg3 拷贝出 sizeof(len) 个字节 到 len

2412
02:09:54,101 --> 02:09:56,701
So what, arg3 must be a pointer to len.
所以 arg3 一定是一个指向 长度值 的指针

2413
02:09:56,702 --> 02:10:01,042
And I guess we can look at ledger and say like one, two, three.
我们可以看看ledger  一、二、三

2414
02:10:01,143 --> 02:10:02,795
Yeah, I can't remember what
对 我记不清

2415
02:10:05,362 --> 02:10:07,281
I can't remember what C adder T stands for
我忘了 cadder_t 是什么

2416
02:10:07,282 --> 02:10:08,441
what the C stands for
c 表示什么

2417
02:10:08,442 --> 02:10:10,343
but it's like a user space pointer.
但它就是一个用户空间的指针

2418
02:10:10,465 --> 02:10:13,456
And this is like the type they use to define that.
他们用这个 定义这种类型

2419
02:10:17,389 --> 02:10:18,370
Yeah, that's interesting.
嗯 这挺有意思的

2420
02:10:20,131 --> 02:10:21,469
Yeah, we can look at
嗯 我们可以看看

2421
02:10:21,832 --> 02:10:24,534
and we can maybe hopefully use my tricks if I wasn't full of.
如果我没记错 也许可以用我的方法

2422
02:10:36,458 --> 02:10:37,191
There we go.
好了

2423
02:10:39,780 --> 02:10:42,221
So now we can go look at this
现在我们可以看看这个

2424
02:10:42,222 --> 02:10:46,081
but at least we know the semantics here
至少我们知道了这里的语义

2425
02:10:46,106 --> 02:10:51,186
the user address, the kernel address, and the number of bytes, copyio.c.
用户地址 内核地址 和 字节数，在 copyio.c

2426
02:10:51,187 --> 02:10:55,746
This would probably be something we look in our heads of, like I should understand how this works.
这大概是我们需要记住并理解的

2427
02:10:56,251 --> 02:10:56,706
Also...
另外...

2428
02:11:06,144 --> 02:11:08,952
So we don't do any copy if the number of bytes is zero.
所以 如果字节数为零 就不进行复制

2429
02:11:10,033 --> 02:11:13,390
This copy validates function is very interesting because
这个复制验证函数非常有趣 因为

2430
02:11:14,038 --> 02:11:17,339
so you have to remember the security boundary here
你必须记住这里的安全边界

2431
02:11:17,340 --> 02:11:18,879
from user space and kernel space, right?
用户空间和内核空间之间的 对吧？

2432
02:11:18,918 --> 02:11:21,204
So if we're copying something from user space
所以 当我们从用户空间复制东西

2433
02:11:21,482 --> 02:11:23,943
but the user has tricked us
如果用户欺骗了我们

2434
02:11:23,944 --> 02:11:25,264
and given us a kernel address
并给了我们一个内核地址

2435
02:11:25,265 --> 02:11:27,749
and now we're copying kernel data somewhere
现在我们拷贝的是内核某处数据

2436
02:11:28,168 --> 02:11:29,908
and that maybe makes it back to user space
这些数据可能会传回到用户空间

2437
02:11:29,909 --> 02:11:33,354
that would be a clear vulnerability.
这将是一个明显的漏洞

2438
02:11:33,432 --> 02:11:36,418
So we want You have to be very careful when doing all this stuff.
所以我们在做这些事情时必须非常小心

2439
02:11:36,419 --> 02:11:39,514
I assume this stuff's been tested
我估计这些功能已经测试过

2440
02:11:39,559 --> 02:11:40,439
but I don't know.
但我不确定

2441
02:11:40,440 --> 02:11:43,096
You're free to look at this and poke around here.
你可以自由探索

2442
02:11:43,481 --> 02:11:45,081
Because like this copy validate
比如 这个 copy validate 函数

2443
02:11:45,082 --> 02:11:45,822
what's this do?
它有什么作用？

2444
02:11:45,823 --> 02:11:46,922
What are these arguments?
这些参数是什么？

2445
02:11:46,923 --> 02:11:48,881
Whenever I see like flags to a function
每当我看到函数中的flag

2446
02:11:48,882 --> 02:11:53,964
this is like kind of makes me skeptical.
这让我有点怀疑

2447
02:11:54,001 --> 02:11:55,945
And I'm like what do these arguments mean?
然后我就想  这些参数是什么意思？

2448
02:11:55,946 --> 02:11:59,365
Can I grep for every single instance of copy validate
我能用 `grep` 查找每一处 `copy validate` 吗

2449
02:11:59,366 --> 02:12:02,628
and look to make sure that they're using the right arguments for that context?
并确认 它们在上下文中用的是正确的参数吗？

2450
02:12:02,629 --> 02:12:03,608
And can I do that quickly?
我能快速做到这一点吗？

2451
02:12:03,609 --> 02:12:05,503
Just like, manually.
就像手动一样

2452
02:12:05,504 --> 02:12:06,735
That's a way I would do this.
这是我处理的方式

2453
02:12:12,028 --> 02:12:13,135
Yeah, interesting.
嗯 挺有意思的

2454
02:12:13,509 --> 02:12:15,068
If the result is EXDEV
如果结果是 EXDEV

2455
02:12:15,069 --> 02:12:16,371
I have no idea what that means.
我真不知道那是什么意思

2456
02:12:19,292 --> 02:12:20,073
Oh, maybe.
哦 大概是吧

2457
02:12:22,374 --> 02:12:24,138
Then copyin_kern so it's a
然后执行 copyin_kern 复制到内核

2458
02:12:24,905 --> 02:12:30,218
otherwise user enable access.
否则 执行 user_access_enable

2459
02:12:30,279 --> 02:12:31,298
That sounds interesting.
听上去挺有趣的

2460
02:12:31,380 --> 02:12:34,640
_bcopyin from the user address to the kernel address
_bcopyin 从用户地址 复制到内核地址

2461
02:12:34,641 --> 02:12:36,700
and then user access disable.
再禁用用户访问

2462
02:12:40,253 --> 02:12:42,220
Might as well look to see what this is.
不如看看这是什么

2463
02:12:44,893 --> 02:12:46,420
Ooh, ARM stuff, great.
哦 ARM 的东西 真好

2464
02:12:46,486 --> 02:12:47,953
What the heck does this do?
这是干什么的？

2465
02:12:52,467 --> 02:12:53,146
Nice.
好

2466
02:12:53,648 --> 02:12:56,086
So what is pan?
那 PAN 是什么？

2467
02:12:58,266 --> 02:13:00,808
Making sure that we can't access kernel stuff
确保我们不能访问内核的东西

2468
02:13:00,809 --> 02:13:02,866
or user space stuff from the kernel.
并且 内核不能直接访问用户空间的东西

2469
02:13:03,058 --> 02:13:08,032
So this is funny.
所以说这挺逗的

2470
02:13:08,323 --> 02:13:09,763
This is just a thing that does nothing
这个东西什么也不做

2471
02:13:09,764 --> 02:13:13,150
if this is not available on the system of the target.
如果目标系统上 不支持这个PAN 的话

2472
02:13:20,217 --> 02:13:21,864
Oh, Privilege Access Never.
哦 特权 访问 永不

2473
02:13:21,952 --> 02:13:23,330
I thought you said network.
我以为你说的是网络

2474
02:13:23,629 --> 02:13:24,712
I know that doesn't make sense
我知道”网络“不对

2475
02:13:24,713 --> 02:13:28,817
so I didn't go with it until I looked at it.
所以我查了后 才确认

2476
02:13:30,626 --> 02:13:31,503
Cool.
太好了

2477
02:13:37,941 --> 02:13:38,521
Yeah.
嗯

2478
02:13:54,326 --> 02:13:55,318
Maybe.
可能吧

2479
02:13:56,350 --> 02:13:58,293
You looked at all of them?  Ah, damn.
你都看过了？啊 糟了

2480
02:13:59,879 --> 02:14:02,383
We could have found something right on stream.
我们本可以直播时 一起发现些什么

2481
02:14:03,326 --> 02:14:04,047
Okay.
行

2482
02:14:05,323 --> 02:14:05,976
Maybe.
可能吧

2483
02:14:07,283 --> 02:14:07,743
Okay, yeah.
行 嗯

2484
02:14:07,768 --> 02:14:10,114
So zero means privileged reads and writes are not disabled.
所以 0 表示 特权读和写 未禁用

2485
02:14:10,154 --> 02:14:13,227
One means privileged reads and writes are, yeah, okay.
 1 表示特权读写 已禁用。好的

2486
02:14:13,228 --> 02:14:14,227
Now this makes sense.
现在这说得通了

2487
02:14:14,327 --> 02:14:16,009
So does everyone understand what this is doing?
都明白这是怎么回事吗？

2488
02:14:22,045 --> 02:14:25,526
Well, now I feel like we need to just see if Justin is full of it or not.
我觉得 是时候看看 贾斯汀是不是在吹牛了

2489
02:14:39,279 --> 02:14:41,942
What is it, like dash A for more context?
是加上 -A 来获取更多上下文信息吗？

2490
02:14:45,942 --> 02:14:47,186
I guess they're all in this file
估计都在这个文件里

2491
02:14:47,187 --> 02:14:49,409
so we could have just looked at them.
所以我们可以直接查看这些内容

2492
02:15:01,193 --> 02:15:01,949
I don't know.
我不知道

2493
02:15:03,269 --> 02:15:05,100
Could any of these fault?
这些会出问题吗？

2494
02:15:17,680 --> 02:15:25,960
Yeah. Right.  yeah. That makes sense. Okay.
有道理

2495
02:15:27,150 --> 02:15:29,206
Um, Yeah, here it's done very easy,
嗯 这里实现得很简单

2496
02:15:29,207 --> 02:15:37,572
done very easy, done, done, done, done.
都很简单

2497
02:15:43,035 --> 02:15:44,273
That seems weird.
这确实有点奇怪

2498
02:15:48,578 --> 02:15:51,058
bcopy is like their raw copy.
bcopy 是原始的复制函数

2499
02:15:51,059 --> 02:15:53,864
I don't fully understand what it actually is.
我还没完全搞清楚它是什么

2500
02:16:14,282 --> 02:16:15,550
Interesting.
挺有趣的

2501
02:16:18,673 --> 02:16:20,261
The question is, why do you need different ones?
问题是 为什么需要不同的版本？

2502
02:16:20,286 --> 02:16:23,793
These are almost identical in terms of their semantics
这些在语义上几乎相同

2503
02:16:24,449 --> 02:16:25,453
from what I'm seeing.
依我看

2504
02:16:25,771 --> 02:16:27,171
Well, let's look at these bcopies then
我们来看看这些 bcopy 函数

2505
02:16:31,191 --> 02:16:32,644
I remember I looked at them before.
我记得之前看过这些

2506
02:16:32,673 --> 02:16:35,554
I think they're just raw kernel like just copy memory around
我以为 他们就是内核里拷贝内存数据的

2507
02:16:35,555 --> 02:16:36,635
but you don't want people to use them.
但你不想让用户用这些

2508
02:16:36,636 --> 02:16:38,044
You want them to use the other thing.
你希望他们用其他的

2509
02:16:40,098 --> 02:16:41,258
Yeah, and I think they're assembly.
对 我想这些是用汇编写的

2510
02:16:41,259 --> 02:16:41,860
Ooh, look at this.
哇 看看这个

2511
02:16:41,861 --> 02:16:42,499
See, look at it.
你看 就是这个

2512
02:16:42,653 --> 02:16:44,142
You all learned assembly
你们都学过汇编

2513
02:16:44,143 --> 02:16:44,783
and it's useful.
这就用上了

2514
02:16:48,399 --> 02:16:49,039
There we go.
就是这样

2515
02:16:49,239 --> 02:16:51,806
Okay, OSFMK, ARM64.
好的 在 osfmk/arm64

2516
02:16:57,495 --> 02:16:59,693
machine_routines_asm.s

2517
02:17:04,941 --> 02:17:06,381
All right, look at this.
好 看看这个

2518
02:17:07,962 --> 02:17:08,621
Okay.
好的

2519
02:17:09,368 --> 02:17:12,904
ARM64 stack prolog, push frame.
ARM64 栈序言， 压栈

2520
02:17:12,905 --> 02:17:14,653
I guess these are macros, I assume.
我觉得这些是宏

2521
02:17:17,129 --> 02:17:19,446
Copy IO recover range.
复制 I/O 恢复区间

2522
02:17:20,099 --> 02:17:22,051
Move zero into X4
将 0 移入 X4

2523
02:17:22,052 --> 02:17:23,326
the total bytes copied.
复制的总字节数

2524
02:17:24,033 --> 02:17:27,036
loop load a byte from the user source.
循环 从用户处 加载一个字节

2525
02:17:27,096 --> 02:17:31,819
So dereference X0, which is user address.
解引用 X0 这是用户地址

2526
02:17:34,798 --> 02:17:39,905
ldrb. See remember when I said they use all this crazy stuff, right?
看吧 我提到过 他们会用这些东西 对吧

2527
02:17:41,838 --> 02:17:45,537
Wait, this is X0. Oh, this is a post increment operation, right?
等一下 这个 X0  哦 这是一个后索引操作 对吧？

2528
02:17:45,538 --> 02:17:49,778
So it's dereference X0, move that byte into W5
所以是 先解引用X0 将内存里的字节 放到w5

2529
02:17:49,839 --> 02:17:52,112
and then add one to X0.
然后再将 X0 加 1

2530
02:17:52,320 --> 02:17:56,266
So store byte from user space, load a byte from user space,
从用户空间取1字节

2531
02:17:56,291 --> 02:17:57,920
store byte to the destination.
存到目标地址

2532
02:17:57,921 --> 02:17:59,921
So then store, it's actually really nice.
这样其实真的很好

2533
02:17:59,922 --> 02:18:01,421
This is pretty compact.
这相当简洁

2534
02:18:01,422 --> 02:18:02,373
I like it.
我喜欢这个

2535
02:18:02,644 --> 02:18:06,844
So then store W5 that byte to X1 and then increment that.
然后把 W5 里的字节 存到 X1  再递增 X1

2536
02:18:06,896 --> 02:18:08,750
So you have both of your pointers moving.
这样两个指针都在动

2537
02:18:09,930 --> 02:18:12,286
Increment byte copied.
增加 已拷贝字节计数

2538
02:18:12,287 --> 02:18:15,808
So then X4 is what?
那么 X4 是什么呢？

2539
02:18:15,809 --> 02:18:18,129
Zero, one, two, three.
零 一 二 三

2540
02:18:18,209 --> 02:18:19,569
Oh, X4 is always set to zero.
哦 X4 置零了

2541
02:18:19,570 --> 02:18:21,195
That's going to be our return address.
它是输出参数

2542
02:18:23,137 --> 02:18:24,164
cbz

2543
02:18:25,297 --> 02:18:27,064
This byte is null. We're done.
如果这个字节是空，就完成了

2544
02:18:27,089 --> 02:18:31,644
So compare. Oh, so this is like a copy until null.
哦 这相当于 一直复制到null字节

2545
02:18:31,694 --> 02:18:32,617
Is that?
是这样吗？

2546
02:18:32,759 --> 02:18:33,471
The idea.
它的意思

2547
02:18:41,444 --> 02:18:43,609
This makes a thousand times more sense.
这相当合理

2548
02:18:44,223 --> 02:18:44,884
Okay.
好的

2549
02:18:44,985 --> 02:18:45,546
So yeah.
没错

2550
02:18:45,586 --> 02:18:46,465
So everyone get that?
大家都明白了吗？

2551
02:18:46,490 --> 02:18:53,937
This is b copy in string, not instruction.
这个是 b 拷贝 字符串，不是 指令

2552
02:18:55,559 --> 02:18:56,246
Amazing.
太棒了

2553
02:18:56,432 --> 02:18:58,451
But see, we learned it by reading the code.
我们通过读代码学到了

2554
02:18:58,452 --> 02:18:59,910
This is what you have to do sometimes.
有时候这是必须的

2555
02:18:59,994 --> 02:19:03,556
But now I'm curious. Let's just like look at what's, what, the ending is.
现在我很好奇 我们看看结尾是什么

2556
02:19:03,795 --> 02:19:05,503
So compare x5 with null.
将 x5 和 null 比较

2557
02:19:05,554 --> 02:19:06,476
If it's null
如果它是 null

2558
02:19:09,696 --> 02:19:11,600
then branch to done
就跳转到 done

2559
02:19:11,640 --> 02:19:20,133
which loads let's see what, oh, store x4 into x3.
它会 把 x4 存到 x3 指向的内存

2560
02:19:20,462 --> 02:19:23,519
So put the number of bytes read where x3 points
所以 将 x3记录的 已读入字节数

2561
02:19:23,544 --> 02:19:26,839
because x3, 0, 1, 2, 3 is the actual
因为 x3 是这个 actual

2562
02:19:26,904 --> 02:19:29,219
so this is the number of bytes that we copied in.
所以这就是我们复制的字节数

2563
02:19:29,666 --> 02:19:35,943
And then... Move x5 into x0, which was our...
然后 将 x5 赋值给 x0

2564
02:19:37,903 --> 02:19:41,549
Yeah, the result of the comparison which if we're done is going to be zero.
对 如果拷贝完了 比较结果（x5）就是零

2565
02:19:43,546 --> 02:19:44,229
Right?
对吧？

2566
02:19:44,448 --> 02:19:45,787
Yeah, because that's the byte that we read in.
对 因为我们读入的就是null

2567
02:19:45,816 --> 02:19:48,067
Wow, that's a hyper-optimization.
哇 真是优化到了极致

2568
02:19:48,136 --> 02:19:50,076
But rather than setting...
但与其设置...

2569
02:19:51,070 --> 02:19:52,751
That is weird. Why not just set...
这真奇怪 为什么不直接设...

2570
02:19:58,293 --> 02:20:00,353
Oh, okay.
哦 好的

2571
02:20:01,800 --> 02:20:03,926
and then pop the frame and then epilogue,
然后弹出栈帧 执行尾声

2572
02:20:04,008 --> 02:20:11,580
and then compare x4 to x2, and then branch back to loop.
然后比较 x4 和 x2  再跳回循环

2573
02:20:11,879 --> 02:20:13,919
Otherwise, oh, the name was too long.
否则 报错 名字太长了

2574
02:20:13,920 --> 02:20:14,660
Ah, that's interesting.
啊 真有趣

2575
02:20:16,007 --> 02:20:20,493
So, okay, let's look back at our copyio.
好的，我们回过头接着看 copyio

2576
02:20:21,806 --> 02:20:24,733
In string, now that we know the semantics here
现在我们知道了 这个instr 指的是 字符串

2577
02:20:24,845 --> 02:20:27,785
which makes sense why it's almost exactly identical except for that
这就解释了为什么它几乎是完全一样的 除了那个地方

2578
02:20:32,166 --> 02:20:32,850
Yeah. Okay.
好的

2579
02:20:32,851 --> 02:20:35,558
So copy in and then result.
copyin 返回结果放到result

2580
02:20:37,892 --> 02:20:38,354
Okay.
好的

2581
02:20:38,435 --> 02:20:42,473
So yeah, the vulnerability, I mean this is like a classic
这像一个经典的漏洞

2582
02:20:44,773 --> 02:20:50,186
 str, what is it? strncpy that doesn't put the null byte at the end of the string,
str什么来着？strncpy 不在字符串末尾放null字节

2583
02:20:50,333 --> 02:20:50,658
right?
对吧？

2584
02:20:50,659 --> 02:20:53,019
So you can call that and if strncpy
如果你调用 strncpy

2585
02:20:53,020 --> 02:20:55,040
you give it exactly the number of bytes
你给它确切的字节数

2586
02:20:55,599 --> 02:20:58,112
or it copies up to those number of bytes
或者 当它拷贝到那些个字节

2587
02:20:58,325 --> 02:21:00,538
and If it doesn't get to the null byte
并且如果中间没遇到null字节

2588
02:21:00,563 --> 02:21:01,472
it won't include it.
它就不会加null字节

2589
02:21:01,545 --> 02:21:03,651
And so you can have a null terminating string.
你就可以得到一个 不以空字节结尾的字符串

2590
02:21:03,826 --> 02:21:06,688
So that's a similar problem that they have here, right?
这里也有类似的问题 对吧？

2591
02:21:06,689 --> 02:21:08,325
_bcopyinstr

2592
02:21:09,585 --> 02:21:11,913
If you end up copying number of bytes
如果拷贝到一定的字节数

2593
02:21:11,914 --> 02:21:14,154
you will get this E name too long
会返回一个错误码 E name too long

2594
02:21:14,155 --> 02:21:16,919
that gets returned as an error code from here.
会从这里返回这个错误码

2595
02:21:17,078 --> 02:21:18,515
But then you need to be very careful
但这里需要特别小心

2596
02:21:18,540 --> 02:21:21,387
that everyone that calls this actually checks the return value.
确保每个调用者都检查返回值

2597
02:21:21,414 --> 02:21:22,934
So maybe we should check that.
所以也许我们可以检查一下

2598
02:21:38,975 --> 02:21:40,820
and I don't care about those ones.
我不关心那些

2599
02:21:46,213 --> 02:21:51,513
And let's give ourselves like four lines after of context
我们在后面加上四行上下文

2600
02:21:51,586 --> 02:21:52,943
because that should be good.
那样会很好

2601
02:21:54,056 --> 02:21:57,836
Okay, well, that looks at an error.
好的 这里看到一个error

2602
02:21:58,523 --> 02:22:01,796
Oh, see it, it actually tells us exactly what we just learned, right?
看 它说了 我们刚学到的内容

2603
02:22:02,054 --> 02:22:04,029
E name too long is a term of length bytes have copied in
ENAMETOOLONG 表示 拷贝len个字节

2604
02:22:04,076 --> 02:22:06,255
but the null pointer was not encountered.
但没有遇到空指针

2605
02:22:06,282 --> 02:22:11,660
That does not require raising, CPU_DTRACE_BADADDR and we press on.
这不会引发 CPU_DTRACE_BADADDR 会继续执行

2606
02:22:11,661 --> 02:22:13,161
That seems weird.
这看起来有点奇怪

2607
02:22:15,962 --> 02:22:16,382
Okay.
好的

2608
02:22:23,636 --> 02:22:25,036
Okay, but this is in dtrace
好的 这是在 dtrace 里

2609
02:22:25,096 --> 02:22:27,373
and you need to be root to use dtrace anyways
而且使用 dtrace 需要 root 权限

2610
02:22:27,374 --> 02:22:28,783
but that could be something interesting.
但这可能很有趣

2611
02:22:28,808 --> 02:22:30,056
Maybe there's something there.
说不定有什么漏洞

2612
02:22:33,381 --> 02:22:33,970
Okay.
好的

2613
02:22:34,486 --> 02:22:37,245
Oh, there's an interesting there's this dtrace_copyinstr
哦 有个有趣的东西 dtrace_copyinstr

2614
02:22:37,246 --> 02:22:38,850
which we probably don't care about.
不过我们可能不太关心

2615
02:22:39,748 --> 02:22:41,065
Yeah, so here's like
是的 这里有

2616
02:22:42,872 --> 02:22:46,179
I don't know, nullfs, is that literally like dev null?
nullfs 不知道是不是类似 linux 里的 /dev/null

2617
02:22:46,230 --> 02:22:49,446
I think this actually may be the code that does dev null.
这可能是实现类似 /dev/null 功能的代码

2618
02:22:56,614 --> 02:22:59,269
copyin error.
copyin 出错的情况

2619
02:22:59,915 --> 02:23:03,720
Yeah, this is something you could probably write a, CodeQL query for
这时候可以写一个 codeQL 查询 看看

2620
02:23:03,766 --> 02:23:04,840
I'm just not very good at that.
我不太擅长这个

2621
02:23:04,865 --> 02:23:06,086
I just like looking at the code
我喜欢读读代码

2622
02:23:06,087 --> 02:23:09,133
because the error checking is going to be the next thing that happens.
因为接下来会进行错误检查

2623
02:23:10,328 --> 02:23:11,953
So we see that there.
我们看到它在那里

2624
02:23:13,640 --> 02:23:16,420
If error, if not error
如果有错误 如果没有错误

2625
02:23:17,953 --> 02:23:19,486
if error return error
如果有错误就返回错误

2626
02:23:19,511 --> 02:23:21,360
this seems weird but it seems fine.
看着挺奇怪 不过应该没问题

2627
02:23:28,993 --> 02:23:30,046
That seems interesting.
这看起来挺有意思的

2628
02:23:33,376 --> 02:23:35,210
copy in string

2629
02:23:39,323 --> 02:23:41,656
i don't know what this does but it continues executing
我不知道这是干嘛的 但它继续执行下去了

2630
02:23:41,687 --> 02:23:44,076
that could be something interesting to look at for somebody
这可能挺有趣的

2631
02:23:44,136 --> 02:23:46,403
and uh so this is nfs
这就是 NFS

2632
02:23:46,976 --> 02:23:49,603
and the just like on linux right
就像在 Linux 上一样

2633
02:23:49,654 --> 02:23:52,555
if you're creating some virtual file system you have to create
如果你要创建一个虚拟文件系统 你得先

2634
02:23:52,556 --> 02:23:54,897
you have to handle all the virtual file system operations
你得能处理 虚拟文件系统的所有操作

2635
02:23:54,980 --> 02:23:56,374
open close whatever
比如打开、关闭等

2636
02:23:58,566 --> 02:24:00,007
Yeah, this seems sketchy.
是啊 这看着不太对

2637
02:24:00,074 --> 02:24:01,480
Maybe it's at the end of a loop
可能是循环的末尾

2638
02:24:01,548 --> 02:24:03,913
and then at the top of the loop it'll check error
然后在循环的开头 它会进行错误检查

2639
02:24:04,230 --> 02:24:06,831
which we just don't have enough context to tell
我们目前没有足够的上下文来判断

2640
02:24:06,832 --> 02:24:07,988
but it seems weird.
但看起来有点奇怪

2641
02:24:13,538 --> 02:24:14,780
Yeah, we could do that
嗯 我们可以那样做

2642
02:24:14,838 --> 02:24:16,886
but I guess I didn't look at how many there are.
我没数清楚有多少个

2643
02:24:16,921 --> 02:24:18,441
Maybe I should have done that before looking at this.
也许我应该先搞清楚 再来看这个

2644
02:24:18,442 --> 02:24:19,913
We'll do this for like one more minute.
我们再看一分钟

2645
02:24:20,724 --> 02:24:22,238
That's an error check. That's good.
有错误检查  很好

2646
02:24:22,278 --> 02:24:23,571
That's an error check. That's good.
有检查错误 很好

2647
02:24:26,640 --> 02:24:28,509
That's an error check, that's good.
检查了错误 好的

2648
02:24:31,322 --> 02:24:33,710
copy_error is not equal to zero.
拷贝结果 不为零

2649
02:24:35,576 --> 02:24:38,604
Okay, so this is the interesting one you need to look at, right?
好的 这就是你要特别关注的 对吧？

2650
02:24:38,605 --> 02:24:42,196
Because this is checking if copy error is named too long
因为这个检查了 ENAMETOOLONG

2651
02:24:42,787 --> 02:24:44,455
and it only errors out there
只在那出错

2652
02:24:45,368 --> 02:24:46,849
but if it is named too long
如果为真

2653
02:24:47,028 --> 02:24:49,213
then it also sets the last one to be null.
它会将最后一个字节设置为 null

2654
02:24:49,308 --> 02:24:52,261
So that's what we're trying to find.
这是我们想要找的（没置null的话）

2655
02:24:53,421 --> 02:24:54,161
Error.
出错

2656
02:24:58,524 --> 02:25:04,177
Again, another, looks like another safe mark of a null byte.
又一个 看起来也安全设置null了

2657
02:25:06,418 --> 02:25:07,940
I kind of assumed they would fix all of these
我猜他们把这类问题都修复了

2658
02:25:07,941 --> 02:25:08,797
but you never know
但谁知道呢

2659
02:25:08,831 --> 02:25:10,511
and this is how you find stuff.
这就是怎么发现问题的

2660
02:25:11,543 --> 02:25:12,509
Error check.
检查错误

2661
02:25:12,581 --> 02:25:13,830
I guess maybe what you could do
我觉得你可以

2662
02:25:13,855 --> 02:25:19,043
is write a codeQL query that checks for the other copy stuff
写个codeQL查询 检查其他 copy 函数

2663
02:25:19,116 --> 02:25:21,888
that it's using the same, like, Mac, Apple, and everything.
检查一下其它用这个的，像 mac、苹果等

2664
02:25:21,913 --> 02:25:24,295
Yeah, where I could see this be an error, right
对 我看 出错的情况 大概像

2665
02:25:24,296 --> 02:25:27,339
is if somebody used copy in
如果有人之前用的copyin

2666
02:25:27,477 --> 02:25:29,959
and then just changed it to a copy in string
然后直接改成了copyinstr

2667
02:25:30,000 --> 02:25:32,353
without thinking about the semantics there
没考虑语义问题

2668
02:25:32,421 --> 02:25:33,686
and then that causing a problem.
这样就会出问题

2669
02:25:36,624 --> 02:25:38,665
Yeah, that's like these are all fine.
是的 这些都没问题

2670
02:25:41,408 --> 02:25:44,450
That could be interesting depending on what this is, but...
这具体看情况 可能会很有趣

2671
02:25:46,274 --> 02:25:49,214
I would assume maybe after all of these case statements
我想 在这些 case 语句之后

2672
02:25:49,215 --> 02:25:51,956
that one of these is checking the error
其中一个是在检查错误

2673
02:25:51,957 --> 02:25:55,121
but this is another interesting one at the end of something.
这个也挺有意思，像是在什么的末尾

2674
02:25:56,078 --> 02:25:57,801
Oh, here, maybe at this.
哦 这里 在这里检查的

2675
02:26:02,902 --> 02:26:07,662
I mean, I didn't think that we would find just a bug a clear bug after this
我不认为 我们这样 能直接找到一个明显的bug

2676
02:26:07,663 --> 02:26:08,942
but it was worth looking at
但值得一看

2677
02:26:09,435 --> 02:26:10,244
because I think it's a fun.
因为我觉得很有趣

2678
02:26:13,742 --> 02:26:15,115
Okay, this is hard to read.
这很难读

2679
02:26:17,370 --> 02:26:18,730
This looks like it's not checking.
看起来这里没有检查

2680
02:26:26,094 --> 02:26:28,883
There's a debug and a resolver and then nothing.
这里有一个调试器和解析器 之后就没有了

2681
02:26:31,034 --> 02:26:32,673
Maybe it's doing it afterwards.
可能之后会处理

2682
02:26:34,096 --> 02:26:35,766
kern_credential sounds interesting.
内核凭据 听起来很有趣

2683
02:26:41,698 --> 02:26:43,046
VFS lookup.
VFS 查找

2684
02:26:47,180 --> 02:26:48,424
I gotta, I don't know.
我不知道 得看看

2685
02:26:50,420 --> 02:26:51,700
Anyways, okay, cool.
不管怎样 好的 不错

2686
02:26:51,745 --> 02:26:55,886
So we practiced recon and now we learned a lot about XNU, hopefully.
我们进行了侦察演练 希望能对 XNU 有更多的了解

2687
02:26:57,547 --> 02:27:00,723
My intuition here is that there's probably not anything here.
我觉得这里应该没什么bug

2688
02:27:00,750 --> 02:27:03,486
If there was, somebody would have already found it
如果有的话 早就有其他人发现了

2689
02:27:03,487 --> 02:27:05,388
because these are very shallow bugs, right?
因为这些bug都很明显 对吧？

2690
02:27:05,389 --> 02:27:09,200
The copying in from user space happens at the very first part of the system call.
从用户空间的复制 发生在系统调用的最初阶段

2691
02:27:09,225 --> 02:27:11,762
So testing this stuff is very, very easy.
所以测试这些内容非常简单

2692
02:27:11,831 --> 02:27:13,675
You just need to be able to talk to the system call.
只要能和系统调用交互就行

2693
02:27:14,028 --> 02:27:16,902
So it's not a bug I would expect like later on in the code, but.
所以我不认为能在代码中找到这样的bug

2694
02:27:17,307 --> 02:27:18,628
Hey, you know, whatever.
嘿 总之

2695
02:27:19,114 --> 02:27:21,341
If one of you finds some stuff with this, that's great.
如果你们找到bug了，那太好了

2696
02:27:21,421 --> 02:27:23,714
And that'll be good.
那很好

2697
02:27:25,260 --> 02:27:26,794
Cool. Thanks for class.
谢谢大家的参与

