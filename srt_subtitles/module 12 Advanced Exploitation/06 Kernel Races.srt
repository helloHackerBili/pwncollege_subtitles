1
00:00:01,100 --> 00:00:02,133
你好黑客
hello hackers 

2
00:00:02,200 --> 00:00:04,133
欢迎回到pwn学院
welcome back to pwn College

3
00:00:04,533 --> 00:00:06,466
我们谈论的是高级漏洞利用
we're talking about advanced exploitation

4
00:00:06,533 --> 00:00:09,966
Linux内核中的竞争条件
specifically race conditions in the Linux kernel

5
00:00:12,366 --> 00:00:13,499
我们为什么要谈这个
why are we talking about this

6
00:00:13,600 --> 00:00:17,233
因为Linux内核中会发生竞争条件
well because race conditions happen in the Linux kernel

7
00:00:17,400 --> 00:00:20,666
内核是隐式并发的
the kernel is implicitly concurrent

8
00:00:22,133 --> 00:00:23,599
如果你有一个内核入口点
if you have a kernel entry point

9
00:00:23,633 --> 00:00:24,599
系统调用
the system call 

10
00:00:24,700 --> 00:00:26,733
包括很常见的
including very common one

11
00:00:26,766 --> 00:00:29,933
像ioctl是这些问题的常见来源
ioctl is a common source of these issues

12
00:00:30,966 --> 00:00:34,599
文件访问
a file access 

13
00:00:34,633 --> 00:00:38,766
假设你编写了一个在内核中运行的文件系统驱动程序
let's say you've written a file system driver that runs in the kernel

14
00:00:39,666 --> 00:00:42,366
任何类型的中断处理程序
any sort of interrupt handlers 

15
00:00:42,400 --> 00:00:44,066
如果你在做一些疯狂的事情
if you're doing something really crazy

16
00:00:44,200 --> 00:00:51,866
所有这些都可以由用户空间同时触发
all of this stuff can be triggered by user space simultaneously concurrently

17
00:00:52,533 --> 00:00:54,933
通过不同的用户空间进程
by many different user space processes 

18
00:00:55,266 --> 00:01:05,066
同时运行并与这些内核资源交互
running and interacting with these kernel resources all at once

19
00:01:05,666 --> 00:01:08,199
因此，编写内核代码必须考虑并发性
so kernel code must be written with concurrency in mind

20
00:01:08,300 --> 00:01:11,866
当然，经常没考虑到
and of course often times it is not

21
00:01:12,800 --> 00:01:13,200
哎呦
whoops

22
00:01:13,500 --> 00:01:14,566
我们来看一看
let's take a look

23
00:01:15,566 --> 00:01:16,966
露底了
that shouldn't

24
00:01:18,166 --> 00:01:20,366
那是一个预览
that was a preview of things to come

25
00:01:20,633 --> 00:01:22,133
我们来看看
let's take a look at

26
00:01:22,766 --> 00:01:32,333
内核代码中没考虑并发性，会发生什么
what happens when kernel code is not written with concurrency in mind

27
00:01:33,566 --> 00:01:38,266
这是竞争条件模块题目
here we have a version of one of your race condition challenges 

28
00:01:38,400 --> 00:01:40,000
为内核编写的版本
but written for the kernel

29
00:01:40,333 --> 00:01:41,733
有一个ioctl
we have an ioctl

30
00:01:42,466 --> 00:01:48,566
内核驱动程序注册了/proc/pwn-college-ioctl
the kernel driver registers /proc/pwn-college-ioctl

31
00:01:48,800 --> 00:01:54,033
定义了4个ioctl_number
it has 4 ioctl numbers 

32
00:01:54,433 --> 00:02:01,499
LOGIN，会将你的权限级别设置为1
and it has LOGIN which sets your privilege level to 1

33
00:02:01,766 --> 00:02:03,833
ADMIN，将其设置为2
ADMIN which sets it to 2 

34
00:02:03,933 --> 00:02:06,999
但前提是你已经知道flag了
but only if you already know the flag 

35
00:02:07,133 --> 00:02:10,066
它是ADMIN的密码
that is the password for administrative access 

36
00:02:10,533 --> 00:02:11,299
SUDO
SUDO

37
00:02:11,466 --> 00:02:15,366
如果你的访问权限大于1
which once you have administrative access of greater than 1

38
00:02:16,466 --> 00:02:25,733
就将你的ruid、euid等设置为0
sets your real effective and so forth user ids to 0

39
00:02:25,733 --> 00:02:28,599
这正是内核漏洞利用程序会做的事情
this is exactly what a kernel exploit would do

40
00:02:29,900 --> 00:02:34,200
LOGOUT会降低你的权限级别
and a LOGOUT which decrements your privilege level

41
00:02:35,600 --> 00:02:40,933
这基本上是一个疯狂的内核模块版的sudo
this is basically a kernel module sudo in some crazy way 

42
00:02:41,066 --> 00:02:43,466
非常粗糙的版本
very hacked up version

43
00:02:43,500 --> 00:02:46,700
当然，问题在于特权级别是一个全局变量
the problem of course is the privilege level is a global variable

44
00:02:48,866 --> 00:02:50,533
这个内核模块做出如下假设
this kernel module makes the Assumption that

45
00:02:50,533 --> 00:02:53,933
一次只有一个线程访问它
only one thread will be accessing it at one time

46
00:02:53,933 --> 00:02:56,366
但事实并非如此
but that is definitely not the case

47
00:02:56,366 --> 00:03:00,866
内核资源可以并发访问
kernel resources can be accessed concurrently

48
00:03:02,566 --> 00:03:06,599
当然，这里的攻击类似于babyrace
of course the attack here is similar as babyrace

49
00:03:06,600 --> 00:03:07,766
权限降低这里
this decrement

50
00:03:08,533 --> 00:03:10,433
如果我们能安排这样一个竞争
if we can set up a race 

51
00:03:10,800 --> 00:03:14,600
我们传入LOGIN，特权级别设为1
where we pass privilege level of 1

52
00:03:14,600 --> 00:03:15,833
因为我们不知道flag
we obviously don't know the flag

53
00:03:15,866 --> 00:03:17,899
所以特权级别不能设为2
so we can't make privilege level be 2

54
00:03:18,333 --> 00:03:24,799
如果我们通过了，特权级别是否设置的检查
if we pass the check that checks for privilege level being set

55
00:03:27,200 --> 00:03:28,100
并且
and

56
00:03:30,533 --> 00:03:34,699
同时有两个线程执行到这里
if we get here concurrently with two threads at the same time

57
00:03:34,800 --> 00:03:36,666
或者是同时两个进程执行到这里
or two processes at the same time

58
00:03:36,900 --> 00:03:39,533
都执行PWN_LOGOUT
doing the PWN_LOGOUT ioctl number

59
00:03:40,000 --> 00:03:41,566
都会降低一次特权级别
they will each decrement

60
00:03:41,600 --> 00:03:44,733
最后特权级别将是-1
and we will end up with a privileged level of negative 1

61
00:03:45,800 --> 00:03:47,566
这是一个无符号整型
this is an unsigned INT

62
00:03:48,000 --> 00:03:49,266
正因如此
so because of that

63
00:03:49,600 --> 00:03:50,833
这里的检查就能通过了
this check will now pass 

64
00:03:50,933 --> 00:03:53,733
因为特权级别将是40亿多
privilege level will be 4 billion something 

65
00:03:53,733 --> 00:03:55,333
满足大于1
which is greater than one

66
00:03:55,600 --> 00:03:57,300
我们将成为root
and we will become root

67
00:03:57,533 --> 00:03:59,866
所以我制造了一个攻击程序
so I created an attack

68
00:04:02,166 --> 00:04:04,933
我们可以用它来探索这个概念
that we can use to explore this concept

69
00:04:05,166 --> 00:04:06,533
很简单
very simple 

70
00:04:06,533 --> 00:04:08,899
先启动几个竞争进程
spin off first

71
00:04:09,800 --> 00:04:11,733
这些其实毫无意义
this is actually pointless

72
00:04:12,000 --> 00:04:15,066
这是之前沙盒逃逸视频遗留的
that was a leftover from a previous sandbox thing

73
00:04:15,766 --> 00:04:18,533
首先我们启动4个工作进程
first we spin up four workers

74
00:04:19,766 --> 00:04:22,366
我们在每个工作进程做不同的事情
and in each worker we do a different thing

75
00:04:22,366 --> 00:04:25,199
或者一个进程LOGIN
or in one worker we do the login 

76
00:04:25,200 --> 00:04:34,000
这要用密码登录
this will log in with password secret

77
00:04:34,366 --> 00:04:37,733
它可从内核模块中获得
which is from the kernel module

78
00:04:37,766 --> 00:04:38,866
它必须是保密的
that has to be secret 

79
00:04:38,866 --> 00:04:43,599
顺便说一下，这是非常不安全的内核编程方法
this by the way is very very unsafe kernel programming practices

80
00:04:43,866 --> 00:04:46,533
永远不要直接访问用户空间
you should never access user space directly 

81
00:04:46,533 --> 00:04:48,333
这是用户空间
and this is user space

82
00:04:48,333 --> 00:04:51,199
我应该先从用户空间复制过来
I should have copied it from user 

83
00:04:51,333 --> 00:04:52,499
再访问它
and then accessed it 

84
00:04:52,566 --> 00:04:56,599
但我想要一个简洁的例子
but I wanted it concise example

85
00:04:58,500 --> 00:05:01,766
我们有一个线程一直在登录
so we have one thread that's always logging in

86
00:05:03,333 --> 00:05:04,599
我们有一个线程
we have one thread that's

87
00:05:04,800 --> 00:05:08,733
哦，我们有三个线程一直登出
oh we have three threads that are always logging out right

88
00:05:08,733 --> 00:05:10,566
思路是
the idea of course we want to

89
00:05:11,533 --> 00:05:18,133
我们想让两个不同线程
hit with two different threads at the same time in here 

90
00:05:18,333 --> 00:05:20,733
使特权级减2次
to decrement that twice

91
00:05:20,766 --> 00:05:27,099
然后我的主线程就等着变成root线程
and then my main thread is just waiting to become root

92
00:05:27,100 --> 00:05:28,366
与此同时
and in the meantime

93
00:05:28,466 --> 00:05:32,866
它会一遍遍地尝试SUDO
it is hitting that sudo ioctl over and over and over

94
00:05:33,266 --> 00:05:37,599
一旦竞争成功，它就会关闭所有工作进程，并启动一个shell
once I win it kills the workers and executes a shell

95
00:05:37,600 --> 00:05:39,933
这里不需要-p
and of course I don't need -p here 

96
00:05:40,033 --> 00:05:46,333
因为这会将ruid、euid和saved uid都设为零
because this sets the real effective and saved user ids all to zero 

97
00:05:46,333 --> 00:05:48,499
所以shell很满意
so shell is perfectly happy

98
00:05:48,500 --> 00:05:50,466
/bin/sh欣然接受了自己是root的这一情况
/bin/sh perfectly happy being root

99
00:05:51,800 --> 00:05:55,266
我们来编译一下
let's compile that

100
00:05:56,333 --> 00:05:57,499
启动内核
launch the kernel

101
00:06:05,066 --> 00:06:06,699
加载模块
load up the module

102
00:06:08,766 --> 00:06:09,599
然后
and

103
00:06:13,800 --> 00:06:15,566
切换到CTF用户
become the ctf user

104
00:06:17,100 --> 00:06:18,100
我们开始攻击吧
and let's do this

105
00:06:23,700 --> 00:06:24,800
真快
that was fast

106
00:06:25,533 --> 00:06:26,533
我们是root了
and we are root

107
00:06:27,733 --> 00:06:29,699
我想指出一点
one thing I want to point out

108
00:06:30,000 --> 00:06:36,933
要强调的是，我们需要执行两次LOGOUT
to stress that we need to hit the logout twice

109
00:06:37,666 --> 00:06:39,699
所以LOGOUT这里
so this logout

110
00:06:40,166 --> 00:06:43,499
我们需要两个进程同时进入
we need to get in here with two process at the same time

111
00:06:43,500 --> 00:06:47,533
如果只有一个进程执行登录
if you just have one process that does the login 

112
00:06:47,633 --> 00:06:49,399
一个进程执行登出
one process that does the logout

113
00:06:49,466 --> 00:06:50,933
这永远不会成功
this will never succeed

114
00:06:50,933 --> 00:06:54,733
希望我没说错
I hope this doesn't make me a liar

115
00:06:54,733 --> 00:06:56,166
哦，我不需要重启它
oh I didn't need to restart that 

116
00:07:00,566 --> 00:07:01,866
好了，开始吧
okay here we go

117
00:07:08,733 --> 00:07:09,399
开始
here we go

118
00:07:15,700 --> 00:07:17,833
它永远不会结束
no luck and it will never finish 

119
00:07:17,833 --> 00:07:21,133
因为已经不在竞争了
because of course we are no longer racing

120
00:07:21,133 --> 00:07:26,266
我们需要2个登出行动，同时在这里执行
we need to race 2 logout actions into here at the same time

121
00:07:28,400 --> 00:07:35,266
这是我们讨论过的一个很标准的竞争条件
so that's a pretty standard race condition that we've explored

122
00:07:35,366 --> 00:07:39,499
这在内核中经常发生
and it happens a lot in the kernel

123
00:07:40,533 --> 00:07:43,699
尽管内核有
this is despite the fact that the kernel of course has

124
00:07:47,200 --> 00:07:48,300
什么来着
what are they called

125
00:07:48,300 --> 00:07:50,300
防止这种情况发生的机制
mechanisms  for preventing this

126
00:07:50,400 --> 00:07:52,533
内核有互斥信号量
the kernel has mutexas semaphores 

127
00:07:52,733 --> 00:07:54,133
专门的信号量
specialized semaphores 

128
00:07:54,166 --> 00:07:59,799
为快速访问而设计的
made for very fast access of like 

129
00:07:59,833 --> 00:08:02,366
该机制允许多个线程可以读取一个共用值
where multiple threads can read a value 

130
00:08:02,466 --> 00:08:03,899
但一次只有一个线程可以修改它
and one thread can write it

131
00:08:03,966 --> 00:08:06,333
有通用互斥信号量
there's generic mutex semaphore

132
00:08:06,333 --> 00:08:07,466
等好东西
all sorts of good stuff

133
00:08:07,533 --> 00:08:09,766
通用互斥接口是最简单的
the generic mutex interface is the simplest

134
00:08:09,766 --> 00:08:11,733
其实它非常简单
it's actually super simple

135
00:08:12,133 --> 00:08:14,733
它几乎与pthread互斥锁接口完全相同
it's almost exactly like the pthread mutex interface

136
00:08:14,733 --> 00:08:18,266
你只要在某地声明一个锁
you declare it somewhere 

137
00:08:18,366 --> 00:08:19,933
然后就可以加锁，解锁
and then you lock unlock

138
00:08:20,200 --> 00:08:21,100
超级简单
super simple

139
00:08:22,200 --> 00:08:25,066
但不容易理解的是
but it is not easy to understand 

140
00:08:25,066 --> 00:08:27,999
什么资源可以被不同线程影响
what resources can be impacted by different threads

141
00:08:28,000 --> 00:08:30,300
特别是在复杂的代码中
especially in complex code

142
00:08:30,333 --> 00:08:35,366
从有大量这类错误的事实，就能看出
and we can see this from the fact that errors persist a lot 

143
00:08:35,766 --> 00:08:37,666
我改一下幻灯片
let me fix this slide one second

144
00:08:40,333 --> 00:08:41,933
有大量这类错误
errors persist a lot

145
00:08:44,100 --> 00:08:45,300
就在今年
just this year

146
00:08:45,900 --> 00:08:49,700
在各种内核，不光是linux内核，曝出了20个CVE
there have been 20 CVEs in various kernels not just in linux kernel

147
00:08:50,000 --> 00:08:52,966
都是竞争条件类的
that are specific to race conditions

148
00:08:54,133 --> 00:08:57,799
2017年
in 2017 

149
00:08:58,233 --> 00:09:05,233
自动检测这些错误的尝试
kind of the attempt to automatically detect these sort of errors 

150
00:09:05,333 --> 00:09:06,466
已经开始了
has started up

151
00:09:07,533 --> 00:09:10,166
传统上，这些错误是手动识别的
traditionally these errors were identified manally 

152
00:09:10,233 --> 00:09:13,766
这样做很痛苦
and it is a pain to do so

153
00:09:14,133 --> 00:09:15,499
至少可以这么说
to say the least it's

154
00:09:16,766 --> 00:09:18,299
在我们看的例子中
in the example that we looked at 

155
00:09:18,333 --> 00:09:19,366
很明显就能看出
it was very obvious

156
00:09:19,366 --> 00:09:23,800
这里存在竞争条件和对全局变量的不安全访问
where there was a race condition and unsafe access of a global variable

157
00:09:24,166 --> 00:09:29,233
但这在Linux内核这个复杂代码中经常发生
but these happen in complex code in the Linux kernel all the time

158
00:09:29,333 --> 00:09:31,633
Dr. Checker发表于2017年
Dr Checker published in 2017 

159
00:09:31,633 --> 00:09:34,333
找到了63个和这个完全一样的竞争条件
found 63 race conditions exactly like this

160
00:09:34,333 --> 00:09:39,966
都是，在不同Android版本中，对全局变量的不安全访问
unsafe access of global variables in different versions of Android

161
00:09:40,400 --> 00:09:42,233
这当然是Linux内核
which of course is Linux kernel 

162
00:09:42,233 --> 00:09:46,166
2019年，谷歌发布了 内核并发消毒程序
in 2019 Google released the Kernel concurrency Sanitizer

163
00:09:46,333 --> 00:09:47,899
发现了数百个
that found hundreds 

164
00:09:47,900 --> 00:09:53,800
我看到的数字是，发现了多达300个竞争条件在linux内核中
I see numbers as much as 300 of races in the Linux kernel 

165
00:09:53,833 --> 00:09:58,733
在2019年和2020年，有更多的学术工作
and in 2019 and 2020 there have been more academic work

166
00:09:59,700 --> 00:10:05,500
创建了识别内核中竞争条件的技术
works that have created techniques to identify race conditions in the kernel

167
00:10:06,300 --> 00:10:10,300
在文件系统，设备驱动程序和各种东西中的竞争条件
in file systems in device drivers and all sorts of things

168
00:10:11,833 --> 00:10:14,699
我特意把这4个写在上面的原因是
the reason I have these 4 specifically up here

169
00:10:14,700 --> 00:10:16,000
它们都是开源的
they're all open source

170
00:10:16,000 --> 00:10:18,333
你可以获取Dr.Checker
you can actually grab Doctor Checker 

171
00:10:18,433 --> 00:10:20,299
KCSAN
grab KCSAN 

172
00:10:20,500 --> 00:10:29,566
据我所知，KCSAN已经合到Linux内核主线了
actually KCSAN is as far as I am aware merged into the Linux kernel mainline source

173
00:10:30,333 --> 00:10:32,399
你可以玩一下它
so you can actually play around with it

174
00:10:33,200 --> 00:10:37,466
构建一个自己的fuzzer，尝试触发竞争条件
and build your own fuzzers and try to trigger race conditions

175
00:10:40,200 --> 00:10:41,266
我应该提一下
I should mention

176
00:10:41,966 --> 00:10:46,166
这个KCSAN专门用于检测竞争条件
this KCSAN specifically is for detecting the race conditions

177
00:10:46,233 --> 00:10:49,099
Dr Checker是针对静态ELF的工具
Dr Checker is a static ELF tool 

178
00:10:49,266 --> 00:10:50,599
并不运行Linux内核
doesn't actually run the Linux kernel 

179
00:10:50,666 --> 00:10:52,299
就看看源码
just looks at the source code

180
00:10:52,900 --> 00:10:55,466
这些技术结合了
and then these techniques combine

181
00:10:56,166 --> 00:10:59,299
触发系统调用本身，与静态分析
triggering of system calls themselves with an analysis 

182
00:10:59,433 --> 00:11:02,899
来识别何时遇到竞争条件
to identify when race conditions are hit

183
00:11:04,566 --> 00:11:07,166
结论是
the takeaway of course is that 

184
00:11:07,166 --> 00:11:09,599
这仍然是一个大问题
this is still a major problem

185
00:11:10,700 --> 00:11:12,300
这四种技术代表
these four techniques represent

186
00:11:12,300 --> 00:11:16,733
仅在Linux内核中就有成百上千的竞争条件
hundreds and hundreds of race conditions found in the Linux kernel alone

187
00:11:16,966 --> 00:11:20,499
还只是过去的三年
in the last three years

188
00:11:23,133 --> 00:11:27,699
或者说过去四年，算上2017年的话
or the last four years I guess if you include 2017

189
00:11:28,466 --> 00:11:29,599
我们仍然
and we're still

190
00:11:30,366 --> 00:11:31,399
这种情况仍在发生
this is still happening

191
00:11:31,400 --> 00:11:34,733
2017年确实是内核竞争条件曝出数量的一个高点
2017 was really was a high point in race conditions in the kernel

192
00:11:34,733 --> 00:11:36,399
但在过去几年里
but over the last couple of years 

193
00:11:36,400 --> 00:11:40,366
也在持续稳定地发现竞争条件
there have been very stable amount of race conditions found

194
00:11:40,366 --> 00:11:43,733
所以这告诉我们，还有很多有待发现
so which tells me that there's a lot left to find

195
00:11:46,133 --> 00:11:46,633
当然
of course 

196
00:11:46,633 --> 00:11:48,766
在你的练习题中，你会发现一些
in your challenge problems you'll find some 

197
00:11:48,766 --> 00:11:52,099
但也许有一天你也会在现实世界中找到一些
but maybe you'll find some in the real world one day as well 

198
00:11:52,333 --> 00:11:53,133
祝你好运
good luck

