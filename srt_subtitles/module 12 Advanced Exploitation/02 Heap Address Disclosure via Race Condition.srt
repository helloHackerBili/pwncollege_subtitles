1
00:00:00,933 --> 00:00:02,366
你好黑客
hello hackers

2
00:00:02,866 --> 00:00:06,533
欢迎回到高级利用
welcome back to advanced exploitation 

3
00:00:07,933 --> 00:00:10,366
PWN学院的组合模块的第二个视频
the second putting it all together module of pwn college

4
00:00:10,500 --> 00:00:17,500
今天专门讨论通过堆上的竞争条件进行数据泄露
today we're going to be talking about data disclosure via race conditions on the heap specifically

5
00:00:18,800 --> 00:00:24,600
我们这里使用上个视频末尾提到的服务
as a reminder we have our example service here from the previous video

6
00:00:24,666 --> 00:00:29,099
它有很多安全检查
the service has a lot of security checks 

7
00:00:29,333 --> 00:00:30,666
但是这些安全检查
but these security checks

8
00:00:30,866 --> 00:00:34,000
尽管它们在单线程场景中很好
while they are good in a single threaded scenario

9
00:00:34,000 --> 00:00:35,900
但在多线程场景中是差强人意的
are bad in a multi threaded scenario

10
00:00:35,966 --> 00:00:39,866
所以我们要迈出开发利用的第一步
so we're going to kind of take the first step toward exploitation

11
00:00:40,100 --> 00:00:43,400
这里也有一个微不足道的缓冲区溢出
there's also a trivial buffer overflow here 

12
00:00:43,533 --> 00:00:48,499
在fscanf到栈上的input变量时
in this fscanf onto the input variable on the stack

13
00:00:48,566 --> 00:00:50,533
但我们无法利用它
but we can't exploit that of course

14
00:00:50,666 --> 00:00:54,666
因为我们不知道金丝雀，也不知道任何地址
because we don't know the canary or any addresses

15
00:00:55,133 --> 00:00:55,933
好吧
all right

16
00:00:56,900 --> 00:00:58,100
让我们深入了解一下
so let's dive in

17
00:01:01,066 --> 00:01:02,166
我们有很多
we have a lot of

18
00:01:02,566 --> 00:01:04,200
这是一个多线程服务
this is a multi threading service right

19
00:01:04,200 --> 00:01:05,366
我们可以连接到它
we can connect to it

20
00:01:06,100 --> 00:01:10,200
每个连接都在自己的线程中运行刚刚看到的循环
and each connection gets its own thread to run through that loop that we just saw

21
00:01:10,933 --> 00:01:14,133
当然，正如从竞争条件模块中知道的那样
of course as you know from the race condition module

22
00:01:14,266 --> 00:01:19,066
当多个线程同时运行时，危险就可能发生
with multiple threads going on at the same time crazy stuff can happen

23
00:01:20,800 --> 00:01:29,000
结论是程序中的代码可以以任何顺序执行
the takeaway is all of the this code that is in the original program can really run in any order

24
00:01:29,500 --> 00:01:33,300
因为你能让足够多的线程做不同的事
because you can get enough threads in there doing a lot of different stuff

25
00:01:33,500 --> 00:01:36,766
而且线程之间的执行顺序是交错的
that execution ordering between threads gets interleaved 

26
00:01:36,933 --> 00:01:38,799
但它们都基于全局变量执行
and they all act on global data 

27
00:01:39,000 --> 00:01:44,666
因此，一个线程修改全局变量，其他线程也会受到影响
and so when one thread modifies global data that effect is seen in the other thread as well

28
00:01:44,700 --> 00:01:53,066
因此，启动足够多的线程，灵活地编织它们的行为
so by interleaving in a clever way with enough threads actions in this program

29
00:01:53,266 --> 00:02:02,599
你可以以任何顺执行这些依赖全局变量的指令
 you can basically run any of this stuff in more or less any order with the global data being acted upon

30
00:02:02,800 --> 00:02:04,000
这有几个要注意的
and there are a couple of things here

31
00:02:04,133 --> 00:02:22,199
我们能用一个线程将任意一个全局消息设置成已存或未存状态
one is we can have one thread set the stored or unstored condition of any of the global messages

32
00:02:22,300 --> 00:02:26,900
同时用另一个线程打印消息，或分配消息内存
while another thread is printing them out or another thread is allocating

33
00:02:26,900 --> 00:02:35,100
或者我们可以在消息释放后，重新分配前，打印它（uaf）
or we can have a print triggered after a free before an allocation 

34
00:02:35,266 --> 00:02:38,599
即使在代码中它是做了保护的
even though in the normal code it's guarded

35
00:02:39,500 --> 00:02:46,100
因为我们可以在其他线程中设置stored[idx]为0或1
because we can trigger these stored indexes yes and stored indexes no in other threads

36
00:02:46,200 --> 00:02:49,300
所以我们可以利用竞争条件绕过这些防护
we can basically bypass these guards with race conditions

37
00:02:49,766 --> 00:02:51,200
这里的核心概念是
the core concept here is that

38
00:02:51,200 --> 00:02:56,400
在单线程场景中有用的安全检查
you can have security checks that makes sense in a single threaded scenario

39
00:02:56,700 --> 00:02:59,900
如果你不考虑到每一个攻击场景
and if you don't specifically think about every attack scenario

40
00:03:00,000 --> 00:03:02,700
如果你没考虑多线程场景
if you don't specifically think about the multi threaded case

41
00:03:02,700 --> 00:03:06,900
而你的库或程序最终被以多线程的方式使用
and your library your program ends up being used in a multi threaded way

42
00:03:08,066 --> 00:03:10,533
这些安全检查是不够的
those checks can be insufficient

43
00:03:10,966 --> 00:03:14,233
好吧，让我们来看看具体细节
alright let's take a look at you know specifics

44
00:03:14,333 --> 00:03:16,499
刚刚讲的有点抽象了
 I know this is a little high level

45
00:03:16,500 --> 00:03:20,100
让我们来看看可以拆解出来的
but let's take a look at a specific way in which this can break down

46
00:03:20,700 --> 00:03:26,500
利用这个程序的具体步骤
from the perspective of accomplishing some actual step toward exploitation this program 

47
00:03:26,766 --> 00:03:29,066
好的，我们很接近了
right so we're close right 

48
00:03:29,200 --> 00:03:33,500
在babyheap中有和现在相同的功能
as in babyheap you had the same sort of primitives

49
00:03:33,533 --> 00:03:35,333
比如malloc scanf free
you had malloc scanf free

50
00:03:35,733 --> 00:03:37,699
当时是puts，现在是printf
instead of printf you had puts

51
00:03:37,900 --> 00:03:40,333
老实说，都差不多
it's the same thing honestly

52
00:03:42,866 --> 00:03:45,900
所有这些工具
and all of these tools

53
00:03:48,800 --> 00:03:53,700
你用了这些工具来利用babyheap
you used all these tools to achieve exploitation in babyheap

54
00:03:53,800 --> 00:03:59,200
但现在缺少必要信息
but here we don't know where anything is 

55
00:03:59,800 --> 00:04:02,466
和某个babyheap中的场景一样
like a scenario that you face in babyheap

56
00:04:02,466 --> 00:04:03,700
不知道PIE基址
you don't know where the PIE base is

57
00:04:03,700 --> 00:04:07,800
不知道ASLR后的基址，比如库的基址
we don't know where the ASLR base is for a library address and stuff

58
00:04:07,866 --> 00:04:09,733
不知道栈基址，堆基址
we don't know where the stack is the heap base

59
00:04:09,733 --> 00:04:10,700
还有栈金丝雀
the canary right

60
00:04:10,700 --> 00:04:14,800
如果我们知道金丝雀和libc基址，就可以ROP
if we knew the canary and let's say the libc base  we could ROP

61
00:04:14,866 --> 00:04:16,333
或者知道PIE基址，也可以ROP
or the PIE base we could ROP 

62
00:04:16,466 --> 00:04:17,533
正如从babyrop中学到的
as you know from babyrop

63
00:04:17,666 --> 00:04:18,933
但我们不知道金丝雀
but we don't know the canary

64
00:04:18,933 --> 00:04:20,400
这些基址我们都不知道
we don't know any of those bases

65
00:04:20,400 --> 00:04:29,466
从babyheap中知道了，能用这些功能泄露地址
so from babyheap as you know you can use these primitives to start disclosing addresses

66
00:04:29,900 --> 00:04:36,500
比如你可以用tcache来
so for example you could use tcache to

67
00:04:40,166 --> 00:04:42,066
通过使用这些竞争条件
by using these race conditions

68
00:04:42,166 --> 00:04:45,566
和穿插执行不同指令的能力
and the ability to interleave different instructions all at the same time

69
00:04:45,700 --> 00:04:48,900
基本上能复现在babyheap中做的事
you can accomplish basically what you did with babyheap

70
00:04:48,900 --> 00:04:52,300
比如先释放消息
in terms of triggering a free of a message

71
00:04:52,366 --> 00:04:55,400
然后再打印消息
and then triggering a print of that message right

72
00:04:55,900 --> 00:04:58,533
这是可行的
and that is a viable path forward

73
00:04:58,933 --> 00:05:00,566
但有个问题
there's one complication

74
00:05:01,900 --> 00:05:03,933
事情并不像你想象的那么简单
things aren't as simple as you might expect

75
00:05:04,033 --> 00:05:10,133
在babyheap中，我们研究了单线程程序中的堆
so in babyheap we looked at heap operations in a single threaded program

76
00:05:10,266 --> 00:05:13,733
单线程程序有一个主线程
a single threaded program has one main thread

77
00:05:13,900 --> 00:05:19,300
但ptmalloc，t表示线程
and it turns out that ptmalloc which stands for P thread malloc

78
00:05:19,300 --> 00:05:23,366
实际上使用了很多多线程概念
actually has a lot of thread specific concepts that it employs

79
00:05:23,500 --> 00:05:26,000
其中之一是arenas（竞技场）
one of these concepts is arenas

80
00:05:27,500 --> 00:05:30,066
它放弃了一些旧有想法
going off of the idea that 

81
00:05:30,266 --> 00:05:32,733
如，不同线程往往做不同的事
different threads tend to do different things

82
00:05:32,800 --> 00:05:39,200
线程间分享的资源往往比线程内用的要少等等 
tend to share fewer resources between threads than they do within that thread and so forth

83
00:05:39,400 --> 00:05:45,400
ptmalloc为每个线程提供自己的arena，数量有限超了共用
ptmalloc had the bright idea to give every thread kind of its own heap

84
00:05:45,666 --> 00:05:48,266
宏观上的堆实际上被分成了多个arena
so the heap is actually split into arenas 

85
00:05:48,533 --> 00:05:53,899
每个arena都能被进程中的线程访问到（链表相连，有锁）
each arena lives in a section of memory accessible to all the threads in the process

86
00:05:55,900 --> 00:06:08,500
每个arena都记录了一片内存用来分配chunk
but each arena has a space for its chunks that that arena will allocate

87
00:06:09,700 --> 00:06:15,300
还有指向其它arena的指针
 and pointers back to other arenas in case that arena runs out of space and so forth right

88
00:06:17,800 --> 00:06:22,100
线程至少会从一个arena中取过内存
each thread ends up with at least one arena to allocate from

89
00:06:22,166 --> 00:06:26,166
因为ptmalloc的算法
I think actually there's some crazy algorithm by which

90
00:06:26,333 --> 00:06:32,099
一个线程可能在8还是几个arena中取过chunk
a thread might end up with up to 8 arenas or some amount of arenas

91
00:06:32,200 --> 00:06:35,000
但要知道的是
but basically the takeaway is

92
00:06:35,000 --> 00:06:43,133
在非主线程中malloc获得的地址
that the addresses that you receive from malloc within a non main thread 

93
00:06:43,233 --> 00:06:46,699
和主线程中malloc获得的地址不同
are different than the addresses you receive from malloc within the main thread

94
00:06:48,400 --> 00:06:49,733
这意味着
this means that

95
00:06:50,133 --> 00:06:55,133
1泄露出的指针指向的是普通线程的arena
one the leaks will be pointers to the threads arena

96
00:06:55,333 --> 00:06:57,000
而不是
instead of the

97
00:06:57,500 --> 00:06:58,866
这个应该是1
this is this should be one probably

98
00:06:58,866 --> 00:07:00,666
稍等，我改一下
let me just fix that and slide 1 sec

99
00:07:01,966 --> 00:07:02,766
好了
all right

100
00:07:02,900 --> 00:07:05,000
现在要点的顺序没问题了
now you have the takeaways in the proper order

101
00:07:05,000 --> 00:07:06,300
第一个要点是
so the first takeaway is

102
00:07:06,333 --> 00:07:10,433
当有信息泄露，也许是堆误用导致的
the leaks that you might get out of a heap misuse 

103
00:07:10,666 --> 00:07:13,299
比如泄露了tcache的next指针
the tcache forward pointer leak

104
00:07:13,300 --> 00:07:16,100
它将会是一个指向普通线程arena的指针
is going to be a pointer to the threads arena

105
00:07:17,433 --> 00:07:21,466
（口误发现中）

106
00:07:21,666 --> 00:07:24,166
是一个指向普通线程arena中的chunk的指针
a pointer to a chunk in the threads arena 

107
00:07:24,300 --> 00:07:25,300
指向的是arena中的某个地址
to somewhere inside it 

108
00:07:25,300 --> 00:07:33,566
第二条：这些线程的头几个chunk的地址含有00
and then two early chunks in those threads will have nulls in the addresses

109
00:07:33,766 --> 00:07:35,733
让我们来看看为什么会这样
let's take a look at why this is

110
00:07:36,300 --> 00:07:38,133
为了探究这个概念
to explore that specific concept 

111
00:07:38,266 --> 00:07:41,866
我写了个arena.c
I created arena.c

112
00:07:44,333 --> 00:07:48,199
一个非常简单的多线程程序
we have basically a very simple multi-thread program

113
00:07:48,333 --> 00:07:49,966
它启动了一堆线程
that spins up a bunch of threads 

114
00:07:50,133 --> 00:07:57,599
每个线程只是malloc一次，请求大小和前面讲的例子相同
and just does one malloc and the same size malloc as in our example program

115
00:07:57,800 --> 00:08:00,200
编译一下
so let's compile this

116
00:08:04,566 --> 00:08:06,466
运行一下
here we go let's run it

117
00:08:08,866 --> 00:08:10,166
让我
and actually let me 

118
00:08:10,366 --> 00:08:14,366
刚意识到，在主arena中也这样做，会更好
just realized it would be good to also do this in the main arena

119
00:08:24,300 --> 00:08:25,600
有了主线程的结果
so we have the main thread

120
00:08:25,700 --> 00:08:28,933
这很像我们在babyheap中习惯的
this looks like a heap address that you're used to from babyheap

121
00:08:29,000 --> 00:08:39,000
接着是一堆我们没想到会从malloc返回的地址
and then here are a bunch of different weird addresses that you don't expect from malloc

122
00:08:39,266 --> 00:08:43,000
能看到它们都以B60结尾
and you can see they're all end in this B60

123
00:08:44,100 --> 00:08:47,000
显然有一些
so obviously there is some 

124
00:08:47,233 --> 00:08:53,699
如果我们把它改成2个malloc 16
if we modify this to have two malloc of 16

125
00:08:55,700 --> 00:08:57,900
让我们，是的
and let's yeah

126
00:08:57,933 --> 00:09:00,166
它们当然会交织在一起，但是
they're gonna get interleaved of course but

127
00:09:01,666 --> 00:09:02,533
看到了
here we see it

128
00:09:03,733 --> 00:09:06,133
它从0x60增加到0x80
it goes from hex 60 to hex 80

129
00:09:06,800 --> 00:09:10,566
增加的这个是chunk的大小
which of course is the size of the chunk

130
00:09:10,800 --> 00:09:14,100
它有可用大小16字节（0x10）
that has a usable allocation space of 16 bytes 

131
00:09:14,333 --> 00:09:24,866
还有0x10字节用来放chunk元数据
right there's the extra hex 10 for the chunk metadata

132
00:09:25,666 --> 00:09:26,566
但基本上
but basically

133
00:09:27,300 --> 00:09:36,700
它们都是在不同高内存区的低地址处
these are all at very similar low addresses in different high address allocation areas 

134
00:09:36,800 --> 00:09:39,600
当线程启动时
basically when the thread starts up

135
00:09:39,733 --> 00:09:42,933
libc会为它分配一个arena
libc allocates an arena for it

136
00:09:44,100 --> 00:09:48,100
来响应malloc请求
to service malloc requests

137
00:09:49,200 --> 00:09:52,466
它基本上是特定于线程的
so basically this is a thread specific

138
00:09:52,600 --> 00:09:54,533
也不能说是特定于某个线程（线程过多会共用）
well not quite thread specific

139
00:09:54,733 --> 00:09:57,966
只能说是为了这个线程创建的一片堆
 but a piece of the heap creates specifically for the thread

140
00:09:58,133 --> 00:10:00,199
当然，它在线程外也有效
of course it is valid outside of the thread

141
00:10:01,100 --> 00:10:05,400
实际上，如果用strace -f，你能看到创建它的过程
and you can actually see it being created  if you do strace -f

142
00:10:07,200 --> 00:10:11,900
举个例子，我们从这里找一个
for example let's grab one of these

143
00:10:12,966 --> 00:10:13,966
这个
this guy

144
00:10:14,800 --> 00:10:16,900
它是刚刚的堆地址之一
it's one of the heap addresses

145
00:10:16,933 --> 00:10:18,700
看看它是从哪里来的
and let's see where that came from

146
00:10:25,900 --> 00:10:26,966
在这里
there 

147
00:10:27,166 --> 00:10:30,399
这是在用mprotect设置堆
so this is the mprotect setting up that heap

148
00:10:30,400 --> 00:10:32,566
这是，额，unmap??
here's the uh unmap

149
00:10:33,966 --> 00:10:34,766
这是,
here's that

150
00:10:36,266 --> 00:10:37,600
抱歉，这是。
sorry this is a

151
00:10:38,900 --> 00:10:44,200
再多过滤一个字节
let's grab more oh an extra byte

152
00:10:44,200 --> 00:10:47,200
1 2 3 4 5 6好的
1 2 3 4 5 6 yeah

153
00:10:47,800 --> 00:10:49,600
这应该足以避免混淆
that should be enough to avoid confusion

154
00:10:49,666 --> 00:10:51,099
筛出来的太多了
I think you're seeing way too many

155
00:10:59,266 --> 00:11:01,133
额
ah it it um

156
00:11:04,300 --> 00:11:08,100
这就是不按剧本来的后果
this is what happens when you go off script

157
00:11:08,233 --> 00:11:14,099
我觉得它是在别的地方分配的
 I think it gets allocated elsewhere

158
00:11:20,100 --> 00:11:24,700
或者有可能是通过其它隐式方法创建的
or rather by by something else implicitly possibly

159
00:11:33,866 --> 00:11:35,266
不，这些都不是
nope these are all

160
00:11:35,666 --> 00:11:37,733
啊，在这里
ah here here is

161
00:11:52,000 --> 00:11:52,900
好了，开始吧
okay here we go

162
00:11:53,666 --> 00:11:54,966
我们有这个地址
we have this address

163
00:11:55,066 --> 00:11:58,800
7f932c0
let's say 7f932c0

164
00:11:59,933 --> 00:12:03,600
这里的某个地方应该在分配它
and then somewhere here we're going to be allocating

165
00:12:09,800 --> 00:12:14,700
这儿，7 f 9 32 c 0....
boom 7 f 9 3 2 c 0 blah blah blah

166
00:12:14,866 --> 00:12:19,066
它来自以7结尾的PID，就是这个
this is from PID ending in 7 that's this guy

167
00:12:20,100 --> 00:12:24,200
所以在线程创建后的某一刻
so at some point after creation it actually

168
00:12:24,300 --> 00:12:32,600
线程首次使用malloc时，libc会为该线程分配一个arena
libc will allocate an arena for this thread when it first goes to use the heap

169
00:12:34,566 --> 00:12:36,166
好的
all right whoops

170
00:12:38,366 --> 00:12:43,166
这用另一个方法，验证了
that was a roundabout way of saying that threads have 

171
00:12:50,000 --> 00:12:53,000
说明由线程分配的地址通常
allocated addresses by a thread will often 

172
00:12:53,100 --> 00:12:58,766
但并非总是，这取决于堆缓存的状态等等
but not always it really depends on the state of the heap cache and everything

173
00:12:59,000 --> 00:13:06,066
通常是特定于线程的
often have end up with addresses that are kind of thread specific 

174
00:13:06,266 --> 00:13:08,499
当然要记住一点
now of course keep in mind

175
00:13:08,700 --> 00:13:13,900
这让我们发现一个待掌握的新知识点——线程相关的arena
so this first of all gives us a new thing that we need to know the thread specific arenas

176
00:13:14,500 --> 00:13:20,833
但请记住，这不是个什么全新的内存区
but keep in mind this isn't removed like independently existing somewhere in memory

177
00:13:21,066 --> 00:13:22,166
只是个内存映射
this is memory map

178
00:13:22,800 --> 00:13:32,266
一个处在某种程度上由内核决定的地址的内存映射
memory map at an address that is decided by the Linux kernel at least to some extent 

179
00:13:32,433 --> 00:13:37,399
它们之间还是相互有些关联的
I think at the very least they're very relative to each other

180
00:13:37,400 --> 00:13:39,933
如果你泄露了一个，剩下的你也就知道了
I think if you leak one you know the rest 

181
00:13:41,200 --> 00:13:45,500
将来我们会看到如何从一个泄露的arena，了解到更多内存信息
but we'll see how to go from leaking one to knowing much more of the memory space

182
00:13:45,666 --> 00:13:50,499
总之，线程arena的泄露途径很广
all right anyways so we have thread specific arenas that we can leak on top of everything

183
00:13:51,066 --> 00:13:52,166
我们继续深入
so let's dive in

184
00:13:54,333 --> 00:13:56,533
（纠正前面口误，略）
that we can leak on top of everything

185
00:13:56,766 --> 00:14:00,633
我们现在讨论的信息泄露
so now our information disclosure that we talked about 

186
00:14:00,900 --> 00:14:14,300
它利用程序的并发问题泄露tcache指针
with this tcache pointer leak to carry out in this program that has concurrency errors

187
00:14:15,733 --> 00:14:20,466
能提供一个线程arena地址（但null导致打印不全）
will at first give us a thread specific arena address

188
00:14:20,666 --> 00:14:21,933
该如何解决打印不全的问题呢
so how do we do it all right

189
00:14:22,533 --> 00:14:25,966
有2种方法
we have two routes first we can use race conditions to

190
00:14:26,466 --> 00:14:31,433
方法1，利用提供的malloc，分配大量内存
or just intelligent use of those message allocations to make enough allocations 

191
00:14:31,600 --> 00:14:35,400
使后续获得的内存地址中不含空字节
to create an address that doesn't have null bytes in it

192
00:14:35,766 --> 00:14:43,166
如果我们分配足够多的内存
right so if we allocate enough messages 

193
00:14:43,366 --> 00:14:44,066
最终
then eventually 

194
00:14:44,200 --> 00:14:53,900
malloc返回的地址中的空字节
that single null byte that we were seeing in the address of the the return of malloc

195
00:14:54,400 --> 00:14:55,200
将会消失
will go away

196
00:14:55,200 --> 00:14:56,966
它会以1开头
it'll become a 1 initial 

197
00:14:57,133 --> 00:15:00,766
显然，随着分配次数增多，地址会增长
and then obviously keep climbing as more and more is allocated

198
00:15:00,833 --> 00:15:03,999
这样就解决了这个问题
 and then we'll be able to beat this

199
00:15:04,133 --> 00:15:05,266
我们可以这样做
we can take that route

200
00:15:05,500 --> 00:15:08,700
我们还可以用另一个有趣的方法
we can also take a different route that's very interesting

201
00:15:10,300 --> 00:15:16,400
稍微变通一下竞争条件的利用方法
we can utilize the same race condition in a slightly different context

202
00:15:16,566 --> 00:15:18,799
欺骗一下另一处代码
to confuse a different part of the code

203
00:15:18,933 --> 00:15:19,933
这个代码甚至不在我们写的程序中
that's not even in the program

204
00:15:20,033 --> 00:15:21,133
它在库里
that's in the libraries

205
00:15:21,166 --> 00:15:24,699
想一下printf是如何实现的
so consider how printf is implemented 

206
00:15:24,800 --> 00:15:32,266
在我们的代码中，输出时调用了
in our code we have this in the printf functionality of 

207
00:15:32,300 --> 00:15:38,566
fprintf "message:%s" stored[idx]
fprintf message column percent s of  the stored index right

208
00:15:40,866 --> 00:15:42,633
printf是如何实现的
how is printf implemented 

209
00:15:42,800 --> 00:15:44,000
你会如何实现它
how would you implement it

210
00:15:44,000 --> 00:15:47,366
你要往一个文件中写入一个字符串
you need to write to some file descriptor a string

211
00:15:47,666 --> 00:15:49,500
但是事先不知道要写入的字符串
but that string isn't known ahead of time

212
00:15:50,033 --> 00:15:53,366
具体来说，事先不知道要写入字符串的长度
the length of the string more specifically isn't known ahead of time

213
00:15:53,533 --> 00:15:55,866
需要先解析要写入的长度
you need to parse the length to write in that 

214
00:15:55,933 --> 00:15:57,533
然后printf会调用write
and then printf will call write

215
00:15:57,600 --> 00:16:00,100
所以它首先需要算出字符串的长度
so it first needs to figure out the length of the string

216
00:16:00,933 --> 00:16:03,333
然后再写入
and then it does the write

217
00:16:04,200 --> 00:16:08,100
你会发现，在我们这个例子中
and you notice something in our kind of strawman example

218
00:16:08,100 --> 00:16:17,500
我们没有对字符串占用的内存加锁
we didn't lock the memory that the string is occupying

219
00:16:17,566 --> 00:16:20,366
也没有办法这样加锁
there is no way to just lock memory like that anyways

220
00:16:20,533 --> 00:16:21,933
如果加锁的话，我们需要一个互斥锁
right we would need a mutex

221
00:16:22,000 --> 00:16:23,566
所有这个字符串的使用者
everyone that uses that string 

222
00:16:24,000 --> 00:16:28,900
都得同意在使用字符串前先上互斥锁
would have to agree that before they touch the string they lock the mutex

223
00:16:28,966 --> 00:16:31,066
printf使用时要上互斥锁、
and then printf would lock the mutex

224
00:16:31,200 --> 00:16:34,066
算长度、写入、解锁
do the length do the write unlock the mutex

225
00:16:34,066 --> 00:16:35,566
这不是不可行
this is not non viable

226
00:16:36,200 --> 00:16:37,133
因为
because

227
00:16:38,000 --> 00:16:39,266
只是开发者一般不会这么做
just developers won't do that

228
00:16:39,266 --> 00:16:40,333
你从没想过
you never think about

229
00:16:40,500 --> 00:16:43,333
哦，printf前我该上个锁
oh I should lock this mutex when I do printf and so forth

230
00:16:43,800 --> 00:16:49,300
实际上，这就是printf
so realistically speaking this is printf

231
00:16:50,566 --> 00:16:52,100
而且我们可以与其竞争
and we can race printf

232
00:16:52,100 --> 00:16:53,166
想象一下
so imagine this

233
00:16:53,300 --> 00:16:57,800
先malloc分配内存
you use the malloc action to allocate memory

234
00:16:58,600 --> 00:17:08,500
再scanf填充大量可打印的非空数据
then you use the scanf action to fill it with some large amount of printable not null data

235
00:17:09,133 --> 00:17:10,966
然后将它打印出来
then when you go to print it out

236
00:17:12,400 --> 00:17:16,800
此时printf会解析它的长度
printf will take its length

237
00:17:17,500 --> 00:17:20,200
当然，你希望在此时竞争成功
and then of course this is where you hope to win the race

238
00:17:20,400 --> 00:17:29,500
需要在strlen之后，write之前，切换到另一个线程
you win the race by having the other thread get scheduled between the strlen and the write 

239
00:17:29,900 --> 00:17:31,533
然后
and then fill the

240
00:17:34,566 --> 00:17:35,966
那叫什么来着
ah what's it called

241
00:17:38,266 --> 00:17:40,866
哦，抱歉，然后在那个线程free它
oh sorry and then free that allocation

242
00:17:41,000 --> 00:17:49,300
free时，libc会写入堆元数据
of course then libc will pthread will write in the pthread metadata when it frees the allocation

243
00:17:49,300 --> 00:17:55,000
write将按原长度，输出free时写入的元数据
and your write will actually write out the pthread metadata of that length

244
00:17:55,400 --> 00:17:59,166
很疯狂，但确实有效
pretty crazy right but it actually works

245
00:17:59,533 --> 00:18:02,000
事实上，这里竞争成功并不困难
in fact this is not a hard race to win

246
00:18:02,000 --> 00:18:03,933
因为write是一个系统调用
because write is a system call

247
00:18:04,500 --> 00:18:09,300
所以这个线程会暂停，然后跳转到内核
and this thread will basically pause to jump into the kernel

248
00:18:09,366 --> 00:18:10,733
内核会做一些检查
the kernel will do some checks

249
00:18:10,733 --> 00:18:12,766
可能还要去执行别的进程或线程
might go execute something else

250
00:18:13,200 --> 00:18:16,700
具体要看调度策略和当时的环境
depending on the scheduling policy and what else has been going on

251
00:18:16,700 --> 00:18:19,800
与此同时，另一个线程在不同的核心上运行
in the meantime this other thread is running on a different core

252
00:18:20,400 --> 00:18:26,866
并释放这个内存
and free that allocation 

253
00:18:27,000 --> 00:18:28,466
而且这里没有互斥锁
and there are no mutexes anywhere

254
00:18:28,866 --> 00:18:31,966
互斥锁是要显式声明的
you know the mutexes are something that you have to do explicitly

255
00:18:32,200 --> 00:18:33,933
我们看看具体该如何利用
let's take a look at how to exploit this 

256
00:18:33,966 --> 00:18:41,733
这是我们这个程序表面的第一个裂缝
this is our first kind of crack in the veneer of this program 

257
00:18:42,033 --> 00:18:45,099
哦，不，我刚刚显示界面有问题
oh no I switched to the wrong thing okay

258
00:18:45,166 --> 00:18:47,500
这个是我刚才在讲的ppt
here's that slide that I was just talking about

259
00:18:48,600 --> 00:18:52,200
刚刚放在右上角了，看起来很小
that was tiny on the top right alright cool

260
00:18:55,066 --> 00:18:57,499
我们继续
let's dive onwards 

261
00:18:57,733 --> 00:19:03,533
现在在终端
so here is our terminal

262
00:19:03,700 --> 00:19:10,000
我创建了这个ult程序
 I created the program as this ult

263
00:19:10,300 --> 00:19:12,033
ult启动了
 so ult is now running 

264
00:19:12,300 --> 00:19:17,266
我可以连接到 localhost 1337
I can connect to localhost 1337 

265
00:19:17,533 --> 00:19:17,966
连上了
and here it is 

266
00:19:18,066 --> 00:19:19,366
它提供了 malloc scanf printf
malloc scanf printf 

267
00:19:19,500 --> 00:19:22,600
我可以malloc 1
I can malloc allocation 1

268
00:19:23,333 --> 00:19:25,333
scanf 1
scanf allocation 1

269
00:19:26,166 --> 00:19:27,433
输入 hello
say hello 

270
00:19:27,600 --> 00:19:29,633
printf  1
printf allocation 1 

271
00:19:29,866 --> 00:19:30,566
输出 hello
and it says hello

272
00:19:30,966 --> 00:19:36,399
这样我们就能，还记得堆的利用技巧吗
so that we， remember our heap trickery

273
00:19:36,700 --> 00:19:38,466
我可以连接
I can connect

274
00:19:39,566 --> 00:19:41,266
重来吧
let's just restart this whole thing

275
00:19:41,766 --> 00:19:42,566
好的
all right

276
00:19:43,366 --> 00:19:44,333
接入
connect up

277
00:19:46,800 --> 00:19:52,900
可以 malloc 0 malloc 1 malloc 2
I can say malloc an allocation 0 malloc an allocation 1 malloc an allocation 2

278
00:19:52,900 --> 00:19:59,600
再 free 0 free 1 free 2
of course I can free allocation 0 free allocation 1 free allocation 2 and now

279
00:19:59,800 --> 00:20:01,933
现在如果我打印的话应该可以
I should be able to if I printf

280
00:20:03,600 --> 00:20:09,500
不好意思，如果我malloc，会拿到最后释放的chunk
oh sorry if I then malloc whatever the last thing that was freed 

281
00:20:09,533 --> 00:20:11,133
所以chunk3的地址是
so allocation 3 is now gonna be

282
00:20:11,733 --> 00:20:13,733
chunk3的地址是
that pointer could be put into allocation

283
00:20:14,500 --> 00:20:20,900
是原来缓存在tcache中的chunk2
the pointer that was in allocation 3 is going to be returned again by tcache to allocation 2

284
00:20:23,100 --> 00:20:24,500
如果我执行printf
if I do printf here

285
00:20:26,100 --> 00:20:28,433
可能是不可显字符（没指定内存，等待输入中）
it's probably not printable

286
00:20:28,766 --> 00:20:30,000
我们这样试一下
so let's do this

287
00:20:36,400 --> 00:20:37,200
退出
let's quit

288
00:20:40,300 --> 00:20:42,733
确实打印了message:
so it did give me message colon

289
00:20:43,466 --> 00:20:44,266
然后
then

290
00:20:44,700 --> 00:20:48,500
3a，不，3a是冒号
3a no 3a is the colon

291
00:20:51,300 --> 00:20:52,266
啊，好了
ah here we go

292
00:20:52,900 --> 00:20:53,766
不是，是空格
nope space

293
00:20:54,533 --> 00:20:55,333
0
zero

294
00:20:56,066 --> 00:20:59,566
啊，是的，这个是30 13
ah yeah here we go 3 0 13

295
00:21:00,266 --> 00:21:02,266
这是泄露地址的最后两字节
that is the last two bytes

296
00:21:02,800 --> 00:21:04,300
我好奇它为什么需要
I wonder why it needed

297
00:21:04,700 --> 00:21:10,400
我们再来一次
let's just do this again

298
00:21:16,900 --> 00:21:18,333
我复制一下
let me copy that

299
00:21:20,666 --> 00:21:22,100
里面包含了一堆换行符
including a bunch of new lines

300
00:21:22,100 --> 00:21:24,133
nc认为它
so that Netcat realizes it's

301
00:21:24,500 --> 00:21:27,500
好了，我们开始吧
okay there we go all right here we go when we say

302
00:21:29,800 --> 00:21:34,600
输出了message:空格
it says message colon space

303
00:21:35,200 --> 00:21:38,133
30 13 换行符
3 0 1 3 new line right 

304
00:21:38,166 --> 00:21:41,166
如果我们少malloc一个
if we have one fewer allocation

305
00:21:42,800 --> 00:21:44,900
末尾的地址应该不同
it'll be a different last bytes

306
00:21:44,966 --> 00:21:48,199
只显示末尾地址，是因为小端序和00阻断了printf
with that null byte as we talked about is screwing us up

307
00:21:53,333 --> 00:21:54,700
还是30 13
still 3 0 1 3

308
00:21:56,300 --> 00:21:57,900
为什么是30 13
why why 3 0 1 3

309
00:22:05,933 --> 00:22:06,766
哦
oops

310
00:22:08,600 --> 00:22:09,400
我的锅
my bad

311
00:22:10,500 --> 00:22:11,900
这应该是printf 3
that should be printf three

312
00:22:21,933 --> 00:22:22,966
我message呢?
where's my message

313
00:22:37,933 --> 00:22:44,266
肯定是io相关缓冲区问题
there's some buffering problem for sure

314
00:22:44,466 --> 00:22:46,366
我们在Python中试试
let's do this in Python

315
00:22:56,600 --> 00:23:06,300
执行malloc 0 malloc 1 free 0 free 1 malloc 3 printf 3 quit
okay we're gonna do malloc 0 malloc 1 free 0 free 1 malloc 3 printf 3 quit

316
00:23:09,000 --> 00:23:14,100
然后打印出所有内容
and then we're going to print everything

317
00:23:14,566 --> 00:23:15,633
好了
all right there we go 

318
00:23:15,700 --> 00:23:19,600
message是0x30 0x13
message is hex 30 Hex 13

319
00:23:20,100 --> 00:23:22,966
如果我们多malloc一个
if we do an additional allocation instead

320
00:23:23,466 --> 00:23:26,166
比方说在一个新连接中
let's say on a new connection

321
00:23:26,500 --> 00:23:30,500
首先在一个新连接上仍然是0x30 0x13
so first of all on a new connection still hex 30 Hex 13

322
00:23:34,400 --> 00:23:36,866
如果我们额外malloc一个
if we do an additional allocation

323
00:23:38,400 --> 00:23:43,300
malloc 2，然后free 2
malloc 2 and then free 2

324
00:23:47,300 --> 00:23:49,300
仍然是0x30 0x13
still Hex 30 Hex 13

325
00:23:58,400 --> 00:24:02,500
按理说应是一个不同的地址
this should be a different tcache address

326
00:24:08,366 --> 00:24:11,233
脱离剧本讲是这样的
this is what happens when we go off a

327
00:24:48,500 --> 00:24:52,800
好吧，我先暂停，搞清楚怎么回事
all right I need to figure out what is going on  rather than keeping you waiting

328
00:24:52,866 --> 00:24:53,800
我马上回来
I'll be right back

329
00:24:55,066 --> 00:24:56,266
我回来了
I'm back okay 

330
00:24:56,400 --> 00:24:59,033
搞清楚了，我去
I figured out what was going on oh man 

331
00:24:59,233 --> 00:25:03,899
messages和所有这些都是全局变量
so the messages and all of this they're stored globally

332
00:25:04,066 --> 00:25:05,433
所以每当我重连时
so when I was reconnecting 

333
00:25:05,566 --> 00:25:10,033
message数组的初始状态都是有数据的
I was starting off with a state of that message buffer

334
00:25:10,200 --> 00:25:12,966
和我期望的不一样
that was not what I was expecting

335
00:25:12,966 --> 00:25:16,766
这是ult的源码
here is the source code of that ult

336
00:25:17,133 --> 00:25:17,933
哎呦
whoops

337
00:25:20,700 --> 00:25:25,400
在新连接中，这些不是我期望的0
this was not null like I was expecting it on a new connection

338
00:25:25,466 --> 00:25:28,900
要注意这些长期运行的多线程服务
keep in mind with these long running threading services

339
00:25:28,900 --> 00:25:32,466
它们的内部状态可能会一直有效
the internal state might persist

340
00:25:32,600 --> 00:25:34,366
既是好事也是坏事
this is a good thing and a bad thing

341
00:25:34,566 --> 00:25:37,566
好的原因是，作为攻击者可以泄漏其中的一部分
it is a good thing because as an attacker you can leak parts of it 

342
00:25:37,733 --> 00:25:43,533
或修改一部分，然后一步一步完成利用
set things up and then actually do step by step exploitation

343
00:25:43,700 --> 00:25:45,866
对攻击者不好的一面是
 as a bad thing as an attacker

344
00:25:46,033 --> 00:25:49,699
因为你可能会忘记，会搞混
is because you can forget and get mixed up 

345
00:25:49,900 --> 00:25:51,400
为了解决这个问题
alright so to fix that

346
00:25:51,700 --> 00:25:54,366
我现在在pwntools脚本中启动它
I'm now launching it in my pwntools script

347
00:25:54,633 --> 00:25:58,200
当你对一个网络上的服务这么做时
when you do this for a service that listens on a network

348
00:25:58,200 --> 00:26:00,133
确保事后清理干净
make sure to clean it up afterwards

349
00:26:00,500 --> 00:26:01,633
你可以这么做
you can do this 

350
00:26:01,733 --> 00:26:07,899
或者可以用pwntools的context实现
or you can have pwntools do it for you using a context

351
00:26:08,100 --> 00:26:09,466
所以不管发生什么
so no matter what happens 

352
00:26:09,533 --> 00:26:12,399
它总是会清理这个进程
it'll now always clean up that process

353
00:26:12,400 --> 00:26:14,500
好，我们启动这个进程
all right so we run that process

354
00:26:14,566 --> 00:26:15,366
接入
we connect to it

355
00:26:15,366 --> 00:26:17,899
然后malloc 2次，free 2次
and then we do 2 allocations 2 frees 

356
00:26:17,966 --> 00:26:20,166
再malloc 1次，输出它
and then we do an allocation and print it out

357
00:26:20,866 --> 00:26:24,766
这是tcache next指针的最后2字节，0x20 0x0f
that is the last two bytes hex 20 hex 0f of the tcache forward pointer

358
00:26:25,400 --> 00:26:32,400
当然我们可以多malloc free 一次
of course we can do free another malloc and free

359
00:26:37,100 --> 00:26:42,333
现在这是next指针的最后2字节，0x30和0x13
now these are the forward last two bytes hex 30 and hex 13

360
00:26:42,533 --> 00:26:46,699
用0x1330-0x0f20，它应该在0x400左右
if you subtract this it should be somewhere around hex 400 

361
00:26:46,833 --> 00:26:51,099
因为我们每次分配1024字节（0x400）
because we're allocating 1024 bytes per allocation

362
00:26:51,600 --> 00:26:56,200
是0x410，因为包括了元数据
hex 410 including the metadata all right

363
00:26:57,100 --> 00:27:00,800
提醒一下，我们本来是要做这个竞争的
so as a reminder we were going to do this race

364
00:27:00,800 --> 00:27:02,133
我们开始竞争吧
so let's do this race

365
00:27:02,300 --> 00:27:10,633
我们在一个线程循环malloc内存，写入数据，释放内存
so we're going to allocate write data into it  and deallocate in one thread in a loop 

366
00:27:10,733 --> 00:27:12,966
在另一个线程中，输出这个内存
and in another thread we'll just print out that allocation

367
00:27:12,966 --> 00:27:14,566
最终会这样
eventually this will happen 

368
00:27:14,600 --> 00:27:15,433
我们会输入数据
we'll input the data 

369
00:27:15,500 --> 00:27:16,866
打印它
we'll trigger the printf

370
00:27:17,566 --> 00:27:19,533
竞争将会发生
the race will happen 

371
00:27:19,600 --> 00:27:21,766
当printf算出长度后
so that the length is calculated

372
00:27:21,766 --> 00:27:23,333
但在要写入到标准输出时
but by the time the write happens

373
00:27:23,333 --> 00:27:25,266
这个内存已经被释放了
that allocation has been freed

374
00:27:25,300 --> 00:27:36,600
这个内存中的数据被换成了，什么来着，tcache元数据
and that location has been replaced by what's it called a tcache metadata

375
00:27:36,766 --> 00:27:40,866
我们启动它
we launch it

376
00:27:41,600 --> 00:27:43,366
我们要用我们的
we're going to use our

377
00:27:43,600 --> 00:27:45,866
当然，你可以更合理地使用多进程
of course you can use multi processing properly

378
00:27:45,866 --> 00:27:47,499
我们不会那样做
we're not going to do that 

379
00:27:47,600 --> 00:27:49,066
我们建立两个连接
we're gonna make two connections

380
00:27:52,400 --> 00:27:59,600
我们要
and in one connection we're going to

381
00:28:05,133 --> 00:28:07,533
我们要fork
we're gonna fork the interpreter

382
00:28:08,700 --> 00:28:11,266
在子进程中
if the result of the fork is the child 

383
00:28:11,566 --> 00:28:17,766
我们要循环
we're going to in a loop 

384
00:28:17,866 --> 00:28:21,133
当然这样输出会很乱
and of course this will be messy and 

385
00:28:21,266 --> 00:28:24,199
好吧，写的好一点
well I'll just do it more properly

386
00:28:24,800 --> 00:28:27,900
循环1000次
say 1000 times 

387
00:28:27,966 --> 00:28:40,066
我们发送malloc 0 scanf 0
we're going to send the line malloc 0 scanf 0 

388
00:28:40,366 --> 00:28:42,799
你想要输出多长的数据
how much do you want to

389
00:28:44,400 --> 00:28:51,700
假设要的是next指针和tcache_perthread_struct指针（key）
let's say if you want the two keywords the next pointer and the per thread struct pointer

390
00:28:51,866 --> 00:28:56,766
输入AAAAAAAABBBBBBBB
AAAAAAAABBBBBBBB

391
00:28:57,133 --> 00:29:03,166
然后我们free 0
and then we want to printf 0 no sorry and then we want to free 0

392
00:29:03,666 --> 00:29:06,699
在另一个线程中，我们一直printf
and in another thread we want to printf all the time

393
00:29:06,933 --> 00:29:11,666
希望printf会从这里开始运行
and the printf will hopefully start running right here

394
00:29:13,900 --> 00:29:19,400
但是不，不好意思
but  no sorry

395
00:29:20,900 --> 00:29:22,933
我们在这里printf
we want printf here

396
00:29:22,933 --> 00:29:24,433
然后在另一个线程中free
then we want the free in another thread

397
00:29:24,566 --> 00:29:25,599
其实我觉得这不重要
actually don't think it matters

398
00:29:25,666 --> 00:29:27,699
因为是竞争嘛
because of the way the race happens

399
00:29:28,200 --> 00:29:31,400
但我们先这么做
but this what we're going to do

400
00:29:31,666 --> 00:29:34,266
然后我们
and then in the and then we'll

401
00:29:35,800 --> 00:29:37,066
记得清理干净
remember to clean up

402
00:29:41,866 --> 00:29:42,666
好吧
okay

403
00:29:43,733 --> 00:29:44,533
稍等
wait

404
00:29:45,366 --> 00:29:46,800
我应该取TID的
I should get TID

405
00:29:48,500 --> 00:29:49,700
哦，我可以得到pid
oh I can get pid

406
00:29:49,700 --> 00:29:51,500
哦，没问题，这是fork
oh no this is forking

407
00:29:51,966 --> 00:29:53,900
然后在父进程中
okay and then in the parent

408
00:29:54,266 --> 00:29:55,200
我们将
we will

409
00:29:55,533 --> 00:29:58,033
这是就是父进程，所以不用else了
well this is the parent so

410
00:29:58,400 --> 00:30:03,200
在父进程中，我们不会干等着
in the parent we will instead sit there 

411
00:30:03,466 --> 00:30:12,199
在另一个线程中free 0
and in the other thread free 0

412
00:30:12,933 --> 00:30:13,766
好吧
all right

413
00:30:15,166 --> 00:30:16,100
然后
and then

414
00:30:19,200 --> 00:30:29,300
我们要看一下输出结果
we're going to see what comes out from these prints

415
00:30:30,566 --> 00:30:31,366
好的
boom

416
00:30:31,533 --> 00:30:34,766
能看到有一大堆AAAA BBBB
alright so you can see we have a bunch of AAAA BBBB

417
00:30:35,266 --> 00:30:37,000
也有一堆NONE
we also have a bunch of NONE

418
00:30:37,666 --> 00:30:39,200
看起来像
where it looks like we

419
00:30:42,000 --> 00:30:47,100
是这样的，free执行在了scanf之后，printf之前
what happened was that the free happened between the scanf and the printf

420
00:30:49,700 --> 00:30:53,200
我想我们在这里free 0，可能会更好
actually I think we'll have better luck if we do free 0 here

421
00:30:54,600 --> 00:30:59,300
然后在这里printf 0
and  printf 0 here

422
00:31:00,166 --> 00:31:00,966
好
okay

423
00:31:03,733 --> 00:31:05,000
好像崩溃了
think it crashed

424
00:31:05,666 --> 00:31:06,466
哦
ops

425
00:31:10,766 --> 00:31:11,566
什么情况
what is going on

426
00:31:17,966 --> 00:31:19,200
为啥什么都没打印
why wasn't printing anything

427
00:31:25,166 --> 00:31:25,966
好吧
okay

428
00:31:26,166 --> 00:31:27,566
哦，它打印了
oh it was printing

429
00:31:28,500 --> 00:31:29,300
在这
this is all again

430
00:31:29,300 --> 00:31:30,400
好吧，好吧，没事
okay okay cool

431
00:31:30,400 --> 00:31:33,300
所以我们需要打印的是r2的输出
so now we need to read of this second thread

432
00:31:33,800 --> 00:31:35,766
我们用malloc scanf free
so we're doing malloc scanf free

433
00:31:36,300 --> 00:31:37,600
然后在另一个线程printf
and then we're doing printf

434
00:31:37,733 --> 00:31:39,733
我们希望在这里切换到printf
we're hoping to hit the printf right here

435
00:31:39,900 --> 00:31:44,000
这样它会在free后再write
 so it write during the free

436
00:31:45,900 --> 00:31:53,600
这样它先解析出字符串的长度，然后free执行了
so that it first  calculates the string then the free happens 

437
00:31:53,700 --> 00:31:55,266
最后输出
and then it prints it out

438
00:31:56,266 --> 00:31:57,700
好了
so here it is again

439
00:31:58,533 --> 00:31:59,933
我们没竞争成功
we didn't win the race there

440
00:32:00,700 --> 00:32:02,766
可能循环次数还不够
this might just be not be enough

441
00:32:07,400 --> 00:32:11,200
如果分成几行，我们可以更容易地打印出来
we can actually print this out easier if we split into lines

442
00:32:11,533 --> 00:32:14,766
再用set去重
and then just compute the set of unique ones

443
00:32:15,466 --> 00:32:16,366
结果出来了
and here it is 

444
00:32:16,400 --> 00:32:19,600
这是我们得到的所有东西
so here is all of the things that we got 

445
00:32:19,700 --> 00:32:21,000
有MESSAGE: AAAAAAA
we got message aaaaa

446
00:32:21,133 --> 00:32:22,366
有点奇怪
that's a weird one

447
00:32:22,500 --> 00:32:24,900
所以这里可能是
so probably or possibly what's happening here is 

448
00:32:25,066 --> 00:32:26,299
在strlen的时候
during the strlen the 

449
00:32:26,700 --> 00:32:32,366
好吧，没想到一个好的原因
yeah this one I don't have a good explanation for it

450
00:32:32,466 --> 00:32:39,200
这条message是我们想要的
here we have a message are the exact thing we're looking for which is

451
00:32:39,466 --> 00:32:42,266
strlen解析出长度是16字节
we have we did the strlen of 16 bytes

452
00:32:42,266 --> 00:32:44,200
然后输出了16字节
and then we wrote out 16 bytes

453
00:32:44,500 --> 00:32:48,500
当然，第一个QWORD（8字节）是null
then of course the first QWORD is null

454
00:32:48,500 --> 00:32:50,166
因为这是第一个free的（next为null）
because that's the first allocation that was freed

455
00:32:50,266 --> 00:32:52,066
tcache中在他面前什么也没有
there's nothing in tcache before him

456
00:32:52,200 --> 00:32:56,400
另一个qword是一个指向线程arena的指针
and then the next one is a pointer to somewhere inside the tcache arena

457
00:32:56,400 --> 00:33:01,500
tcache_perthread_struct存储在该arena
the tcache perthread_struct lives in that tcache arena

458
00:33:06,933 --> 00:33:07,733
在吗？
does it

459
00:33:08,800 --> 00:33:12,100
不，它应该在进程的线程本地存储中
no this should be in the thread local storage of the process

460
00:33:15,600 --> 00:33:21,800
还有一个消息，和这个略微不同
we have other garbage another thing with a slightly different 

461
00:33:21,966 --> 00:33:29,599
它看起来像指针，DCS 7f
it looks like pointer DCS 7f

462
00:33:29,700 --> 00:33:34,533
由于某种原因，这只打印了15字节而不是16字节
oh yeah this only printed 15 instead of 16 bytes for some reason 

463
00:33:34,666 --> 00:33:35,833
但我们已经可以泄露了
 but we have our leak

464
00:33:37,300 --> 00:33:42,000
我们试着和ppt匹配一下
so I would say let's do this matches closer to the slides

465
00:33:42,900 --> 00:33:45,266
如果我们malloc scanf printf
if we do malloc scanf printf 

466
00:33:45,566 --> 00:33:46,933
然后在另一个线程中free
then we do the free in the other one

467
00:33:51,000 --> 00:33:53,166
哦，对了，该输出 r1的
oh and then we read r1

468
00:33:56,866 --> 00:33:58,100
哦，这行不通
oh but that doesn't work

469
00:33:59,333 --> 00:34:01,733
我应该调整一下幻灯片
I should actually adjust the slides 

470
00:34:02,000 --> 00:34:06,833
就应该在一个循环中malloc scanf free
because this is the way to do it malloc scanf free in a loop

471
00:34:07,033 --> 00:34:09,866
这样做才有意义
doing stuff that that makes sense

472
00:34:10,700 --> 00:34:15,300
然后我们希望能在这两者之间进行打印
and then the printf we hope to get running right between there

473
00:34:19,333 --> 00:34:20,733
好吧
boom all right

474
00:34:20,900 --> 00:34:23,066
现在我们泄露出了
so now we have leaked out

475
00:34:27,566 --> 00:34:34,699
指向线程tcache_perthread_struct对象的指针
a pointer somewhere in memory to the tcache per thread struct of that thread

476
00:34:35,100 --> 00:34:38,700
这是件大事，非常令人兴奋
right this is huge and very exciting

477
00:34:38,700 --> 00:34:47,500
顺便说一下，我认为它在arena中
I actually do think that this is allocated in the memory space of that arena by the way

478
00:34:50,766 --> 00:34:54,866
现在我们有了线程特定的arena的地址
and now we have a thread specific arena address

479
00:34:55,700 --> 00:34:56,733
很酷
very awesome 

480
00:34:56,866 --> 00:35:02,499
接下来，我们将讨论如何利用这个地址
so moving on we'll talk about what we'll do with that address

481
00:35:02,600 --> 00:35:04,766
既然现在我们知道内存中的某个东西在哪里了
now that we know where something in memory is

482
00:35:04,800 --> 00:35:09,200
我们就可以开始尝试重叠chunk和各种好东西了
of course now we can start overlapping allocations and all sorts of good stuff

483
00:35:09,200 --> 00:35:12,100
因为我们知道要在哪里重叠了
because we know where to overlap them into 

484
00:35:12,600 --> 00:35:13,900
请继续关注
stay tuned

