1
00:00:00,700 --> 00:00:08,500
黑客们好，欢迎观看高级漏洞利用模块的视频
hello hackers welcome to another video in the Advanced Exploitation Module

2
00:00:09,333 --> 00:00:11,633
我们将讨论内存取证
we're going to be talking about memory forensics

3
00:00:11,800 --> 00:00:12,733
基本就是
so really just the concept 

4
00:00:12,866 --> 00:00:17,000
内存里有用的东西在哪里
that hey once you know where something is in memory

5
00:00:17,200 --> 00:00:23,800
哪里有能用于下一步行动的内存
where there's valid memory you can actually use that as a building block for your next steps

6
00:00:25,400 --> 00:00:27,366
我们尝试围绕这一个概念
we're gonna try to cover one concept 

7
00:00:27,433 --> 00:00:28,433
就这一个主题
just that concept

8
00:00:28,766 --> 00:00:30,133
在GDB中探索答案
crawl around in GDB a little

9
00:00:30,466 --> 00:00:31,866
内容就这么多
and call it a day for the video 

10
00:00:32,200 --> 00:00:39,200
我们讨论的还是同一个多线程消息服务器
as a reminder we're still talking about the same threading message server

11
00:00:39,300 --> 00:00:42,833
在这个服务中可以接入、留言、检索留言
where you can connect in leave messages retrieve messages 

12
00:00:43,033 --> 00:00:47,300
在单线程场景，它有安全地使用堆
and it uses the heap safely in a single threaded scenario

13
00:00:47,433 --> 00:00:51,100
但在多线程场景中有问题
 but with multiple threads problems occur

14
00:00:51,266 --> 00:00:52,066
好吧
all right

15
00:00:52,366 --> 00:00:53,900
再次提醒大家
and as a reminder again

16
00:00:54,600 --> 00:01:01,766
在上集，我们泄露出了tcache_perthread_struct的地址
we in the last video leaked the address of actually the per thread struct 

17
00:01:01,833 --> 00:01:10,700
它位于进程里相关线程的arena中
which is in the thread specific arena of that process so

18
00:01:11,366 --> 00:01:13,366
我把那个脚本整理了一下
I cleaned up that script a little bit

19
00:01:14,266 --> 00:01:15,533
要指出几点
a couple of things I'll point out 

20
00:01:15,700 --> 00:01:19,700
一是我现在在GDB中启动服务进程
one is i am now launch the process in GDB

21
00:01:20,766 --> 00:01:24,166
抱歉，我先启动进程，再用GDB附加到它
sorry I launch the process and then attached to it with GDB

22
00:01:24,333 --> 00:01:28,533
这样方便我们进行内存取证
 this is so that we can later do memory forensics 

23
00:01:28,666 --> 00:01:31,100
并在泄露出地址后探索内存
and crawl around memory when you leak some addresses

24
00:01:32,733 --> 00:01:33,600
有几个问题
a couple of gotches 

25
00:01:33,733 --> 00:01:40,966
我先前，先建立连接，再附加进程，经常出问题
I have had very bad luck attaching with GDB after attaching over the network

26
00:01:42,000 --> 00:01:49,200
gdb附加后会中断其它线程的read系统调用
that GDB attached tends to interrupt the read system call of whatever thread is reading

27
00:01:49,366 --> 00:01:52,633
这导致了问题，所以我现在这样做
it causes havoc so what I tend to do now is 

28
00:01:52,800 --> 00:01:55,966
（口误）
I attaching GDB and I sorry 

29
00:01:56,200 --> 00:01:57,266
我先启动进程
I launched the process 

30
00:01:57,366 --> 00:01:58,333
用GDB附加进程
I attached GDB 

31
00:01:58,466 --> 00:02:01,500
gdb附加进程需要些时间
now this takes some time attaching GDB

32
00:02:01,900 --> 00:02:07,100
它会中断程序，直到运行了这个continue
and then of course it interrupts the program and until this continue can run

33
00:02:09,266 --> 00:02:11,966
脚本中可能存在竞争条件
you might have a race condition in your script

34
00:02:12,133 --> 00:02:16,333
可能你尝试连接的进程正处于挂起状态
where you will try to connect to a process that is currently hung

35
00:02:17,933 --> 00:02:20,766
它目前被gdb挂起
that's currently suspended by GDB and

36
00:02:22,500 --> 00:02:26,900
为了解决它，我在这里加了个sleep
to get around that I have a sleep here all right

37
00:02:26,933 --> 00:02:28,466
但攻击方式是一样的
so but the attack is the same

38
00:02:28,600 --> 00:02:31,566
我在后台建立两个连接
I connect with two connections in the background 

39
00:02:31,666 --> 00:02:36,166
在一个线程中，发送1万次malloc和free
on one I send 10,000 allocation and free loops

40
00:02:36,366 --> 00:02:42,066
在主线程中发送大量printf
in the other one, the main thread, I send a bunch of prints

41
00:02:42,300 --> 00:02:46,500
然后展示结果
and then I read the the result

42
00:02:46,566 --> 00:02:48,900
竞争条件发生在printf中
and of course we had that race condition in printf

43
00:02:48,900 --> 00:02:57,000
通过它，泄露了指向tcache_perthread_struct的key指针
through which we leak out the key pointer back to the perthread struct in tcache

44
00:02:57,600 --> 00:03:03,200
这样就完成了一个泄露
and with that we can get a leak so

45
00:03:03,400 --> 00:03:05,466
我会展示一下这个泄露过程
I'm going to show you this leak 

46
00:03:05,633 --> 00:03:07,700
然后展示能通过泄露的地址挖掘出什么
and then show you what we can dig around for

47
00:03:07,866 --> 00:03:09,266
这是GDP在启动
that's GDP starting up

48
00:03:10,800 --> 00:03:12,766
这次失败了，没关系
and it failed this time that's fine

49
00:03:12,766 --> 00:03:14,800
竞态条件并不能总成功
the race condition doesn't always succeed

50
00:03:16,366 --> 00:03:20,500
成了，现在有了这个地址
boom so now we have a leak at this location 

51
00:03:20,600 --> 00:03:27,100
这应该是r1对应线程的tcache_perthread_struct
this is the per thread struct of most likely thread 1

52
00:03:27,300 --> 00:03:29,766
因为是在这个循环中malloc的
because that's what's doing this looping

53
00:03:29,933 --> 00:03:33,733
好吧，那我们能
all right so what can we

54
00:03:35,133 --> 00:03:36,566
我们能从此通向何处
where can we go from there

55
00:03:36,900 --> 00:03:41,066
好吧，当我们找到一个地址
all right the key thing is once we have one address

56
00:03:41,766 --> 00:03:44,500
我们来到小白板前思考
we go back to drawing board and figure out

57
00:03:45,100 --> 00:03:47,166
我们还能从中得到什么呢
what else can we get from that

58
00:03:47,500 --> 00:03:50,733
要利用所有可用的信息
so use all of the information that's available 

59
00:03:50,800 --> 00:03:51,700
如果你有
if you have

60
00:03:52,200 --> 00:03:53,900
现在你知道的是
right now what you know is

61
00:03:54,600 --> 00:04:00,900
有个合法内存在这个指针指向的地址
there is valid memory at the page pointed to here

62
00:04:00,966 --> 00:04:04,000
你还知道该内存页有写权限
you also know there's writable memory at that page

63
00:04:04,000 --> 00:04:07,400
tcache_perthread_struct肯定是可写的
the per thread struct of course is writable 

64
00:04:07,500 --> 00:04:08,633
它要修改
it has to change

65
00:04:08,700 --> 00:04:15,700
它有指向各个bin的指针等之类的变量
it has the pointers forward for the individual bins to the free allocations and so forth

66
00:04:15,766 --> 00:04:18,500
它是可写的，而你现在知道了它的位置
it is writable and you now know where it is

67
00:04:18,900 --> 00:04:24,900
而且你清楚这一整个内存页都是可写的
and you know that this whole page is full of writable memory

68
00:04:24,966 --> 00:04:26,266
对，这很酷
right so that's very cool

69
00:04:28,100 --> 00:04:35,433
有了这个地址，现在能在gdb中查看
given that you can now check in GDB for

70
00:04:35,733 --> 00:04:36,433
当然
and of course 

71
00:04:36,533 --> 00:04:43,100
在调试器中，我们可以暂停攻击目标
 we have the awesome capability of being able to stop what thing we're attacking in the debugger

72
00:04:43,100 --> 00:04:44,500
但我们并非总能这样
you don't always have this capability 

73
00:04:44,633 --> 00:04:46,833
可能攻击的是个远程目标之类的
you might be attacking a remote target or whatever

74
00:04:47,100 --> 00:04:51,100
但现在我们能查看这里还有什么
but we can actually check hey what else is there right 

75
00:04:54,266 --> 00:04:57,000
知道了它，是否能立马知道些其它地址
by knowing this address do we know any other addresses right away

76
00:04:57,266 --> 00:05:00,000
有些地址间是有固定偏移量的
some addresses are at a constant offset

77
00:05:02,700 --> 00:05:09,633
当知道了这些地址，又是否能立马知道些有用数据
and by knowing these addresses do we know the locations of interesting data

78
00:05:09,733 --> 00:05:11,433
我们看个例子
so let's take a look for example

79
00:05:11,533 --> 00:05:12,600
好的
all right

80
00:05:13,366 --> 00:05:14,800
我们有了这个地址
so we have this address

81
00:05:15,166 --> 00:05:17,166
tcache_perthread_struct的地址
this is the per thread struct

82
00:05:17,800 --> 00:05:21,133
中断ult
let's break here 

83
00:05:21,333 --> 00:05:22,766
很简单，只需Ctrl C
simple just Ctrl C

84
00:05:24,400 --> 00:05:25,766

info threads

85
00:05:27,933 --> 00:05:30,700
有三个线程，都共享内存
we have three threads but they all share memory

86
00:05:30,700 --> 00:05:31,800
我们来看一下
so let's just take a look

87
00:05:31,800 --> 00:05:32,600
好吧
all right

88
00:05:32,966 --> 00:05:35,066
这是我们刚刚泄露的地址
this is what we just leaked

89
00:05:35,700 --> 00:05:42,100
它是这里某个线程的tcache_perthread_struct的地址
it is the per thread struct location of one of these threads

90
00:05:43,300 --> 00:05:47,500
我们看看在这个内存页还有什么
let's take a look at what else is in that page

91
00:05:48,200 --> 00:05:53,300
一个内存页有512个qwords（4k）
so page contains 512 qwords

92
00:05:54,800 --> 00:05:56,166
把内存页的偏移清零
let's 0 out that page (offset)

93
00:05:56,333 --> 00:05:58,766
这里有很多东西
boom a lot of stuff in that page

94
00:05:58,900 --> 00:06:02,366
很多都是指向自身的指针
so a lot of it is pointers back to basically itself

95
00:06:02,500 --> 00:06:09,866
这可能是另一种结构
so this is probably some some other structure 

96
00:06:09,900 --> 00:06:12,566
也许和arena有关，这是一些
maybe something to do with arena this is some

97
00:06:14,300 --> 00:06:15,100
让我们看看
let's see

98
00:06:15,666 --> 00:06:17,066
我还真不知道
I mean I honestly don't know

99
00:06:19,133 --> 00:06:20,900
有一个
there is

100
00:06:21,333 --> 00:06:23,966
我们要找到是一个有趣的不太一样的
what we're looking for is interesting looking things

101
00:06:23,966 --> 00:06:26,900
这个看起来很有趣，对吧
this looks like an interesting thing right

102
00:06:27,033 --> 00:06:29,200
我们要找到是
and of course what we're looking for here 

103
00:06:29,300 --> 00:06:35,500
还记的在arena元数据中（malloc_state）
as you recall in the thread metadata

104
00:06:35,500 --> 00:06:38,566
有个指针能间接或直接指向main_arena（环形单链表）
all arenas have a pointer back to the main arena

105
00:06:38,966 --> 00:06:42,766
我打赌这个指针在这
and here I bet is this pointer at this location

106
00:06:43,400 --> 00:06:44,200
看一看
take a look

107
00:06:48,866 --> 00:06:52,866
为啥它没解析出在libc中的符号
why is it not presolving the symbol in libc

108
00:06:52,966 --> 00:06:56,200
总之，它是我们要找到。信我的
anyways that's what it is you'll have to take my word for it

109
00:06:57,133 --> 00:06:57,933
如果我们
if we

110
00:07:00,400 --> 00:07:03,600
稍等，我用另一种方式启动看看
I'll launch this a different way in a second to take a look

111
00:07:03,600 --> 00:07:08,100
很奇怪，它竟然没解析出来
but it's really weird that it's not resolving the symbol

112
00:07:08,266 --> 00:07:11,466
你要是用info proc map看一下
but if you look at info proc map

113
00:07:12,133 --> 00:07:15,300
这个7f9d800
this 7 f 9 9 d 8 0

114
00:07:16,366 --> 00:07:20,100
不，抱歉，这个 7f99dc5e
no sorry 7 f 9 9 d d c 5 e

115
00:07:20,533 --> 00:07:26,400
7f99dc5e在这里，就在libc中
7 f 9 9 d d c 5 e is right here in libc

116
00:07:26,866 --> 00:07:29,500
就在libc的最后一个映射中
in the last mapping of libc which is

117
00:07:30,166 --> 00:07:32,333
我们换个方法看看
if we actually look at a different way

118
00:07:33,100 --> 00:07:37,200
或者你装了能查看map的gdb插件
or if you have a GDB plugin installed that gives you permissions

119
00:07:37,933 --> 00:07:40,066
libc的最后一个映射页 是可写的
the last mapping libc is writable

120
00:07:40,100 --> 00:07:43,800
这肯定是main_arena的元数据
and this is of course the main arena metadata

121
00:07:44,366 --> 00:07:46,500
我换种方式重启它
let me restart this in a different way

122
00:07:48,266 --> 00:07:50,866
不在这里重启它了，而是
so instead of restarting it here we're just going to

123
00:07:50,866 --> 00:07:53,766
我直接在gdb启动ult
I'm just gonna launch it ult in GDB here 

124
00:07:56,333 --> 00:07:56,966
运行
run

125
00:07:57,733 --> 00:07:58,533
好
boom

126
00:08:01,600 --> 00:08:03,933
竞争失败，重来
we lost the race let's restart it

127
00:08:05,733 --> 00:08:06,066
好
boom

128
00:08:06,066 --> 00:08:06,766
竞争成功
we won the race 

129
00:08:06,866 --> 00:08:09,433
好的，这是泄露的地址
all right here's the address

130
00:08:09,600 --> 00:08:15,200
现在它指向8d0，而890就指向main_arena
now it goes to 8d0 and 890 is the main arena pointer

131
00:08:15,366 --> 00:08:18,100
这并不令人意外
that isn't a surprise

132
00:08:20,933 --> 00:08:21,733
稍等
wait

133
00:08:23,600 --> 00:08:24,966
有东西在后台运行
something's running in the background

134
00:08:26,133 --> 00:08:27,333
没
that wasn't okay

135
00:08:28,900 --> 00:08:29,700
好吧
okay

136
00:08:32,266 --> 00:08:33,600
我一直没启动这个
I never started this one

137
00:08:34,566 --> 00:08:35,366
运行
run

138
00:08:36,166 --> 00:08:39,100
攻击，竞争成功
attack win the race okay

139
00:08:39,300 --> 00:08:43,100
当然了我们在GDB上，所以禁用了随机化
oh and of course we are on the GDB so it disabled randomization

140
00:08:43,700 --> 00:08:46,200
我们看一下这里
so let's take a look here

141
00:08:46,866 --> 00:08:48,533
0 好
0 boom

142
00:08:51,133 --> 00:08:53,866
线程arena内存页到next指针的偏移量是890
oh sorry 890 was the offset

143
00:08:54,933 --> 00:08:55,733
什么鬼
what the hell

144
00:09:01,200 --> 00:09:03,133
就在我开始录制这个视频前
up until I started recording this video

145
00:09:03,133 --> 00:09:04,466
GDB还在告诉我
GDB was happily telling me that

146
00:09:04,466 --> 00:09:06,066
这是个main_arena指针
that's the main arena pointer

147
00:09:07,600 --> 00:09:09,533
哦,抱歉
oh sorry

148
00:09:11,733 --> 00:09:13,566
看到没，这是main_arena
there that's the main arena

149
00:09:13,966 --> 00:09:16,333
好吧，之前的方式也能看到
okay and we'll of course see the same thing

150
00:09:16,933 --> 00:09:22,200
看，这就是现场演示的诅咒
see this is the live demo curse

151
00:09:22,300 --> 00:09:23,800
好了，我们开始
 all right there we go

152
00:09:25,133 --> 00:09:26,666
我们泄露了地址
we leaked the thing

153
00:09:26,900 --> 00:09:29,300
我们重做一遍，暂停它
let's just redo this here okay kill it

154
00:09:29,866 --> 00:09:32,200
这里是tcache_perthread_struct
here's the perthread struct

155
00:09:33,800 --> 00:09:40,000
这里是  额
here is that main arena handler header thing metadata

156
00:09:40,133 --> 00:09:44,700
线程arena的arena元数据中的一个指向main_arena的指针
the arena metadata for a thread arena with a pointer to the main arena

157
00:09:44,766 --> 00:09:46,866
现在这个是main_arena
and here we go is the main arena

158
00:09:47,666 --> 00:09:50,000
终于讲清了，酷
whoo okay cool

159
00:09:50,600 --> 00:09:51,866
那么还有什么
so then what else

160
00:09:52,400 --> 00:09:56,600
还有从这里到别处的已知偏移量吗
are there known offsets from here to other places in memory

161
00:09:59,533 --> 00:10:02,533
现在我们知道了这个内存页
we again know this address or know this page

162
00:10:03,266 --> 00:10:04,066
我们来看看
so let's see 

163
00:10:06,933 --> 00:10:08,233
还有其他的页面
there is other pages 

164
00:10:08,366 --> 00:10:14,433
这片内存大小是0x21000
so this guy is hex 2 1 0 0 0 in size 

165
00:10:14,500 --> 00:10:15,533
它们看起来像
they are look like

166
00:10:16,600 --> 00:10:18,733
看起来他们是其它线程的
it looks like they are other

167
00:10:19,366 --> 00:10:21,133
这是，我们看看
so this is let's see

168
00:10:21,866 --> 00:10:24,966
这可能是第一个线程的栈
this is probably the stack of that first thread

169
00:10:25,266 --> 00:10:27,466
这是第一个线程的堆
this is the heap of that first thread

170
00:10:28,100 --> 00:10:33,700
准确的讲，它是一个堆区，主要给这个线程用
uh it's a heap region that was allocated for that thread's primary use

171
00:10:34,133 --> 00:10:36,066
这是第二个线程的栈
this is the stack of the second thread

172
00:10:36,666 --> 00:10:37,666
给第二个线程用的堆区
heap for the second thread

173
00:10:37,833 --> 00:10:47,600
很明显，两者之间有一个固定偏移值
and it looks like obviously there is a constant offset between the two

174
00:10:47,733 --> 00:10:51,100
所以仅通过泄露一个tcache_perthread_struct
so already we know where just by leaking one per thread pointer

175
00:10:51,133 --> 00:10:52,500
就知道了所有线程的它的地址
we know where all the threads are

176
00:10:52,566 --> 00:10:55,300
有到libc基址的固定偏移吗
is there a constant offset to libc

177
00:10:55,600 --> 00:10:57,566
我们已经知道了一个libc中的地址
right we know the location of a libc pointer

178
00:10:57,566 --> 00:10:59,933
但从中提取出libc基址有点困难
but it's a little tricky to extract that

179
00:10:59,933 --> 00:11:01,266
我们可以，也会这样做
we can and we will

180
00:11:01,400 --> 00:11:03,600
但我们先来确认一下
but let's first confirm that 

181
00:11:03,766 --> 00:11:07,100
它到libc的距离不是恒定的
the distance to libc is not constant

182
00:11:18,800 --> 00:11:21,100
或者是恒定的
or it is constant

183
00:11:25,100 --> 00:11:27,333
好吧，我觉得是
okay so I believe actually it is

184
00:11:27,333 --> 00:11:29,200
是的，它当然是常数
yeah of course it is constant

185
00:11:31,200 --> 00:11:35,700
知道了perthread_struct的地址，也就知道了libc的地址
so by knowing where the per thread struct is we also know where libc is

186
00:11:35,700 --> 00:11:39,700
我们甚至不需要这个
so we don't even necessarily need this guy

187
00:11:39,700 --> 00:11:45,900
这个偏移量，多次执行也不会变
we have this offset that will hold over multiple executions

188
00:11:49,400 --> 00:11:51,366
好的，现在泄露出的地址变了
okay now we have a different address

189
00:12:01,533 --> 00:12:02,766
和哦
and oops

190
00:12:12,466 --> 00:12:13,533
偏移量会变
it doesn't hold

191
00:12:14,300 --> 00:12:15,100
这是正确的
that's right

192
00:12:17,700 --> 00:12:22,166
libc是映射到进程的
so libc is mapped

193
00:12:22,366 --> 00:12:24,900
在这个映射过程中有一些抖动
 there's some jitter that happens in this mapping

194
00:12:24,966 --> 00:12:26,100
不是特别大的抖动
not a lot of jitter

195
00:12:26,700 --> 00:12:31,000
事实上，这应该挺容易暴破
in fact probably that's easily bruteforceable

196
00:12:31,900 --> 00:12:36,600
也可能是因为
it might also actually be the fact that

197
00:12:38,600 --> 00:12:39,866
我们泄露的
we leaked

198
00:12:41,200 --> 00:12:42,966
这里是怎么竞争的来着
how does that race condition work

199
00:12:43,300 --> 00:12:44,866
会不会是我们泄漏错了
can we have leaked the wrong

200
00:12:45,366 --> 00:12:46,833
我们再试第三次
let's try it again a third time 

201
00:12:46,933 --> 00:12:48,266
看看结果怎么样
and see what the result is

202
00:12:49,700 --> 00:12:50,766
竞争失败了
that one failed

203
00:12:54,100 --> 00:13:00,200
尝试第四次
let's try the fourth time

204
00:13:01,466 --> 00:13:02,266
好吧
okay

205
00:13:03,700 --> 00:13:05,466
这是tcache_perthread_struct的地址
that is the perthread struct

206
00:13:10,900 --> 00:13:13,133
用第一个基址减它
Scrab the first

207
00:13:25,100 --> 00:13:33,400
所以libc基址与泄露地址的偏移不是固定的
so there is jitter between the base of libc and the base of our thread struct

208
00:13:33,533 --> 00:13:35,900
事实上偏移量变化不大
not a lot of jitter in fact

209
00:13:38,100 --> 00:13:41,900
看起来最差的情况变的只有2字节
it looks like only really two bytes of jitter at worse

210
00:13:41,900 --> 00:13:44,000
我们试个6万次
we tried this 60 000 times and

211
00:13:44,200 --> 00:13:46,133
如果幸运的话，能试出来
and we eventually get lucky with an offset 

212
00:13:46,300 --> 00:13:47,966
现在我们知道了libc基址
now we know libc 

213
00:13:48,066 --> 00:13:53,500
现在我们有一定概率知道libc基址
so let's say for now we know libc with a probability though a libc address

214
00:13:53,600 --> 00:13:59,000
一个相当高的概率
with a probability of fairly high right

215
00:14:02,866 --> 00:14:04,666
或者说六万分之一
or one out of 60,000

216
00:14:04,833 --> 00:14:08,633
看你对高的定义，它可以是高的
so depending on your definition of high this can be high

217
00:14:08,666 --> 00:14:09,666
也可能不是
it might not be

218
00:14:09,666 --> 00:14:10,466
好吧
all right

219
00:14:10,900 --> 00:14:12,333
这对我们有什么帮助
how does that help us 

220
00:14:12,533 --> 00:14:16,866
当然，我们马上就能看到
of course right away we see that 

221
00:14:17,000 --> 00:14:20,333
因为这里有缓冲区溢出
because there's a buffer overflow here

222
00:14:21,000 --> 00:14:22,966
知道libc基址，我们就能rop
knowing libc will allow us to rop

223
00:14:22,966 --> 00:14:24,733
只要我们找出金丝雀
as soon as we find out the canary

224
00:14:25,000 --> 00:14:27,266
我们还需要知道什么才能找到金丝雀
what else do we need to know to find the canary

225
00:14:27,266 --> 00:14:28,066
我们需要知道
we need to know

226
00:14:32,533 --> 00:14:35,600
比如，返回地址在哪里
where the return address is for example 

227
00:14:35,800 --> 00:14:40,433
我们需要一个，抱歉
we need a sorry

228
00:14:41,333 --> 00:14:43,466
要在不破坏金丝雀的情况下溢出
to do the overflow and not trip the canary

229
00:14:43,566 --> 00:14:44,466
我们需要知道金丝雀
we need to know the canary

230
00:14:44,466 --> 00:14:45,700
这样能用原值覆盖它
so that we can write in the canary

231
00:14:45,700 --> 00:14:51,100
或者我们要做一些其他的事，来跳过金丝雀
or we need to do some other thing to skip over the canary

232
00:14:51,100 --> 00:14:52,966
所以不管怎样，重点是
so anyways the point is

233
00:14:53,900 --> 00:15:01,600
我们已经大致知道libc在哪里
already we know where to some probability where libc is

234
00:15:02,200 --> 00:15:04,166
我们知道了其他线程结构在哪里
we know where other thread structs are

235
00:15:04,400 --> 00:15:07,266
我们知道了一个指向libc的指针的位置
and we know where a pointer to libc is

236
00:15:07,366 --> 00:15:10,866
我们泄露了一个指向tcache_perthread_struct的指针
we have leaked a pointer to the per thread struct

237
00:15:12,900 --> 00:15:22,500
在它前面一点，就是指向libc中main_arena的指针
and again a little before that is a pointer back to the main arena of libc

238
00:15:22,533 --> 00:15:26,700
接下来我们要关注能通过它泄露出什么
so that is what then we can then focus on to leak next

239
00:15:28,300 --> 00:15:31,700
这样我们就能百分百知晓libc基址
so that we know libc with complete certainty

240
00:15:31,700 --> 00:15:34,800
所以我要在这里结束这个视频
so I'm going to end this video here 

241
00:15:35,000 --> 00:15:37,733
在下一集视频中，我们会搞清楚
in the next video we are going to figure out

242
00:15:37,900 --> 00:15:45,200
当知道这个地址后，我们该如何动这里的值
how to get our hands on the value at this address when we know the address

