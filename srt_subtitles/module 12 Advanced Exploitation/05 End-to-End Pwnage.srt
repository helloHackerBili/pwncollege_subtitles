1
00:00:00,700 --> 00:00:02,300
你好黑客
hello hackers

2
00:00:02,666 --> 00:00:06,499
欢迎回到高级漏洞利用模块
welcome back to the Advanced Exploitation Module

3
00:00:06,533 --> 00:00:08,533
在这个视频中，我们将讨论
in this video we're going to be talking about

4
00:00:08,666 --> 00:00:12,066
针对这个例子的完整利用过程
end to end pwnage of our motivating example 

5
00:00:12,233 --> 00:00:15,233
一个多线程消息存储服务
a multi threaded message storing service 

6
00:00:15,366 --> 00:00:18,799
我们在前4个视频中已经把它讲透了
that in the last four videos we have thoroughly dumped

7
00:00:19,300 --> 00:00:21,700
目前情况如下
so status report

8
00:00:22,600 --> 00:00:25,466
已知线程arena位置
we know where the thread specific arena is

9
00:00:25,633 --> 00:00:26,799
哦，稍等
oh and hold on

10
00:00:26,800 --> 00:00:29,100
我忘了标libc位置
I forgot to mark off where libc is 

11
00:00:29,166 --> 00:00:30,333
实际上，马上会讲到
actually let's get to that

12
00:00:30,366 --> 00:00:32,366
我们已知线程arena地址
we know where the thread specific arena is

13
00:00:33,400 --> 00:00:35,066
而且我们有以下能力
and we have the follow capabilities

14
00:00:35,166 --> 00:00:39,666
可以泄露连接线程tcache_perthread_struct地址
we have the tcache perthread struct address disclosure for our connection thread

15
00:00:39,866 --> 00:00:42,466
这让我们得到了这个
that got us this

16
00:00:42,500 --> 00:00:46,500
还有我们前面讲的任意读和任意写
we have an arbitrary read and an arbitrary write that we've gone over previously

17
00:00:47,100 --> 00:00:50,700
我们开始利用吧
so let's make things happen

18
00:00:51,166 --> 00:00:52,866
我们要做这些
here's what we're going to do

19
00:00:52,966 --> 00:00:55,499
首先要获取信息
first we're going to get all of our knowledge

20
00:00:55,700 --> 00:00:59,200
这是上个视频中的脚本
this is the script from the last video

21
00:00:59,433 --> 00:01:07,499
我们要尽可能的获取这些待搜集信息
you're going to get all the knowledge we want as much of these check marks as we can

22
00:01:08,033 --> 00:01:12,899
先看看要泄露或计算的变量
let's take a look at what variable to leak and compute first

23
00:01:15,400 --> 00:01:19,700
我们用这个竞争条件泄露出了perthread_struct地址
so we leaked the perthread struct using that awesome race condition

24
00:01:20,100 --> 00:01:29,433
基于它计算出了线程arena中指向main_arena的指针
we computed based on that where a pointer to the main arena is stored on the thread's arena metadata 

25
00:01:29,600 --> 00:01:36,566
并用另一个竞争条件，实现了任意读
and using our race condition in a different way we got an arbitrary read

26
00:01:36,933 --> 00:01:43,166
泄露出了main_arena地址
to leak out the main arena address itself 

27
00:01:43,300 --> 00:01:44,400
这是什么地址呢
what the hell is this address

28
00:01:44,533 --> 00:01:46,533
这是一个libc内部的地址
well this is an address inside libc

29
00:01:46,800 --> 00:01:51,300
具体来说，main_arena元数据位于libc的bss段
specifically the main arena metadata is in the BSS segment of libc

30
00:01:51,500 --> 00:01:59,000
当然，它到libc基址的偏移值是常量
which is of course a constant offset of the base of libc where libc is loaded

31
00:02:00,266 --> 00:02:03,499
我们启用GDB，以便查看
let's enable GDB so we can look around

32
00:02:06,133 --> 00:02:07,766
好了，开始吧
okay here we go

33
00:02:08,100 --> 00:02:08,833
泄露出了，成功了
leak a boom 

34
00:02:09,000 --> 00:02:09,800
就是这个
here it is

35
00:02:11,400 --> 00:02:12,800
这是泄露出的信息
this is what we've leaked

36
00:02:18,000 --> 00:02:20,200
下面是内存映射
here are the mappings

37
00:02:21,400 --> 00:02:24,500
我们泄露的信息就在这个地址
what we leaked is in this address

38
00:02:33,100 --> 00:02:35,700
确认无误
perfect amazing all right

39
00:02:36,100 --> 00:02:42,800
能用减法算出它到libc基址之间的距离
we can figure out what the distance between that and the base of libc is using subtraction

40
00:02:44,066 --> 00:02:45,399
结果就是这个
and it is this

41
00:02:45,533 --> 00:02:46,999
它不会变
and it'll always be this

42
00:02:47,000 --> 00:02:50,800
现在我们知道libc加载在哪了
so now we know where libc is

43
00:02:52,533 --> 00:02:53,799
删了这段代码
let's take this off 

44
00:02:54,000 --> 00:02:55,166
这段代码没用
this serves no purpose of course

45
00:02:55,700 --> 00:03:03,000
我们之前用aaaacccc覆盖了它，这只是为了展示任意写
we also have overwrote it with aaaacccc but that was just for show

46
00:03:03,233 --> 00:03:05,499
现在你知道libc在哪里了
so now you know where the libc is

47
00:03:08,733 --> 00:03:13,899
libc基址 = main_arena地址 - 它
the libc base is the main arena address minus that

48
00:03:13,966 --> 00:03:16,533
很好
amazing all right so

49
00:03:18,833 --> 00:03:21,033
这个内存映射还告诉了我们什么
what else does that tell us

50
00:03:24,100 --> 00:03:29,400
首先，告诉了我们所有其他库的加载位置
this tells us first of all where all of the other libraries are loaded

51
00:03:29,500 --> 00:03:32,400
因为它们彼此之间都有固定的偏移值
because they're all loaded at these constant offsets of each other

52
00:03:32,566 --> 00:03:33,499
这很好
which is great

53
00:03:33,900 --> 00:03:37,700
但它还告诉了我们一件有趣的事
but it also tells us one more interesting thing actually

54
00:03:38,266 --> 00:03:41,566
它告诉了我们内存映射基址
it tells us the memory mapping base 

55
00:03:41,766 --> 00:03:45,799
即ASLR后库加载的基址
that address space layout randomization base where all the libraries are loaded 

56
00:03:45,933 --> 00:04:00,399
还告知了所有普通的内存映射都映射在相邻的位置
but also where all of the memory mapped allocations in general are adjacently mapped in

57
00:04:00,966 --> 00:04:08,633
这包括我们的线程数据，比如线程结构
right and this includes our thread data such as the thread struct

58
00:04:08,866 --> 00:04:11,766
线程堆有被随机化
now the thread heap has some randomization built in

59
00:04:12,066 --> 00:04:14,399
但幸运的是，线程结构没有
but the thread struct luckily does not

60
00:04:14,866 --> 00:04:16,266
如果检查一下我们的线程
if you look at our threads

61
00:04:16,866 --> 00:04:19,133
我的脚本创建了3个连接
my script makes 3 connections

62
00:04:19,900 --> 00:04:22,066
1 2 3
1 2 3

63
00:04:22,133 --> 00:04:23,666
虽然我们只用这两个
although we only ever use these two

64
00:04:23,666 --> 00:04:25,366
我也不知道为啥创建这第三个
so I don't know why we do the third one

65
00:04:25,400 --> 00:04:27,300
但不管怎样，这也ok
but anyways that's fine so here we go 

66
00:04:27,566 --> 00:04:28,433
线程2
thread 2 

67
00:04:28,433 --> 00:04:31,666
线程1是主线程，它在那里等待连接请求
thread 1 is the main thread that is sitting there waiting for connections

68
00:04:31,700 --> 00:04:36,733
线程2、3和4是连接处理线程
thread 2 3 and 4 are our awesome connection handler threads 

69
00:04:37,033 --> 00:04:40,099
如果我们切换到线程2
if we switch to thread 2

70
00:04:41,500 --> 00:04:44,700
然后回退
and we scroll up

71
00:04:46,100 --> 00:04:51,400
用bt看一下子线程调用栈
 so of course the back trace of this our call stack

72
00:04:52,133 --> 00:04:54,166
目标在vuln
it's up at vuln 

73
00:04:54,333 --> 00:04:57,000
一直回退到vuln
let's go all the way up to vuln

74
00:04:57,266 --> 00:04:58,799
这是我们的那个有漏洞的函数
this is our vulnerable function

75
00:04:59,200 --> 00:05:04,800
gdb好用的一点是，它知道这个栈帧中的rbp
in here GDB is nice enough to figure out what RBP should be in this function

76
00:05:04,966 --> 00:05:06,166
你可以查看它
so you can actually examine it

77
00:05:06,366 --> 00:05:11,666
在RBP+8处，是到handle_connection里的返回地址
at RBP+ 8 is going to be the return address into handle connection

78
00:05:12,400 --> 00:05:15,466
然后，线程将在这里退出
and then of course that's where the thread will exit

79
00:05:15,900 --> 00:05:18,666
如果我们能覆盖这个地址
but if we can overwrite this address 

80
00:05:18,800 --> 00:05:20,533
我们就能劫持控制流
then we have hijacked control flow 

81
00:05:20,700 --> 00:05:21,433
幸运的是
luckily 

82
00:05:26,666 --> 00:05:31,933
这个地址到libc基址的偏移值是常量
that address is a constant offset off of libc

83
00:05:41,466 --> 00:05:43,333
就是4138
and it's that 4138

84
00:05:44,100 --> 00:05:52,366
所以我们甚至知道线程2（口误）中栈上存RIP的地址
so we even know where the stored rip address for thread 1 is

85
00:05:52,600 --> 00:05:58,366
它在libc基址 - 0x4138
it's at libc base minus 0x4138

86
00:06:00,733 --> 00:06:01,933
仅仅是通过泄漏libc
just by leaking libc

87
00:06:02,300 --> 00:06:07,566
我们计算出了libc基址
so now let's say we computed the libc base

88
00:06:08,166 --> 00:06:10,999
我会区分什么是计算的，什么是泄露的
I'd like to get track of what I've computed and what I've leaked

89
00:06:11,133 --> 00:06:12,133
这不仅有助于教学
it's nice for teaching 

90
00:06:12,300 --> 00:06:15,466
也有助于快速发现
but it's also nice to quickly understand 

91
00:06:15,633 --> 00:06:19,466
是基于前面的泄露结果，计算出错了
if you have a computation that's wrong based on previous leak

92
00:06:19,633 --> 00:06:21,099
还是泄露出错了
or you have a leak that's wrong

93
00:06:36,666 --> 00:06:37,599
当然
and of course

94
00:06:38,133 --> 00:06:39,633
现在执行脚本，能得到这些
if we run we can get these

95
00:06:39,733 --> 00:06:41,366
实际上还能知道一个信息
you can get actually one more thing

96
00:06:41,666 --> 00:06:44,533
请注意stored_rip_address中的值
you notice at this stored rip address

97
00:06:51,366 --> 00:06:53,533
它是一个text段的地址
is an address into our binary

98
00:06:53,666 --> 00:06:56,099
现在我们甚至可以得到PIE基址了
so now we can even get the pie base

99
00:06:59,133 --> 00:07:01,166
当然还是用我们的任意读
using our arbitrary read again of course

100
00:07:05,100 --> 00:07:08,733
addr_in_binary就在handle_connection指令中
see addr_in_binary somewhere in handle connection

101
00:07:08,966 --> 00:07:11,899
我们读出stored_rip_address中的值
we read out the stored rip address

102
00:07:12,000 --> 00:07:17,600
我们就可以算出text段的基址
and we can of course calculate the base of the binary

103
00:07:18,800 --> 00:07:27,900
用这个值减去gdb中获取的text段基址
by taking this and subtracting that

104
00:07:31,700 --> 00:07:34,533
获取固定偏移量 0x17f
that's 17f into the binary

105
00:07:35,900 --> 00:07:39,800
现在我们甚至知道了text段基址
now we can even say binary base

106
00:07:45,066 --> 00:07:48,466
我们现在可以输出更多东西了
okay so now we can print more stuff

107
00:07:48,700 --> 00:07:50,900
现在我们基本上已经看透了
and we know basically everything at this point

108
00:08:07,700 --> 00:08:11,300
我们禁用GDB并运行
let's disable GDB and run

109
00:08:14,900 --> 00:08:16,766
首次泄漏失败
the initial leak failed

110
00:08:18,866 --> 00:08:19,633
怎么了
what's going on here 

111
00:08:20,000 --> 00:08:22,466
大概是这几次运气不好
okay we just got unlucky several times I think

112
00:08:25,900 --> 00:08:27,400
看看这个
all right check this out

113
00:08:27,866 --> 00:08:29,799
我们泄露出了main_arena地址
we leaked the main arena address

114
00:08:29,800 --> 00:08:31,533
这个已经做过无数次了
we've done this a million times now

115
00:08:31,766 --> 00:08:33,866
在此基础上，我们计算出了libc基址
based on that we computed the libc base

116
00:08:34,033 --> 00:08:38,633
它以000结尾，这看起来很好
this looks pretty good in the sense that it ends in 000

117
00:08:38,733 --> 00:08:41,066
当然我们可以调出maps
and of course we'll read out our own maps

118
00:08:41,066 --> 00:08:43,233
确认它是匹配的
so we can actually confirm that it does match

119
00:08:43,700 --> 00:08:50,100
在此基础上，我们找出了stored_rip_address
based on that we figured out where the stored instruction pointer is

120
00:08:50,200 --> 00:08:53,566
它作为返回地址，存储在子线程的栈上
where the return address is stored on the thread stack

121
00:08:53,566 --> 00:08:55,566
这是子线程栈上的地址
this is an address into the thread stack

122
00:08:55,800 --> 00:08:58,400
我们泄露出它的值，以找出text段中的地址
we leak that out to figure out an address in the binary

123
00:08:58,400 --> 00:09:01,433
是一个返回到handle_connection中的返回地址
in the return address into the handle connection function

124
00:09:01,666 --> 00:09:04,533
并依此算出text段基址
and based on that we figure out where the binary base is

125
00:09:04,600 --> 00:09:05,566
注意，一个经验是
again rule of thumb 

126
00:09:05,633 --> 00:09:07,199
当你的计算正确时
when your calculations are correct

127
00:09:07,966 --> 00:09:11,433
页面基址的末尾会是000
you'll have a 000 at the base of all pages

128
00:09:11,600 --> 00:09:12,200
当然
of course

129
00:09:12,200 --> 00:09:14,200
这并不能保证其余部分都是正确的
this doesn't guarantee that the rest is correct

130
00:09:14,200 --> 00:09:16,400
但至少是一个快速的烟雾测试
but at least it's a quick smoke test

131
00:09:19,866 --> 00:09:20,333
这之后呢
now what

132
00:09:20,400 --> 00:09:22,133
已经可以宣告成功了
well now guys we're done

133
00:09:22,133 --> 00:09:24,499
我们知道栈在哪里
we know where the stack is

134
00:09:24,500 --> 00:09:26,100
知道返回地址在哪里
we know where the return address is

135
00:09:26,300 --> 00:09:29,766
假如说我们不知道canary
for example if we don't know the canary

136
00:09:29,866 --> 00:09:30,366
但能知道
we could

137
00:09:30,566 --> 00:09:31,833
我们能任意读
we have an arbitrary read 

138
00:09:32,133 --> 00:09:35,799
而canary就在这个地址前16字节处
the canary is 16 bytes before this address

139
00:09:36,033 --> 00:09:37,399
哦不对，在这个地址前
no before this address 

140
00:09:37,533 --> 00:09:38,466
但其实，我们都不需要知道它
but we don't even need to

141
00:09:38,633 --> 00:09:40,899
我们可以直接覆盖返回地址
we can overwrite directly from the return address

142
00:09:41,066 --> 00:09:42,166
我们可以任意写
and we have an arbitrary write

143
00:09:42,366 --> 00:09:44,299
任意写可以直接覆盖返回地址
that'll allow us to do that

144
00:09:44,700 --> 00:09:46,766
这太不可思议了
right so this is incredible

145
00:09:49,133 --> 00:09:51,399
我们现在
let's of course now

146
00:09:52,366 --> 00:09:54,599
我们先看一下当前进度
actually let's do a quick status check

147
00:09:54,933 --> 00:09:56,133
知道了很多东西
know a lot of stuff

148
00:09:56,733 --> 00:09:58,166
现在的计划是什么
what's the plan now

149
00:09:59,700 --> 00:10:02,900
我们在这一步
we are here

150
00:10:03,966 --> 00:10:04,799
我们要这么做
we're going to do this

151
00:10:04,800 --> 00:10:07,500
可以泄露出canary，从溢出点覆盖到返回地址
we can either leak the canary and overflow the whole stack

152
00:10:07,533 --> 00:10:08,699
提醒一下
as a reminder

153
00:10:09,133 --> 00:10:12,766
在这个输入的scanf处有一个溢出点
there's an overflow right here in this input scanf

154
00:10:13,033 --> 00:10:15,666
但这工作量太大了
but that's too much work

155
00:10:16,000 --> 00:10:19,300
我们直接用rop链覆盖返回地址
we're just gonna overwrite the return address directly with a ROP chain as I said

156
00:10:19,466 --> 00:10:20,366
我们开始吧
so let's do it

157
00:10:22,533 --> 00:10:25,333
我们要
here we go we are going to 

158
00:10:31,000 --> 00:10:32,666
输出：let's roll
print let's roll

159
00:10:33,733 --> 00:10:34,599
有些人喜欢
some more into

160
00:10:35,400 --> 00:10:39,000
在利用程序中彰显个性
for your exploits to have some personality

161
00:10:40,366 --> 00:10:41,499
你甚至可以这样做
you can even do this

162
00:10:45,533 --> 00:10:46,933
这很好
that's pretty good all right

163
00:10:49,366 --> 00:10:50,766
我们开始吧
okay so we're rolling

164
00:10:51,500 --> 00:10:59,900
从pwntools中取一个表示libc的elf实例
grab an ELF instance from pwntools representing libc

165
00:11:01,500 --> 00:11:05,700
我要用pwntools来自动生成ROP链
one thing I'm about to do is use pwntools to auto generate the ROP chain

166
00:11:09,900 --> 00:11:12,600
有时ROP很困难，缺少很多条件
ropping in constrained situations happens

167
00:11:12,866 --> 00:11:16,999
但通常，当你有了足够的原语，足够的信息
but very frequently once you build up enough primitives enough knowledge

168
00:11:17,300 --> 00:11:19,900
就很容易了
you can go the easy way right

169
00:11:20,866 --> 00:11:23,433
现在就是这样的情况
in this case that is one such case

170
00:11:23,633 --> 00:11:26,299
我们设置好libc基址
we're gonna set the libc base

171
00:11:26,933 --> 00:11:28,699
所以现在
so now and

172
00:11:29,000 --> 00:11:33,500
在用pwntools生成ROP链时，别忘了
very important when you're generating ROP chains with pwntools don't forget

173
00:11:33,500 --> 00:11:36,300
或者说做任何复杂的事时，不要忘了设置架构
or doing anything complicated don't forget to set your architecture

174
00:11:36,500 --> 00:11:37,866
我们还没设置
we haven't done that yet

175
00:11:38,900 --> 00:11:41,500
我会创建一个ROP
I'll create a ROP guy

176
00:11:44,400 --> 00:11:49,900
但我不会光用pwntools创建一个默认ROP对象
but I'm not just gonna create a ROP object with pwntools

177
00:11:49,966 --> 00:11:51,399
pwntools真的很好
pwntools is really nice 

178
00:11:51,566 --> 00:11:56,233
因为它支持过滤掉ROP链中的一些字符
in that it supports filtering out some characters in your ROP chain

179
00:11:56,400 --> 00:11:59,366
或者说能让ROP链中不含一些特定的字符
or being careful to make a ROP chain that doesn't have certain characters in it

180
00:12:00,300 --> 00:12:02,966
我们在这里忽视了一点
one thing we've loss over in all of this is that

181
00:12:03,533 --> 00:12:13,033
程序用printf和scanf读取我们给的地址、所有数据
the program uses printf and scanf to read in our addresses all of our data

182
00:12:14,000 --> 00:12:19,200
这是一个问题，因为printf和scanf将在空格处停止读取
this is the problem because printf and scanf will stop at white space

183
00:12:19,366 --> 00:12:22,399
所以要避免带有所有类型的空格
so we have to avoid all white space all spaces

184
00:12:22,400 --> 00:12:24,900
我们必须避免换行符
we also have to avoid new lines

185
00:12:25,900 --> 00:12:30,966
回车和其他一些东西
carriage returns and a bunch of other stuff right

186
00:12:33,200 --> 00:12:35,333
垂直制表符，水平制表符等
vertical tabs tabs etc

187
00:12:38,900 --> 00:12:41,900
pwntools很好，能过滤掉这些
pwntools is really nice that it lets you do that

188
00:12:41,900 --> 00:12:44,200
否则你就要用grep
otherwise you will have to you know grep

189
00:12:45,200 --> 00:12:48,133
在你的ROP链搜索器中用grep排除这些
exclude things using grep in your rop chain finder

190
00:12:48,300 --> 00:12:52,100
现在只需给pwntools设置好要过滤的
all right so then we just set that to pwntools and

191
00:12:52,166 --> 00:12:53,466
我们就不用考虑这些了
we don't have to think about it

192
00:12:53,566 --> 00:12:54,899
我们做一个快速测试
let's run a quick test

193
00:12:55,533 --> 00:12:57,166
只执行 exit 42
just exit 42

194
00:12:57,866 --> 00:12:59,133
整个ROP链就这些
that'll be our entire rop chain 

195
00:12:59,200 --> 00:13:07,766
然后把它写入栈上的返回地址
and we're gonna write it into our stored rip address over the stack

196
00:13:10,533 --> 00:13:12,966
基本上就好了
boom and we're basically done

197
00:13:13,166 --> 00:13:14,099
如何触发它呢
so how do we trigger that

198
00:13:14,266 --> 00:13:16,199
只需终止线程
of course we terminate the thread

199
00:13:16,566 --> 00:13:20,299
我们发送quit，使vuln函数返回
we send quit so that vuln returns

200
00:13:20,600 --> 00:13:26,400
它会返回到它以为的handle_connection函数
it'll return to what it thinks would be handle connection

201
00:13:26,600 --> 00:13:27,800
但实际上返回到了ROP链
but is actually a ROP chain

202
00:13:29,000 --> 00:13:33,033
我们在这个进程wait一下
and then we're going to wait on this process

203
00:13:34,033 --> 00:13:38,166
打印出退出码
and print out what it exited with

204
00:13:38,333 --> 00:13:39,699
应该是42
and this should be 42

205
00:13:43,000 --> 00:13:45,100
好了，我们开始吧
all right let's roll

206
00:13:48,000 --> 00:13:49,900
忘了右括号，好了，开始吧
forget to close parentheses all right let's roll

207
00:13:50,566 --> 00:13:52,566
计算,泄漏
computed computing leaks

208
00:13:54,766 --> 00:13:55,666
崩溃
crash

209
00:13:57,300 --> 00:14:01,400
啊，我们的任意写需要一个整数参数
ah our arbitrary write assumes an integer input

210
00:14:01,666 --> 00:14:03,366
我们就在这用了它
it is the only place we use it

211
00:14:04,000 --> 00:14:11,200
scanf可以接受任意长的输入
and scanf can take an arbitrarily long input or whatever the format string must to

212
00:14:11,300 --> 00:14:15,800
我们把这个改成直接发送值
so we're actually gonna change this to just send the value directly

213
00:14:15,800 --> 00:14:18,100
只要那里没有空格，就没问题
as long as there are no spaces there we're good to go

214
00:14:20,166 --> 00:14:21,533
我的意思是
I mean yeah

215
00:14:21,733 --> 00:14:24,733
因为这个，我们知道这里没有空格
and there and we know there are no spaces because of that

216
00:14:24,900 --> 00:14:29,500
我们不再传入整数给任意写
so instead of passing an integer to our arbitrary write

217
00:14:29,700 --> 00:14:35,133
再编码，转成小端序
and then encoding it and then packing it in little endian

218
00:14:35,266 --> 00:14:36,899
我们直接传入字节
 we're just going to send bytes directly

219
00:14:36,900 --> 00:14:39,400
很好，按回车键
all right perfect hit enter

220
00:14:39,900 --> 00:14:42,466
好的，参数超出范围
okay argument out of range 

221
00:14:42,766 --> 00:14:46,466
因为泄露perthread_struct失败了
because we fail to leak the perthread struct 

222
00:14:46,633 --> 00:14:47,866
是有这种情况
it happens

223
00:14:49,900 --> 00:14:50,766
开始吧
here we go

224
00:14:51,900 --> 00:14:53,400
好了，我们开始吧
all right let's roll

225
00:14:55,133 --> 00:14:57,633
砰砰砰退出码是42
boom boom boom exited 42

226
00:14:57,933 --> 00:14:59,799
我们可以代码执行了
we have code execution

227
00:15:00,300 --> 00:15:02,066
执行了ROP链
ROP chain we're done

228
00:15:03,100 --> 00:15:06,500
当然，我们来完善这个ROP链
of course let's do this ROP chain

229
00:15:14,100 --> 00:15:17,066
我们需要字符串：/flag
it hmm we need the word flag

230
00:15:17,266 --> 00:15:20,433
想要打开/flag文件
I want to smoothly open the flag

231
00:15:20,733 --> 00:15:25,566
需要从可控标准输入中，读入/flag字符串
so we're going to read the word flag from standard in which we control 

232
00:15:25,800 --> 00:15:32,400
能通过连接的文件描述符，写入数据到libc的bss段
we could use any of the connection file descriptors into the libc BSS

233
00:15:32,466 --> 00:15:35,333
它对我们来说只是临时可读可写的数据段
this is just temporary readable writable data for us

234
00:15:35,333 --> 00:15:36,666
libc会使用它
libc use it for something

235
00:15:36,666 --> 00:15:38,466
但这是一个很大的bss段
but there's a big BSS

236
00:15:38,600 --> 00:15:43,400
在完成利用前，所用数据被破坏的可能很小
the chances that we'll corrupt something that we need before down to our exploit is low

237
00:15:43,666 --> 00:15:44,999
我们直接用libc函数
and we're using the libc functions

238
00:15:45,000 --> 00:15:51,033
尽管已知libc地址，里面有gadget能调用系统调用
even though we have libc and there are syscall gadgets in there 

239
00:15:51,333 --> 00:15:54,166
但这样简单多了，pwntools处理得更好
this is much easier pwntools handles it a lot better

240
00:15:54,500 --> 00:15:56,000
我们打开/flag文件
all right we'll open that

241
00:15:57,500 --> 00:16:05,700
调用sendfile从文件描述符3发到标准输出
we will send file from the third file descriptor to standard out 

242
00:16:05,933 --> 00:16:10,599
只是，我们不能假设文件描述符3可用
except for the third file descriptor is not something that we can assume

243
00:16:11,300 --> 00:16:13,700
在很简单的程序中，可以
in very simple programs it is

244
00:16:13,900 --> 00:16:15,700
但是在任何复杂的程序中
but in any complex program

245
00:16:15,700 --> 00:16:19,400
就比如这个，用一个描述符接收连接
such as this one which uses a file descriptor to listen further connection

246
00:16:19,500 --> 00:16:30,900
再针对每个连接用一个来通信
then uses a file descriptor per connection to actually speak to the client and so forth

247
00:16:31,266 --> 00:16:33,733
所以这里的文件描述符大概是
this file descriptor is probably going to be

248
00:16:33,800 --> 00:16:35,600
因为我们打开了三个连接
because we open three connections

249
00:16:36,333 --> 00:16:37,466

7

250
00:16:38,933 --> 00:16:40,933
但我们不用担心这个
but let's not worry about it

251
00:16:41,166 --> 00:16:43,166
我们先关了文件描述符3
let's close file descriptor 3

252
00:16:43,700 --> 00:16:46,400
那么下一个，这里open的，就是3了
so that the next this one that's open is gonna be 3

253
00:16:46,500 --> 00:16:50,300
这样写的话，我们不能新建连接了
so with this we can't connect again

254
00:16:50,400 --> 00:16:52,333
否则 3 将被占用
that's the accept file descriptor 

255
00:16:52,533 --> 00:16:53,999
但谁在乎呢
but who cares all right

256
00:16:54,666 --> 00:16:57,266
这样应该能泄露出flag
and then this should leak as the flag

257
00:16:57,500 --> 00:17:01,900
这里p.wait改成
so let's instead of p.wait we will

258
00:17:06,300 --> 00:17:08,500
readall 开始吧
readall  here we go

259
00:17:14,966 --> 00:17:17,399
这里在等我们发送/flag
and it's waiting for us to send flag

260
00:17:18,133 --> 00:17:18,933
我的锅
my bad

261
00:17:28,700 --> 00:17:31,300
好的，现在发送了/flag
here we go now we send slash flag

262
00:17:31,400 --> 00:17:33,233
它被读入到libc的bss中
that gets read into the BSS 

263
00:17:33,433 --> 00:17:35,666
然后 open、sendfile、exit
and then you open send file exit

264
00:17:44,266 --> 00:17:45,099
好的
boom

265
00:17:46,400 --> 00:17:47,466
我们的flag在这里
there is our flag

266
00:17:47,900 --> 00:17:49,133
很酷吧
how cool is that 

267
00:17:52,400 --> 00:17:54,066
要点是
so takeaway is here

268
00:17:55,733 --> 00:17:58,533
当我们能任意读、任意写时
once we had arbitrary read and arbitrary write

269
00:17:58,900 --> 00:18:00,766
距离成功就很近了
it was pretty simple to get to game over

270
00:18:04,066 --> 00:18:04,999
但是为了做到这一点
but in order to do that 

271
00:18:05,200 --> 00:18:06,933
我们需要在内存中探索
we had to do some sleuthing around memory

272
00:18:07,600 --> 00:18:15,300
经过本模块的课后题，你将成为这方面的专家
you will become an expert in sleuthing around memory with these challenge problems for this module

273
00:18:16,100 --> 00:18:19,100
还有一个有趣的点
and an interesting takeaway is

274
00:18:19,233 --> 00:18:23,866
我们的任意写实际上是有限制的
our arbitrary write actually had a limit a limitation

275
00:18:23,933 --> 00:18:26,966
这个限制是非常具体的
that limitation was very specific it was

276
00:18:29,366 --> 00:18:33,266
我们不能写入空格
the fact that we could not write white spaces

277
00:18:33,400 --> 00:18:34,466
完全没办法
there's no way

278
00:18:36,500 --> 00:18:40,400
在任意写或任意读时，你将经常面对这些限制
often times you'll be faced with these limitations on arbitrary write or an arbitrary read

279
00:18:40,400 --> 00:18:43,700
实际上我们的任意读、写还有一个限制
actually our arbitrary read and write also had another limitation

280
00:18:44,100 --> 00:18:51,400
因为我们用scanf读取想要的地址
in that because we used scanf to read in the address we wanted right here

281
00:18:52,000 --> 00:18:58,200
你同样也不能用含有能被解析成空格字符的地址值
you also couldn't use any addresses that have any white space characters in the address

282
00:18:58,800 --> 00:19:01,900
假如我们的地址值中含有0x20
so if our address had a hex 20 in it

283
00:19:02,866 --> 00:19:04,366
就写入不了这个地址值
we can't do it

284
00:19:08,166 --> 00:19:09,166
这很棘手
so that's tricky

285
00:19:11,533 --> 00:19:13,366
我说到哪了
what was I yeah 

286
00:19:13,500 --> 00:19:17,166
这在利用开发中并不罕见
so this happens not rarely in exploitation

287
00:19:17,266 --> 00:19:19,133
你的能力将有限制
you'll have limited capabilities 

288
00:19:19,233 --> 00:19:23,433
不过，如你所见，这些限制通常不足为虑
as you can see often times these limited capabilities aren't that big a deal

289
00:19:23,700 --> 00:19:27,133
你依旧能拿到flag
and you can still get the flag

290
00:19:27,800 --> 00:19:28,600
好吧
alright

291
00:19:29,400 --> 00:19:32,966
希望这是一个有趣的旅程
hopefully this was an interesting journey 

292
00:19:33,233 --> 00:19:39,699
这一高级利用系列视频，在这里达到了高潮
this video series for advanced exploitation culminating and putting it all together here

293
00:19:41,500 --> 00:19:46,900
当你未来看到一个任意读、任意写和一个栈地址
when you see in the future an arbitrary read arbitrary write and a stack address

294
00:19:46,900 --> 00:19:48,266
你知道该怎么做了
you know what to do

295
00:19:48,366 --> 00:19:49,099
祝你好运
good luck

