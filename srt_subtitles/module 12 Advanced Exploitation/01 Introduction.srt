1
00:00:00,900 --> 00:00:02,333
你好黑客
hello hackers

2
00:00:02,400 --> 00:00:06,200
欢迎来到pwn学院高级漏洞利用模块
welcome to the Advanced Exploitation Module of pwn College

3
00:00:06,500 --> 00:00:10,400
我是Yan，我们将在这个系列视频中整合
I'm Yan and we're going to be putting together in this video series 

4
00:00:10,500 --> 00:00:12,900
目前在该课程中学到的所有知识
all of the things you've Learned in the course so far

5
00:00:13,100 --> 00:00:17,400
当然，如果你是碰巧在网上看到这个视频
of course if you are just knowing on this video from the open Internet

6
00:00:19,100 --> 00:00:20,933
下面这个建议可能会让你有点震惊
it might be a bit of a shock

7
00:00:21,400 --> 00:00:25,300
我建议你先学完前面的内容
I would recommend going through all the existing content in the course

8
00:00:25,400 --> 00:00:27,900
因为他们都会在这到达另一个难度
because it all culminates here

9
00:00:28,600 --> 00:00:29,666
让我们开始吧
let's dive in

10
00:00:31,200 --> 00:00:36,100
这个视频是该系列的第一个
this video specifically is going to be the first of a series of videos in which

11
00:00:36,233 --> 00:00:43,099
我们将在该系列尝试攻击启用所有保护机制的多线程服务
we will tackle the exploitation of a multi threaded service with all mitigations enabled

12
00:00:43,166 --> 00:00:44,733
当然，这个服务是有漏洞的
of course the service is vulnerable

13
00:00:45,500 --> 00:00:47,533
我们会把所有的概念组合起来
but we're going to pull together concepts 

14
00:00:47,600 --> 00:00:54,400
包括：竞争条件、堆漏洞、ROP等
from race conditions from heap errors from return oriented programming

15
00:00:54,500 --> 00:00:59,300
我们将应对这一挑战
and we're going to tackle this challenge 

16
00:00:59,500 --> 00:01:02,300
向你展示攻击它的全流程
and show end to end how you'll exploit that

17
00:01:04,400 --> 00:01:09,400
回想一下我们第一个讲利用场景的模块
if you think back to our first kind of exploitation scenarios module

18
00:01:09,466 --> 00:01:11,200
第一个整合概念的模块
the first putting it together module

19
00:01:11,266 --> 00:01:14,599
有这样一张ppt鼓励你
I have this slide where I encourage you to think like a hacker 

20
00:01:14,766 --> 00:01:17,433
在解决挑战题时
when you're approaching hacking challenges

21
00:01:18,133 --> 00:01:22,699
或在分析理解一个系统时，要像黑客一样思考
or a system that you are trying to analyze and understand

22
00:01:23,500 --> 00:01:28,300
有这样一些思考步骤
and there are a number of steps that you undergo 

23
00:01:28,566 --> 00:01:31,733
首先拿到一个程序，尝试理解它
first you look at the program understand it 

24
00:01:31,933 --> 00:01:34,099
逆向工程、使用它、调试它等等
reverse engineer it interact with it etc

25
00:01:34,166 --> 00:01:36,933
找到一个小的安全瑕疵
then you find the smallest security flaw

26
00:01:37,600 --> 00:01:39,766
想办法利用它
figure out how to exploit it

27
00:01:40,000 --> 00:01:44,400
弄清楚它能提供什么
then you figure out what that flaw allows you 

28
00:01:44,633 --> 00:01:50,899
能不能让你理解或者修改目标进程
to understand or change about the running program the process that you're exploiting

29
00:01:51,900 --> 00:01:56,400
或者有其它的用处
and what additional capabilities it gives you

30
00:01:56,633 --> 00:01:58,399
然后利用它带来的能力
then you use those capabilities

31
00:01:58,400 --> 00:02:00,366
重复以上几步
and then you repeat that step

32
00:02:01,133 --> 00:02:04,266
直到攻陷整个系统
until you have this sort of total system compromise

33
00:02:04,500 --> 00:02:08,666
希望你们能用这样的思路
that is the mindset that I encouraged you 

34
00:02:08,833 --> 00:02:12,299
解决本模块中所有挑战问题
to approach all of the challenge problems for this module with

35
00:02:13,700 --> 00:02:23,900
在该系列视频中，我们要运用这一思路解决问题
this is the thought process that we're going to try to apply in this video series for this challenge itself

36
00:02:24,000 --> 00:02:26,966
我们来谈谈信息
so let's talk about information

37
00:02:26,966 --> 00:02:28,600
信息是至关重要的
information is critical

38
00:02:28,700 --> 00:02:34,800
如果缺失必要的信息，你所知道的许多技术都无法使用
a lot of the techniques that you know aren't viable without knowing the necessary information

39
00:02:34,800 --> 00:02:38,200
如果不知道程序指令地址，就无法ROP
you can't ROP without knowing where program addresses are

40
00:02:38,200 --> 00:02:39,300
在ROP模块
now in the ROP module

41
00:02:39,300 --> 00:02:42,300
我们已经探讨了找出指令地址的方法
we've explored techniques to figure out where the program addresses are

42
00:02:42,366 --> 00:02:44,266
你得先搞清楚指令地址
but you still need to first figure it out

43
00:02:44,400 --> 00:02:46,800
才能执行ROP链
before you can actually execute a ROP chain

44
00:02:47,300 --> 00:02:50,133
通常情况下，除了某些特定情况
often times except for in certain situations

45
00:02:52,100 --> 00:02:58,200
任何针对堆缓存的攻击，或堆分配重定向
any sort of heap cache poisoning or heap allocation redirection techniques

46
00:02:58,200 --> 00:03:01,300
都需要知道，你要让堆分配在哪里
require knowing where you want the heap to allocate data

47
00:03:01,300 --> 00:03:05,200
或者要知道，堆内存的初始地址
or require knowing where the heap structures are in memory in the first place

48
00:03:05,933 --> 00:03:09,533
为了能获取到这些信息
in order to be able to provide that information

49
00:03:09,600 --> 00:03:12,133
您至少需要知道哪些地址是有效的
you have very at least need to know what data addresses are valid

50
00:03:12,266 --> 00:03:17,399
但理想情况下，您需要知道目标进程的大量信息
but ideally you need to know quite a lot of information about the running process

51
00:03:17,466 --> 00:03:19,600
那么如何最大化利用已知信息
so how do you maximize this information that you know

52
00:03:19,600 --> 00:03:20,400
当然
of course

53
00:03:22,500 --> 00:03:26,000
我们讨论过了一些保护机制
we have talked about a number of mitigations

54
00:03:26,000 --> 00:03:29,800
他们的目的就是让我们无法获知这些信息
that are explicitly aimed at keeping this information away from you

55
00:03:30,333 --> 00:03:31,500
栈金丝雀
stack canaries

56
00:03:31,866 --> 00:03:35,466
在每个栈帧的末尾放置一个未知值
put a unknown value at the end of every stack frame

57
00:03:35,466 --> 00:03:37,100
地址空间布局随机化ASLR
Address Space Layout Randomization

58
00:03:37,133 --> 00:03:39,533
将内存放在随机位置
puts memory in random places

59
00:03:40,400 --> 00:03:44,200
内存区域随机分布在内存空间中
memory spaces in random places in the memory space

60
00:03:44,366 --> 00:03:46,900
比如堆，栈，等等
so the heap the stack and so forth

61
00:03:47,300 --> 00:03:53,600
但是在软件中可能有信息泄露漏洞
but we have information disclosure vulnerabilities that occur in software

62
00:03:53,600 --> 00:03:56,600
我们已经在很多场景见过这类漏洞了
and you've seen a lot of these in different contexts right

63
00:03:56,700 --> 00:04:03,000
在内存错误模块，利用了未初始化内存，泄露金丝雀和地址
you've used uninitialized memory to read out canaries and addresses in the memory errors module

64
00:04:03,500 --> 00:04:07,600
通过tcache泄露出的next，了解堆地址
you have read out tcache addresses to understand where the heap is

65
00:04:07,800 --> 00:04:13,000
在堆，动态分配器安全相关模块
I mean the heap metadata dynamic allocator security module

66
00:04:14,700 --> 00:04:20,266
利用了分配重叠chunk
you've in that module used overlapping allocations 

67
00:04:20,600 --> 00:04:23,866
读取并写入你本不应访问的内存
to read and write memory that you weren't supposed to have access to

68
00:04:24,666 --> 00:04:32,066
然后在很多模块中，都有暴力破解地址或者部分地址
and in many modules you've ended up brute forcing addresses or parts of addresses 

69
00:04:32,166 --> 00:04:33,299
最终找到正确的值
to get them right 

70
00:04:33,633 --> 00:04:37,999
要点是
right so the kind of takeaway is 

71
00:04:38,600 --> 00:04:48,700
比如，有一个漏洞能让你劫持执行流
if there's a bug that you can use to hijack Control flow for example

72
00:04:48,700 --> 00:04:54,900
但你不知道要将执行流重定向到哪里
but you don't know where program instructions are to hijack control flow to

73
00:04:55,100 --> 00:04:57,600
这并不是说这个漏洞没用
doesn't mean the control flow bug is useless

74
00:04:57,600 --> 00:04:59,500
只是目前还无法使用它
it just means you can't use it yet

75
00:04:59,500 --> 00:05:01,500
你需要找到更多的信息
and you need to get more information

76
00:05:01,500 --> 00:05:02,200
例如
for example

77
00:05:02,200 --> 00:05:07,200
使用在程序中找到的信息泄露漏洞
using an information disclosure vulnerability that you find in that program

78
00:05:09,733 --> 00:05:12,166
如何发现信息泄露漏洞
how do you find information disclosure vulnerability

79
00:05:13,600 --> 00:05:18,500
一个机智的回答是
well the kind of wise saying of this would be that

80
00:05:18,733 --> 00:05:21,066
一把锤子有两个头
a hammer has two ends 

81
00:05:21,166 --> 00:05:23,533
一头可以用来锤钉子
a hammer can hammer in nails 

82
00:05:23,800 --> 00:05:25,166
另一头可以用来拔钉子
and it can pull up nails

83
00:05:25,433 --> 00:05:31,699
同样，一个漏洞可能有多种用途
in the same way vulnerability might have multiple uses

84
00:05:32,133 --> 00:05:35,599
你可能用一个漏洞，比如堆溢出漏洞
you might be able to use a vulnerability a heap metadate overwrite 

85
00:05:35,700 --> 00:05:42,200
获得重叠chunk后，写内存
to get overlapping allocations and overwrite memory

86
00:05:42,400 --> 00:05:44,933
或者你可以用这个漏洞
or you might be able to use that same vulnerability

87
00:05:45,566 --> 00:05:49,566
获得重叠chunk后，读内存
to get overlapping allocations and read out parts of memory

88
00:05:49,700 --> 00:05:55,400
读出包括像地址、金丝雀等本来无法读出来的内存
including addresses canaries etc that you might not supposed to have access to

89
00:05:56,100 --> 00:05:57,566
一般来说，在做这个的时候
in general as you're doing this

90
00:05:57,733 --> 00:06:01,100
你要持续追问一些问题
you have to keep track of what your current mental state is

91
00:06:01,100 --> 00:06:03,900
你对目标程序有多少了解
what you know about the program that you're trying to exploit

92
00:06:04,000 --> 00:06:06,000
你对目标进程有多少了解
what you know about the process

93
00:06:06,100 --> 00:06:13,100
当前你要利用的运行着的程序实例
the specific instance of that program that's running that you can exploit or

94
00:06:13,300 --> 00:06:18,300
有哪些之前运行获得的，并对当前进程有用的信息
what you know about previous iterations of that process that would still apply to this process

95
00:06:18,300 --> 00:06:21,500
例如，内存中的相对布局
relative layout in memory for example

96
00:06:22,100 --> 00:06:26,600
要多问自己还有没有能找到的有用信息
you need to keep track of what you need to know which you need to find out

97
00:06:26,766 --> 00:06:33,299
并多想想能做什么
and you need to keep track of what you can to do

98
00:06:33,700 --> 00:06:38,300
要活用这些信息提供给你的工具
you need to understand what are the tools available at your disposure

99
00:06:38,800 --> 00:06:42,800
如果拿到了一个锤子，别忘了锤子的另一头
don't forget if you have a hammer you might have the other end of a hammer

100
00:06:42,866 --> 00:06:44,466
你也可能要用它来拔钉子
you might have the nail puller as well

101
00:06:44,466 --> 00:06:46,000
也许有个更好的名字
there's probably a better name for it

102
00:06:47,533 --> 00:06:49,800
我们来看一个例子
we're going to look at this as a motivating example

103
00:06:49,800 --> 00:06:53,200
我把它分在两张ppt上了，一张放不下
I spread across two slides because it won't fit on one side

104
00:06:53,200 --> 00:06:54,966
这里只是网络设置的代码
this is just the network setup code

105
00:06:54,966 --> 00:06:57,066
它是一个多线程服务器
it is a threading server

106
00:06:57,600 --> 00:07:01,700
在main里，它只是启动并监听1337端口
in main it just starts up and listens on port 1337

107
00:07:03,266 --> 00:07:06,400
来一个连接，他就创建一个线程
and for every new connection it creates a thread

108
00:07:09,100 --> 00:07:13,200
它在每个线程中调用handle_connection来处理
it invokes the handle_connection handler in every thread

109
00:07:14,500 --> 00:07:19,300
这里用FILE对象来装文件描述符，是因为
thus wraps the file descriptor in a file object for

110
00:07:19,333 --> 00:07:22,166
这样可以使用 fprintf 和 fscanf 等函数
so that we can use fprintf and fscanf and so forth

111
00:07:22,400 --> 00:07:25,133
然后调用一个有漏洞的函数
and then calls the vulnerable function

112
00:07:25,133 --> 00:07:26,500
这是个样板
this is all boilerplate

113
00:07:26,600 --> 00:07:29,500
任何多线程服务都可以套用这个
could be any service that's threading could use the same thing

114
00:07:29,600 --> 00:07:41,166
一个建议是，是否有用取决于你的规划，
in fact one useful thing in your life depending on where you go from here 

115
00:07:41,366 --> 00:07:50,299
建立一套可以快速使用的C模板代码库
is having like sets of these sort of templates in C that you can really quickly grab

116
00:07:50,366 --> 00:07:51,266
要是需要一个多线程服务器
you need a threading server

117
00:07:51,400 --> 00:07:52,866
ppt上的代码随便用
feel free to grab this slide

118
00:07:52,966 --> 00:07:54,266
然后实现这个vuln函数
implement the vuln function

119
00:07:54,433 --> 00:07:55,766
希望你写的函数没有漏洞
hopefully yours won't be vulnerable  

120
00:07:55,833 --> 00:07:58,066
除非你想让它有，然后利用它
unless you want it to and go for it

121
00:07:58,066 --> 00:08:01,833
好吧，不管怎样，真正的有意义的是什么
all right anyways so what is the actual meat

122
00:08:02,033 --> 00:08:03,333
这是实际的服务代码
here's the actual service

123
00:08:03,866 --> 00:08:05,566
看起来应该很熟悉
and it should look pretty familiar

124
00:08:05,566 --> 00:08:08,800
这简直和babyheap一模一样
this is almost exactly babyheap

125
00:08:09,100 --> 00:08:14,233
几乎和动态分配器误用模块的挑战题模板完全一样
almost exactly the challenge template from the dynamic allocator misuse

126
00:08:14,400 --> 00:08:17,900
但有一个重要的不同点
 with one massive difference

127
00:08:19,766 --> 00:08:21,133
它是安全的
it's secure

128
00:08:21,500 --> 00:08:28,900
它实时记录着messages各元素的分配情况
right it actually keeps track of whether or not the messages are allocated

129
00:08:29,000 --> 00:08:34,033
在babyheap的那些挑战题中
so if in babyheap in those challenges 

130
00:08:34,100 --> 00:08:42,400
你把messages地址放在这个数组中，当时称为allocations数组
you allocated messages into this allocation array there was called allocations

131
00:08:42,466 --> 00:08:46,100
把分配地址放到这个allocations表中
so you allocated stuff into the allocations table

132
00:08:48,100 --> 00:08:49,500
等free时
and then when you freed it

133
00:08:49,500 --> 00:08:50,933
程序不将指针清零
it didn't zero out the pointer

134
00:08:50,933 --> 00:08:52,900
你可以利用那个指针
and you could mess with that pointer

135
00:08:53,000 --> 00:08:56,500
解引用它，然后操纵里面的数据
dereference the pointer and mess rather with the data inside it

136
00:08:56,700 --> 00:09:04,200
随意修改堆缓存的元数据
with the heap caching information as much as you wanted to

137
00:09:04,500 --> 00:09:08,300
在这里你不能
here you can't

138
00:09:08,300 --> 00:09:12,300
当我们申请分配时，只会在
when we allocate it will only do the allocation

139
00:09:12,566 --> 00:09:17,699
这里没有分配过时，分配
 if there isn't something allocated in that entry of the messages table

140
00:09:17,900 --> 00:09:20,900
然后它会实时记录目前哪些分配过了
and then it'll keep track of what it has allocated so far 

141
00:09:21,033 --> 00:09:23,066
free时也一样
and likewise for deallocation

142
00:09:23,066 --> 00:09:26,099
只有在分配状态时，才执行free
it'll only do the deallocation if there isn't an entry there

143
00:09:26,400 --> 00:09:30,366
它也会持续记录目前已经释放的
 and it'll also keep track of what it has deallocated so far

144
00:09:31,000 --> 00:09:39,333
当然，它也对溢出做了保护
and of course it also protects against overflows 

145
00:09:39,566 --> 00:09:42,333
它最多只读取已分配内存的大小
it will only read the size of the allocation 

146
00:09:42,700 --> 00:09:44,966
至少输入到堆上时没问题
at least on the heap

147
00:09:45,333 --> 00:09:51,533
在写入前，它会检查确保已经分配了内存
it will check to make sure that you actually have something allocated before it writes it there

148
00:09:53,066 --> 00:09:55,866
以单线程的角度看，挺安全的
it seems pretty secure in a single threaded way

149
00:09:56,500 --> 00:09:58,866
显然，这里仍然存在一些缺陷
obviously there are still some flaws here

150
00:09:59,533 --> 00:10:03,466
一个例子是，这个input有缓冲区溢出
one for example is there's a buff overflow in the input

151
00:10:03,666 --> 00:10:07,100
你能向这个程序发送任意长的输入
so you can send any length of input to this program

152
00:10:07,400 --> 00:10:09,000
你能触发一个栈缓冲区溢出
and you can do a stack buff overflow

153
00:10:09,000 --> 00:10:10,700
但它是一个多线程服务
but it's a threading service

154
00:10:10,800 --> 00:10:13,166
一旦破坏栈金丝雀，服务就崩了
the moment you hit that canary that service is dead

155
00:10:13,900 --> 00:10:18,933
因此，在单线程方式下，你无法利用此漏洞
so in a single threaded way you would not be able to exploit this

156
00:10:19,066 --> 00:10:25,699
但是在多线程中，就不一样了
but in multi threading all bets are off 

157
00:10:25,866 --> 00:10:33,199
这个服务中不同线程运行的代码依赖了很多
basically this service has a lot of dependencies between code that is running in different threads

158
00:10:33,600 --> 00:10:39,000
全局变量
and global variables that that code uses that are in global memory

159
00:10:39,700 --> 00:10:41,366
它在线程之间是共享的
that is shared between threads

160
00:10:41,866 --> 00:10:44,166
而且没使用互斥锁
and not guarded by mutexes

161
00:10:44,600 --> 00:10:47,700
这意味着存在竞争条件
right this means that there are race conditions

162
00:10:47,700 --> 00:10:51,466
蓝色箭头代表这个依赖关系
the blue arrows are any data dependency that

163
00:10:52,133 --> 00:10:56,099
会导致不走if分支，走else（有的话）
disables something that is pointing to

164
00:10:56,133 --> 00:10:58,166
如果这个stored[idx]等于0成立
so if this stored equals 0 happens

165
00:10:58,166 --> 00:10:59,800
如果我们free了它
so if we free an allocation

166
00:11:00,300 --> 00:11:05,900
我们将无法写入到messages数组（光标指错了）
then we will no longer be able to write into this messages array

167
00:11:05,966 --> 00:11:08,666
红色的这些箭头，将导致走if分支
the red ones the red arrows enable things

168
00:11:08,700 --> 00:11:13,600
如果stored[idx]等于1，就可以free
so if stored is equal to 1 then we'll be able to free

169
00:11:14,000 --> 00:11:17,000
当然，在单线程中，就像我说的，这是安全的
now of course in a single thread like I said this is secure

170
00:11:17,366 --> 00:11:19,400
但在多线程场景中
but in the multi threaded scenario

171
00:11:19,700 --> 00:11:25,600
这里以及世界上大多数的计算机服务
in which we and most of the rest of civilized computer science operates

172
00:11:27,900 --> 00:11:29,266
都会有问题
there are going to be problems

173
00:11:30,333 --> 00:11:33,200
下个视频我们将深入一步
next video we're gonna dive into the first step

174
00:11:33,200 --> 00:11:38,500
利用这些问题，攻破整个程序
of leveraging these problems toward the compromise of this whole program

175
00:11:38,666 --> 00:11:39,466
到时见
see you there

