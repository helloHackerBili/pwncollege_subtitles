1
00:00:00,800 --> 00:00:02,000
你好黑客
hello hackers

2
00:00:02,100 --> 00:00:07,000
欢迎继续观看PWN学院高级漏洞利用模块
welcome to another video in the advanced exploitation module of pwn college

3
00:00:07,100 --> 00:00:12,900
今天我们要讨论的是原语，具体来说是漏洞利用原语
today we're going to be talking about primitives exploitation primitives to be specific

4
00:00:13,600 --> 00:00:21,800
以这个模块一直在用的例子为背景
in the context of our motivating example that we've been rolling with this whole video series

5
00:00:22,600 --> 00:00:31,800
例子中对堆的使用，在单线程情景下是安全的
this example has heap operations that would appear to be safe in a single threaded scenario

6
00:00:31,900 --> 00:00:34,733
但多线程场景下，是不安全的
but in a multi threaded scenario they are not safe 

7
00:00:34,766 --> 00:00:43,333
我们使用了printf和free之间的竞争
and we have already used a race between printf and free 

8
00:00:43,733 --> 00:00:48,833
泄漏了线程特定的arena地址
to leak for example the thread specific arena address 

9
00:00:49,100 --> 00:00:53,800
具体来说，在上个视频中泄露了perthread_struct的地址
specifically the tcache perthread leak in the last video

10
00:00:55,533 --> 00:00:58,499
在这个视频中，我们将继续深入
in this video we're going to push further

11
00:00:58,666 --> 00:01:05,999
现在已经泄露了perthread_struct的地址
so we've leaked the address of the perthread struct

12
00:01:06,333 --> 00:01:09,533
稍等，我改一下ppt的布局
and hold on let me fix the layout of this slide real quick

13
00:01:09,933 --> 00:01:11,666
好了
there we go all right

14
00:01:12,800 --> 00:01:16,666
现在已经泄露了perthread_struct的地址
so we leaked out the perthread struct 

15
00:01:16,800 --> 00:01:21,600
每个被释放后会放到tcache中的chunk
that every freed allocation gets placed in the tcache

16
00:01:22,933 --> 00:01:25,933
它都会被写入chunk第二个八字节中
gets written into the second qword right

17
00:01:26,600 --> 00:01:29,200
使用它并在GDB中查找
using that and looking in gdb

18
00:01:29,366 --> 00:01:33,766
我们看到了一个指向libc的指针
we looked at where a pointer to libc is

19
00:01:33,766 --> 00:01:38,866
我们利用已知的tcache perthread_struct地址
so you use the fact that we know where the tcache perthread struct is

20
00:01:38,966 --> 00:01:44,133
查找在arena元数据中指向libc的指针
to look up where there's a pointer to libc specifically in the arena metadata

21
00:01:44,333 --> 00:01:45,366
为了得到一个
to get a

22
00:01:48,066 --> 00:01:52,866
在线程arena的arena元数据中
in the arena metadata of the thread arena

23
00:01:53,300 --> 00:01:56,200
它就位于perthread_struct之前
which is immediately before the perthread struct

24
00:01:56,466 --> 00:01:58,166
它里面有个libc中的地址
there is an address to libc 

25
00:01:58,266 --> 00:02:02,366
所以现在我们知道了一个libc中的地址
so we know the address of a libc address right

26
00:02:02,866 --> 00:02:04,533
接下来呢
so what's next all right

27
00:02:05,966 --> 00:02:07,966
为了找到接下来的方向
in order to really reason about what's next

28
00:02:07,966 --> 00:02:09,333
我们需要一个最终目标
we need an end goal right

29
00:02:09,333 --> 00:02:11,733
先假定一个最终目标
and end goal let's arbitrarily 

30
00:02:12,333 --> 00:02:14,399
当然，到那时一切都会清楚的
of course it'll all become clear then 

31
00:02:14,766 --> 00:02:16,766
我们想获得flag
but let's say of course we want to get the flag 

32
00:02:17,033 --> 00:02:22,933
但没有一个便于我们获得flag的win函数
there is no convenient win function that will give us the flag

33
00:02:23,100 --> 00:02:25,000
换句话说
or putting in other ways 

34
00:02:25,133 --> 00:02:30,533
简单地修改程序逻辑，无法实现目标获得flag
we can't suddenly corrupt the logic of this program to give us the flag to achieve our goals

35
00:02:30,866 --> 00:02:35,599
我们要完全控制这个程序
so we want to hijack the program completely

36
00:02:35,933 --> 00:02:39,266
我们这样做是因为没有
we do this because there is no

37
00:02:39,800 --> 00:02:41,566
因为所有的保护机制都启动了
because all the mitigations are on 

38
00:02:41,866 --> 00:02:43,999
栈是不可执行的，等等
the stack is non executable etc etc 

39
00:02:44,200 --> 00:02:52,200
我们只能用ROP来控制这个程序
our remaining path forward is to use a rop chain to take over the program

40
00:02:52,200 --> 00:02:58,600
拼凑gadget来泄露出flag
and piece together gadgets to leak the flag

41
00:02:58,933 --> 00:03:02,299
为了做到这一点，我们需要
so in order to do that we need to

42
00:03:02,400 --> 00:03:04,333
或者说，知道libc的地址很有帮助
or it really helps to know where libc is

43
00:03:04,700 --> 00:03:09,400
所以接下来的一步是找到libc的地址
so let's say our immediate next step is to figure out where the address of libc

44
00:03:09,700 --> 00:03:12,600
libc被加载到进程内存的位置
where libc is loaded in memory in the process 

45
00:03:12,733 --> 00:03:17,566
幸运的是，我们知道libc中的一个地址
luckily as i said we know the address of an address of libc

46
00:03:18,400 --> 00:03:26,400
在线程arena元数据中有一个指针，指向libc中的main_arena
in the arena metadata there's a pointer back to the main arena in libc awesome

47
00:03:26,600 --> 00:03:30,500
为了利用这一点，我们将
so to exploit this we are going to

48
00:03:30,500 --> 00:03:34,266
或者说，为了向泄露flag迈进一步
or to get closer to leaking the flag

49
00:03:34,266 --> 00:03:37,699
我们将在这节课中讨论
we are now going to in this lecture talk about 

50
00:03:37,766 --> 00:03:40,833
我们所谓的任意读原语
what we are going to call an arbitrary read primitive

51
00:03:41,100 --> 00:03:44,466
我们将用它找出libc的地址
that we will use to figure out where libc is

52
00:03:46,066 --> 00:03:47,833
那么什么是原语
all right so what's a primitive

53
00:03:48,800 --> 00:03:52,266
这里漏洞利用原语
a primitive is an exploitation primitive

54
00:03:52,266 --> 00:03:54,366
大意是
is a word that basically means

55
00:03:54,466 --> 00:03:58,966
一种攻击者可重复使用的功能
a reusable capability that an attacker can use

56
00:03:59,200 --> 00:04:06,466
它通常组合利用了一堆漏洞
through often by combining a bunch of vulnerabilities

57
00:04:06,566 --> 00:04:15,166
通常是以复杂的方式，通过组合一堆程序逻辑，误用等等
and often complex ways by combining a bunch of program logic misusing it etc etc

58
00:04:15,200 --> 00:04:17,800
来实现一个单纯的目标
 to achieve a simple goal

59
00:04:18,100 --> 00:04:20,200
原语有各种各样的
primitives come in all shapes and sizes

60
00:04:20,200 --> 00:04:22,766
但常见的有任意读原语
but common ones are an arbitrary read primitive

61
00:04:23,066 --> 00:04:24,833
如果你有一个任意的读原语
so if you have an arbitrary read primitive

62
00:04:24,966 --> 00:04:31,799
这表示有一个可复用的功能
that is an reusable capability

63
00:04:32,000 --> 00:04:37,700
它能让作为攻击者的你泄露任意地址的内存
that will allow you as an attacker to disclose memory at an arbitrary address

64
00:04:37,900 --> 00:04:41,300
还有任意写原语，有时称为写-什么-到哪里
arbitrary write primitive sometimes known as a write-what-where

65
00:04:41,466 --> 00:04:43,099
能让作为攻击者的你
will allow you as an attacker

66
00:04:43,166 --> 00:04:49,199
将受控数据写入受控地址
to write some controlled piece of data to some controlled address

67
00:04:49,366 --> 00:04:50,633
还有任意调用原语
an arbitrary call privilege 

68
00:04:50,700 --> 00:04:51,933
如果作为攻击者的你
imagine if you as an attacker 

69
00:04:51,933 --> 00:04:54,099
覆盖了一个稍后会被调用的函数指针
overwrote a function pointer and that was later called

70
00:04:54,200 --> 00:04:57,700
能让你调用任意函数
will allow you to call arbitrary functions

71
00:04:58,533 --> 00:05:01,299
有各种各样的原语
there are all sorts of different primitives

72
00:05:01,300 --> 00:05:05,600
例如，能将零写到任意地址的原语
you might have a write zero wherever you want primitive for example

73
00:05:05,600 --> 00:05:10,500
但最想要的还是任意读、任意写、任意调用
but the kind of holy grail is arbitrary read arbitrary write arbitrary call and jump

74
00:05:10,566 --> 00:05:12,199
也有一些替代品
there're also relative alternative

75
00:05:12,300 --> 00:05:15,533
有时运气不够覆盖一个指针
sometimes you're not lucky enough to overwrite a pointer 

76
00:05:15,566 --> 00:05:19,999
但正好可以覆盖一个偏移值
you are however lucky enough to overwrite a offset

77
00:05:20,000 --> 00:05:22,966
或者你能控制大小值，之类的
or you can control a size or something along these lines

78
00:05:24,500 --> 00:05:30,500
在这几种原语的相对替代品中
and in these relative alternatives to these various primitives

79
00:05:30,600 --> 00:05:35,933
攻击者可以控制一个要加到指针的值
the attacker can control some value that's added to a pointer

80
00:05:35,933 --> 00:05:37,633
这也是非常强大的
this is also very powerful 

81
00:05:37,666 --> 00:05:42,133
但显然没有完全控制指针那么强大
but obviously not as powerful as being able to control a pointer completely

82
00:05:42,333 --> 00:05:45,399
我一直强调，这些漏洞利用原语是可复用的
and these exploit primitives i keep saying reusable

83
00:05:45,500 --> 00:05:49,300
它们被用作构建利用程序的模块
they're used as building blocks of exploits

84
00:05:49,300 --> 00:05:52,066
一个利用程序
and an exploit with these

85
00:05:54,900 --> 00:05:59,700
使用这些原语的过程，就像程序开发
when using these primitives becomes kind of like a program in itself

86
00:05:59,700 --> 00:06:04,700
不再只是读这个，写那个，读什么的
it's no longer just you know read this write that read or whatever

87
00:06:05,000 --> 00:06:08,066
不再只是单纯调用pwntools的send、read_until
send read_until send read_until in pwntools

88
00:06:08,200 --> 00:06:13,400
现在是调用函数，如arbitrary_read并传参数之类的
now you're calling functions arbitrary underscore read with arguments and so forth

89
00:06:13,600 --> 00:06:19,166
它变成了一种软件开发
 it's kind of becomes a software development sort of life

90
00:06:19,900 --> 00:06:23,800
但这就是复杂利用程序的制作方法
but this is how complex exploits are made

91
00:06:23,900 --> 00:06:25,733
你实现一个原语
you achieve this primitive

92
00:06:25,733 --> 00:06:27,566
然后把它封装在一个函数中
and then you encapsulate it in a function

93
00:06:27,566 --> 00:06:30,166
这样就能在利用脚本中调它
so you can call in your exploit script

94
00:06:30,300 --> 00:06:31,266
你可以调用这个函数
you can call that function

95
00:06:31,300 --> 00:06:34,566
以便于更简单地思考整个利用过程
so that you can reason about your exploit easier all right

96
00:06:34,833 --> 00:06:36,600
我们来讨论一下任意读
so let's talk about arbitrary read specifically

97
00:06:36,600 --> 00:06:40,033
具体是以这个程序为背景讨论
specifically in the context of this application

98
00:06:41,400 --> 00:06:48,900
这个程序，如我们所见，因为竞争条件，没有安全地使用堆
this application as we saw because of race conditions uses the heap unsafely

99
00:06:49,300 --> 00:06:52,166
单线程，它对堆的使用是安全的
single threaded it will be safe heap wides

100
00:06:52,300 --> 00:06:55,233
多线程，一下就有了问题
multi threaded suddenly we have problems 

101
00:06:55,366 --> 00:07:02,499
在动态分配器误用模块中，已经做过了堆利用
so of course you have done heap exploitation in the dynamic allocator misuse module

102
00:07:02,766 --> 00:07:05,466
进行了很多次tcache poisoning
and you did a lot of tcache poisoning

103
00:07:05,466 --> 00:07:06,999
在这里也可这么做
and you can apply that here

104
00:07:07,100 --> 00:07:10,766
想象一下，要tcache poisoning攻击
so imagine tcache poisoning attack

105
00:07:11,066 --> 00:07:16,800
使用malloc free scanf malloc malloc
you use malloc free scanf malloc malloc

106
00:07:16,933 --> 00:07:18,633
哦，我漏了一个free
oh i missed a free here actually

107
00:07:18,866 --> 00:07:21,533
我马上改一下，别误导你们
let me fix that real quick so you're not confused one second

108
00:07:22,800 --> 00:07:24,566
不，等等，我没漏
no wait no i didn't

109
00:07:25,166 --> 00:07:27,199
没误导
i didn't so you 

110
00:07:27,700 --> 00:07:29,366
我们重来，仔细过一遍
actually let's run through this in detail

111
00:07:29,533 --> 00:07:36,900
通过恶意利用tcache，能强行获取一个已控内存
basically by abusing the tcache we'll be able to force an allocation that we control

112
00:07:37,300 --> 00:07:43,500
然后我们可以使用程序提供的printf功能
and then of course we can using the printf functionality in the program

113
00:07:43,600 --> 00:07:46,900
读出那个地址的数据
we can read out data of that address all right

114
00:07:46,900 --> 00:07:54,900
看一下如何针对这个消息服务器，完成上述利用
let's see how this will look in the context of this program which is a message server

115
00:07:54,933 --> 00:07:59,099
我们分配两条消息，消息a，消息b
so we allocate two messages message a message b 

116
00:07:59,166 --> 00:08:00,566
messages[1] messages[2]
message one message two

117
00:08:00,733 --> 00:08:06,466
我们创建了2个chunk，a和b
so we create a tcache emm allocated chunk a and b

118
00:08:06,466 --> 00:08:08,699
然后将两者都free掉
and then we free both of them right

119
00:08:08,700 --> 00:08:14,566
第一次free将b放入tcache时
and that first puts entry b in the tcache

120
00:08:14,566 --> 00:08:17,333
我们回退到释放b时
let's actually rewind when we free entry b

121
00:08:17,900 --> 00:08:23,100
将b放入tcache，并将该bin的计数置为1
puts entry b in the tcache adds sets the count of that bin to 1

122
00:08:23,900 --> 00:08:31,900
再将perthread_struct的地址放到该内存的第二个qword中
and put the address of the perthread struct into the second 8 bytes of that allocation

123
00:08:31,966 --> 00:08:35,366
顺便一提，这就是我们上个视频中泄露的
this is what we leaked out by the way in the last video

124
00:08:36,133 --> 00:08:38,599
然后将next设为空
and then sets the next pointer to null

125
00:08:38,600 --> 00:08:42,933
因为此时它是这个bin中唯一的chunk
because it is the only thing in that tcache bin 

126
00:08:43,166 --> 00:08:47,133
当我们释放存储在message[1]中的a时
when we free a which was stored in message 1

127
00:08:48,066 --> 00:08:51,733
我们实际上是把它插入到该列表的头部
we actually insert that into the head of the list

128
00:08:51,733 --> 00:08:54,699
所以head指针指向a
so the first entry points to a

129
00:08:54,733 --> 00:08:57,333
然后a指向b
and then a points to b okay

130
00:08:57,700 --> 00:09:06,266
然后我们想往a，即消息1中，写入一个任意地址
and then of course we want to scanf into a into our message one an arbitrary address 

131
00:09:07,333 --> 00:09:11,333
这将使tcache示意图变成这样
that will then make the tcache conceptually look like this

132
00:09:11,566 --> 00:09:13,999
在这个任意地址处，有一些数据
right at this arbitrary address there's some data

133
00:09:14,266 --> 00:09:18,266
这个例子中，我们要读的是存在这儿的b和c
in this example is b and c that is stored that we want to read

134
00:09:20,066 --> 00:09:21,533
我们有
we have our

135
00:09:22,866 --> 00:09:25,566
我们用指向它的地址值覆盖了a的next
we overwrote the next pointer of a with address to that

136
00:09:25,566 --> 00:09:28,466
现在bin链表可以说是被劫持了
and so now the link list has kind of been hijacked

137
00:09:28,466 --> 00:09:30,466
然后malloc两次
and then of course we malloc twice

138
00:09:30,533 --> 00:09:33,699
当第一次malloc时，a返回给了我们
 when we malloc once  we receive a back 

139
00:09:33,833 --> 00:09:39,199
注入的地址被写入到了链表的head中
and the injected address actually gets put into the head of the list

140
00:09:39,200 --> 00:09:40,466
当我们再次malloc时
when we malloc again

141
00:09:40,700 --> 00:09:43,533
注入的地址将返回给我们
the injected address gets returned to us

142
00:09:44,500 --> 00:09:54,900
但不幸的是，第二个8字节的会被清空
but unfortunately the second 8 bytes of that address is nulled out

143
00:09:55,166 --> 00:09:58,699
在申请chunk时，它会把存储的perthread地址清零
when you allocate something it nulls out this perthread 

144
00:09:58,900 --> 00:10:03,433
当申请一个在tcache中的，已释放的chunk
when you allocate a previously freed tcache entry 

145
00:10:04,266 --> 00:10:08,733
正如以前看到的，它将把第二个8字节清空
it will null out those second 8 bytes as we observed in the heap allocation module

146
00:10:09,066 --> 00:10:11,299
到目前为止，还都是babyheap的内容
so this so far is all babyheap 

147
00:10:11,500 --> 00:10:16,666
还都是在动态分配器误用模块学到的内容
it's the heap the dynamic allocator misuse module that we have come to know and love

148
00:10:17,000 --> 00:10:19,400
那么任意读取在哪里
so where is the arbitrary read

149
00:10:19,733 --> 00:10:24,733
使用这个printf，我们可以打印出结果
with this printf we can print out the resulting

150
00:10:28,400 --> 00:10:31,133
就是我们想要的目标地址的数据
the data at the address that we want to gain

151
00:10:31,300 --> 00:10:32,633
这就是我们的任意读
and that is our arbitrary read 

152
00:10:32,766 --> 00:10:36,599
选一个任意地址，就可以读里面8个字节
we chose an arbitrary address and we can read 8 bytes from it

153
00:10:39,166 --> 00:10:40,333
问题是什么呢
what's the problem 

154
00:10:40,400 --> 00:10:42,866
当然，问题在于服务器很小心
of course the problem is that the server is careful 

155
00:10:43,066 --> 00:10:47,866
在释放消息时，它会将其状态设置为未存储
when it frees a message it'll set it as not currently stored

156
00:10:48,300 --> 00:10:54,500
如果是未存储，它会拒绝scanf该消息
then it will refuse to actually scanf into that message if it is not stored 

157
00:10:54,500 --> 00:10:59,700
相反，它就会scanf
instead it'll just scanf into a buffer does not used anymore in that loop

158
00:11:00,133 --> 00:11:03,366
乍一看，完蛋了（被防住了）
so on the face of it we're screwed

159
00:11:03,366 --> 00:11:06,999
但由于竞争条件，情况并非如此
but that's not the case again because of race conditions

160
00:11:07,166 --> 00:11:11,599
我们要与分配竞争，说错了，抱歉
so we're going to race the allocation no sorry

161
00:11:11,700 --> 00:11:18,000
我们要让scanf与free竞争
we're going to race the scanf against the free

162
00:11:18,000 --> 00:11:20,966
我们希望达到的状态是
and what we are hoping to accomplish is that

163
00:11:21,533 --> 00:11:24,199
当我们free时
when we try to free 

164
00:11:24,433 --> 00:11:27,099
我刚意识到，我可以更好地展示给你们看
actually i just realized i can show you this much better

165
00:11:27,100 --> 00:11:30,300
我改一下，这样好多了
so let me do that alright that's much better

166
00:11:30,500 --> 00:11:34,200
我们能用提供的free去竞争
so we can actually race using the free action 

167
00:11:34,266 --> 00:11:39,166
它先释放内存，再将stored置0
which frees the message and then sets the stored bit to 0 

168
00:11:39,766 --> 00:11:42,433
而scanf会检查stored
and the scanf which checks the stored bit 

169
00:11:42,766 --> 00:11:47,633
如果它被置为1，就会写入message
and if it is set if it is 1 actually writes into the message

170
00:11:47,833 --> 00:11:53,299
通过让这两个操作竞争
using by racing these two actions

171
00:11:53,800 --> 00:12:03,000
使scanf运行在，释放内存和stored置0之间
and getting the scanf to run in between the free and the unsetting of the stored byte

172
00:12:03,300 --> 00:12:07,333
然后我们就能利用scanf
then we can actually get a scanf 

173
00:12:07,400 --> 00:12:11,400
来覆盖我们之前不能覆盖的地址
to overwrite that address before we are no longer allowed to 

174
00:12:12,000 --> 00:12:14,400
我们来实践一下
so let's do that

175
00:12:16,733 --> 00:12:18,166
我们先演示
actually let's do that first 

176
00:12:18,400 --> 00:12:23,033
然后我们再看一些存在的问题
and then we'll go and look at some gotchas 

177
00:12:23,166 --> 00:12:31,599
好的，这是上个视频的程序
all right so this is our program from last time right

178
00:12:31,600 --> 00:12:33,000
在上个视频中
from the last video where 

179
00:12:33,066 --> 00:12:39,933
通过free与printf的竞争，泄漏了perthread_struct地址
we were leaking the perthread struct by racing the free and the printf 

180
00:12:41,000 --> 00:12:45,166
现在我们来实现一个任意读
and now we're going to get a read

181
00:12:45,300 --> 00:12:47,133
我们已经泄露了perthread_struct的地址
so we leaked the perthread struct 

182
00:12:47,333 --> 00:12:57,399
提醒一下，我们计算出了一个指向libc的指针的地址
as a reminder we actually computed the address where there was a libc pointer

183
00:12:58,066 --> 00:12:59,666
我们把它也打印出来
so let's print that out as well

184
00:13:01,700 --> 00:13:10,400
现在也知道了一个指向libc中main_arena的指针的地址
all right so now you have the address of a pointer into the main arena in libc which is in libc

185
00:13:10,566 --> 00:13:11,099
太棒了
awesome 

186
00:13:11,533 --> 00:13:17,799
我们来实现一个任意读原语
so let's get an arbitrary read primitive

187
00:13:18,700 --> 00:13:23,066
我们把这个函数命名为arbitrary_read
and we're just gonna call this function arbitrary read alright

188
00:13:24,100 --> 00:13:30,600
当然，我们要做的类似于leak_perthread_addr
we're gonna of course similar to our the leaking of the perthread

189
00:13:30,700 --> 00:13:35,700
我们将传给他2个连接，用于竞争
we're going to pass it two connections that it'll use to do the race

190
00:13:35,800 --> 00:13:43,166
还有我们想读取的地址
and basically the address that we want to leak right

191
00:13:43,366 --> 00:13:47,866
好极了，除了这些
awesome all right so other than that 

192
00:13:48,033 --> 00:13:51,866
我们会按照之前的计划行事
we're going to do exactly our prior game plan

193
00:13:55,200 --> 00:13:56,566
在我们开始之前
before we get started 

194
00:13:56,933 --> 00:13:59,033
把管道清理一下
let's clean out the pipes 

195
00:13:59,066 --> 00:14:03,366
以防那里有东西在等待
just in case there's something waiting there

196
00:14:03,366 --> 00:14:08,499
导致我们在读取值时出问题
and it'll screw us up when we try to read the value whoops

197
00:14:11,066 --> 00:14:11,866
好的
okay

198
00:14:13,400 --> 00:14:21,300
打包好我们要读取的地址（转成小端序）
let's of course pack the address that we want to read

199
00:14:22,466 --> 00:14:23,733
把这个改成addr
let's make this addr

200
00:14:24,100 --> 00:14:27,566
为了节省时间，我会拷贝我写好的脚本
to save time i'm copy pasting of a script i wrote 

201
00:14:28,766 --> 00:14:32,733
这样你们就不用等我打字了
so that you don't have to wait for me to type 

202
00:14:32,866 --> 00:14:36,499
还是不要这么做了
but actually let's not do that all right so

203
00:14:38,133 --> 00:14:43,966
如你所见，你需要malloc 2次
as we saw you're going to have to allocate two allocations

204
00:14:44,066 --> 00:14:45,799
我们执行了 malloc 1 malloc 2
we did a malloc 1 malloc 2

205
00:14:45,900 --> 00:14:55,400
这样我们最终会得到一个链表
so that we end up when we free them with that awesome link list

206
00:14:55,566 --> 00:14:58,833
然后我们就可以覆盖head的next指针
that we can overwrite the next address of the first entry of

207
00:14:58,966 --> 00:15:02,566
我们先释放chunk2
we're going to free the second one

208
00:15:02,566 --> 00:15:03,833
再释放chunk1
and then we'll free the first one 

209
00:15:03,900 --> 00:15:09,933
当然，我只是依照这里的计划行事
and of course i'm just going by our game plan right here

210
00:15:11,666 --> 00:15:13,599
这是我们的计划
here's the game plan we're gonna have 

211
00:15:14,466 --> 00:15:15,733
实际上让我们
and actually let's 

212
00:15:15,733 --> 00:15:18,233
这是我们要达到的效果
there so this is what we'll end up with 

213
00:15:18,433 --> 00:15:21,566
获得2个chunk，先释放chunk2
gonna get two allocations we'll free 2 

214
00:15:21,833 --> 00:15:26,266
我们想让第二次free与scanf竞争，再从这里执行下去
we want to race this second free against the scanf and go from there

215
00:15:26,766 --> 00:15:28,699
我们回到终端
so let's get back to the terminal

216
00:15:29,633 --> 00:15:33,899
tcache中有一个chunk，malloc 1 malloc 2 free 2
so we have one allocation malloc one malloc two free two

217
00:15:35,533 --> 00:15:37,999
然后持续尝试竞争
then we're gonna keep trying to race

218
00:15:38,000 --> 00:15:42,700
这个竞争不容易成功
so the race isn't gonna be extremely likely to succeed

219
00:15:42,700 --> 00:15:46,800
尝试在free和修改store状态之间，切走去scanf
we're trying to get right between the free and the store

220
00:15:47,033 --> 00:15:51,733
这里的指令不是很多
this is not a lot of instructions to get

221
00:15:54,500 --> 00:15:59,900
要在这中间，切出free线程
in which the free thread can get discheduled 

222
00:16:00,133 --> 00:16:03,999
执行scanf线程
our scanf thread can get run and so forth

223
00:16:04,000 --> 00:16:06,900
所以我们要运行很多次
so we're going to have to run multiple times 

224
00:16:07,100 --> 00:16:13,100
当然，在疯狂fork python进程的同时
and of course simultaneously by using this insane forking of the python processor

225
00:16:13,200 --> 00:16:21,200
我们将发送第二次free， free 1
we're going to send both the free of course that second one

226
00:16:22,266 --> 00:16:24,766
我们要发送它很多次
and we actually want to send a lot of this

227
00:16:25,166 --> 00:16:28,933
因为我们尝试一次又一次的释放它
because we want to have a trying freeing over and over

228
00:16:29,133 --> 00:16:34,566
然后scanf需要命中第一个free
and then our scanf needs to hit that first free

229
00:16:39,900 --> 00:16:42,466
实际上，我觉得不用
actually so i guess this doesn't 

230
00:16:42,666 --> 00:16:44,866
其他free没有用
other frees won't do anything 

231
00:16:44,900 --> 00:16:47,466
只有第一次free有用
only the first free matters 

232
00:16:47,733 --> 00:16:50,966
我们这样做，我们在这里发送一个free
so let's do that so we send a free here

233
00:16:54,266 --> 00:16:57,333
我们再终止这个子进程
we will kill the that same process all right 

234
00:16:57,900 --> 00:17:01,566
然后在主线程或主进程中
and then in our main thread or main process

235
00:17:01,566 --> 00:17:04,733
我们会发送一堆scanf
we will send a bunch of scanfs 

236
00:17:04,966 --> 00:17:07,066
因为我们要scanf scanf scanf
because we want to do scanf scanf scanf

237
00:17:07,366 --> 00:17:10,899
那个free可能击中其中之一
and then that free that will hit in one of the

238
00:17:16,400 --> 00:17:18,500
一个线程执行free
one thread will do the free

239
00:17:18,566 --> 00:17:20,966
而另一个线程在执行这些scanf
while the other thread is doing all these scanfs 

240
00:17:21,233 --> 00:17:29,499
导致竞争，希望能如我们在这张ppt上看到的
will have a race and as we saw on this slide will be hopefully

241
00:17:29,699 --> 00:17:31,399
好的
alright so

242
00:17:35,033 --> 00:17:37,066
发送scanf
send scanf 

243
00:17:37,533 --> 00:17:45,066
要输入的idx，不对，我们知道idx
and we want to put in the index no index we know the index 

244
00:17:45,466 --> 00:17:46,799
我们scanf 1
we want to scanf one

245
00:17:47,300 --> 00:17:52,166
然后输入打包好的地址，还有一个换行符
and we want to put in our packed address and a new line

246
00:17:52,300 --> 00:17:53,933
乘以2000，好的
times 2000 all right

247
00:17:54,200 --> 00:17:58,133
这里竞争，wait一下
so we hit that let's do wait here

248
00:17:59,333 --> 00:18:10,099
给点时间，处理这些scanf
now let's give everything some time to actually process all of these scanfs

249
00:18:10,600 --> 00:18:17,966
然后看一下攻击成功了没
and then we check to make sure that the attack worked

250
00:18:17,966 --> 00:18:19,933
我们要做的是
so what we're going to do is

251
00:18:23,300 --> 00:18:28,100
我们malloc一下，希望返回chunk的next被覆盖了
we're going to malloc that guy that we hopefully just overwrote the next point

252
00:18:28,333 --> 00:18:31,566
我们malloc一下，拿到chunk a
we will malloc an allocation to receive chunk a 

253
00:18:31,733 --> 00:18:35,733
希望我们已经覆盖了chunk a的next指针
hopefully we have just overwritten the next pointer of chunk a

254
00:18:36,766 --> 00:18:40,899
然后我们输出chunk a
we'll printf chunk a then

255
00:18:42,900 --> 00:18:52,900
再取出直到换行符的输出
we'll just retrieve the message up to the new line

256
00:18:53,166 --> 00:18:54,499
最后确认一下
and we'll confirm

257
00:18:55,200 --> 00:18:57,866
我复制粘贴一下，这个打起来很麻烦
i'll copy paste this because it's annoying to type

258
00:18:57,900 --> 00:19:06,300
我们确认一下，这个tcache没清零的next指针
we'll confirm that the next address which tcache doesn't clear out is

259
00:19:08,900 --> 00:19:11,933
当chunk给到我们时
when the chunk gets returned to us

260
00:19:12,000 --> 00:19:14,666
我们要确认一下它的next是否被正确覆盖
we'll confirm that the next address is properly set

261
00:19:14,766 --> 00:19:17,933
如果覆盖成功，就跳出循环
if it's properly set we're done and then we can break

262
00:19:18,066 --> 00:19:19,099
如果没覆盖成功
 if it's not properly set

263
00:19:19,100 --> 00:19:20,800
说明竞争失败了
then we didn't win the race

264
00:19:20,933 --> 00:19:22,299
就重来，回到free 1
we're going to free one again 

265
00:19:22,666 --> 00:19:24,599
我们刚刚malloc 1，所以这没问题
we just malloced it so that's perfectly fine

266
00:19:24,600 --> 00:19:27,433
然后再试一次scanf
and try again with our scanf

267
00:19:28,133 --> 00:19:30,899
这个竞争有个好处，他很安全
so the nice thing is this race is very safe

268
00:19:31,400 --> 00:19:37,066
即使竞争失败，也不会导致进程崩溃
it will not kill our process if we lose

269
00:19:37,066 --> 00:19:38,766
这很好
which is great okay

270
00:19:39,066 --> 00:19:41,799
当成功后
so when we're done here

271
00:19:41,800 --> 00:19:47,733
我们要再malloc chunk b
we're going to malloc our second chunk b 

272
00:19:47,866 --> 00:19:52,299
我们要等它发生
and we are going to wait for that to actually happen

273
00:19:52,400 --> 00:19:56,500
我在这里用clean，我也可以用time.sleep
i use .clean here i could also use time.sleep

274
00:19:56,500 --> 00:19:58,100
clean会休眠一小会
.clean sleeps a tiny bit

275
00:19:58,266 --> 00:20:03,133
这就够malloc一次了
and that's all we really need to get one allocation done

276
00:20:03,900 --> 00:20:08,500
然后再发送printf
and we're going to send the printf

277
00:20:15,900 --> 00:20:21,900
用同样代码解析出目标地址的值
and read it out using this same code

278
00:20:24,300 --> 00:20:25,133
太棒了
awesome

279
00:20:31,666 --> 00:20:34,566
我粘贴一下代码
let me just paste this code and

280
00:20:36,700 --> 00:20:41,833
我们要从小端序转成字符串
we're going to unpack it

281
00:20:42,000 --> 00:20:46,733
取出8字节，转成可读的，返回它
 we'll get 8 bytes unpack it and return that 

282
00:20:46,933 --> 00:20:48,766
现在有了一个函数
so now we have a function

283
00:20:48,800 --> 00:20:51,266
这个函数会完成一个任意读
and this function will do an arbitrary read

284
00:20:52,800 --> 00:20:54,833
我们可以重复执行它
and we can run it over and over

285
00:20:55,333 --> 00:20:56,966
我们执行一下这个arbitrary_read
let's do this arbitrary read

286
00:20:57,500 --> 00:21:00,633
如果想要main_arena_address
so if you want the main arena address

287
00:21:01,066 --> 00:21:02,033
我们来获取它
let's get it 

288
00:21:05,833 --> 00:21:12,899
执行 arbitrary_read(r1, r2, main_arena_ptr_address)
we will arbitrary_read r1 r2 main_arena_ptr_address

289
00:21:12,966 --> 00:21:16,499
我们传入指向main_arena指针的地址
so we send in the address of the pointer to the main arena

290
00:21:16,600 --> 00:21:24,400
就能拿到泄露出的main_arena_address
and we will get back a leaked main arena address

291
00:21:26,300 --> 00:21:29,200
如果第一次就成功了，那就太不可思议了
and if this works on the first try that'll be insane 

292
00:21:29,233 --> 00:21:30,233
大概率不会
but it likely won't

293
00:21:31,500 --> 00:21:36,133
sendline我竟然写成了sendfile
so instead of sendline i did sendfile that's weird

294
00:21:36,333 --> 00:21:38,366
我们kill这个进程
let's kill that process 

295
00:21:38,766 --> 00:21:40,566
我们先这样
actually here let's do this

296
00:21:40,900 --> 00:21:48,233
我们在启动进程前，先尝试kill一下
we're going to try to kill that process before we started up

297
00:21:48,466 --> 00:21:51,533
太棒了，好的
awesome okay um

298
00:21:53,400 --> 00:21:55,166
sendline在哪里
where's that sendline

299
00:21:55,733 --> 00:21:56,866
你们都没警告我
you didn't warn me

300
00:21:56,866 --> 00:21:58,066
一个都没警告我
none of you warned me

301
00:21:58,366 --> 00:21:59,499
期待你找到它（估计是读评论）
hoping you'd catch it 

302
00:21:59,633 --> 00:22:00,566
哦，我开个玩笑
oh just kidding

303
00:22:02,233 --> 00:22:03,966
哦，sendfile在这儿
oh sendfile

304
00:22:05,066 --> 00:22:05,866
太棒了
awesome

305
00:22:06,666 --> 00:22:08,366
好的，我们再试一下竞争
okay we're trying the race

306
00:22:13,533 --> 00:22:15,299
时间比预期的长
taking longer than expected 

307
00:22:15,433 --> 00:22:17,133
有时用时确实会比预期的长
sometimes it takes longer than expected

308
00:22:17,399 --> 00:22:21,866
但也可能是一个信号，表明这行不通
but could also so be a sign that it's not gonna work

309
00:22:33,866 --> 00:22:34,699
有趣
fascinating

310
00:22:38,700 --> 00:22:40,333
稍等
oh wait

311
00:22:41,766 --> 00:22:42,666
怎么回事
what was it

312
00:22:42,866 --> 00:22:49,199
停在readline了
it was sitting on readline

313
00:22:49,533 --> 00:22:52,066
sendline我写成了readline
i did readline instead of sendline

314
00:22:56,300 --> 00:22:57,800
不不不，这里是对的
no no no this is right

315
00:23:01,900 --> 00:23:05,100
哦，不不不不，这里没问题
oh no no no no no this is all good 

316
00:23:05,200 --> 00:23:06,266
不，不在这里
no it's not here

317
00:23:06,866 --> 00:23:08,099
这里应该是sendline
this should be sendline

318
00:23:10,366 --> 00:23:11,166
好的
okay

319
00:23:15,200 --> 00:23:17,533
如果你看到明显的错误，请说出来
please say something if you saw something that was obviously wrong

320
00:23:33,500 --> 00:23:38,433
我们没竞争成功
we're not winning the race we're not winning the race 

321
00:23:39,533 --> 00:23:41,566
哦，这里我没发送换行符
oh i didn't send a new line here

322
00:23:41,666 --> 00:23:42,733
这里应该是sendline
this should be sendline

323
00:23:42,733 --> 00:23:44,533
所以它从未真正开始处理它
so it never actually started processing it 

324
00:23:45,466 --> 00:23:46,933
我们再试一下，成功
let's try that boom

325
00:23:47,866 --> 00:23:50,499
我们写出了正确的脚本，我们竞争成功了
we make a correct script we win the race

326
00:23:50,600 --> 00:23:55,733
我们竞争成功了，执行了printf
so we won the race we did our amazing printf 

327
00:23:56,200 --> 00:24:02,966
现在我们泄露出了一个指向libc中main_arena的指针
and now we have leaked a pointer into the main arena which is inside libc

328
00:24:03,866 --> 00:24:05,533
我们先看些存在的问题
all right let's get to some gotches

329
00:24:05,533 --> 00:24:07,299
再看看它们的含义
and then we'll look at the implications 

330
00:24:08,133 --> 00:24:09,499
有几个问题
some gotches

331
00:24:10,066 --> 00:24:13,599
一是我们有
one is we have

332
00:24:17,500 --> 00:24:18,666
蒙住了
brain dump 

333
00:24:18,833 --> 00:24:24,933
一是在泄露libc地址的同时，破坏了堆元数据
one is that we have now corrupted the heap metadata alongside leaking out that address of libc

334
00:24:26,200 --> 00:24:31,300
我们已经将libc里的地址写到了tcache的head指针
we have also set that address of libc as the next entry in the tcache struct right

335
00:24:31,400 --> 00:24:33,733
这意味着如果count不为零
that means if count was not zero

336
00:24:34,366 --> 00:24:37,133
那么下次malloc将尝试返回这个地址
then the next malloc would try to return this entry

337
00:24:37,333 --> 00:24:40,533
再把第二个8字节归零
and then also zero out the second 8 bytes of it

338
00:24:40,699 --> 00:24:42,999
清零Ben（key指针）
to try to null out the beyond

339
00:24:43,000 --> 00:24:46,566
然后用第一个8字节覆盖head指针
and then take the first 8 bytes and overwrite the entry with it

340
00:24:46,566 --> 00:24:49,299
然后下一次malloc会返回这个地址
and then the next malloc would return those and so on right

341
00:24:49,300 --> 00:24:50,866
这样我们就劫持了这个链表
so we've hijacked that linked list

342
00:24:50,866 --> 00:24:53,866
我们需要理解它的含义
and we need to understand it as implications

343
00:24:54,300 --> 00:24:55,800
幸运的是，在这里count为零
luckily in this case the count is zero

344
00:24:55,966 --> 00:24:59,799
所以之后的malloc，将创建并返回个新chunk
so a future allocation will just be created as fresh chunks and given to us

345
00:24:59,866 --> 00:25:02,166
但并不总是这么幸运
but that's not always so lucky

346
00:25:03,800 --> 00:25:08,766
有一种情况
one thing that you can rely on in a situation 

347
00:25:08,766 --> 00:25:14,099
就是多线程下，有竞争条件，而且你还能创建线程
where there's multiple threads and there's a race condition and you can create new threads

348
00:25:14,400 --> 00:25:19,300
就像这里可以创建新连接，来创建新线程
like we can create here by creating a new connection

349
00:25:20,066 --> 00:25:24,499
每个线程都有自己的tcache元数据
each thread has its own tcache metadata

350
00:25:24,700 --> 00:25:27,100
Tcache是指线程缓存
tcache means thread cache

351
00:25:27,100 --> 00:25:31,100
正如其名，它是每个线程都有的
it's perthread like this perthread struct implies

352
00:25:31,100 --> 00:25:34,800
如果你断开一个连接，再新建个
so if you just disconnect from one connection and new connect from another one

353
00:25:35,266 --> 00:25:40,333
你就有了一个新的tcache
you have a new tcache and you're good to go

354
00:25:40,333 --> 00:25:41,766
断开连接不是必须的
you don't even have to disconnect from the old one

355
00:25:41,766 --> 00:25:42,999
只需要新建个连接
just connect from the new one

356
00:25:43,000 --> 00:25:47,866
事实上，我们用的两个连接都有自己的tcache
and in fact both of the connections we were using  actually had their own tcache 

357
00:25:47,966 --> 00:25:58,199
如果你注意观察r1里的所有chunk，就能发现
if you notice being careful to all the allocations on the first connection r1

358
00:25:58,400 --> 00:26:06,533
另个问题是，message现在指向libc内部
the other problem is that our message is now pointing to somewhere inside libc 

359
00:26:06,900 --> 00:26:12,100
我们控制了要读取内容的地址
so we controlled address that we're going to read stuff out of

360
00:26:12,100 --> 00:26:18,566
或者说，消息现在指向了perthread_struct
so or rather our message is now pointing to the perthread struct 

361
00:26:18,733 --> 00:26:22,199
而perthread_struct看起来不像chunk
the perthread struct doesn't look like a chunk right

362
00:26:22,700 --> 00:26:24,766
抱歉，它不是指向perthread_struct
sorry it's not points to the perthread struct 

363
00:26:24,833 --> 00:26:29,633
而是perthread_struct前，arena元数据中指向ibc的指针的地址
it's pointing before the perthread struct to where the arena metadata that had libc

364
00:26:29,766 --> 00:26:31,099
它看起来不像一个chunk
and that doesn't look like a chunk

365
00:26:31,566 --> 00:26:33,466
它没有chunk的正确元数据
it doesn't have the right metadata 

366
00:26:34,866 --> 00:26:37,966
所以当元数据
and so when that metadata

367
00:26:40,700 --> 00:26:42,500
当你试图free它时
when if you try to free it

368
00:26:43,533 --> 00:26:46,033
程序会崩溃
the whole program will crash

369
00:26:46,233 --> 00:26:52,966
因为当free的不是一个合法chunk，libc会恐慌
because libc will panic that what it is trying to free is not a valid chunk 

370
00:26:53,233 --> 00:26:54,899
看到异常的size，它崩溃了
it will look at that size and it will freak out

371
00:26:54,900 --> 00:26:56,766
它会中止这个程序
and it will abort the program

372
00:26:58,600 --> 00:27:01,533
解决办法是不要这样做
the solution is don't do that  

373
00:27:01,633 --> 00:27:03,299
不要重复
don't repeat it

374
00:27:04,066 --> 00:27:07,299
因为在这里，你不需要
because you don't need to in this case

375
00:27:07,300 --> 00:27:09,566
这里有很多很多的消息索引
there are many many message indexes right

376
00:27:09,566 --> 00:27:11,199
我来演示一下
so let me actually show you

377
00:27:14,933 --> 00:27:17,066
如果我想泄露点别的
if i try to leak out something else

378
00:27:17,066 --> 00:27:18,633
假设，我泄露了main_arena后
so let's say i leaked out the arena 

379
00:27:19,133 --> 00:27:23,399
我还想泄露
and i want to leak out something 

380
00:27:24,666 --> 00:27:27,566
我泄露了一个libc地址
actually at i leaked out a libc address 

381
00:27:27,900 --> 00:27:30,533
还想泄露这个地址里的东西
i want to leak out whatever was there

382
00:27:42,200 --> 00:27:44,266
我没调任意读来泄露
i didn't even leak it out 

383
00:27:44,466 --> 00:27:46,933
又大脑宕机了
that was a weird brain dump

384
00:27:54,700 --> 00:27:58,700
main_arena_address而不是main_arena_ptr_address
instead of main_arena_ptr_address just main_arena_address

385
00:28:03,666 --> 00:28:05,733
我们之前的，嗯，好了
our earlier okay there 

386
00:28:05,733 --> 00:28:09,566
有时竞争失败，也会崩溃
sometimes the races don't work and we crash okay

387
00:28:10,366 --> 00:28:11,133
开始吧
here we go

388
00:28:11,133 --> 00:28:16,566
正如你看到的，我在试着打印出main_arena_address
i was trying as you can see to print out the main arena address

389
00:28:17,500 --> 00:28:22,700
当我在这里发送malloc 1 printf 1时
and when i sent the malloc one printf one here

390
00:28:23,533 --> 00:28:24,833
它实际上
it actually 

391
00:28:25,033 --> 00:28:29,366
实际上，发送free 1，就开始坏起来了
actually when i sent the free one that's when shit really hit the fan

392
00:28:30,100 --> 00:28:38,700
但等发送这个时，它才发现服务挂了，管道已关闭
but it noticed when sending this that the program was dead the pipe was closed

393
00:28:38,733 --> 00:28:40,499
还有一个新的EOF错误
and there's a new end of file error 

394
00:28:40,733 --> 00:28:47,299
如果我打印程序输出，它提示我，释放了非法指针
if i read what the program wrote to me says free invalid pointer

395
00:28:49,133 --> 00:28:51,099
让我们在GDB中运行它
let's run this in gdb

396
00:29:06,500 --> 00:29:08,666
perthread struct（泄露）失败
the perthread struct failed 

397
00:29:09,100 --> 00:29:12,700
稍等，在GDB中跑一下
hold on run this in gdb

398
00:29:13,933 --> 00:29:17,866
好的，我们泄露出了main_arena
okay we leak the thing we leak the main arena 

399
00:29:17,866 --> 00:29:19,866
现在我们要试着泄露
and now we're gonna try to leak 

400
00:29:20,500 --> 00:29:21,366
啊，好了
ah and here we go

401
00:29:21,366 --> 00:29:22,933
我们触发了SIGABRT
we got that SIGABRT 

402
00:29:23,600 --> 00:29:30,200
回退到调用者，再回退，释放非法指针，再回退
let's go up up up free invalid pointer go up

403
00:29:31,866 --> 00:29:34,399
我编译时开启了调试符号，所以能看到这些
i compiled this with debug symbol so i could show you this

404
00:29:35,266 --> 00:29:38,466
我们当时正在释放messages[idx]
we are freeing messages index

405
00:29:39,766 --> 00:29:43,266
messages[idx]是我们的
messages index is our perthread 

406
00:29:44,133 --> 00:29:50,166
首先idx是1，额，2
first of all index is one as emm two

407
00:30:01,800 --> 00:30:04,166
哦，对对对，2. idx是2
oh yeah yeah yeah two index is two 

408
00:30:04,566 --> 00:30:08,566
这是我们
that is the index that we

409
00:30:14,333 --> 00:30:16,733
啊，在这里挂了
ah so died here actually even

410
00:30:18,300 --> 00:30:26,600
messages[2] 指向的是已经控制的地址
so 2 is the allocation that is controlled right

411
00:30:26,600 --> 00:30:35,300
我们就是用它指向的在线程arena中指向main_arena的指针
and that is what we pointed at the main arena pointer on our thread heap

412
00:30:37,500 --> 00:30:38,366
这就是它指向的地址
that's where it's pointing 

413
00:30:38,500 --> 00:30:40,133
当试图free它时
when we try to free this

414
00:30:41,000 --> 00:30:44,733
当然这里的地址，正是我们讨论的
of course the address here is an address as we discussed

415
00:30:44,733 --> 00:30:47,799
是我们在printf时泄露出的，指向main_arena的地址
is the address we leaked into the main arena when we did printf

416
00:30:48,200 --> 00:30:50,266
这就是我们泄露的信息
and that's in fact what we leaked

417
00:30:51,266 --> 00:30:54,966
但如果我们看一下元数据
but if we look at the metadata

418
00:30:54,966 --> 00:30:58,366
这个chunk的size，它存储在该地址-8字节处
the size metadata of this chunk which is stored 8 bytes back

419
00:30:58,366 --> 00:31:00,633
是0，这不是一个合法大小
is 0 that is not a valid size 

420
00:31:00,733 --> 00:31:04,199
当我们试图释放它时，libc就会崩溃
when we try to free it libc freaks out 

421
00:31:05,100 --> 00:31:07,566
这并不好，对吧
that is not good right

422
00:31:09,000 --> 00:31:14,566
所以如果可以的话，我们最好能让原语可复用
so we need to make primitives ideally if you can repeatable

423
00:31:14,700 --> 00:31:18,066
再次声明，好的软件实践意味着
again good software practice means that 

424
00:31:18,099 --> 00:31:22,799
如果你调用一个函数一次，你应该能够再次调用它
if you call a function once you should be able to call it again

425
00:31:23,000 --> 00:31:25,700
除非有什么明显的变化
unless something obvious has changed

426
00:31:26,766 --> 00:31:32,766
正如这张ppt上说的
so as we see from this slide of course

427
00:31:34,133 --> 00:31:35,133
我们已经把桥烧了
we've burned the bridge 

428
00:31:35,266 --> 00:31:38,499
messages[2]指向一个随机的地址
messages 2 specifically is pointing to some random stuff 

429
00:31:38,633 --> 00:31:39,899
这是ppt上的一个bug
this is a bug on the slide 

430
00:31:40,100 --> 00:31:44,100
我来修正一下，这样大家就不会感到困惑了
let me actually fix it so no one's confused all right

431
00:31:44,300 --> 00:31:46,933
所以messages[2]现在指向一些垃圾数据
so messages 2 is now pointing to some garbage data

432
00:31:47,166 --> 00:31:51,266
也不能说是垃圾数据，它指向libc内，这很好
not garbage data it's pointing to into libc which is great

433
00:31:51,600 --> 00:31:54,600
但它指向的东西看起来不像chunk
but it's pointing to something that doesn't look like a heap chunk

434
00:31:56,933 --> 00:32:02,099
所以我们可以这样修改我们的任意读原语
so we can actually change our arbitrary read primitive 

435
00:32:02,200 --> 00:32:05,266
就是每次使用不同的messages[idx]
to use different messages as time goes on

436
00:32:05,266 --> 00:32:10,333
我们更新一下，这很容易
so let's update that this is easy to do

437
00:32:10,600 --> 00:32:15,100
我们只要记录一下当前使用的idx
let's just keep track of what index it's currently on

438
00:32:16,100 --> 00:32:24,766
我们使用格式化字符串
and we'll just put in some format strings 

439
00:32:24,966 --> 00:32:31,266
来确保分配或释放了正确的idx
to make sure we allocate and free the right indexes

440
00:32:33,166 --> 00:32:35,199
这应该是一个格式化字符串
this should be a format string okay 

441
00:32:35,599 --> 00:32:38,899
这里应该是idx
here this should be index

442
00:32:39,866 --> 00:32:42,499
不幸的是，没有字节类型的格式化字符串
we can't have byte format strings unfortunately

443
00:32:42,500 --> 00:32:44,966
所以我们必须这样做
so we have to do that way all right 

444
00:32:45,433 --> 00:32:48,733
这是idx
here is the index

445
00:32:51,566 --> 00:32:53,799
这是idx + 1
and here is index plus one

446
00:32:58,400 --> 00:33:00,400
然后idx + 1被消耗掉了
and then index plus one is burned 

447
00:33:01,600 --> 00:33:05,066
意识到，我们不能再将它指向别处
realized we can't repoint it somewhere else

448
00:33:05,200 --> 00:33:10,100
所以现在我们要将idx加2
so now we're just going to incremented by 2

449
00:33:10,233 --> 00:33:11,766
将idx声明成全局变量
 let's declare this is a global

450
00:33:13,300 --> 00:33:24,400
为了让python知道要用全局变量idx而不是其它局部变量
just for so that python knows to use the global index versus some local variable

451
00:33:24,933 --> 00:33:27,299
每次调用arbitrary_read时
and this every time you're on arbitrary_read

452
00:33:27,433 --> 00:33:29,133
它会使用一组不同的idx
it will now use a different set of indexes 

453
00:33:29,466 --> 00:33:34,999
所以现在我们可以读到我们要的内容了
so now we can read memory to our harsh content

454
00:33:36,900 --> 00:33:37,700
发生了什么事?
what's going on

455
00:33:40,700 --> 00:33:43,900
哦，gdb挂起了服务
oh gdb is hugging things up

456
00:33:43,933 --> 00:33:45,733
我们把GDB关了
let's disable gdb here

457
00:33:46,133 --> 00:33:46,933
好的
alright

458
00:33:53,500 --> 00:33:54,266
哦
oops

459
00:33:54,266 --> 00:33:55,366
泄漏失败了
the leak failed

460
00:33:56,000 --> 00:33:57,566
所以我们可能
so we might have just

461
00:33:57,566 --> 00:33:59,899
可能有bug
we might have left the bug 

462
00:34:00,333 --> 00:34:02,133
连续两次泄漏失败
leak failed twice in a row

463
00:34:05,100 --> 00:34:07,900
perthread struct泄漏失败三次
perthread struct leak failed three times 

464
00:34:08,466 --> 00:34:09,066
泄漏失败
leak failed 

465
00:34:09,300 --> 00:34:10,600
好吧，肯定有bug
okay there's the bug somewhere 

466
00:34:10,866 --> 00:34:15,566
哦，忘了将这些字符串改成格式化字符串
oh yeah because we forgot to make these f strings

467
00:34:15,800 --> 00:34:17,600
还有其它字符串忘了的吗
anything else we forgot to make f strings

468
00:34:17,766 --> 00:34:19,933
我不这么认为，试试吧
i don't think so let's give that a try

469
00:34:24,300 --> 00:34:25,666
好的，泄漏成功
okay leak succeeded

470
00:34:28,800 --> 00:34:30,800
第二次泄漏还没有失败
the second leak is not failing yet

471
00:34:38,266 --> 00:34:39,666
不过花了很长时间
it's taking a long time though

472
00:34:44,700 --> 00:34:45,533
发生了什么
what's happening

473
00:34:50,733 --> 00:34:52,999
我一直在尝试，还在尝试
i was trying still trying

474
00:34:53,000 --> 00:34:53,800
发生了什么事?
what's going on

475
00:34:55,400 --> 00:34:58,166
free scanf 都没问题
we free scanf properly

476
00:35:12,300 --> 00:35:15,100
我们重启一下ipython
let's restart ipython

477
00:35:18,200 --> 00:35:19,000
哦
oh

478
00:35:22,933 --> 00:35:23,733
太棒了
awesome

479
00:35:24,000 --> 00:35:25,733
泄漏成功
so that leaked properly

480
00:35:25,733 --> 00:35:26,866
我是说它返回了
i mean it returned

481
00:35:26,866 --> 00:35:29,199
我马上会证明0是对的
i'll show you that the zero is actually correct

482
00:35:29,200 --> 00:35:31,966
刚刚应该是python卡住了
there must have been something stuck up with python

483
00:35:32,800 --> 00:35:39,100
可能是因为我们一直fork进程执行后台任务
probably because of the way that we're just yolo forking to run background tasks all right

484
00:35:39,266 --> 00:35:40,133
这样可行
so this works

485
00:35:40,266 --> 00:35:42,299
任意读原语可以执行多次了
arbitrary primitive works multiple times 

486
00:35:42,433 --> 00:35:48,433
我们用gdb看看，来证明给你看
let's grab gdb and actually explore to so i can convince you 

487
00:35:48,666 --> 00:35:51,033
好了，test 0x0
alright here we go test 0 

488
00:35:51,366 --> 00:35:53,433
该死，我关了它
ah shit and then i killed it

489
00:35:54,800 --> 00:35:56,766
重来
let me restart that

490
00:36:01,333 --> 00:36:02,866
泄露 test 0x0
leak test zero all right

491
00:36:03,533 --> 00:36:04,333
关了它
kill that

492
00:36:08,366 --> 00:36:09,899
这些是messages
here are the messages

493
00:36:10,966 --> 00:36:12,933
这是arena地址
here's the address of arena 

494
00:36:13,066 --> 00:36:15,666
能看到有message 1和2
and you can see now we have message one and two 

495
00:36:15,966 --> 00:36:20,699
这是用来泄露main_arena指针的
this is what was used to leak the main arena pointer from here

496
00:36:20,866 --> 00:36:23,666
然后是message 3和4
and then message three and four

497
00:36:23,700 --> 00:36:29,200
在message 4中，有地址
and in message four we have the address the 

498
00:36:29,566 --> 00:36:33,899
这就是我们泄露的值
this is what we leaked this value and whoops

499
00:36:34,300 --> 00:36:35,533
这是main_arena
here is main arena 

500
00:36:35,700 --> 00:36:38,300
main_arena里的头8字节是0
and what is there is a zero all right

501
00:36:39,366 --> 00:36:42,299
这就是任意读原语
so this is the arbitrary read primitive  

502
00:36:42,533 --> 00:36:43,699
我们成功了
we did it

503
00:36:45,600 --> 00:36:50,033
我们在这里暂停一下
we are going to pause here 

504
00:36:50,500 --> 00:36:52,766
实际上我要提一件事
actually i'll mention one thing 

505
00:36:53,000 --> 00:36:59,733
剩下的我会在下一集汇总视频中做
and then i will do the rest in the putting it all together video that's coming up next

506
00:36:59,966 --> 00:37:04,400
我要提的一件事是我们不仅能任意读
one thing i'll mention is we can go actually beyond the arbitrary read

507
00:37:04,600 --> 00:37:07,566
几乎不用怎么改
we can do the same almost the same thing

508
00:37:07,766 --> 00:37:10,866
只是最后不用printf，而用scanf
but instead of a printf we do a scanf

509
00:37:11,000 --> 00:37:13,166
瞬间，我们就有了一个任意写
and suddenly we have an arbitrary write

510
00:37:13,800 --> 00:37:15,700
这并不奇怪
right so it's not so rare

511
00:37:15,800 --> 00:37:18,500
因为这些原语很复杂
because of the complexity of a lot of these primitives

512
00:37:18,700 --> 00:37:25,500
这个原语结合了竞争条件与堆攻击
this primitive is a tricky race condition combined with a tricky heap attack

513
00:37:25,700 --> 00:37:32,500
对这个原语稍作改动就能实现各种功能并不奇怪
it is definitely not rare to have slight tweaks on these primitives that can accomplish multiple things 

514
00:37:32,500 --> 00:37:34,900
这里相比任意读
so here instead of an arbitrary read

515
00:37:34,933 --> 00:37:36,799
不printf了，改scanf
instead of a printf we do a scanf 

516
00:37:36,900 --> 00:37:39,666
瞬间，我们就能覆盖被控内存了
suddenly we overwrite the controlled allocation 

517
00:37:39,866 --> 00:37:43,199
当然，我们就有了一个任意写
of course that gives us an arbitrary write

518
00:37:43,466 --> 00:37:45,066
我们快速看一下
let's take a very quick look

519
00:37:46,333 --> 00:37:47,866
我们只要复制这个
so we're just gonna copy this

520
00:37:54,166 --> 00:37:55,999
实际我们可以粘贴它
and we can actually paste it

521
00:37:57,600 --> 00:38:00,666
改成arbitrary_write
and we can say arbitrary write

522
00:38:06,200 --> 00:38:08,033
所有这些都保持原样
all of this remains the same 

523
00:38:08,200 --> 00:38:12,733
除了这个printf改成scanf
except for this printf becomes a scanf 

524
00:38:13,766 --> 00:38:14,866
我们想要的是
and what we want 

525
00:38:15,000 --> 00:38:18,100
我们不能这样了，要那样
we can no longer use this we need to use something like this

526
00:38:25,500 --> 00:38:27,266
因为这里是字节字符串
cause we need the byte string

527
00:38:27,400 --> 00:38:32,966
所以我们要pack想要写入的值（转成小端序）
we need to pack the value that we want to write

528
00:38:36,866 --> 00:38:40,933
这里声明要写入的值，这里是任意写
i can put the value here and this is arbitrary write

529
00:38:42,500 --> 00:38:44,400
现在可以
and now you can do a

530
00:38:45,400 --> 00:38:46,166
我们做个测试
let's do a test 

531
00:38:46,366 --> 00:38:47,833
我们写入41
we'll write four one

532
00:38:51,600 --> 00:38:54,000
我们写入41414141
we'll do four one four one four one four one

533
00:38:58,666 --> 00:39:01,066
到libc中的main_arena地址
to the main arena address in libc

534
00:39:04,100 --> 00:39:06,800
aaaacccc
aaaacccc

535
00:39:07,266 --> 00:39:09,566
好的，按回车键
alright hit enter

536
00:39:12,766 --> 00:39:16,499
arbitrary_write接受三个参数，但给了四个
arbitrary_write takes three positional parameters but four were given 

537
00:39:16,933 --> 00:39:18,866
显然这不是我们想要的
obviously that is not what we want

538
00:39:22,366 --> 00:39:23,166
哦
oops

539
00:39:24,933 --> 00:39:27,099
我之前改了什么
what did i update

540
00:39:27,100 --> 00:39:28,133
啊偶，我写在这了
oops i put it

541
00:39:30,600 --> 00:39:32,300
这应该是arbitrary_read
this should be arbitrary read

542
00:39:32,300 --> 00:39:34,400
我的错
so my bad

543
00:39:39,366 --> 00:39:40,499
测试
test and

544
00:39:42,800 --> 00:39:44,300
一直在竞争
we are racing we are racing

545
00:39:51,200 --> 00:39:51,933
怎么回事
what's going on

546
00:40:00,500 --> 00:40:03,866
是的，没那么容易，我们忘了
yeah that's not quite so easy we forgot

547
00:40:04,200 --> 00:40:08,033
在任意读中，我们要一直读到接收到MESSAGE
In an arbitrary read we were reading until the message

548
00:40:08,166 --> 00:40:09,099
这里不需要这么做
we don't do any of that

549
00:40:09,133 --> 00:40:12,433
这些都不重要，直接返回就好
none of that matters right we just return

550
00:40:12,666 --> 00:40:15,466
我们执行scanf，没有需要读的
 we do our scanf there's nothing to read

551
00:40:17,700 --> 00:40:18,500
回车
hit enter

552
00:40:23,000 --> 00:40:26,333
成功了，我们完成了
it's done we did our read so let's

553
00:40:28,900 --> 00:40:30,766
我们完成了写入，任意写
we did our write our arbitrary write

554
00:40:31,466 --> 00:40:34,533
看看这些信息，太棒了，这有一条
look at the messages awesome here's a message 

555
00:40:34,633 --> 00:40:39,299
我们用这个泄露了main_arena指针
ah so here is when we leaked out the main arena pointer

556
00:40:39,533 --> 00:40:42,633
我们用这个泄露了test值，它是main_arena里的0
here is when we leaked out the test value of the main arena which was zero 

557
00:40:42,833 --> 00:40:48,799
我们用这个写入了main_arena
and here is when we wrote to the main arena

558
00:40:48,866 --> 00:40:52,133
为什么没写入
and why is it not written

559
00:40:58,100 --> 00:40:59,966
说真的，为什么没写入呢
seriously why isn't not written

560
00:41:02,266 --> 00:41:06,499
啊，因为这不该是idx，而是idx+1
ah because this should be not index but index plus one

561
00:41:09,166 --> 00:41:11,766
我们写入到了错误的地址，写到这里了
we wrote to the wrong message we wrote here

562
00:41:14,366 --> 00:41:15,333
这可不好
that's not good all right

563
00:41:15,533 --> 00:41:16,599
我们再试一次
let's try that again

564
00:41:18,300 --> 00:41:19,400
我们改完了
we fix that up

565
00:41:24,600 --> 00:41:27,133
测试，完成，关闭它
test done boom kill that

566
00:41:27,866 --> 00:41:29,799
以下是我们的messages
here are our messages 

567
00:41:30,233 --> 00:41:32,066
写入到了目标地址
get write to the point 

568
00:41:33,033 --> 00:41:40,366
用4141414143434343覆盖了libc的一部分
boom be overwritten part of libc with 4141414143434343

569
00:41:40,566 --> 00:41:42,833
任意写，达成
arbitrary write all right 

570
00:41:43,200 --> 00:41:51,533
还要说的是，这不是一个好的软件实践
one thing that i will say is that was not good software engineering practices

571
00:41:51,900 --> 00:41:53,733
我改一下ppt布局
let me fix the layout of the slide real quick

572
00:41:55,333 --> 00:41:57,699
这不是好的软件实践
that was not good software engineering practices

573
00:41:58,966 --> 00:42:04,266
现在有大量的重复代码
there's a ton of repeated code that exists right now

574
00:42:04,266 --> 00:42:07,199
就在我刚展示的任意读与任意写代码中
as i just showed you between arbitrary read and arbitrary write

575
00:42:07,200 --> 00:42:09,400
所有这些疯狂的竞态条件
all of this crazy race condition stuff

576
00:42:09,566 --> 00:42:13,399
任意读和写的区别只在于printf还是scanf
actually the difference between read and write is just that printf versus the scanf 

577
00:42:14,600 --> 00:42:25,000
当你的漏洞利用代码很复杂时，尽量复用和封装代码
so try to reuse and encapsulate in your exploits as much as possible when they're complex

578
00:42:25,000 --> 00:42:27,733
有些情况不需要
there are cases when it's not what you want to do

579
00:42:27,866 --> 00:42:32,566
比如，如果读和写之间要做的修改非常微小
if there's very subtle differences that you need to make between the read case and the write case

580
00:42:32,700 --> 00:42:34,700
但在我们的漏洞利用代码里
but in our exploit

581
00:42:35,066 --> 00:42:37,333
我们应该封装一个controlled_allocation函数
we should have a controlled allocation function

582
00:42:37,333 --> 00:42:39,866
它能让分配的内存位于受控地址
that makes the allocation at a controlled address

583
00:42:39,866 --> 00:42:46,233
然后基于我们想要读还是写，执行printf或scanf
and then be either printf or scanf based on whether we want to read or write

584
00:42:46,766 --> 00:42:49,799
软件开发技巧在漏洞利用开发中很重要
software development in exploit development is important

585
00:42:50,033 --> 00:42:51,399
从个人经验来看
from personal experience 

586
00:42:51,666 --> 00:42:54,766
对于非常复杂的漏洞利用代码，我会准备测试用例
for very complex exploits i have had test cases

587
00:42:54,800 --> 00:43:00,200
因为要尽快找出问题，就和软件开发一样
because you want to catch things going wrong similar to software development as fast as possible

588
00:43:00,500 --> 00:43:05,100
我来演示一下正确的做法
so let me show you the right way of doing this

589
00:43:05,100 --> 00:43:10,400
有两个比较大的函数arbitrary_read和arbitrary_write
so you have these kind of two big arbitrary read and an arbitrary write function

590
00:43:11,266 --> 00:43:13,933
就停在这里
let's stop it right here

591
00:43:14,133 --> 00:43:17,066
这里获得了位于受控地址的chunk
this is where we malloc the controlled allocation

592
00:43:17,966 --> 00:43:19,466
在这里直接返回
and then let's just return 

593
00:43:19,666 --> 00:43:24,299
我们在这里更新idx，因为这对该函数很重要
we'll do our index because the index really matters for this guy

594
00:43:26,466 --> 00:43:32,166
然后，这里开始是arbitrary_read
and then here we will arbitrary read r1 r2 addr

595
00:43:32,200 --> 00:43:35,000
这里是controlled_allocation
so this becomes controlled allocation

596
00:43:39,500 --> 00:43:43,366
这里是arbitrary_read
all right and this becomes arbitrary read

597
00:43:51,266 --> 00:43:54,966
我们调用controlled_allocation
so we do the controlled allocation

598
00:43:59,000 --> 00:44:07,233
在这之后，我们得到了一个位于受控地址的message
now after this we have a malloced message at a controlled location 

599
00:44:07,433 --> 00:44:09,866
现在我们可以打印message了
now we can print the message

600
00:44:10,033 --> 00:44:11,600
一切都很好
and everything is good 

601
00:44:11,766 --> 00:44:15,266
这个变成了idx-1，因为这里idx增加了
this now becomes index minus one because index was incremented

602
00:44:15,466 --> 00:44:17,199
我们实际看的是上一个idx
so we're actually looking at the last index

603
00:44:17,666 --> 00:44:19,333
我们准备好了
and we're good to go 

604
00:44:19,466 --> 00:44:20,533
这里也一样
same thing here 

605
00:44:20,700 --> 00:44:24,333
只是注意scanf这里是idx-1
just for that scanf becomes index minus one 

606
00:44:24,800 --> 00:44:32,800
这里改成调用controlled_allocation(r1,r2,addr)
and instead we do controlled allocation r1 r2 addr 

607
00:44:33,000 --> 00:44:36,800
软件实践好多了
much better software engineering practices

608
00:44:37,000 --> 00:44:39,300
确保能运行
let's make sure that they fly 

609
00:44:40,700 --> 00:44:42,366
执行，回到这里
run it go back here

610
00:44:43,733 --> 00:44:45,199
好的，第一次泄漏成功
okay first leak works 

611
00:44:45,266 --> 00:44:49,533
测试泄漏成功，写入也没有崩溃
the test leak works the write didn't crash

612
00:44:50,166 --> 00:44:51,899
让我们看看这些消息
let's look at the messages

613
00:44:52,333 --> 00:44:54,166
我看着没问题
looks well set up to me

614
00:44:56,133 --> 00:45:00,399
覆盖也成功了
and overwrite is working all right

615
00:45:01,966 --> 00:45:04,566
这就是制作优秀软件的方法
that's how you make good software 

616
00:45:04,833 --> 00:45:06,666
我们需要什么原语呢
so what primitives do you need

617
00:45:08,900 --> 00:45:13,100
通常如果有任意读和任意写，你就赢了
typically if you have an arbitrary read and an arbitrary write you win

618
00:45:13,500 --> 00:45:18,900
通常你需要一条信息来开始
you need one piece of information to get you started usually

619
00:45:18,900 --> 00:45:22,533
一般是一个你能通过它泄露东西的指针
and that is a valid pointer at which you can start reading

620
00:45:22,533 --> 00:45:25,699
我们用它泄露了tcache元数据
we use that by leaking the tcache metadata

621
00:45:25,700 --> 00:45:27,800
如果我们只有任意读或任意写
if we had an arbitrary read or an arbitrary write

622
00:45:27,800 --> 00:45:29,933
但没有这个tcache泄露
but we didn't have that tcache leak

623
00:45:30,133 --> 00:45:31,533
我们还是不好弄
we would still be in trouble

624
00:45:31,700 --> 00:45:33,333
因为我们不知道从哪里开始泄露
because we wouldn't know where to start reading

625
00:45:33,433 --> 00:45:35,933
但因为我们能从某处开始读
but because we started reading somewhere

626
00:45:37,300 --> 00:45:45,500
我们现在可以把任意数据写入libc
we were able to you know just now write arbitrary data into libc

627
00:45:45,666 --> 00:45:48,599
能达到这一点，你就完事了
at that point generally you are done all right

628
00:45:49,100 --> 00:45:50,566
这期视频将在此到达尾声
so we're gonna end the video here 

629
00:45:50,800 --> 00:45:52,966
在下一个视频中，我们将把所有东西放在一起
in the next video we're gonna put it all together 

630
00:45:53,066 --> 00:45:56,466
之前讲到全部，来获得flag
everything that we just did into the flag

631
00:45:56,766 --> 00:45:57,566
到时见
see you there

