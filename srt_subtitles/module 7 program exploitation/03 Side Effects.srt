1
00:00:01,000 --> 00:00:02,133
你好黑客
hello hackers

2
00:00:02,133 --> 00:00:03,666
欢迎回到PWN学院
welcome back to pwn college

3
00:00:03,666 --> 00:00:07,866
我是Yan，今天我们要讨论的漏洞利用场景是
I'm Yan today we're talking about exploitation scenarios

4
00:00:08,200 --> 00:00:10,400
直接控制执行流之外的利用效果
 and specifically vulnerability side effects

5
00:00:12,933 --> 00:00:14,166
这里只是非常概况的讲一下
a very high level of this

6
00:00:14,166 --> 00:00:17,099
需要在练习问题中具体深入了解更多
you'll dive more into this in the practice problems

7
00:00:17,100 --> 00:00:20,000
当然这个模块会结合
of course this module we are putting together

8
00:00:20,133 --> 00:00:22,499
我们在以前的模块中学到的一切
everything we've Learned in previous modules

9
00:00:22,733 --> 00:00:24,899
今天的重点是
today focusing on basically

10
00:00:25,000 --> 00:00:32,100
shellcode、内存损坏和以一种有趣的方式越狱
shellcoding and memory corruption and jailing in an interesting way 

11
00:00:33,900 --> 00:00:36,100
好吧，我的建议是
all right my advice to you

12
00:00:36,300 --> 00:00:42,166
当你学习将这些不同的技术组合成端到端攻击链时
 as you learn to combine these different techniques into an end to end attack chain

13
00:00:42,466 --> 00:00:45,166
别忘了这一点
is don't forget that

14
00:00:45,700 --> 00:00:49,700
通过内存损坏劫持执行流
control flow hijacking through memory corruption

15
00:00:49,766 --> 00:00:52,466
不是你唯一能做的
is not the only thing that you can do

16
00:00:52,800 --> 00:00:55,900
程序中有各种各样的漏洞
vulnerabilities in programs come in all shapes and sizes

17
00:00:56,100 --> 00:01:01,600
并不是所有这些都能让你劫持执行流
and not all of them will allow you to hijack control flow

18
00:01:01,666 --> 00:01:03,066
并不是所有的都是
not all of them are

19
00:01:06,900 --> 00:01:10,700
其中一些能让你做的不光是劫持执行流这些
some of that will allow you to do more than just hijack control flow and so on

20
00:01:10,866 --> 00:01:13,499
在内存错误模块中已经对此有了一些了解
you explored this a bit in the memory errors module

21
00:01:13,600 --> 00:01:14,266
但现在
but now

22
00:01:14,266 --> 00:01:16,466
这将变得越来越重要
this is going to become more and more important 

23
00:01:16,500 --> 00:01:22,500
特别是当你要在这节课中学会真正控制这些程序
as you learn to truly take control of these programs over the course of this module

24
00:01:22,533 --> 00:01:24,599
我们来看一个鼓舞人心的例子。
so let's look at a motivating example. 

25
00:01:24,900 --> 00:01:32,400
如果你还记得沙盒模块的jail的话
we have a jail if you remember from the jail

26
00:01:33,300 --> 00:01:38,500
等一下，我把摄像机关了，这样你就能看到
hold on let me turn off the camera so that you don't have to cause you

27
00:01:38,533 --> 00:01:40,066
哦，好的，就是jail ...
oh yeah just jail da da da

28
00:01:40,000 --> 00:01:44,500
如果你回想一下沙盒模块
all right if you recalled from the jailbreaking module the sandboxing module

29
00:01:45,100 --> 00:01:48,400
这是seccomp沙盒，只允许我们读和写
this is a seccomp jail that will only allow us to read and write

30
00:01:48,466 --> 00:01:50,066
这真是个坏消息
that's really bad news

31
00:01:50,666 --> 00:01:52,299
我们打不开flag
we can't open the flag

32
00:01:52,966 --> 00:01:58,533
如果光顾着利用
and if you hyperfocus on using this stack overflow

33
00:01:59,966 --> 00:02:04,266
gets 提供的栈溢出来劫持执行流
that's provided to us by the gets to hijack execution

34
00:02:04,700 --> 00:02:07,500
你最终会被困在这个沙盒里
you're going to end up in a situation where you're stuck in this jail 

35
00:02:07,533 --> 00:02:11,799
相反，你需要关注的是
instead what you need to look at is

36
00:02:11,966 --> 00:02:16,199
gets还能让我做什么呢
what else does this gets allow me to do in this case

37
00:02:16,300 --> 00:02:18,133
在栈上有一个结构
there's a structure on the stack

38
00:02:18,100 --> 00:02:22,400
它有一个shellcode缓冲区和一个flag
that has the shellcode and a flag after the shellcode on the stack

39
00:02:22,500 --> 00:02:24,933
这个flag表示shellcode是否应该在沙盒中执行
whether or not that shellcode should be sandbox

40
00:02:25,300 --> 00:02:27,800
如果设置了该标志，默认是被置为1
and if that flag is set then at which is set by default

41
00:02:27,900 --> 00:02:32,466
就说明要在沙盒中执行
 then that sandbox is set up 

42
00:02:33,300 --> 00:02:37,900
所以如果用一堆a来溢出缓冲区，就会进入if分支执行
so if you overflow with a bunch of A's this check will pass

43
00:02:38,200 --> 00:02:40,133
因为program.sandbox将是aaa
program.sandbox will be aaaaa

44
00:02:41,300 --> 00:02:43,733
它表示真
that's of course it values to true and 

45
00:02:43,900 --> 00:02:45,466
在C中，任何非0值都为真
in C anything non 0 is true

46
00:02:46,333 --> 00:02:51,766
最后导致seccomp被启用
and what ends up happening is the seccomp filters applied

47
00:02:51,700 --> 00:02:56,300
让我们来看看它会是什么样子
let's take a look at at how that might look

48
00:02:57,366 --> 00:02:59,966
我创建了这个sandbox.c
all right so I I created this sandbox.c

49
00:03:03,300 --> 00:03:05,166
和我们在幻灯片上看到的一模一样
 exactly what we saw on the slides

50
00:03:05,600 --> 00:03:09,200
编译时允许栈可执行
and I compiled it and I compiled it with executable stack

51
00:03:09,266 --> 00:03:10,966
因为我们需要在栈上使用shellcode
because we need to actually use shellcode on the stack

52
00:03:10,966 --> 00:03:12,566
当然也
of course the same

53
00:03:13,200 --> 00:03:17,100
可以创建不需要在栈上执行shellcode的示例程序
program could be created without the need to execute the shellcode on the stack

54
00:03:17,200 --> 00:03:20,300
但这要简单得多，并且节约很多时间
but this is much simpler and save tons of life

55
00:03:20,966 --> 00:03:21,766
好了,那么
alright so

56
00:03:21,966 --> 00:03:24,366
我们可以获取一些shellcode
we can grab some shellcode

57
00:03:24,366 --> 00:03:26,166
这是我写的一些shellcode
this is some shellcode that I wrote

58
00:03:26,300 --> 00:03:30,500
这只是打开和发送文件
that just does an open and send file

59
00:03:30,800 --> 00:03:33,400
我们就用它吧
so let's grab it

60
00:03:34,100 --> 00:03:37,300
复制一下
and copy that

61
00:03:40,700 --> 00:03:43,133
嗯，出了点问题
umm something wrong

62
00:03:44,466 --> 00:03:46,466
哦因为复制了两行（引号闭合）
ah it copy across 2 lines

63
00:03:53,600 --> 00:03:54,400
和
and

64
00:03:57,100 --> 00:04:01,500
通过管道传给sandbox程序，不用n用e参数
pipe this through without n，e

65
00:04:02,500 --> 00:04:04,700
表示在末尾添加换行符
so we want the new line on the end 

66
00:04:04,700 --> 00:04:07,200
这样gets读到末尾会停止
so that gets will actually termate

67
00:04:07,333 --> 00:04:09,733
通过管道传给sandbox
and pipe it through sandbox 

68
00:04:12,433 --> 00:04:13,666
然后报bad system called
and says bad system called

69
00:04:13,666 --> 00:04:19,899
因为我们试图调用open，但这不被沙盒允许
because we tried to do an open and it's not allowed by the sandbox

70
00:04:20,300 --> 00:04:29,800
如果输入一堆a来溢出缓冲区
ah if we put a bunch of A's here to overflow the buffer

71
00:04:29,800 --> 00:04:31,566
这会溢出我们的缓冲区
this will overflow our buffer

72
00:04:31,566 --> 00:04:35,333
但系统调用会被seccomp拦截
but  we have a bad system call 

73
00:04:38,066 --> 00:04:40,966
如果shellcode只执行ret呢
if we for our shellcode just do a ret

74
00:04:47,100 --> 00:04:48,766
然后放一堆a
and then we put a bunch of A's

75
00:04:50,500 --> 00:04:51,666
你会看到
as you'll see

76
00:04:54,100 --> 00:04:56,600
哦好吧，也报错了，因为程序退出试图调用exit
oh yeah because the program tries to exit

77
00:04:57,300 --> 00:04:59,733
seccomp也被启用了
of course the seccomp filter is already applied

78
00:05:00,000 --> 00:05:02,166
所以我们有麻烦了
so we're we're in trouble right

79
00:05:02,800 --> 00:05:03,800
当然
of course

80
00:05:04,533 --> 00:05:07,733
如果我们考虑一下程序逻辑
if we think about the program logic

81
00:05:07,966 --> 00:05:16,399
不用A，而是用空字节去溢出
 and instead of A's overflow with null bytes

82
00:05:17,800 --> 00:05:21,566
那就能使这个检查失效，不启用seccomp
then that'll have a side effect of disabling this check

83
00:05:22,566 --> 00:05:23,766
让我们来看看
so let's take a look

84
00:05:26,800 --> 00:05:32,300
输入100个空字节
um I'm gonna put in 100 null bytes

85
00:05:40,266 --> 00:05:41,866
一定有更好的办法
there's gotta be a better way

86
00:05:49,200 --> 00:05:50,266
好完美
okay perfect

87
00:05:50,933 --> 00:05:53,599
输入一堆空字节，它就成功了
put in a bunch of null bytes and it works 

88
00:05:59,466 --> 00:06:01,733
我们打开发送文件的shellcode成功执行了
our open sent file shellcode works

89
00:06:01,700 --> 00:06:10,500
因为我们溢出了shellcode变量覆盖了sandboxed
because we overflowed this shellcode variable into sandboxed

90
00:06:10,800 --> 00:06:12,900
并且是用null覆盖的sandboxed变量
and overloaded with nulls

91
00:06:13,000 --> 00:06:19,100
内存损坏并不总是直接导致劫持执行流
memory corruption does not always lead to control executions directly

92
00:06:19,100 --> 00:06:21,200
在这种情况下，程序已经提供了执行代码的机会
in this case the program already gave you code execution

93
00:06:21,200 --> 00:06:26,700
但是您需要利用内存损坏漏洞
but you needed to use a memory corruption vulnerability together with that code execution

94
00:06:26,866 --> 00:06:30,133
来禁用沙盒，再读取flag
to actually disable the sandbox and get the flag

95
00:06:30,766 --> 00:06:31,566
好吧
all right

96
00:06:32,100 --> 00:06:38,000
坏消息是，有些漏洞利用效果的副作用是很严重的
the bad news of this is that some side effects in a program are fatal

97
00:06:38,000 --> 00:06:40,066
想一下这个例子
consider this example

98
00:06:40,266 --> 00:06:41,466
你有一个shellcode
you have a shellcode

99
00:06:41,500 --> 00:06:44,000
还有一个shellcode的副本
and you have a copy of the shellcode

100
00:06:44,400 --> 00:06:48,900
shellcode副本存储在堆上的缓冲区
and the copy of the shellcode has an allocated buffer on the heap

101
00:06:49,733 --> 00:06:53,566
用strcpy把栈上的shellcode拷贝到了堆上
that is strcpy into from the shellcode

102
00:06:54,500 --> 00:07:00,200
这是个坏消息，因为当你要溢出这个shellcode缓冲区
this is really bad news because when you overflow this shellcode buffer

103
00:07:00,400 --> 00:07:03,200
理想情况下通过栈溢出很容易
to then ideally overflow the stack and 

104
00:07:03,200 --> 00:07:04,666
将执行流重定向到shellcode中
redirect control flow into your shellcode

105
00:07:05,500 --> 00:07:10,100
特别是如果所有的保护措施都没有，像1999年那样
if all the mitigations are disabled like it's you know 1999

106
00:07:12,733 --> 00:07:13,933
不好意思，问题来了
sorry there we go

107
00:07:13,933 --> 00:07:15,166
让我把视频移开
let me move that video

108
00:07:15,766 --> 00:07:17,899
你会很难过
you're going to have a hard time

109
00:07:18,700 --> 00:07:24,666
因为你会覆盖shellcode_copy指针
because you will overwrite your shellcode_copy pointer 

110
00:07:25,066 --> 00:07:26,933
很可能用的无效地址
most likely with something invalid

111
00:07:27,166 --> 00:07:29,666
你的程序会在这里崩溃
and your program will crash here this strcpy

112
00:07:29,600 --> 00:07:33,000
在这种情况下你必须小心
you have to be very careful in these scenarios

113
00:07:33,200 --> 00:07:39,300
保持程序的状态，以便程序正常执行
to keep the state of the program viable for further execution

114
00:07:39,400 --> 00:07:42,300
至少在目标实现之前
at least until you achieve your goals

115
00:07:42,400 --> 00:07:43,566
所以在这种情况下
right so in this case

116
00:07:43,700 --> 00:07:45,166
当shellcode溢出时
when you overflow shellcode 

117
00:07:45,300 --> 00:07:49,000
您需要用一个有效的地址重写shellcode_copy
you would need to rewrite shellcode_copy with a valid address

118
00:07:49,000 --> 00:07:50,733
你们应该很熟悉这个
you're actually familiar with this

119
00:07:51,100 --> 00:08:00,500
就像内存错误模块中需要在shellcode中修复金丝雀
with the requirement to fix up the canary in the shellcode in the memory errors module

120
00:08:00,600 --> 00:08:02,166
这是类似的
this is analogous

121
00:08:02,533 --> 00:08:03,299
记住这点
keep it in mind

122
00:08:03,300 --> 00:08:05,866
当创建复杂的多阶段漏洞利用时
as you create complex multi stage exploits

123
00:08:05,866 --> 00:08:07,333
或者多级攻击时
or multi stage attacks

124
00:08:07,533 --> 00:08:08,333
那
that

125
00:08:08,700 --> 00:08:11,166
有时候你的攻击必须非常非常小心
sometimes your attacks have to be very very careful

126
00:08:12,066 --> 00:08:13,499
好吧
all right um

127
00:08:13,566 --> 00:08:16,666
这就是我在这要说的一些副作用
that's all I'll say right now about side effect

128
00:08:16,666 --> 00:08:19,533
你们会在练习题中探索更多
um you'll explore a lot more in the practice problems

129
00:08:19,533 --> 00:08:20,266
祝你好运
good luck

