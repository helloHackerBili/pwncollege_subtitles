1
00:00:00,933 --> 00:00:04,066
黑客们好，欢迎回到PWN学院
hello hackers welcome back to pwn college

2
00:00:04,333 --> 00:00:06,133
今天我们要讨论的是
today we're talking about

3
00:00:06,533 --> 00:00:08,099
漏洞利用场景
exploitation scenarios

4
00:00:08,100 --> 00:00:09,566
这个模块
this is a module

5
00:00:09,600 --> 00:00:12,900
把我们以前学到的结合到一起
that puts together everything we've Learned in previous modules

6
00:00:13,400 --> 00:00:14,300
并加以应用
and applies it

7
00:00:14,800 --> 00:00:22,400
这个视频主要讨论利用内存错误
this specifically is a discussion about the use of memory error

8
00:00:22,500 --> 00:00:27,200
在程序中注入shellcode并运行
to inject shellcode and run shellcode into in a program 

9
00:00:27,600 --> 00:00:31,600
我们在shellcode模块中讲过很多它的使用方法和场景
we've run shellcode and all sorts of different scenarios in module 2

10
00:00:32,700 --> 00:00:36,400
在内存错误模块
and in module 5

11
00:00:36,900 --> 00:00:42,400
我们讲了很多内存错误及其利用
we did a whole lot of memory error exploitations of the impacts of memory errors

12
00:00:42,466 --> 00:00:43,933
现在要把它们结合到一起
now we're going to put them together

13
00:00:45,766 --> 00:00:47,199
回想一下,
recall that

14
00:00:48,400 --> 00:00:52,100
内存错误和控制劫持是同时发生的
memory errors and controlful hijack occurs in part

15
00:00:52,300 --> 00:00:55,066
因为控制信息和数据是混合的
because of the mixing of control and information data

16
00:00:55,100 --> 00:01:04,900
起初程序有代码在text段
right so when you have a program starting off that has code in the text segment section

17
00:01:05,966 --> 00:01:10,933
有数据、堆和栈，有用户控制的
data and the heap and the stack and there is user controlled 

18
00:01:11,266 --> 00:01:14,899
或者当用户是攻击者时，攻击者控制的
or what is attacker controlled when the user is an attacker

19
00:01:14,900 --> 00:01:21,400
在栈上和控制信息，例如返回地址，放在一起的数据
data that is on the stack interlieved with control information such as return addresses

20
00:01:21,466 --> 00:01:23,299
正如您在前面的模块中看到的那样
as you've seen in the previous module

21
00:01:23,666 --> 00:01:25,199
事情可能会变得危险
things can get dicey

22
00:01:25,300 --> 00:01:28,700
我们将在这里探讨可能变得危险的方式之一
one of the ways that they can get dicey that we're going to explore here

23
00:01:29,600 --> 00:01:34,500
是当返回地址被覆盖，并且
is when a return address is over written and 

24
00:01:35,300 --> 00:01:42,700
通过覆盖返回地址程序被重定向到shellcode中
by being overwritten  it ends up redirecting control flow into shellcode all right

25
00:01:45,100 --> 00:01:51,100
示例使用shellcoding模块中的示例
for our example we're going to recall the example from the shellcodeing module

26
00:01:51,500 --> 00:01:52,000
就是这个
this was it

27
00:01:52,000 --> 00:01:55,100
这是一个简单的程序，有一个非常愚蠢的错误
it's a simple program with a really dumb bug

28
00:01:55,100 --> 00:01:56,400
实际上是2个bug
actually 2 bugs

29
00:01:57,300 --> 00:02:00,500
但是在shellcoding上下文中
but in the shellcodeing context

30
00:02:00,700 --> 00:02:05,200
这个bug是hello调用的参数混淆了
the bug was that the argument to this call of hello were mixed up

31
00:02:05,300 --> 00:02:11,000
该传函数指针，结果传了name变量
instead of the function pointer for bye func the name was passed in

32
00:02:11,100 --> 00:02:16,700
我们可以直接把name当作shellcode执行
 and so we could directly execute the name as shellcode

33
00:02:17,933 --> 00:02:20,066
这些bug的发生令人震惊
these bugs happen shockingly

34
00:02:20,133 --> 00:02:22,299
但这种情况很少发生
but they happen fairly rarely

35
00:02:22,300 --> 00:02:28,100
这需要忽略大量编译器警告
this takes a lot of ignoring of compiler warnings to occur

36
00:02:31,466 --> 00:02:33,166
这个程序还有一个bug
this program has another bug

37
00:02:33,400 --> 00:02:35,000
即使你修复了
and even if you fix the bug 

38
00:02:35,400 --> 00:02:39,500
这个在shellcoding模块中讲的允许任意代码执行的bug
that allowed for arbitrary execution of shellcode in the shellcodeing module

39
00:02:39,766 --> 00:02:41,333
我们还有个问题
we still have a problem

40
00:02:41,366 --> 00:02:43,399
这个问题是gets函数
and that problem is gets

41
00:02:44,100 --> 00:02:50,100
Gets在任何情况都是一个不安全的函数
gets is a function that is always unsafe

42
00:02:50,133 --> 00:02:52,466
在这种情况下，当然也是的
and in this case yeah 

43
00:02:53,100 --> 00:02:58,500
这是典型的老式缓冲区溢出
it's a typical classic old school buffer overflow 

44
00:02:58,533 --> 00:03:01,099
典型到如果使用gets，编译器都会向你报警
to the point where the compiler will complain at you if you use gets

45
00:03:01,100 --> 00:03:03,900
但很明显，正如你在之前的模块中看到的
but obviously as you've seen in the previous module

46
00:03:04,600 --> 00:03:12,000
这些错误会非常频繁地在不同的场景中发生
these errors can occur quite frequently in a lot of varied scenarios where

47
00:03:12,133 --> 00:03:16,099
即使开发人员实际上非常注意大小
even when developers are actually careful about sizing

48
00:03:16,900 --> 00:03:21,700
在这种情况下，我们有一个栈缓冲区溢出
so in this case we have a stack buffer overflow

49
00:03:21,900 --> 00:03:24,333
当然，你们现在对这个已经很熟悉了
and of course as you are well familiar by now

50
00:03:24,333 --> 00:03:26,366
可以覆盖返回地址
you can overwrite the return address and

51
00:03:26,800 --> 00:03:28,200
重定向到你想要的地方
redirect to you should know wherever you want

52
00:03:28,266 --> 00:03:30,999
当然，这个程序没有win 函数
of course this program doesn't have a win function

53
00:03:31,300 --> 00:03:37,200
没有能让你直接读到flag的函数
there's no function that allows you to hijack to read the flag

54
00:03:37,500 --> 00:03:39,100
你必须自己写一个
you have to write it yourself

55
00:03:39,100 --> 00:03:42,066
这就是shellcode注入
and of course that is shellcode injection

56
00:03:42,266 --> 00:03:43,066
好吧
all right

57
00:03:44,300 --> 00:03:45,933
让我们来看一看
let's take a look

58
00:03:46,166 --> 00:03:47,133
提醒一下
as a reminder

59
00:03:47,200 --> 00:03:53,500
这是一个非常简单的例子，我们禁用了很多保护措施
this is a very simple example we have a lot of mitigations disabled with

60
00:03:56,066 --> 00:03:57,699
有意思，等一下
that's interesting hold on

61
00:03:59,266 --> 00:04:02,299
让我修正一下这里的文本设置
let me fix my text setup here

62
00:04:03,066 --> 00:04:03,866
好吧
all right

63
00:04:04,600 --> 00:04:06,400
让我们先看一下
let's 1st take a look

64
00:04:06,400 --> 00:04:10,200
我首先在这里写了这个程序。hello.c
I first wrote this program out here. hello.c

65
00:04:12,300 --> 00:04:17,700
和幻灯片上的一样，并且修复了这个传错参数的bug
we have the exact thing from the slides with the bug fixed

66
00:04:17,766 --> 00:04:19,166
如果你运行这个
right so if you run this

67
00:04:19,600 --> 00:04:21,066
我们来编译一下
um let's compile it

68
00:04:21,566 --> 00:04:22,799
正如我提到的
as I mentioned

69
00:04:22,866 --> 00:04:24,599
我要关闭一堆保护机制
I'm turning off a bunch of mitigation

70
00:04:24,600 --> 00:04:26,100
我允许了可执行栈
I'm turning on an executable stack

71
00:04:26,100 --> 00:04:28,000
我们要注入shellcode到那里
that's where we're going to inject our shellcode

72
00:04:28,100 --> 00:04:31,600
我关掉了栈金丝雀
and I'm turning off um stack canaries

73
00:04:31,700 --> 00:04:36,100
您已经从前面的模块中了解了这些含义
you understand what those implications are from the previous modules

74
00:04:37,266 --> 00:04:40,666
但我们要先从一个简单的例子开始
but we're gonna start with a very simple example here

75
00:04:40,666 --> 00:04:43,766
之后再讨论如何处理更复杂的示例
talk about how to tackle more complex examples later

76
00:04:44,500 --> 00:04:45,333
我们会
and we will

77
00:04:48,200 --> 00:04:53,400
之后你们会在练习题中探索很多
 and then you will explore a lot of that on your own at the practice problems

78
00:04:53,466 --> 00:04:56,899
好了，编译它
all right so we compile this and 

79
00:04:57,733 --> 00:05:01,099
正如我提到的，如果使用gets，编译器会报警
as I mentioned if you use gets the compiler complaints at you right

80
00:05:01,466 --> 00:05:04,299
当然，这些bug还会以其他方式出现
of course there are other ways that these bugs gonna occur

81
00:05:04,466 --> 00:05:07,333
好，我们来执行它
 all right let's execute it

82
00:05:08,100 --> 00:05:09,200
输入名字
we put it on our name 

83
00:05:09,733 --> 00:05:11,499
然后它会回你好
and then it just says hello

84
00:05:11,733 --> 00:05:15,699
然后随机选一个bye函数执行
and then tells us one of 2 randomly chosen goodbye functions

85
00:05:16,266 --> 00:05:18,366
好的，太棒了
 alright awesome so

86
00:05:18,600 --> 00:05:21,966
这就是我们要利用的程序
so this is the program of how do we exploit it 

87
00:05:22,266 --> 00:05:23,199
很明显
obviously

88
00:05:23,700 --> 00:05:27,400
如果我们输入大量的文本
if we put in a whole lot of text 

89
00:05:29,666 --> 00:05:31,066
它会崩溃
it'll crash

90
00:05:31,333 --> 00:05:33,533
让我们来看看为什么
let's take a look at why

91
00:05:39,533 --> 00:05:44,166
它将在从主函数返回时崩溃
it'll crash at the ret from the main function

92
00:05:44,400 --> 00:05:51,600
如果我们看一下栈，它被A的OX41覆盖了
and if we look at the stack it was over written by A's OX41

93
00:05:52,333 --> 00:05:55,733
这就是为什么它会崩溃
and that's why it's crashing all right

94
00:05:58,300 --> 00:06:00,166
如果你看一下进程内存映射
if you look at the process map

95
00:06:00,700 --> 00:06:06,000
你可以看到我们的栈是可执行的
you can see that our stack is executable um

96
00:06:09,966 --> 00:06:12,766
这个进程，让我们快速看一下
here's the process let's just take a quick look

97
00:06:16,066 --> 00:06:17,733
好了，这样就能看权限了
okay here it is with the permissions

98
00:06:17,733 --> 00:06:20,266
你可以看到我们的栈是可执行的
you can see our stack is executable

99
00:06:20,466 --> 00:06:23,399
因为之前用execstack编译的
because you compiled with execstack and

100
00:06:24,200 --> 00:06:26,266
如你所见，没有触发金丝雀
 as you saw there was no canary triggered

101
00:06:26,300 --> 00:06:35,100
程序返回到我们覆盖的返回地址时，没被终止
to kill the program  before it could return to our overwritten return address 

102
00:06:36,066 --> 00:06:37,066
很酷
cool

103
00:06:37,100 --> 00:06:39,000
现在我们只需要构建漏洞利用程序
so now we just need to build the exploit

104
00:06:39,000 --> 00:06:40,200
我们要做的是
what we're going to do is

105
00:06:40,200 --> 00:06:44,700
我们会用（想要的）返回地址溢出缓冲区
we're going to overflow the buffer with our return address ummm

106
00:06:47,100 --> 00:06:51,000
溢出缓冲区，修改返回地址
with overflow the buffer modify the return address

107
00:06:51,433 --> 00:06:54,099
指向我们写入了代码的缓冲区
 to point into the buffer that we're writing

108
00:06:54,133 --> 00:06:55,533
也就是我们放shellcode的位置
where we'll put shellcode

109
00:06:55,600 --> 00:06:57,300
因为栈是可执行的
since that's executable

110
00:06:57,466 --> 00:07:00,899
shellcode将被执行，我们可以开始了
the shellcode will execute and we'll be good to go

111
00:07:00,933 --> 00:07:02,733
我们要用pwntools来做这个
we're gonna do this with pwntools

112
00:07:03,500 --> 00:07:10,500
特别是使用PWN调试功能
specifically using the pwn debug functionality

113
00:07:12,200 --> 00:07:18,100
pwntools很好，它允许我们禁用ASLR
and pwntools is nice that allows us to disable ASLR

114
00:07:18,100 --> 00:07:21,600
我们在这个基本演示中禁用了所有的保护措施
so we're disabling really all mitigations for this basic demo

115
00:07:21,800 --> 00:07:25,700
这样我们可以直接覆盖写入正确的地址
 so that we can of course set the right address

116
00:07:25,733 --> 00:07:27,599
这样我们就知道发送什么地址了
so that we know what address to send

117
00:07:29,200 --> 00:07:33,533
我们启动PWN，程序正在运行
so we we start up pwn here is is the program running

118
00:07:34,200 --> 00:07:36,566
你要做的第一件事就是弄清楚
the 1st thing you got to do is figure out 

119
00:07:36,900 --> 00:07:39,700
返回地址离缓冲区有多远
how far away the return address is from the buffer

120
00:07:39,700 --> 00:07:43,066
我们使用一个循环模式
we're going to be super lazy and use a cyclic pattern

121
00:07:43,900 --> 00:07:47,400
我们写pwn.cyclic
so we're going to write pwn.cyclic

122
00:07:47,500 --> 00:07:49,800
当然是64位的机器
of course it's a 64 bit machine 

123
00:07:50,600 --> 00:07:59,166
我们写2000字节，每8字节为一个单位
so let's just write 2 000 bytes with 8 bytes at a time 

124
00:07:59,566 --> 00:08:02,099
这样我们就可以按8字节查找
so that we can look up with with 8 bytes

125
00:08:02,800 --> 00:08:05,800
并且gets是不安全
and gets is unsafed

126
00:08:05,900 --> 00:08:07,933
因为它总是读到换行符
because it always reads to the new line 

127
00:08:07,933 --> 00:08:11,333
它根本不关心它读取的字节数
it has no no it doesn't care at all about the amount of bytes its read

128
00:08:11,300 --> 00:08:15,400
gets肯定会导致缓冲区溢出
 gets is almost guaranteed buffer overflow again

129
00:08:15,533 --> 00:08:18,799
但是我们需要换行符，这样它才能停止
but we need a new line so that it stops reading

130
00:08:19,000 --> 00:08:22,000
好的，我们这样写了。boom
all right we wrote that. boom

131
00:08:23,933 --> 00:08:25,366
段错误
segmentation fault

132
00:08:25,300 --> 00:08:28,400
让我们看看栈上返回地址被什么覆盖了
let's see what is the stack got overwritten with

133
00:08:28,466 --> 00:08:30,666
栈被这些无意义的内容覆盖了
the stack got overwritten with this nonsense

134
00:08:30,700 --> 00:08:32,700
这是我们循环模式的一部分
this is part of our cyclic pattern

135
00:08:33,266 --> 00:08:34,566
说一下
for the record

136
00:08:37,100 --> 00:08:39,500
如果我们打印生成的循环模式
if we generate this pattern

137
00:08:40,366 --> 00:08:42,533
这就是我们的循环模式
this is the cyclic pattern we overflowed with

138
00:08:42,600 --> 00:08:43,600
当然
and of course

139
00:08:44,333 --> 00:08:45,466
这是
this is

140
00:08:49,766 --> 00:08:50,933
如果我们看一下RSP中的字符串
if we look at RSP in a string

141
00:08:51,733 --> 00:08:53,966
你可以看到这是循环模式的一部分
 you can see this is part of it right

142
00:08:53,900 --> 00:08:58,900
这是它的小端序
and so that this is this in a little endian

143
00:08:59,100 --> 00:09:01,133
我们可以查询其中任何一个在循环模式中的位置
and we can query either one of those

144
00:09:01,133 --> 00:09:02,599
你可以执行pwn.find
you can do pwn.find

145
00:09:04,300 --> 00:09:06,000
cyclic_find
cyclic_find

146
00:09:07,866 --> 00:09:09,566
被覆盖后的返回地址和
that address and 

147
00:09:09,700 --> 00:09:12,500
=8。这是循环模式的步长
equals 8 that's the step size of the cyclic pattern

148
00:09:12,500 --> 00:09:14,533
它的位置是1032
and it's at position 10 32

149
00:09:14,500 --> 00:09:17,800
所以我们要发送1032个填充字符
so we have to send 10 32 of anything

150
00:09:18,266 --> 00:09:21,533
然后我们覆盖返回地址，然后
and then we overflow with the return address and then

151
00:09:22,000 --> 00:09:25,900
我们可以把shellcode放在后面
we can put shellcode after that

152
00:09:26,000 --> 00:09:27,300
或者我们可以把shellcode放在前面
or we could put shellcode before that

153
00:09:27,300 --> 00:09:30,100
但放在后面，运行时计算偏移量会更容易一些
but after it's a little easier to calculate offsets on the fly

154
00:09:30,233 --> 00:09:32,199
我们把它放后面
 so we're gonna do that here

155
00:09:32,200 --> 00:09:33,733
好了，最后一件事是
all right the final thing is

156
00:09:33,866 --> 00:09:37,899
当返回发生时，栈指向这里
the stack is pointing here when the return occurs

157
00:09:38,133 --> 00:09:40,699
所以我们要做的是
so what we're going to do is

158
00:09:41,200 --> 00:09:48,500
用 这个+8，shellcode所在的位置，来覆盖返回地址
overwrite the return address with 8B past this location  where our shellcode will be

159
00:09:53,266 --> 00:09:54,899
我们来看一下
so let's let's take a look at that

160
00:09:54,900 --> 00:09:56,066
我们要重新启动
we're going to relaunch 

161
00:09:58,066 --> 00:09:59,799
首先
1st of all

162
00:10:01,600 --> 00:10:02,400
好吧
okay

163
00:10:03,666 --> 00:10:04,599
在这里继续
continue here

164
00:10:04,600 --> 00:10:06,166
好了，我们到了
alright so here we are

165
00:10:06,333 --> 00:10:12,399
写1032个a
we're going to write 1032 As

166
00:10:12,766 --> 00:10:15,299
然后我们
and then we're going to pack

167
00:10:16,300 --> 00:10:19,500
用p64处理这个加8
P 64 of course takes this plus 8

168
00:10:20,000 --> 00:10:27,300
p64将这个数转换为一个小端序的字符串
takes this number and converse it to a little endian string

169
00:10:28,000 --> 00:10:29,500
加上我们的shellcode
plus our shellcode

170
00:10:29,600 --> 00:10:37,900
这将用一个指向返回地址后8个字节的指针覆盖返回地址
right so this will overwrite the return address with a pointer to 8 bytes after the return address

171
00:10:37,900 --> 00:10:39,133
我们把shellcodes放在那里
which is where we'll put our shellcodes

172
00:10:39,133 --> 00:10:40,699
当main返回时
so when main returns

173
00:10:40,766 --> 00:10:42,666
我们的shellcode将运行
boom our shellcode will run

174
00:10:43,500 --> 00:10:45,466
现在我们放入shellcode
and now we put in the shellcode

175
00:10:45,400 --> 00:10:49,400
我已经写在这里了
I actually already wrote it here

176
00:10:49,466 --> 00:10:53,333
这只是一个简单的打开，发送文件的shellcode
this is just a simple open sent file shellcode

177
00:10:53,766 --> 00:10:56,966
这是结果，当我运行它时，它读取我的假旗帜
here's the results it reads my fake flag when I run it

178
00:10:57,600 --> 00:10:59,400
就在这里
and it's right here

179
00:10:59,966 --> 00:11:01,966
我们复制一下
let's just copy this

180
00:11:04,666 --> 00:11:05,466
哦
oops

181
00:11:05,566 --> 00:11:06,533
粘贴
paste it

182
00:11:09,066 --> 00:11:10,766
还有我们的换行符
and our new line

183
00:11:12,266 --> 00:11:13,066
好吧
okay

184
00:11:13,066 --> 00:11:14,599
我们这样写
we write this 

185
00:11:14,600 --> 00:11:16,866
这里我们看到它在非法指令下崩溃了
here we see it crashed on illegal instruction

186
00:11:16,866 --> 00:11:20,133
这很有可能是在shellcode执行完之后崩溃的
that's promising probably right after our shellcode

187
00:11:20,500 --> 00:11:22,000
嗯，让我看看
um and let's see

188
00:11:22,966 --> 00:11:24,533
我们将返回结果都读出来会看到什么
what happened if we read everything

189
00:11:30,333 --> 00:11:31,799
终止
terminated okay

190
00:11:31,966 --> 00:11:33,299
我们开始吧
here we go it

191
00:11:33,733 --> 00:11:36,533
shellcode运行并读取了我们的flag
the shellcode ran and it read our flag

192
00:11:36,733 --> 00:11:38,666
我们在这里做了什么
so what did we do here

193
00:11:39,200 --> 00:11:44,100
我们溢出了name的缓冲区
we overflowed the name buffer

194
00:11:44,400 --> 00:11:48,300
当gets运行时，它溢出覆盖了main的返回地址
when gets ran it overflow the return address of main

195
00:11:48,400 --> 00:11:51,966
当main返回时，它返回到栈中
when main returned it returned onto the stack

196
00:11:52,300 --> 00:11:54,900
因为我们编译它的方式，导致栈是可执行的
which was executable because of the way we compiled it

197
00:11:54,900 --> 00:11:57,166
现代程序则不是这样
modern programs this is not the case

198
00:11:57,900 --> 00:12:01,600
所以我们可以运行shellcode
and we were able to run our shellcode and

199
00:12:02,333 --> 00:12:03,599
读取flag
read the flag

200
00:12:03,700 --> 00:12:08,400
结合了内存损坏和shellcode执行
combination of memory corruption and shellcode execution

201
00:12:09,100 --> 00:12:12,066
太棒了，接下来的课程我们会
awesome through the rest of the module we'll

202
00:12:12,200 --> 00:12:21,066
看看其他的不同组合
look at a couple of other concepts around these various combinations

203
00:12:21,133 --> 00:12:24,999
然后你们会在练习单元的练习题中进行练习
 and then you will practice them in the practice modules in the practice problems

204
00:12:25,733 --> 00:12:27,799
祝你好运
 good luck

