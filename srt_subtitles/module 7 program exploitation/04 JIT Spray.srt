1
00:00:00,766 --> 00:00:01,866
你好黑客
hello hackers

2
00:00:02,000 --> 00:00:06,300
欢迎来到漏洞利用模块的另一个视频
welcome to yet another video in the exploitation scenarios module

3
00:00:06,300 --> 00:00:09,900
我们将概况的讨论一下JIT spray
we're gonna talk about JIT spraying at a high level

4
00:00:09,933 --> 00:00:12,933
当然，在这个模块（练习题中）你将尝试JIT spray
of course you will have to JIT spray in this module

5
00:00:12,933 --> 00:00:14,533
这很令人激动
which will be super exciting

6
00:00:14,900 --> 00:00:15,700
嗯
um

7
00:00:16,533 --> 00:00:21,333
这里主要是对我们接触过的一个概念的回顾
this is mostly a review of a concept  that we touched on

8
00:00:21,633 --> 00:00:24,999
我们在讨论DEP时讲过
 when we talked about data execution prevention

9
00:00:25,400 --> 00:00:29,500
但是让我们回顾一下安全机制
 but let's recall security mitigations

10
00:00:29,900 --> 00:00:33,200
在shellcode模块中，我们讨论了DEP
in the shellcode module we talked about data execution prevention

11
00:00:33,266 --> 00:00:36,366
这可以防止执行注入的shellcode
which prevents the execution of injected shellcode

12
00:00:36,366 --> 00:00:39,199
例如，让栈不可执行
by making for example the stack not executable

13
00:00:40,900 --> 00:00:43,700
在内存错误模块
in the memory errors module

14
00:00:43,700 --> 00:00:48,700
我们讨论了栈金丝雀，它可以防止栈缓冲区溢出被利用
we talked about stack canaries which protect against stack buffer overflow exploitation

15
00:00:49,100 --> 00:00:53,900
还有ASLR，它使得控制流劫持变得不可靠
and address space layout randomization which makes control flow hijacking unreliable

16
00:00:54,100 --> 00:00:58,200
这些保护机制让现代漏洞利用开发变的困难
so modern exploitation is hard because of all of this stuff

17
00:00:58,900 --> 00:01:05,700
但让我们看看一种可以绕过DEP的方法
but let's look at a way  that we can bypass data execution prevention

18
00:01:05,900 --> 00:01:09,966
主要针对采用了JIT编译的脚本程序
when just in time compilation is in play all right

19
00:01:11,900 --> 00:01:13,933
什么是JIT编译
what is Just in time compilation well

20
00:01:14,333 --> 00:01:16,999
JIT编译是一种非常聪明的技术
just in time compilation is a very clever technique

21
00:01:17,200 --> 00:01:22,000
这使得我们每天依赖的解释型语言变得更快
that allows the interpret languages that we rely on every day to be fast 

22
00:01:22,100 --> 00:01:27,200
具体来说，最大的受益者 javascript
specifically the biggest biggest benefactor of this is javascript

23
00:01:28,066 --> 00:01:30,999
还有一般的现代高级语言
modern higher level languages in general though

24
00:01:31,000 --> 00:01:35,400
包括java, lua, python如果使用了pypy
including java, lua, python if you use the pypy python runtime

25
00:01:36,133 --> 00:01:37,599
都采用了JIT编译技术
utilize just in time compilation

26
00:01:37,600 --> 00:01:42,400
你可以选择javascript Java等语言来编写代码
you write the code in the language of choice javascript java etc

27
00:01:43,900 --> 00:01:49,633
在运行时，如果某段代码被认为对性能至关重要
at runtime if code is deemed to be performance critical 

28
00:01:49,866 --> 00:01:54,799
它将被编译为二进制代码，而不是被解释
instead of being interpreted it will be compiled to binary code

29
00:01:54,800 --> 00:01:57,800
这段二进制代码在执行的时候会非常快
and that binary code will then be extremely fast when it executes

30
00:01:57,800 --> 00:01:59,566
当然了，所以
of course right so

31
00:02:01,533 --> 00:02:03,466
根据你目前的经验
in your experience thus far

32
00:02:03,466 --> 00:02:05,799
在逆向模块里你见到了Yan85(出现在练习题中的Yan教授自制虚拟机)
in the reversing module you saw Yan85

33
00:02:05,900 --> 00:02:09,500
Yan85是一个解释型虚拟机
Yan85 is an interpreted virtual machine

34
00:02:10,366 --> 00:02:13,666
在这里，你可以把它当作一个JIT编译器
here you'll see it as a just in time compiler

35
00:02:13,666 --> 00:02:16,599
然后这样利用它
 and you will have to exploit it that way

36
00:02:17,266 --> 00:02:18,333
当然
now of course

37
00:02:19,266 --> 00:02:24,233
生成的二进制代码
the code the binary code that's generated

38
00:02:24,500 --> 00:02:33,100
与攻击者编写的高级语言代码有关
 is related to the higher level language code that the attacker writes

39
00:02:33,566 --> 00:02:35,799
或者说用户写的
or the user write 

40
00:02:35,800 --> 00:02:39,900
又或者一个网页提供的一些javascript
or a webpage provides some javascript

41
00:02:39,900 --> 00:02:42,766
这些javascript会被编译成本地代码
that javascript gets compiled into native code

42
00:02:42,766 --> 00:02:46,499
然后在受害者的机器上运行
and then runs on the machine of the victim

43
00:02:46,966 --> 00:02:50,299
如果网站是恶意的，坏事就会发生
 if the website is malicious bad things can happen

44
00:02:50,333 --> 00:02:53,999
特别是一种叫做jit spray的攻击
specifically an attack called jit spraying

45
00:02:55,900 --> 00:03:04,500
利用了JIT编译的特性
utilizes this interesting property of just in time compilation

46
00:03:05,200 --> 00:03:14,200
它使攻击者可以控制内存的可执行区域中的值
that gives an attacker control of values in executable areas of memory

47
00:03:14,333 --> 00:03:16,899
所以考虑下面这段javascript代码
so considered a following javascript

48
00:03:16,900 --> 00:03:22,600
假设声明一个asdf变量初始化一个巨复杂的值
let's say you have var asdf equals and then a big complex crazy number

49
00:03:22,666 --> 00:03:24,966
同样的也可以是
you can also imagine the same thing

50
00:03:26,500 --> 00:03:31,000
Yan85中的IMM指令
the Yan85 statement of IMM or instruction of IMM

51
00:03:31,200 --> 00:03:33,733
它将一个立即数赋给寄存器
that assigns an immediate to a register

52
00:03:33,800 --> 00:03:36,266
它也可以有一个巨复杂的参数
could also have a crazy argument

53
00:03:36,600 --> 00:03:40,733
如果Yan85虚拟机支持更高的位数
if Yan85 had more bits to play with

54
00:03:41,600 --> 00:03:46,800
这段js代码可能会JIT编译成以下指令
this might JIT to the following native code

55
00:03:46,800 --> 00:03:48,300
mov rdx, 值
move RDX the number 

56
00:03:49,000 --> 00:03:55,000
对，当然它会被汇编成指令对应的编码
right which assembles of course to some encoding of that instruction

57
00:03:55,100 --> 00:03:57,766
这里是小端序表示的值
here is that number verbatim in little Endian

58
00:03:58,300 --> 00:04:05,200
这个48，表示这是64位指令
and here is that 48  that says hey this is a 64 bit instruction

59
00:04:05,466 --> 00:04:08,599
ba表示将立即数赋值给rdx
ba means move an immediate into RDX

60
00:04:09,600 --> 00:04:14,300
单字节操作码，然后这是操作数
single byte opcode  and then here's the operand

61
00:04:14,500 --> 00:04:17,266
如果有一个漏洞
alright but what if there was another vulnerability

62
00:04:17,200 --> 00:04:22,500
能扰乱指令指针的计算方式，让它把值当作指令执行
that messed with the instruction pointer with how it was calculated to jump in

63
00:04:22,500 --> 00:04:25,566
这个漏洞可能是
and then of course this other vulnerability might be 

64
00:04:25,733 --> 00:04:28,733
内存损坏，溢出覆盖指令指针的一个字节
a memory corruption overflowing one byte of the instruction pointer

65
00:04:29,500 --> 00:04:33,700
有很多不同的可能性
a lot of potential different ways that can happen

66
00:04:33,900 --> 00:04:37,500
如果我们不直接跳到指令的开头
but what if we jump not to the beginning of the instruction

67
00:04:37,866 --> 00:04:39,733
而是跳转到指令开头的2字节后
but we jump 2 byte in

68
00:04:39,733 --> 00:04:42,366
如果跳转到指令开头的2字节后，将从这里开始执行
if we jump 2 byte in we start executing right here

69
00:04:42,666 --> 00:04:44,133
就好像这里开始才是指令
as if this was the beginning of the instruction

70
00:04:44,100 --> 00:04:46,800
如果我们反汇编这个值
if we disassemble this code

71
00:04:47,000 --> 00:04:53,000
它是被精心设计的exit系统调用的指令
it was carefully crafted to disassemble to an exit system call

72
00:04:54,000 --> 00:04:56,100
当然也可以被设计成任何其他的系统调用
but of course it could be any other system call

73
00:04:56,100 --> 00:05:01,500
只要我们在上层语言中精心设计常量值
so by carefully creating constants in our higher level language

74
00:05:01,533 --> 00:05:03,733
这个上层语言可以是我们的模拟解释语言
in our emulate interpreted language

75
00:05:03,766 --> 00:05:05,933
或者任何使用JIT的语言
or just in time compiled language rather

76
00:05:06,500 --> 00:05:15,000
我们可以ummm
we can um cause um system calls to be umm

77
00:05:15,100 --> 00:05:18,800
我们可以执行想要的代码
we can execute controlled native code

78
00:05:19,533 --> 00:05:20,999
这很酷，但是
so that's cool but

79
00:05:21,800 --> 00:05:23,066
alsr怎么绕过?
what about alsr 

80
00:05:23,366 --> 00:05:25,566
DEP只是
data execution prevention is only 

81
00:05:25,666 --> 00:05:30,099
我们目前讨论过的三种安全机制中的一种
one of the kind of trifecta of mitigations  that we talked about so far

82
00:05:30,900 --> 00:05:38,100
在内存错误模块，讲了金丝雀的绕过或泄漏方法
we've seen ways to bypass stack canaries situational ways or leak them out  in the memory corruption module

83
00:05:38,200 --> 00:05:41,166
但是地址空间布局随机化呢
but what about address space layout randomization

84
00:05:42,933 --> 00:05:47,699
这个例子中只有一个变量
well this example just has one variable right here

85
00:05:48,000 --> 00:05:50,733
但如果是这样呢？
what if you did something like this

86
00:05:51,200 --> 00:05:52,933
我才发现很难看清
hard to see now I realize

87
00:05:53,100 --> 00:05:57,600
这里声明了成百上千个相同的变量
but this is hundreds and hundreds of declarations of the same variable

88
00:05:57,700 --> 00:05:59,866
这是一种偷懒的方法
and this is kind of a lazy way of doing it

89
00:05:59,800 --> 00:06:03,300
还有更聪明的方法可以动态生成此代码
there are more intelligent ways you could dynamically generate this code

90
00:06:03,300 --> 00:06:06,900
尤其是像javascript这样的高级语言
especially in javascript on high level languages like this

91
00:06:07,066 --> 00:06:09,733
然后这些代码会被运行时编译成
and then that code would be just in time compiled into

92
00:06:10,100 --> 00:06:15,900
包含你需要的常量的多个内存页
pages upon pages upon pages on pages that contain the Constants that you need

93
00:06:16,366 --> 00:06:19,899
大大提高开启aslr后跳转命中率
and then you jump and hope you get lucky

94
00:06:19,900 --> 00:06:25,900
前面的模块中体验过了暴力破解内存偏移量的方法
you've experienced brute forcing memory offsets already in the previous module

95
00:06:27,366 --> 00:06:30,566
靶子越大，就越容易击中
the more code that you can jump to the easier that gets

96
00:06:30,566 --> 00:06:34,199
这不是ASLR的完美解决方案
it's not a full solution to ASLR

97
00:06:34,533 --> 00:06:41,499
但它能显著提高成功几率
 but it helps improve success significantly 

98
00:06:42,100 --> 00:06:46,700
在非ASLR的其他随机性的背景下也是一样
in also in the context of other randomness from other sources other than ASLR

99
00:06:48,333 --> 00:06:52,199
这就是JIT spray. 一项强大的技术
so that is jit spraying it's a powerful technique

100
00:06:53,300 --> 00:07:00,700
到今天在很多情况下仍然是一个可用的攻击方法
and remains a usable attack vector in a lot of situations to this day

101
00:07:01,333 --> 00:07:03,699
尤其是现在JIT的使用激增
especially as jits proliferate

102
00:07:03,700 --> 00:07:08,600
有javascript java python lua等的JIT编译器
there are just in time compilers like I said for javascrip java python lua

103
00:07:08,666 --> 00:07:09,533
它们都是不同的
and they're all different

104
00:07:09,500 --> 00:07:13,900
它们都基于不同的代码，但有很多相同的bug
they're all based on different code bases of course with a lot of the same bugs

105
00:07:14,300 --> 00:07:16,300
在这个模块中（练习题中）
um in this module

106
00:07:16,500 --> 00:07:17,400
就像我暗示的那样
like I hinted

107
00:07:17,400 --> 00:07:20,900
将遇到到Yan85的JIT编译器
you will see a just in time compiler for Yan85

108
00:07:21,333 --> 00:07:22,133
祝你好运
good luck

