1
00:00:00,900 --> 00:00:04,800
现在已经看了正常情况的bin
so now that we've seen how the heap bins work during normal operation

2
00:00:04,800 --> 00:00:09,400
以及chunk是如何缓存到不同bin的
and how chunks can flow between the different bins based on what is occurring

3
00:00:09,766 --> 00:00:12,533
接下来看一下如何运用这些概念
let's take a look at how we can apply those concepts

4
00:00:12,533 --> 00:00:15,900
来控制堆做我们想做的事情
to control the heap and start getting it to do what we want

5
00:00:17,166 --> 00:00:18,533
在此之前
now before going any further

6
00:00:18,533 --> 00:00:19,900
值得强调的是
it's worth emphasizing

7
00:00:19,900 --> 00:00:24,200
堆利用严重依赖于libc版本
that heap exploits are heavily dependent on the libc version

8
00:00:24,800 --> 00:00:26,266
在这个模块中
for this module

9
00:00:26,500 --> 00:00:31,500
所有题目都适用于 libc 2.35
all of the challenges should be working with libc version 2.35

10
00:00:31,500 --> 00:00:37,400
这是 ubuntu 22.04 lts 默认的libc版本
which is the latest version of libc that is used on ubuntu 22.04 lts

11
00:00:37,533 --> 00:00:41,866
我记得libc 2.36版已经发布了
I do believe libc version 2.36 is out

12
00:00:42,500 --> 00:00:46,100
但是我不打算在我们的练习题中用它
however I do not intend on using it for these challenges

13
00:00:46,666 --> 00:00:47,733
不管出于什么原因
and for whatever reason

14
00:00:47,866 --> 00:00:53,166
所有不使用 2.35版本的练习题
any of the challenges use a different version of libc than version 2.35

15
00:00:53,166 --> 00:00:55,766
都会明示
the challenge will explicitly state it

16
00:00:57,366 --> 00:01:00,133
libc版本很重要的原因是
now the reason that the libc version matters

17
00:01:00,266 --> 00:01:05,900
不同版本的libc有不同的安全检查
 is different versions of libc will have different validation checks or verification checks

18
00:01:06,600 --> 00:01:09,100
所以漏洞利用的要求
and so the requirement

19
00:01:09,700 --> 00:01:12,600
能做的，能改的
as far as what you can do and what you can change

20
00:01:12,666 --> 00:01:15,266
每个版本的libc都不一样
is going to be different for every version of libc

21
00:01:16,200 --> 00:01:19,966
一个很好的例子就是安全链接
a good example of this that we've seen is safe linking

22
00:01:20,266 --> 00:01:25,100
安全链接只存在于现代libc的tcache和fast bins中
a safe linking is present on modern libc in tcache and fast bins

23
00:01:25,500 --> 00:01:28,500
往前几个版本的libc
however if we were to go back a couple versions of libc

24
00:01:28,533 --> 00:01:31,733
tcache 和 fast bins 中就没有安全检查
there is no safe linking on tcache or fast bins

25
00:01:31,733 --> 00:01:34,766
再往前几个版本
and if we were to go a few versions back from there

26
00:01:35,000 --> 00:01:37,266
甚至 tcache 都不存在
the tcache itself doesn't exist

27
00:01:37,500 --> 00:01:39,733
但还有 fast bins
but we would still encounter fast bins

28
00:01:40,333 --> 00:01:44,366
所以当在网上看到一些堆利用方法时
and so when you're looking online for heap exploitation

29
00:01:44,433 --> 00:01:48,633
要注意这个利用方法是什么时期的
it's very important to be aware of how old is this exploit

30
00:01:48,700 --> 00:01:52,900
它是针对什么版本的libc写的
what version of libc was this written against

31
00:01:53,100 --> 00:01:59,900
因为有的针对fast bins的利用方法，可能没考虑 tcache
because there are fastbin exploits that used to work on libc that didn't have tcache

32
00:02:00,000 --> 00:02:05,600
单是 tcache 的引入就改变了fast bin的利用方式
just the introduction of tcache changed the way that we interact with fast bin

33
00:02:07,100 --> 00:02:11,900
还有些特性，不像tcache是新加的，而是弃用了
now sometimes features aren't added like tcache but actually removed

34
00:02:12,000 --> 00:02:15,300
malloc hook就是一个很好的例子
a good example of this is the malloc hook symbol

35
00:02:15,566 --> 00:02:17,733
它用于调试
which was meant for debugging purposes

36
00:02:17,733 --> 00:02:21,633
你可以在这个hook符号处写入地址
it was a symbol where you could write an address

37
00:02:21,866 --> 00:02:26,133
不管它指向哪里，malloc都会调用它
 and whatever that address was would get called when malloc was called

38
00:02:27,266 --> 00:02:31,166
这是一个很常见的攻击媒介
now this was such a common vector for exploitation

39
00:02:31,166 --> 00:02:34,133
后来被从libc中删除了
that it was actually removed from libc entirely

40
00:02:34,200 --> 00:02:39,500
所以如果你在网上发现一个依赖于malloc Hook的堆利用
and so if you find a heap exploit online that relies on malloc Hook

41
00:02:40,300 --> 00:02:41,966
现在已经没用了
that doesn't exist anymore

42
00:02:44,566 --> 00:02:46,666
需要好几个小时
now it would take several hours

43
00:02:46,900 --> 00:02:57,800
才能过一遍libc 2.35中这些有名的堆利用
to go through all of the specific named heap exploits that exist in work in libc 2.35

44
00:02:59,100 --> 00:03:00,733
它们都非常巧妙
all of them are very nuanced

45
00:03:00,733 --> 00:03:03,500
都需要特定的设置
there's a very specific setup that is occurring

46
00:03:03,500 --> 00:03:07,400
来创建相应堆漏洞环境
to create the situation inside of the heap where the exploit can occur 

47
00:03:08,800 --> 00:03:10,300
不会挨个演示
rather than do with that

48
00:03:10,466 --> 00:03:11,400
我要讨论的是
I'm going to discuss

49
00:03:11,400 --> 00:03:14,833
这些漏洞中使用的核心概念
some of the core concepts that are used in these exploits

50
00:03:14,933 --> 00:03:16,366
所以在看这些漏洞时
so that when you look at them

51
00:03:16,366 --> 00:03:18,400
你能推理出发生了什么
you can reason about what is occurring

52
00:03:18,600 --> 00:03:22,166
并理解如何才能创建一个相同情景
and what you need to do to create the same scenario

53
00:03:22,166 --> 00:03:25,000
然后复现你见到的利用方法
and replicate an exploit that you see

54
00:03:26,200 --> 00:03:29,900
这些复杂堆利用中使用的许多概念
now many of the concepts that are used in these more complicated heap exploit

55
00:03:29,966 --> 00:03:31,766
我们都见过
which are things that we've already seen

56
00:03:32,000 --> 00:03:35,500
因为我们在之前 tcache 模块已经用过了
because we've done them in earlier heap modules with tcache

57
00:03:35,900 --> 00:03:38,000
比如双重释放
things like creating a double free

58
00:03:38,500 --> 00:03:40,500
你可能需要先使用双重释放
you may need to create a double free 

59
00:03:40,800 --> 00:03:45,700
来作为更复杂堆利用的引子
to even begin the exploitation process where a more complicated heap exploit

60
00:03:45,900 --> 00:03:48,133
再比如 释放重用
or having a use after free

61
00:03:48,700 --> 00:03:50,266
我们也见过了释放重用
we've seen use after free

62
00:03:50,600 --> 00:03:56,100
许多有名的堆利用都需要释放重用才能实现
many of the name heap exploits require a use after free in order to pull them off

63
00:03:57,333 --> 00:04:00,466
所以当你发现这些堆利用方法时
so when you look at these named heap exploits

64
00:04:00,800 --> 00:04:02,866
他们需要一个释放重用
and you see that they need a use after free

65
00:04:03,100 --> 00:04:08,233
你就应该考虑如何创建一个释放重用
you should be thinking how can I create a use after free primitive in the challenge 

66
00:04:08,333 --> 00:04:11,300
来复现这个技巧
to replicate that exploitation technique

67
00:04:11,466 --> 00:04:13,800
如果无法创建释放重用
if I can't create a use after free

68
00:04:13,900 --> 00:04:16,466
那么这个技巧就不适用
then that technique simply won't apply

69
00:04:17,800 --> 00:04:22,900
在复杂堆利用中还存在另外两个核心概念
two other things that we've seen that also exist in more complicated heap exploitation

70
00:04:22,966 --> 00:04:24,700
一是堆元数据破坏
is corrupting heap metadata

71
00:04:24,933 --> 00:04:27,100
这个我们也见过
we've seen this where we overflow

72
00:04:27,166 --> 00:04:29,733
从一个chunk中溢出到下一个
from one allocation into the next 

73
00:04:29,866 --> 00:04:31,366
破坏 tcache 的元数据
and corrupt tcache metadata

74
00:04:31,400 --> 00:04:34,566
同样的它也存在于堆下层bins中
the same thing exists on the heap bins

75
00:04:34,600 --> 00:04:36,700
只是元数据略有不同
except the metadata is slightly different

76
00:04:37,133 --> 00:04:39,500
现在有前向和后向指针
because now we have those forward and backward pointers

77
00:04:39,500 --> 00:04:40,933
是个双链表
it's now a doubly linked list

78
00:04:40,933 --> 00:04:42,800
有不同的校验步骤
we have different verification steps

79
00:04:42,800 --> 00:04:45,300
但原理还是一样的
but the same principle still exists 

80
00:04:45,466 --> 00:04:48,600
我们可以破坏内存和元数据
we can corrupt memory and corrupt that metadata

81
00:04:48,600 --> 00:04:52,500
使堆行为失常或以意想不到的方式运行
to make the heap misbehave or act in an unintended manner

82
00:04:53,800 --> 00:04:58,100
最后tcache中还有重叠分配
lastly in the module we saw overlapping allocations on the tcache

83
00:04:58,300 --> 00:05:03,300
堆下层也存在重叠分配
overlapping allocations still exist with the heap heap

84
00:05:03,800 --> 00:05:08,900
不过现在要创建重叠分配就有点困难了
now it's going to be a little bit more difficult to create an overlapping allocation

85
00:05:09,166 --> 00:05:11,733
因为元数据更复杂
because the metadata is more complex

86
00:05:11,800 --> 00:05:18,500
但是仍然可以创建重叠分配
but the overlapping allocation primitive can still be created

87
00:05:19,400 --> 00:05:24,866
有一些堆利用技术
now there are exploitation techniques that exist on the heap heap

88
00:05:25,166 --> 00:05:27,699
在 tcache 中没有
that didn't exist with tcache

89
00:05:27,800 --> 00:05:32,000
其一是利用合并
and one of those things is taking advantage of consolidation

90
00:05:32,066 --> 00:05:34,166
因为 tcache 不会合并
because tcache doesn't consolidate

91
00:05:34,933 --> 00:05:36,900
那我们能利用合并做什么呢
so what can we do with consolidation

92
00:05:37,333 --> 00:05:39,466
有几件事要记住
well there's a couple things to keep in mind

93
00:05:40,133 --> 00:05:45,100
首先，不会放到 tcache 或 fast bin的chunk
first remember that chunks that do not go to tcache or fast bin

94
00:05:45,200 --> 00:05:47,166
都会放到 unsorted bin
go to the unsorted bin

95
00:05:47,300 --> 00:05:50,333
他们就像被延缓了截止日期
they're all kind of given that extra life 

96
00:05:50,566 --> 00:05:54,100
看看在这段时间能不能被从unsorted bin中捞出去
to see if the chunk can come back from the unsorted bin

97
00:05:54,766 --> 00:05:59,100
我们可以控制unsorted bin
we can control what happens at the unsorted bin

98
00:05:59,733 --> 00:06:02,666
申请一个large chunk
a correctly sized like a large malloc 

99
00:06:02,800 --> 00:06:09,000
能清空fast bins 和 unsorted bin，并且导致整合
can clear the fast bin and the unsorted bin and cause consolidation

100
00:06:09,700 --> 00:06:15,000
同样，也可以让不想被合并的chunk不被合并
similarly maybe there is an allocation that I do not want to be consolidated

101
00:06:15,100 --> 00:06:17,166
同时还要清空这2类bin
but I still want to clear out the bin

102
00:06:17,666 --> 00:06:22,333
我们可以通过精心构建堆来实现
well we can do that by carefully crafting the heap 

103
00:06:22,566 --> 00:06:25,866
我们可以创建 卫兵chunk
such that we have a guard allocation

104
00:06:25,900 --> 00:06:32,800
这个卫兵chunk只是为了防止目标chunk合并
and this guard allocation solely exists to prevent consolidation from occurring to another chunk

105
00:06:33,200 --> 00:06:35,000
看一下工作原理
let's take a look at how that works

106
00:06:36,900 --> 00:06:42,300
这里有一个玩具程序
all right so what I have here is a kind of toy program

107
00:06:42,400 --> 00:06:47,200
它与前面堆模块的题目非常相似
very similar to what we've seen with some of the heap challenges in the earlier modules

108
00:06:47,266 --> 00:06:50,366
这里很多堆题目都有这么一个循环
a lot of heap challenges follow this type of loop format 

109
00:06:50,500 --> 00:06:57,100
在这里可以调用 malloc、free、update、read、write之类的函数
where you can malloc free update read write that type of thing

110
00:06:57,533 --> 00:07:01,166
对于现在的目标，我只需要malloc和free
now for our purposes all I need is malloc and free

111
00:07:01,800 --> 00:07:06,400
我第一点说了，通过malloc一个large chunk
so my first claim was that with a correctly sized large malloc

112
00:07:06,600 --> 00:07:11,800
可以清空fast bin和 unsorted bin，并导致fastbin整合
we can clear the fast bin or the unsorted bin and cause consolidation

113
00:07:12,766 --> 00:07:16,000
看看我为此设计的代码
so let's look at my code for that

114
00:07:16,733 --> 00:07:19,966
我总共要malloc 9次
so I'm going to malloc 9 times in total

115
00:07:20,466 --> 00:07:22,266
先malloc 7次
I'm going to malloc 7 times 

116
00:07:22,433 --> 00:07:24,766
因为要把他们放到tcache中（填满链表）
because I intend to free them into the tcache

117
00:07:24,900 --> 00:07:27,066
还要释放2次
I'm going to free an additional 2

118
00:07:27,533 --> 00:07:30,133
要把他们放到 fast bin中
because I intend these to go to the fastbin

119
00:07:30,733 --> 00:07:33,800
注意，我申请的大小很小
note that the size of my allocation is small

120
00:07:34,000 --> 00:07:38,500
这样才能被放到fast bins中
so this is an allocation that is eligible to go to fast bins

121
00:07:38,866 --> 00:07:42,100
我会输出PID，然后再开始交互
I'm going to print the PID and then go interactive

122
00:07:42,200 --> 00:07:44,333
以便我们可以在GDB中查看
so that we can take a look at it in GDB

123
00:07:44,333 --> 00:07:45,500
发生了什么
and see what's going on

124
00:07:48,500 --> 00:07:50,466
先用gdb 附加目标进程
all right let's attach a GDB

125
00:07:57,566 --> 00:08:00,000
首先我想查看一下 bins
so the first thing I want to look at is the bins

126
00:08:00,166 --> 00:08:04,200
能看到我想要的实现了
and we see that what I intended to occur is what occurred

127
00:08:04,333 --> 00:08:08,333
tcache中有7个chunk
we have seven chunks in the tcache

128
00:08:08,566 --> 00:08:13,300
fast bin中有2个chunk
and we have two chunks here in the fast bin

129
00:08:14,300 --> 00:08:22,300
能看到一个在27a0，另一个在27c0
we'll note that one of them is 27a0 and the other one is 27c0

130
00:08:22,700 --> 00:08:28,600
这是他们在fast bin单链表中的顺序
now this is the order of them in this singly linked list of fastbin

131
00:08:28,900 --> 00:08:33,900
还有一个命令可以查看chunk的物理位置
there's another command that I can use to look at the physical location of the chunks

132
00:08:33,933 --> 00:08:36,766
并推断它们在内存中的位置
and reason about where they are in memory

133
00:08:36,800 --> 00:08:38,700
那就是heap chunks
and that would be heap chunks

134
00:08:39,500 --> 00:08:44,300
能看到在 27a0 处有个chunk
and we see here that there is a chunk 27a0

135
00:08:44,566 --> 00:08:48,466
然后紧接着一个在27c0
and that immediately after that is 27c0

136
00:08:48,700 --> 00:08:52,300
所以这两个块在内存中是紧挨着的
so these two chunks are right next to each other in physical memory

137
00:08:52,600 --> 00:08:53,933
就算我不打印出这个
if I didn't print this out 

138
00:08:54,000 --> 00:08:56,700
我仍然可以这样推断
I could still reason that is the case

139
00:08:56,700 --> 00:09:04,333
因为827a0加0x20等于827c0
because 827a0 plus hex 20 is 827c0

140
00:09:07,666 --> 00:09:10,566
同样值得注意的是
it's also worth noting that

141
00:09:11,900 --> 00:09:17,700
a0，C0，然后就是wilderness
we have a0 we have C0 and then we have the wilderness

142
00:09:18,500 --> 00:09:21,300
最后这个chunk 很大
this last chunk here is very large

143
00:09:21,300 --> 00:09:29,700
它表示当前存在于堆中的所有未分配数据
but this represents all of the unallocated data that exists currently in the heap

144
00:09:30,300 --> 00:09:35,033
所以当我malloc一个large chunk 会发生什么呢
so what's going to occur when I malloc something large

145
00:09:35,933 --> 00:09:37,733
当我malloc一个large chunk
well if I malloc something large

146
00:09:38,566 --> 00:09:41,866
tcache 无法满足它
it is not going to be satisfied by the tcache

147
00:09:41,866 --> 00:09:44,366
fast bin 也无法满足它
it's not going to be satisfied by fast bin

148
00:09:44,366 --> 00:09:46,700
它也不会在small bins里找
it's not going to look in the small bin

149
00:09:46,766 --> 00:09:48,733
因为是malloc的一个large chunk
because I'm mallocing something large

150
00:09:49,200 --> 00:09:53,200
这就意味着我们要清空fast bins
and so that means that we're going to flush the fast bins

151
00:09:54,066 --> 00:09:56,066
我们清空fast bins后
when we flush the fastbins 

152
00:09:56,300 --> 00:10:02,066
这些chunk将能被合并
these chunks will become eligible for consolidation

153
00:10:02,500 --> 00:10:09,500
要记住：合并由PREV_INUSE 位决定
now remember that consolidation is determined by this previous in use bit

154
00:10:09,900 --> 00:10:18,200
尽管27c0前面的，也就是27a0
and even though the previous of 27c0 which is 27a0 

155
00:10:18,433 --> 00:10:23,700
尽管它应该被标记为0
even though this one should be marked as previous not in use

156
00:10:24,533 --> 00:10:27,466
但它还是被标记为1
it is marked as previous in use

157
00:10:27,700 --> 00:10:30,200
这是因为它在fast bins里
this is because it's in the fastbins

158
00:10:30,333 --> 00:10:32,866
所以当我们清空fast bins时
so whenever we flush the fast bins

159
00:10:33,466 --> 00:10:38,966
27c0的PREV_INUSE位将被清0
27c0 the previous in use bit is going to be cleared

160
00:10:39,300 --> 00:10:42,566
这使它能被合并
which then makes it eligible for consolidation

161
00:10:43,766 --> 00:10:45,500
当它被合并时
and when that gets consolidated 

162
00:10:45,666 --> 00:10:50,733
它会和27a0合并，也就是向后合并
it will merge with 27a0 and it will consolidate backwards

163
00:10:50,933 --> 00:10:54,900
但它也会向前合并进wilderness
but it can also consolidate forward into the wilderness

164
00:10:55,033 --> 00:11:02,300
所以我们会看到所有这些chunk突然变成了一个
and so what we'll see is  all of these chunks here will suddenly become one

165
00:11:09,800 --> 00:11:13,300
现在malloc一个large chunk
so let's malloc something large

166
00:11:15,200 --> 00:11:18,900
然后看一下 heap chunks 
and then take a look at heap chunks

167
00:11:20,500 --> 00:11:22,133
发生了什么?
and what happened 

168
00:11:22,400 --> 00:11:23,566
我们看到了
well we saw 

169
00:11:26,400 --> 00:11:31,800
之前说的，所有这些会合并成一个
I claimed that all of these would merge together into one

170
00:11:32,200 --> 00:11:33,166
确实是这样
and they did

171
00:11:34,000 --> 00:11:38,600
这发生在malloc返回之前
they did that before we returned an answer to this malloc

172
00:11:39,000 --> 00:11:46,166
他们合并成了一个在27a0处的巨大chunk
so we merged it all together into one giant chunk starting at 27a0

173
00:11:47,400 --> 00:11:52,300
然后我们该满足malloc请求了
then we had to satisfy that malloc

174
00:11:52,700 --> 00:11:58,700
我们从这个巨大chunk中分出2000B并返回
and so we had this giant chunk  and we broke off 2000 bytes and returned it

175
00:11:58,733 --> 00:12:01,066
但这2000字节是从哪里开始的呢
but where did those 2000 bytes begin

176
00:12:01,366 --> 00:12:05,066
它们从827a0开始
they began at 827a0

177
00:12:05,200 --> 00:12:09,100
我们看到这个malloc返回的地址
and so we see the address that was returned by this malloc

178
00:12:09,300 --> 00:12:13,100
与此处malloc返回的地址相同
is the same as the address that was returned by this malloc

179
00:12:13,300 --> 00:12:16,966
尽管申请的尺寸大不相同
despite the sizes being drastically different

180
00:12:19,366 --> 00:12:22,933
这样我们就可以导致整合发生
and so we can cause consolidation to occur

181
00:12:23,700 --> 00:12:27,300
同样，也可以在unsorted bin中实现类似效果
and you can do a similar thing with the unsorted bin

182
00:12:27,700 --> 00:12:35,100
malloc的值要比unsorted bin里的chunk大
you would malloc something that is larger than the values in the unsorted bin

183
00:12:35,233 --> 00:12:38,766
这样会排完整个unsorted bin
and it would sort the unsorted bin

184
00:12:39,500 --> 00:12:43,000
可以针对unsorted bin整点创新
now you can get a little bit creative here with the unsorted bin

185
00:12:43,200 --> 00:12:48,300
因为如果你在unsorted bin中放入递增的chunk
because if you strategically place increasing values into the unsorted bin

186
00:12:48,500 --> 00:12:58,100
比如把0x2000, 0x3000, 0x4000大小的放进unsorted bin
like let's say we put 0x2000 then 0x3000 then 0x4000 into the unsorted bin

187
00:12:58,700 --> 00:13:04,500
然后malloc 一个0x3000的
and then I put in a malloc request for hex 3000

188
00:13:06,200 --> 00:13:07,566
会发生什么呢
what's going to happen

189
00:13:08,133 --> 00:13:11,833
先会看这个0x2000的chunk
well it's going to look at the Hex 2000

190
00:13:11,966 --> 00:13:13,733
这个显然不满足0x3000
and say this is unsatisfactory

191
00:13:13,733 --> 00:13:15,900
0x2000里分不出一个0x3000的chunk
I can't make 3000 out of 2000

192
00:13:16,033 --> 00:13:20,166
它会把这个0x2000B的chunk放到large bin
and so it would sort the 2000 byte chunk

193
00:13:20,700 --> 00:13:24,800
然后再看这个0x3000B的chunk
then it would grab and look at the 3000 byte chunk

194
00:13:24,866 --> 00:13:27,900
能分出一个0x3000B的chunk吗
 and say can I make a 3000 byte chunk out of 3000 bytes

195
00:13:27,900 --> 00:13:30,366
可以的，这正是需要的
well the answer is yes this is exactly what I need

196
00:13:30,466 --> 00:13:32,800
然后停止排序
and so it would stop sorting

197
00:13:32,866 --> 00:13:35,733
并返回0x3000B的chunk
and return the 3000 byte chunk

198
00:13:36,700 --> 00:13:39,866
不会再去看0x4000B的chunk
4000 byte chunk doesn't even get looked at

199
00:13:39,866 --> 00:13:42,166
它依旧放在unsorted bin里
it's still sitting in the unsorted bin

200
00:13:43,200 --> 00:13:47,733
所以你对unsorted bin有多少控制取决于
and so with the unsorted bin you have a bit more control depending upon 

201
00:13:47,766 --> 00:13:51,200
你对chunk大小
how much influence you have on the size of the chunks 

202
00:13:51,266 --> 00:13:58,266
以及他们在unsorted bin排序时的顺序有多少影响
and the order of them in the unsorted bin as far as flushing them out

203
00:13:59,300 --> 00:14:03,300
要说的第二点是
now my second claim here is that conversely

204
00:14:03,400 --> 00:14:07,966
你可以选定一个chunk，阻止它被合并
you can choose to hold an allocation and prevent consolidation 

205
00:14:08,366 --> 00:14:13,500
可以不改变chunk个数实现这个
now I could do this with the same number of chunks

206
00:14:13,500 --> 00:14:23,200
但我觉得如果稍微修改一下，会更容易理解
but I feel that it's easier to understand if I slightly modify one in a clear manner

207
00:14:23,333 --> 00:14:26,900
第一点和第二点的差异很小
so the difference here between 1 and 2 is pretty small

208
00:14:27,400 --> 00:14:33,500
这里我依旧先申请7个大小为8的chunk
we see here I'm still mallocing 7 instances of size 8

209
00:14:33,900 --> 00:14:38,200
再申请2个，用于填充fast bin
I'm then going to malloc 2 that I intend to put into fast bin

210
00:14:38,700 --> 00:14:40,600
我再多申请一个
and I'm going to malloc 1 more

211
00:14:41,000 --> 00:14:45,266
这多出来的一个
and this 1 more is there to serve as like a 

212
00:14:45,300 --> 00:14:48,700
我称之为合并卫士
consolidation guard is what I'm going to call it

213
00:14:50,133 --> 00:14:52,333
先释放头7个
we're going to free the first 7

214
00:14:52,666 --> 00:14:54,500
他们会放到tcache
so that we fill the tcache

215
00:14:55,133 --> 00:14:58,566
然后释放下标为7的chunk
I'm then going to free index 7

216
00:14:58,733 --> 00:15:01,000
我不释放下标为8的
I'm not going to free 8

217
00:15:01,533 --> 00:15:03,800
再释放下标为9的
and I am going to free 9

218
00:15:05,900 --> 00:15:07,566
启动程序
so let's run this 

219
00:15:10,900 --> 00:15:12,866
并用GDB附加进程
and attach GDB to it

220
00:15:21,933 --> 00:15:23,566
检查一下bins
if we look at the bins 

221
00:15:23,733 --> 00:15:29,133
这看起来与前面的例子非常相似
this looks very similar to what we've had in the prior example

222
00:15:29,200 --> 00:15:33,300
有7个chunk被释放到tcache中
I have 7 chunks freed into the tcache

223
00:15:33,533 --> 00:15:36,866
fast bin中有2个
I have 2 chunks here in fast bin

224
00:15:37,133 --> 00:15:40,266
有什么不同？这个卫士有什么用
so what is different what did this guard do

225
00:15:41,866 --> 00:15:43,866
查看一下heap chunks
well let's look at heap chunks

226
00:15:44,700 --> 00:15:48,366
现在fastbin里有两个元素
now I have two entries in fastbin

227
00:15:48,733 --> 00:15:53,000
分别在 7a0 和 7e0
I have 7a0 and I have 7e0

228
00:15:53,733 --> 00:15:55,766
这里是7a0
well here 7a0

229
00:15:56,966 --> 00:15:59,266
这里是7e0
and here 7e0

230
00:16:01,200 --> 00:16:08,900
卫士在 7c0 处
so my guard chunk was this one right here ending in 7c0

231
00:16:09,866 --> 00:16:11,800
那么现在会发生什么呢
so what will happen now

232
00:16:12,300 --> 00:16:16,533
它处于fastbin里的2个chunk之间
and it's sitting in between the two entries in fast bin

233
00:16:16,733 --> 00:16:18,366
会发生什么呢
so what will happen now

234
00:16:18,366 --> 00:16:20,966
如果我malloc一个large chunk
if I would malloc something large

235
00:16:22,400 --> 00:16:27,400
还是会触发fast bins整合
well we would still flush the fast bin like that occurs no matter what

236
00:16:28,266 --> 00:16:30,466
但当fast bins整合时
but when we flush the fast bin

237
00:16:31,800 --> 00:16:35,100
对这些chunk的处理方式是不同的
we have to treat each one of these chunks differently

238
00:16:35,900 --> 00:16:40,300
对于在7e0的chunk
so 7E0 this chunk here

239
00:16:40,800 --> 00:16:46,900
它的PREV_INUSE位不变
its previous in use bit will not change

240
00:16:47,600 --> 00:16:51,600
因为卫士还没free
because the guard is still allocated

241
00:16:51,766 --> 00:16:53,600
它不在 fast bin中
this isn't in fast bin

242
00:16:54,700 --> 00:16:59,100
当这个7e0处的chunk能被合并后
so then when this chunk becomes available

243
00:16:59,300 --> 00:17:03,600
他可能会向前合并到wilderness中
it may consolidate forward into the wilderness

244
00:17:03,966 --> 00:17:05,200
这种情况仍有可能发生
that could still occur

245
00:17:06,666 --> 00:17:09,666
但它不能向后合并
but it can't consolidate backwards

246
00:17:11,400 --> 00:17:15,133
那对于7a0处的chunk呢
now what's going to happen with 7a0

247
00:17:15,500 --> 00:17:19,500
就是这个在fast bin里的chunk
which is this chunk right here that's in fast bin

248
00:17:19,800 --> 00:17:24,300
对于7a0处chunk的PREV_INUSE位
well 7a0 it's previous in use bit

249
00:17:24,766 --> 00:17:26,100
它会改变吗?
will it change

250
00:17:26,966 --> 00:17:28,166
并不会
well the answer is no

251
00:17:28,200 --> 00:17:31,766
它后面的是什么？780
what's behind it 780

252
00:17:31,900 --> 00:17:35,266
780的chunk在某处使用着
780 is in use somewhere

253
00:17:36,800 --> 00:17:39,700
所以清理fast bin时，7a0的PREV_INUSE不会变
so that's not going to change when we flush the fast bin

254
00:17:40,500 --> 00:17:46,400
所以我们会看到7e0处的chunk
so what we would expect to see is 7E0 which is this chunk right here

255
00:17:46,500 --> 00:17:48,300
会向前合并
will consolidate forward

256
00:17:49,166 --> 00:17:53,200
7a0处的chunk则不会发生合并
7a0 is not eligible for consolidation

257
00:17:53,400 --> 00:17:55,533
那这个chunk会放到哪里呢
so where does this chunk go

258
00:17:57,500 --> 00:17:59,000
先看一下它的大小
well how big is it

259
00:17:59,533 --> 00:18:02,066
chunk大小为0x20
this is a chunk of size hex 20

260
00:18:02,133 --> 00:18:05,066
所以排序时
so if we had to sort this chunk and put it somewhere

261
00:18:05,166 --> 00:18:07,066
它会被放到 small bins中
it should end up in the small bin

262
00:18:07,800 --> 00:18:13,100
所以我预计7a0会放到small bins
so I am expecting to see 7a0 go to the small bins

263
00:18:14,366 --> 00:18:16,500
我们malloc一个large chunk试试
let's perform the large allocation

264
00:18:20,100 --> 00:18:22,733
看看之后堆是什么样的
and see how that influenced the heap

265
00:18:24,500 --> 00:18:25,933
看一下bins
looking at the bins

266
00:18:26,800 --> 00:18:33,300
能看到确实如预期的，fastbin被清空了
I do see that fast bins was flushed which we knew was going to happen

267
00:18:33,766 --> 00:18:39,466
不同之处在于，7a0现在在small bins
the difference is 7a0 is now here in the small bins

268
00:18:39,800 --> 00:18:43,600
能看到它现在有前向和后向指针
and we see that it has a forward pointer and a backward pointer now

269
00:18:43,700 --> 00:18:45,866
因为它现在在small bins里
because now it is in the small bins

270
00:18:45,866 --> 00:18:49,700
所以它是双链表的一部分
and so it is part of a doubly linked list

271
00:18:50,400 --> 00:18:54,600
刚刚讨论的其它chunk呢
well what happened to the other chunk that we are talking about

272
00:18:55,133 --> 00:18:58,500
原来那个 7e0 呢
what was that one 7e0

273
00:18:58,700 --> 00:19:02,133
找不到了
well I don't see 7e0 here

274
00:19:03,200 --> 00:19:04,000
为什么
why

275
00:19:04,800 --> 00:19:11,000
因为 7e0已经合并到 wilderness中了
well 7e0 consolidated forward with the wilderness

276
00:19:11,000 --> 00:19:19,200
然后是一个可以从中取2000B的地址
and then was the location that a 2000 byte chunk could be built from

277
00:19:19,400 --> 00:19:22,200
嗯，7e0向前合并了
and so it consolidated forward

278
00:19:22,200 --> 00:19:27,300
接着是一个2000B chunk的起始地址
and then that was the chunk from which a 2000 byte chunk began

279
00:19:27,600 --> 00:19:30,800
所以原来的7e0和现在2000B的chunk地址相同
and so it began at that same spot

280
00:19:31,400 --> 00:19:35,133
然后为了完整
and then just for completeness sake here

281
00:19:35,566 --> 00:19:38,800
再来看一下 heap chunks
we can look at heap chunks again

282
00:19:39,300 --> 00:19:40,866
能看到什么
and what do we see here

283
00:19:43,966 --> 00:19:47,533
7a0在small bins中
7a0 is in the small bins

284
00:19:48,366 --> 00:19:50,400
7a0在这里
there is 7a0

285
00:19:51,700 --> 00:19:53,266
但有什么变了
but what changed here

286
00:19:53,466 --> 00:19:58,666
当7a0从fast bins移到small bins后
well 7a0 when it moved from the fast bins to the small bins

287
00:19:58,666 --> 00:20:02,066
显然它依旧未被使用
it is clearly not in use

288
00:20:02,500 --> 00:20:09,100
所以内存中挨着它的chunk
and so the chunk that immediately follows in physical memory

289
00:20:10,666 --> 00:20:15,500
紧跟着7a0的，也就是7c0
that immediately follows 7a0 which is 7c0

290
00:20:15,600 --> 00:20:21,133
7c0的PREV_INUSE位已经被清0了
now has its previous in use bit cleared

291
00:20:21,266 --> 00:20:30,800
这表明7a0可以被合并
and so this indicates that 7a0 is eligible for consolidation

292
00:20:30,900 --> 00:20:33,933
然而，它不能向前合并
however it can't consolidate forward

293
00:20:34,166 --> 00:20:36,300
对，因为这个卫士
right because of the guard

294
00:20:36,600 --> 00:20:38,966
这是我们的合并卫士
this is our guard allocation

295
00:20:39,466 --> 00:20:42,100
所以它不能向前合并
and so it can't consolidate forward into that

296
00:20:42,566 --> 00:20:44,366
因为程序还在使用它
because the program still has it

297
00:20:44,566 --> 00:20:50,200
它也不能向后合并 780
and it can't consolidate backwards into 780 either

298
00:20:50,500 --> 00:20:53,966
为什么不能合并780
why can't it go backwards into 780

299
00:20:54,600 --> 00:21:03,000
因为780目前被tcache占用
well it can't go into 780 because 780 is currently held by tcache

300
00:21:03,700 --> 00:21:06,500
tcache使用相同的方法
and tcache performs that same kind of a trick

301
00:21:06,800 --> 00:21:12,600
通过不清除PREV_INUSE位，防止合并
where the previous in use bit is not clear to prevent consolidation

302
00:21:13,200 --> 00:21:18,800
所以现在7a0不能向后合并
and so right now 7a0 can't consolidate backwards

303
00:21:18,900 --> 00:21:21,166
它也不能向前合并
and it can't consolidate forwards

304
00:21:21,266 --> 00:21:26,566
所以它只能被放到small bins中
which is why it is now a small chunk in the small bin

305
00:21:26,900 --> 00:21:33,000
我们可以根据对这些机制的了解来控制他们
and we are able to control that based upon our knowledge of how these mechanisms work

306
00:21:34,700 --> 00:21:39,600
现在除了利用整合
now in addition to working with consolidation or making consolidation work with us

307
00:21:40,000 --> 00:21:42,800
还可以在不同bin中转移chunk
we can also move chunks between the bins

308
00:21:42,866 --> 00:21:46,500
现在看过了大概是如何清空fast bin
now we already saw kind of flushing the fast bin out

309
00:21:46,566 --> 00:21:49,700
以及合并的过程
and how that works with consolidation

310
00:21:50,300 --> 00:21:53,800
我们也可在unsorted bin中做类似的事
but we could also do something similar with the unsorted bin

311
00:21:53,900 --> 00:21:57,500
事实上，我们对unsorted bin有更强的控制
in fact we have more control with the unsorted bin

312
00:21:57,566 --> 00:22:00,933
因为unsorted bin是有条件性的清理chunk
because the unsorted bin is conditionally flushed 

313
00:22:01,000 --> 00:22:06,800
可以根据chunk大小来清理
and can be partially moved through depending upon the size of the chunks that are in it

314
00:22:07,500 --> 00:22:12,000
如果malloc请求大小足够走到unsorted bin
remember that if a malloc call is large enough to get to the unsorted bin

315
00:22:12,300 --> 00:22:15,900
unsorted bin可能包含small或large chunk
the unsorted bin can contain small chunks or large chunks

316
00:22:15,966 --> 00:22:17,333
unsorted bin中2类chunk都能放
it can contain both

317
00:22:17,900 --> 00:22:23,100
unsorted bin的chunk处理方式是
and what the way that the unsorted bin is processed is a chunk is looked at

318
00:22:23,766 --> 00:22:25,966
先取出bin中头一个chunk
grab the first chunk that's in the bin

319
00:22:26,600 --> 00:22:30,966
如果这个chunk小于需要的大小
if the chunk is too small for what we need

320
00:22:31,066 --> 00:22:33,533
那就按类别放到对应的bin中
then we sort it and we place it in the correct bin

321
00:22:33,633 --> 00:22:35,066
可能会把它放到small bins中
so we could place it in the small bins

322
00:22:35,066 --> 00:22:36,733
可能会把它放到large bins中
we could place it in the large bins

323
00:22:36,733 --> 00:22:38,400
总之会放到它该在的位置
but we put it where it needs to go

324
00:22:38,533 --> 00:22:40,200
然后我们取出下一chunk
then we grab the next chunk

325
00:22:40,200 --> 00:22:43,100
如果chunk正好是我们需要的大小
if the chunk happens to be the exact size that we needed

326
00:22:43,200 --> 00:22:44,133
那很好
that's great

327
00:22:44,266 --> 00:22:47,733
就立即把它返回给malloc
we'll return that chunk to malloc right away

328
00:22:48,166 --> 00:22:50,400
但如果chunk太大了
but if the chunk is too large

329
00:22:50,900 --> 00:22:52,966
比我们需要的大
the chunk is larger than what we need

330
00:22:53,700 --> 00:22:55,766
那么分配器会
then what the allocator can do is 

331
00:22:55,866 --> 00:23:01,133
立即分割这个unsorted bin中的chunk
the allocator will split that chunk right now while it's in the unsorted bin

332
00:23:01,866 --> 00:23:05,700
返回给malloc所需的部分
it'll return the piece that is needed for malloc

333
00:23:05,700 --> 00:23:08,666
并将剩下的（last_remainder_chunk）留在unsorted bin中
and will leave the remainder in the unsorted bin

334
00:23:08,766 --> 00:23:16,600
所以unsorted bin中的chunk也能被分割
and so the unsorted bin is a location where chunks can also get split

335
00:23:16,600 --> 00:23:22,700
这意味着可以通过unsorted bin创建更小的chunk
and this means that we can create smaller chunks via the unsorted bin

336
00:23:22,800 --> 00:23:27,833
然后清理unsorted bin将创建的chunk放到目标位置
and then flush the unsorted bin to place those chunks where we want

337
00:23:28,533 --> 00:23:32,800
也可以只清理部分unsorted bin
you can also partially go through the unsorted bin

338
00:23:32,900 --> 00:23:37,800
如果unsorted bin中chunk大小是递增的话
if the unsorted bin has chunks in increasing size

339
00:23:38,300 --> 00:23:44,400
假设它有大小为100 1000和10000的chunk
say it has a chunk of size 100 1000 and 10 000

340
00:23:44,700 --> 00:23:48,333
如果我请求一个800B的chunk
if I request an 800 byte chunk

341
00:23:48,600 --> 00:23:53,100
当先遇到它时，会整理这个100B的chunk
we would sort the 100 if we encounter that first

342
00:23:53,766 --> 00:23:56,566
然后取出1000B的chunk
then we would take the thousand byte chunk

343
00:23:56,566 --> 00:23:59,700
分割，并返回800B的chunk
split it off and return an 800 byte chunk

344
00:23:59,700 --> 00:24:05,200
严谨的说是816B的chunk，如果请求大小为800B的话
well an 816 byte chunk if it was an 800 byte allocation

345
00:24:05,800 --> 00:24:08,766
剩下的部分放在unsorted bin中
well we would put the remainder in the unsorted bin

346
00:24:08,933 --> 00:24:13,200
不会去碰这个超大的10KB chunk
and the super giant 10 000 byte chunk would be untouched

347
00:24:13,400 --> 00:24:18,100
找到需要的chunk后就不动unsorted bin了
because remember we only process the unsorted bin until we find what we need

348
00:24:18,200 --> 00:24:23,900
因此可以构造malloc请求，只遍历部分unsorted bin
so it is possible to make malloc requests to partially go through the unsorted bin

349
00:24:24,166 --> 00:24:26,466
你可以利用这一点
and you can use that to your advantage

350
00:24:27,900 --> 00:24:30,266
我要说的最后一点
the last thing that I'll mention that 

351
00:24:30,333 --> 00:24:34,866
在讨论small bins时没讲
I don't think was included in the discussion on the small bin

352
00:24:35,300 --> 00:24:37,800
在某些情况下
was in certain scenarios 

353
00:24:38,333 --> 00:24:48,500
small bins会利用被访问的机会，缓存tcache
the small bin will take advantage of the fact  that it is being accessed to load up the tcache

354
00:24:48,566 --> 00:24:52,133
如果 tcache 有空位
so if the tcache is empty

355
00:24:52,900 --> 00:24:59,400
但small bin中有chunk
but there are small chunks in a small bin

356
00:24:59,566 --> 00:25:03,066
而且此时正在访问这个small bin
and you're accessing that small bin right now

357
00:25:04,100 --> 00:25:07,600
分配器会做的就是
what the allocator will do is the allocator will reason

358
00:25:08,366 --> 00:25:11,533
既然已经访问到这个small bin了
since we are already accessing this small bin

359
00:25:11,966 --> 00:25:15,400
就好好利用一下这个机会
let's take advantage of the fact that we're here

360
00:25:15,500 --> 00:25:24,100
从在访问的small bin中，取出最多7个chunk，放到tcache
to load up the tcache with up to 7 small chunks from that specific size bin that is being accessed

361
00:25:24,700 --> 00:25:27,266
我们可以看看具体是如何工作的
and we can take a look at how that works

362
00:25:30,533 --> 00:25:31,766
好的
all right so

363
00:25:31,766 --> 00:25:35,300
这个例子和上一个非常相似
this example here is very similar to the previous one

364
00:25:35,866 --> 00:25:38,600
只不过目标不是fast bins了
except instead of targeting the fast bin

365
00:25:38,600 --> 00:25:40,500
这次目标是unsorted bin
I'm targeting the unsorted bin

366
00:25:41,600 --> 00:25:43,766
先malloc 7次
and so I'm going to malloc seven times

367
00:25:43,766 --> 00:25:46,066
目的是之后将他们释放到tcache
with the intent to freeing them into the tcache

368
00:25:46,066 --> 00:25:49,966
再malloc一次，准备放到unsorted bin中
I'm going to malloc once targeting the unsorted

369
00:25:50,100 --> 00:25:57,000
再申请一个卫士chunk用于阻止向前合并
and I'm going to malloc once more with a guard allocation to prevent forward consolidation

370
00:25:57,933 --> 00:26:00,000
我该如何锁定unsorted bin
now how am I targeting the unsorted bin

371
00:26:00,333 --> 00:26:02,100
嗯，我
well I am choosing that

372
00:26:02,700 --> 00:26:08,000
选择一个够大的，fast bins放不下的chunk大小
by choosing a size that is large enough that it will not go into the fast bin

373
00:26:08,100 --> 00:26:12,866
注意：0x80B大小以内的chunk都会放到fast bins中
remember chunks up to 0x80 bytes end up to the fast bin

374
00:26:13,333 --> 00:26:15,100
128(加元数据16B)大于0x80
128 is larger than 88

375
00:26:15,166 --> 00:26:16,766
所以等释放完他们时
so when these get freed 

376
00:26:17,166 --> 00:26:20,400
在tcache填满后，这个会放到unsorted bin
after the tcache this should go to the unsorted bin

377
00:26:22,366 --> 00:26:25,000
等释放后
so that's getting freed then

378
00:26:25,600 --> 00:26:31,000
用gdb附加到该进程，然后查看此时的堆状态
I'm going to attach and take a look at the state of the program at that point

379
00:26:39,500 --> 00:26:45,600
能看到unsorted bin中有一个0x90B的chunk
and what we see here is we have a chunk of size hex 90 in the unsorted bin

380
00:26:45,766 --> 00:26:47,333
为什么是0x90
why hex 90

381
00:26:48,200 --> 00:26:52,500
0x90等于144
well hex 90 is 144

382
00:26:52,600 --> 00:26:57,700
144等于128加16
144 is 128 plus 16

383
00:26:58,200 --> 00:27:01,100
注意，chunk有16B的元数据
remember there's 16 bytes for the chunk metadata

384
00:27:02,800 --> 00:27:07,500
继续执行会发生什么呢
so what's going to happen if I continue running from this point

385
00:27:08,100 --> 00:27:09,333
接下来要怎么做
well what are we going to do

386
00:27:09,533 --> 00:27:12,400
接下来要malloc 7次，用于填充tcache
we're going to malloc seven times targeting the tcache

387
00:27:12,533 --> 00:27:14,533
再malloc一次
we're going to malloc once more

388
00:27:14,533 --> 00:27:16,733
用于之后放入unsorted bin
with the intent of putting something in the unsorted bin 

389
00:27:17,300 --> 00:27:25,100
第九次malloc，用做卫士chunk防止向前合并
and I'm going to malloc in 9th time with a guard to prevent forward consolidation

390
00:27:26,166 --> 00:27:28,900
当首次malloc时
well when this very first malloc occurs

391
00:27:29,400 --> 00:27:33,066
它会被放到unsorted bin里
that is going to go to the unsorted bin

392
00:27:33,500 --> 00:27:40,300
unsorted bin里有一个144B的chunk
and the unsorted bin has a 144 byte chunk here

393
00:27:40,300 --> 00:27:44,700
它无法满足256B的malloc请求
which will be insufficient to satisfy this 256 byte malloc

394
00:27:45,500 --> 00:27:49,600
所以会将其放到对应的bin
so that means that we will sort this chunk

395
00:27:49,800 --> 00:27:53,133
这个chunk会放到small bins中
so this chunk should end up in the small bins

396
00:27:54,500 --> 00:27:57,066
这会发生在第一次malloc时
and that's going to happen on this very first malloc

397
00:27:57,333 --> 00:27:59,600
接着会执行后续malloc
then we're going to do the rest of the mallocs 

398
00:27:59,766 --> 00:28:02,800
再free 8次
and free 8 times

399
00:28:03,500 --> 00:28:10,700
这将在unsorted bin中放一个272B的chunk
and that will place a 272 byte chunk in the unsorted

400
00:28:10,700 --> 00:28:12,566
我们继续
so let's move forward

401
00:28:13,266 --> 00:28:14,800
可以看到
and see that

402
00:28:16,700 --> 00:28:21,833
额，没变化
what we see now is the exact same thing 

403
00:28:21,933 --> 00:28:23,200
因为没执行continue
because I didn't continue

404
00:28:26,400 --> 00:28:34,300
现在能看到unsorted bin中有一个更大的chunk
okay what we see now is a larger chunk in the unsorted

405
00:28:34,400 --> 00:28:42,200
有0x110B，也就是256B
that is 0x110 just 256

406
00:28:45,800 --> 00:28:47,733
哦，搞错了。好了
oh no that's not right there we go

407
00:28:48,000 --> 00:28:53,600
是272B，因为要加16
272 because it's 256 plus 16

408
00:28:54,566 --> 00:28:55,900
这正是预计的效果
which is what we would expect

409
00:28:55,900 --> 00:29:01,300
可以看到144B的chunk已经转移到small bins中了
and we saw that the 144 byte chunk was moved to the small bin

410
00:29:01,700 --> 00:29:05,566
所以我们可以把它放进small bins中
so we were able to flush this into the small bins 

411
00:29:05,633 --> 00:29:09,300
同时保留unsorted bin中的其它chunk
while simultaneously placing something in the unsorted bin

412
00:29:09,800 --> 00:29:16,800
不需要malloc一个巨大的chunk将unsorted bin清空
we didn't have to just malloc something very very large and flush them all out 

413
00:29:19,566 --> 00:29:21,666
还有另一个例子
so I have another example

414
00:29:22,500 --> 00:29:25,833
这个例子是将small chunk放到unsorted bin
this is when we were putting something small in the unsorted 

415
00:29:26,000 --> 00:29:27,966
然后malloc large chunk的情况
and then mallocing something larger

416
00:29:28,100 --> 00:29:29,900
如果我们反过来做会怎样
what happens when we do the reverse

417
00:29:30,500 --> 00:29:33,033
这其实就是代码后半部分
so this is just the later half of that 

418
00:29:33,166 --> 00:29:40,600
这里将272B的chunk放入unsorted bin
we're going to put a 272 byte chunk into the unsorted

419
00:29:40,666 --> 00:29:42,066
然后启用交互模式
and then go interactive

420
00:29:44,666 --> 00:29:48,700
我们运行并附加gdb到进程
so let's run this and attach

421
00:29:53,133 --> 00:29:54,533
看一下这里
and if we look here

422
00:29:55,000 --> 00:29:59,533
在unsorted bin中确实有272B的chunk
we do have a 272 byte chunk in the unsorted

423
00:30:01,166 --> 00:30:04,400
那malloc一个更小的chunk会怎样
so what's going to happen if I malloc something smaller

424
00:30:04,900 --> 00:30:06,666
比如64字节
like 64 bytes

425
00:30:12,866 --> 00:30:15,300
发生了一些有趣的事
well something interesting happens here

426
00:30:16,600 --> 00:30:18,800
unsorted bin中还是有chunk
we still have something in the unsorted bin

427
00:30:18,933 --> 00:30:22,700
只不过unsorted bin中是个比原来小的chunk
but the unsorted bin chunk is now smaller

428
00:30:23,200 --> 00:30:24,900
现在大小是0xC0字节
it is 0xC0

429
00:30:25,133 --> 00:30:26,733
但我没free任何chunk
but I didn't free anything

430
00:30:26,966 --> 00:30:28,800
我只执行了malloc
all I did was malloc

431
00:30:28,933 --> 00:30:30,300
那这里发生了什么呢
so what happened here

432
00:30:31,100 --> 00:30:35,300
我们说过，在遍历unsorted bin时
well we said when we're going through the unsorted bin

433
00:30:35,500 --> 00:30:38,133
如果chunk小了，我们就把它放到对应bin中
if the chunk is too small we sort it

434
00:30:38,300 --> 00:30:39,966
如果chunk大了
but if the chunk is too big

435
00:30:40,533 --> 00:30:41,400
我们会怎么做
what do we do

436
00:30:42,066 --> 00:30:43,933
我们会选择这个chunk
well we can use this

437
00:30:44,500 --> 00:30:50,000
只是我们不想返回chunk中多余的内存
except we don't want to return all of this extra space

438
00:30:50,866 --> 00:30:54,866
能看到这个chunk起始地址是63e30
and so we see this chunk began at 63e30

439
00:30:56,900 --> 00:31:03,000
返回了什么？63e30
what was returned 63e30

440
00:31:06,566 --> 00:31:08,166
这里也能找到它
find that over here again

441
00:31:13,100 --> 00:31:14,966
63e30
63e30 

442
00:31:15,400 --> 00:31:27,500
所以返回的chunk其实是从这个更大的chunk中切出来的
and so the allocation that was returned was cut out of that larger chunk right here

443
00:31:28,400 --> 00:31:31,433
那么此时在unsorted bin中的
so then the thing that's in the unsorted bin 

444
00:31:31,633 --> 00:31:36,500
就是切剩下的半块chunk
is whatever was left after we cut out the allocation

445
00:31:36,700 --> 00:31:39,733
整个过程是，从unsorted bin中取出这个chunk
so we picked up from the unsorted bin this chunk 

446
00:31:39,833 --> 00:31:41,100
然后发现，这个够大
and said yeah this is big enough

447
00:31:41,233 --> 00:31:43,000
然后将他分成两份
and then we just broke it in two

448
00:31:43,333 --> 00:31:46,100
这份是我们要的
and said here's the piece that we need right now

449
00:31:46,300 --> 00:31:49,400
余下的就放在unsorted bin，以后处理
leave the remainder in the unsorted bin to deal with later

450
00:31:51,500 --> 00:31:53,400
那我该怎么做呢
so what can I do from here

451
00:31:54,400 --> 00:31:57,600
要是我malloc一个巨大的chunk
well if I malloc something very large

452
00:32:00,600 --> 00:32:05,000
就可以将在unsorted bin中切剩下的
I can flush that remainder piece that was in the unsorted bin

453
00:32:05,333 --> 00:32:07,666
放到small bins中
into the small bins

454
00:32:10,500 --> 00:32:12,500
所以现在不知怎么的
and so now somehow 

455
00:32:12,700 --> 00:32:20,700
最终在small bins中有了一个0xc0大小的chunk
I've ended up with a chunk of size 0xc0 in the small bins

456
00:32:20,700 --> 00:32:30,300
尽管唯一被释放的是一个0x110B的chunk
even though what the only thing that was freed into here was a chunk of size 0x110 

457
00:32:30,900 --> 00:32:36,000
所以你可以从unsorted bin中取出chunk
and so you can take chunks that are in the unsorted bin

458
00:32:36,200 --> 00:32:41,200
切割，然后将剩下的从unsorted bin中清出
break them down and then flush out pieces of the unsorted bin

459
00:32:42,100 --> 00:32:47,700
你能推出剩下chunk的地址
and you can know what address will be there for that size

460
00:32:47,900 --> 00:32:55,300
如果知道原来chunk的地址
if I know the address of the original pointer up here

461
00:32:56,600 --> 00:32:59,633
那么我就能知道
then I can know the address of 

462
00:32:59,800 --> 00:33:05,633
剩下的被放到small bin中的chunk的地址
the remaining piece that was broken off  and flushed into the small bin

463
00:33:08,133 --> 00:33:10,766
还有一件能做的事
now the last thing that I claim we can do

464
00:33:11,700 --> 00:33:19,600
是small chunk可以从small bins转移到tcache
is small chunks can move into the tcache from the small bin opportunistically

465
00:33:19,800 --> 00:33:24,600
之前在small bin的课程中没有提到
now this is something that I didn't mention in the previous lecture about small bin

466
00:33:24,800 --> 00:33:27,700
我不是很确定
I'm not entirely sure

467
00:33:29,200 --> 00:33:32,500
可能有漏洞利用方法依靠这个机制
there's probably an exploit somewhere that uses this mechanism

468
00:33:33,000 --> 00:33:37,100
但我现在没想到是哪个方法
but I'm not immediately aware of one

469
00:33:38,400 --> 00:33:41,300
所以这里和之前有点不同
so what I'm going to do here is a little bit different

470
00:33:41,866 --> 00:33:43,700
我要调用7次malloc
I'm going to malloc seven times

471
00:33:43,700 --> 00:33:46,133
目的是以后释放到tcache中
with the intention of freeing it into the tcache

472
00:33:46,133 --> 00:33:48,066
再调用两次malloc
I'm going to malloc twice more

473
00:33:48,200 --> 00:33:50,100
瞄准small bins
targeting the small bins

474
00:33:50,100 --> 00:33:52,166
如何瞄准small bins呢
how am I targeting small bins

475
00:33:52,300 --> 00:33:55,600
先填满tcache
well I'm going to fill the tcache

476
00:33:55,966 --> 00:33:58,633
还要确保这些chunk有卫士守护
I'm going to make sure that these allocations are guarded 

477
00:33:58,766 --> 00:34:00,100
不让他们合并
so they don't consolidate

478
00:34:00,700 --> 00:34:05,300
然后将他们释放到unsorted bin中
I'm going to free them into the unsorted bin

479
00:34:06,800 --> 00:34:12,900
最后malloc个大的，使unsorted bin处理里面的chunk
then I'm going to force the unsorted bin to get sorted by mallocing something large

480
00:34:13,300 --> 00:34:19,300
这会导致unsorted bin中的这两个chunk被处理
and that will cause these two chunks that were in the unsorted bin to get sorted

481
00:34:19,333 --> 00:34:21,533
放到small bins里
and get placed into the small bin

482
00:34:25,333 --> 00:34:26,533
再调用一下input
then I have an input

483
00:34:26,600 --> 00:34:35,700
我们来看几个阶段来校验一下
so let's take a look at a couple phases there to verify that is what's going on

484
00:34:38,100 --> 00:34:40,300
176079
176079

485
00:34:40,966 --> 00:34:44,266
所以现在我应该有两个chunk
so right now I should have two chunks

486
00:34:44,666 --> 00:34:45,800
我们就在这里
we are right here

487
00:34:45,800 --> 00:34:49,166
在unsorted bin里应该有2个chunk
I should have 2 chunks in the unsorted bin

488
00:34:51,900 --> 00:34:56,100
能看到unsorted bin确实有2个chunk
and I do have two chunks in the unsorted bin

489
00:34:58,666 --> 00:35:00,700
现在我要malloc个大的
so now I'm going to malloc something large

490
00:35:00,900 --> 00:35:05,200
这能将他们从unsorted bin中转移到small bins里
which should flush them from the unsorted bin to the small bin

491
00:35:05,733 --> 00:35:06,966
我们试一下
so let's do that

492
00:35:11,900 --> 00:35:15,200
现在可以看到unsorted bin是空的
and now we see the unsorted bin is empty

493
00:35:15,700 --> 00:35:19,466
而small bins里有两个chunk
and we have two chunks in the small bins

494
00:35:21,500 --> 00:35:23,466
现在开始变得有趣
now this is where it gets interesting

495
00:35:25,100 --> 00:35:28,900
我现在要清空tcache
what I'm going to do is I'm going to clear the tcache

496
00:35:30,700 --> 00:35:33,600
malloc 7次来清空tcache
so I'm going to malloc 7 times to clear out the tcache

497
00:35:33,766 --> 00:35:35,533
然后进入交互模式
and then we're going to go interactive

498
00:35:37,600 --> 00:35:43,500
现在能看到tcache中有7个chunk
so we see that the tcache does have seven entries for the size that we are working with

499
00:35:48,100 --> 00:35:51,700
如果现在检查一下 heap bins
and if we look at the bins right now

500
00:35:52,266 --> 00:35:54,166
已经清空了tcache
we've cleared out the tcache

501
00:35:54,500 --> 00:35:59,400
small bins里还有两个chunk
and we still have two in the small bins

502
00:35:59,466 --> 00:36:01,866
small bins有2个这个大小的chunk
two chunks in the small bins for this size

503
00:36:02,500 --> 00:36:07,700
现在我要再malloc一次
now what I want to do is I want to malloc just once

504
00:36:08,466 --> 00:36:10,766
按直觉来说
now our intuition is

505
00:36:11,400 --> 00:36:14,600
这个大小正好可以从small bins里取
well this is the correct size to come from the small bins

506
00:36:14,800 --> 00:36:17,700
所以应该会返回small bins中第一个chunk
and so it should return the first chunk in the small bins

507
00:36:17,900 --> 00:36:22,600
应该返回7bd0
it should return 7bd0

508
00:36:24,533 --> 00:36:25,933
实际是这样吗?
is that what happens

509
00:36:32,800 --> 00:36:34,500
它返回了另一个chunk
well it returned the other chunk

510
00:36:36,100 --> 00:36:39,666
但依旧是返回了一个small bins中的chunk
but it still returned a chunk from the small bins

511
00:36:41,300 --> 00:36:44,700
这和我们预计的一样
and so that is what we would expect

512
00:36:45,800 --> 00:36:50,366
但是这里发生一些有趣的事情
but so something interesting is going to happen here

513
00:36:50,800 --> 00:36:56,600
如果我们检查一下heap bins
if we take another look at the heap bins

514
00:36:57,900 --> 00:37:00,166
small bins现在是空的
the small bins are now empty

515
00:37:01,500 --> 00:37:03,466
small bins是空的
and the small bins are empty

516
00:37:04,400 --> 00:37:18,200
因为这个7bd0现在在tcache中
because that 7 where is it 7bd 0 is now in the tcache

517
00:37:18,966 --> 00:37:21,100
所以这里到底发生了什么
so what the heck happened here

518
00:37:22,333 --> 00:37:23,533
事实证明
well it turns out

519
00:37:25,300 --> 00:37:34,500
当small bins里有一个以上chunk
when there are more than one chunk in the small bins

520
00:37:35,400 --> 00:37:39,700
且tcache还没满时
and the tcache is not full

521
00:37:42,366 --> 00:37:43,933
当我们malloc时
when we malloc

522
00:37:44,800 --> 00:37:48,300
分配器认出这种情况
the allocator reasons about this

523
00:37:48,700 --> 00:37:55,300
发现有多余的small chunk可以放到tcache
and says I have extra small chunks that could go into the tcache

524
00:37:55,700 --> 00:37:59,800
只要我们处理到这个small bin对应的链表
as long as we're already working with this small bin list

525
00:38:00,733 --> 00:38:03,266
就会填充tcache
let's load up the tcache

526
00:38:04,333 --> 00:38:06,133
这就是这里发生的事情
and so that's what happened here

527
00:38:06,700 --> 00:38:08,566
我们malloc了一次
we mallocd once

528
00:38:11,100 --> 00:38:13,433
small bins里有2个chunk
we had two things in the small bin 

529
00:38:15,166 --> 00:38:16,466
就在这里和这里
right here and here

530
00:38:16,700 --> 00:38:18,600
我们malloc了一次
we malloc once

531
00:38:20,166 --> 00:38:23,266
small bins中的一个chunk返回给了我们
one of those small bin values was returned to us

532
00:38:25,200 --> 00:38:26,700
7ab0
7ab0

533
00:38:27,500 --> 00:38:31,100
另一个 7bd0
and the other one 7bd0

534
00:38:32,200 --> 00:38:36,366
被放到了tcache中对应大小的链表
was placed inside the tcache for that size

535
00:38:36,700 --> 00:38:40,766
故当用到small bins中的chunk
so the allocator will preload tcache

536
00:38:41,000 --> 00:38:45,533
分配器会将该bin中其它chunk装到tcache
 if it's already working with that size in the small bins

537
00:38:46,300 --> 00:38:47,533
这很有趣
it's kind of interesting

538
00:38:49,866 --> 00:38:53,600
还有几件事值得一提
there's a couple more things that are worth mentioning

539
00:38:54,066 --> 00:38:56,366
虽然我不会演示它们
although I'm not going to demo them

540
00:38:56,900 --> 00:39:00,266
但它们都与这个模块相关
but they're definitely relevant for this module

541
00:39:00,800 --> 00:39:04,300
第一种是伪造chunk
the first is creating fake chunks

542
00:39:05,800 --> 00:39:08,200
我们在tcache中见过
so we saw with tcache

543
00:39:08,300 --> 00:39:10,266
我们可以覆盖next指针
that we could overwrite in next pointer 

544
00:39:10,433 --> 00:39:15,600
然后让tcache返回一个
and get the tcache heap to start returning values that

545
00:39:15,700 --> 00:39:18,300
它本不会返回的地址值
it's not necessarily supposed to be able to do

546
00:39:19,100 --> 00:39:24,200
可以在下层堆做类似的事
well you can do something similar with the heap heap

547
00:39:25,300 --> 00:39:31,600
然而，这不再是简单地覆盖next指针
however it's not as simple as just overwriting a next pointer or

548
00:39:31,766 --> 00:39:34,300
或者为了绕过安全链接
performing safelinking modification

549
00:39:34,300 --> 00:39:38,600
做些异或操作，并用修改后的值覆盖next指针
doing some XOR and writing a modified address to a next pointer

550
00:39:39,200 --> 00:39:43,400
因为这里的堆元数据有前向和后向指针
because remember the heap metadata has forward pointers and back pointers

551
00:39:43,500 --> 00:39:46,933
而且会校验这些指针
and it has validation on those pointers

552
00:39:47,133 --> 00:39:52,533
会校验size与下一个chunk的prev_size是否相等
and it has validation on the size with the next chunks previous size

553
00:39:52,666 --> 00:40:00,500
这种校验约束了那种修改方法
and so there's these validation checks that constrain performing those type of modifications

554
00:40:01,000 --> 00:40:05,500
但是如果你有一块拥有写权限的内存
however if you have a region of memory that you can write

555
00:40:05,766 --> 00:40:08,066
你能牢牢控制住它
and you have full control over it

556
00:40:08,100 --> 00:40:16,200
那么你可以精心伪造一块逼真的堆chunk
you can carefully craft a region of memory by writing data that looks like heap metadata 

557
00:40:16,900 --> 00:40:22,200
所以你可能要写入一个prev_size
so you'd have to write a previous size possibly

558
00:40:22,500 --> 00:40:24,133
写一个size
you'd have to write a size

559
00:40:24,133 --> 00:40:26,133
写一个前向指针
you'd have to write a forward pointer

560
00:40:26,133 --> 00:40:28,133
还有向后指针
you'd have to write a backward pointer

561
00:40:28,400 --> 00:40:34,500
也有可能要写入fd_nextsize和bk_nextsize
you may or may not need to write a forward and backward size pointer

562
00:40:35,100 --> 00:40:38,900
这取决于你要利用的是堆的哪个部分
depending upon what part of the heap you're interacting with

563
00:40:38,900 --> 00:40:42,500
可能有些也需要这些指针
there may be something that requires those pointers as well

564
00:40:42,866 --> 00:40:44,966
反正你可以直接写内存
but you could just write out memory 

565
00:40:45,033 --> 00:40:47,733
来让它看起来像堆元数据
so that it looks like heap metadata

566
00:40:48,800 --> 00:40:53,733
如果你可以破坏现有的chunk
then if you can corrupt existing heap chunks

567
00:40:55,400 --> 00:41:00,733
你就能让堆误认为你给的内存
you can get the heap to interpret your little region of memory 

568
00:41:00,933 --> 00:41:05,166
是真正的chunk元数据
as if it were the metadata of a heap chunk

569
00:41:07,000 --> 00:41:09,466
你能伪造chunk
you can create fake chunks

570
00:41:09,700 --> 00:41:14,866
但你得能很熟练地
but you have to be very skillful in particular 

571
00:41:14,933 --> 00:41:19,266
伪造你要传给堆的内存空间
in how you craft that memory region that you're going to be passing to the heap

572
00:41:20,200 --> 00:41:22,966
取决于你的所作所为
depending upon the specifics of what it is you're doing

573
00:41:22,966 --> 00:41:25,300
以及你使用的内存区域
and what memory region you're working with

574
00:41:25,400 --> 00:41:27,933
这可能导致堆被破坏
this can quickly result in a broken heap

575
00:41:28,066 --> 00:41:33,100
而像GDB、GEF和pwndbg这类工具
where tools like GDB and GEF or pwndbg

576
00:41:33,100 --> 00:41:36,400
也不一定能获取堆破坏的具体原因
will not necessarily be showing you correct information

577
00:41:37,000 --> 00:41:42,400
当输出堆的调试信息时
when you start printing out that heap debug information

578
00:41:43,300 --> 00:41:46,700
它可能会通过指针单向追溯链表
because it may try and follow the pointers in one direction

579
00:41:46,733 --> 00:41:49,666
但因为你对堆的修改
but because of the way that you've manipulated the heap 

580
00:41:49,866 --> 00:41:53,133
必须从另一个方向遍历链表
you have to follow the pointers in a different direction

581
00:41:54,400 --> 00:41:55,900
才能发现哪里有问题
reason about what's going on

582
00:41:55,900 --> 00:42:00,100
所以需要在gdb中打印内存
and so you'll start needing to print out memory regions in GDB

583
00:42:00,200 --> 00:42:01,900
查看原始字节
and looking at the raw bytes 

584
00:42:02,066 --> 00:42:05,200
才能了解实际问题
to reason about what is actually going on with the metadata

585
00:42:05,300 --> 00:42:07,900
所以这是一种利用方法
so this is something that you can do

586
00:42:08,300 --> 00:42:12,066
但可能非常容易破坏堆
but you can quickly end up with a broken heap and

587
00:42:12,400 --> 00:42:16,000
并见到第一节课中看到的错误信息
those corruption errors that I warned about in the first lecture

588
00:42:17,500 --> 00:42:22,400
与伪造chunk类似的
now similar to creating fake chunks right

589
00:42:22,400 --> 00:42:27,033
伪造chunk是伪造了chunk的全部元数据
creating a fake chunk is where you're trying to emulate the entire chunk metadata 

590
00:42:27,233 --> 00:42:30,400
你要尽量做到合理
and you're trying to do it reasonably faithful

591
00:42:31,600 --> 00:42:35,900
但也可以粗糙的伪造chunk
it is possible to simply take a memory region

592
00:42:35,966 --> 00:42:40,000
够通过检查就行
and try and craft it to just past the validation steps

593
00:42:40,166 --> 00:42:42,700
尝试通过检查
and you're just trying to pass the validation steps

594
00:42:42,700 --> 00:42:46,500
仅为了获取一个基础利用方法
so that you can get one specific exploitation primitive

595
00:42:46,500 --> 00:42:54,300
比如创建个假chunk，正好得到了一个任意读
like I just happen to be able to get an arbitrary read by creating a fake chunk 

596
00:42:54,433 --> 00:42:56,800
创建的还不是一个完整的chunk
that isn't a fully working fake chunk

597
00:42:56,866 --> 00:42:59,600
但已经足够
but it's a fake chunk that works just enough

598
00:42:59,900 --> 00:43:04,700
获取一个任意的指针，进行任意读写
so that I get an arbitrary pointer an arbitrary read an arbitrary write

599
00:43:04,766 --> 00:43:08,300
得到了些可以用于后续攻击的，基础利用方法
I get some type of primitive that I can then work with

600
00:43:08,466 --> 00:43:09,500
记住一点
just keep in mind that 

601
00:43:09,600 --> 00:43:13,533
你对堆的篡改行为越多
the more you're doing this like breaking behavior of the heap

602
00:43:13,933 --> 00:43:18,600
就越容易导致崩溃
the closer you are to just utterly crashing

603
00:43:19,400 --> 00:43:23,300
上一个模块中，我们获得了些基础利用方法
in the previous module where we were creating exploitation primitives

604
00:43:23,666 --> 00:43:25,100
我们利用的是tcache
we were working with tcache

605
00:43:25,100 --> 00:43:27,500
tcache很好，因为
and tcache is great in the sense that 

606
00:43:27,633 --> 00:43:31,933
如果我破坏了tcache，大不了重连一次
if I break the tcache I can always connect again

607
00:43:32,100 --> 00:43:35,966
重开一个线程就获得了一个新的tcache
and have a fresh thread and I have a fresh tcache right

608
00:43:36,100 --> 00:43:42,100
但在利用下层堆时就不一样了
well that isn't the case once you go past the tcache into the heap heap

609
00:43:42,200 --> 00:43:47,100
进程中所有线程都用的同样的下层堆
the heap heap is the same heap for all threads in the process

610
00:43:47,100 --> 00:43:52,400
所以这种能快速重置的按钮就不存在了
so you don't have like this quick reset button that you can just hit

611
00:43:54,466 --> 00:43:56,900
这让我们回到了原点
and so this kind of brings us full circle

612
00:43:57,100 --> 00:44:01,700
现在我们回过头来看看这个unlink_chunk函数
and so now we're back in looking at this unlink_chunk function

613
00:44:02,066 --> 00:44:03,800
这是第一节课的内容
that was back in the first lecture

614
00:44:04,933 --> 00:44:07,266
如果我们看看这些校验步骤
and if we look at these validation steps

615
00:44:07,433 --> 00:44:11,633
这里有几种不同类型的校验
there's a couple different types of validations that are occurring

616
00:44:12,333 --> 00:44:14,200
这是第一个校验
there's this first validation

617
00:44:14,500 --> 00:44:20,733
它检查当前要从链表删除的chunk大小
which is looking at is the chunk size of the current chunk that's being unlinked 

618
00:44:20,900 --> 00:44:25,700
是否等于下一个chunk的prev_size
equal to the previous size of the next chunk

619
00:44:26,000 --> 00:44:31,900
这和bins、链表、指针没有任何关系
now this has nothing to do with bins and lists and the pointers

620
00:44:32,100 --> 00:44:36,800
关注的只是内存中的下一个chunk
this is about the next chunk in memory

621
00:44:37,566 --> 00:44:40,500
内存中的实际地址
the actual location in memory

622
00:44:40,566 --> 00:44:43,900
如果我们看一下next_chunk函数
and so if we look at this next_chunk function

623
00:44:45,400 --> 00:44:48,500
我们是如何知道内存中下一个chunk的地址的？
how do we know where the next chunk is in memory

624
00:44:48,566 --> 00:44:50,766
先取指向当前chunk的指针
well we take the pointer which is where we're at

625
00:44:50,766 --> 00:44:52,333
然后加上当前chunk大小
and we add our size

626
00:44:52,966 --> 00:44:55,866
当前chunk结尾处的地址
whatever is at the end of the current chunk

627
00:44:55,866 --> 00:44:57,733
就是下一chunk的起始地址
is the beginning of the next chunk

628
00:44:57,733 --> 00:44:59,866
堆就是这样定义它的
because that's how the heap is defined

629
00:45:00,533 --> 00:45:02,700
所以这就是下一个chunk
and so that is the next chunk

630
00:45:02,700 --> 00:45:05,766
下一个chunk的prev_size最好
and the next chunk better have a previous size

631
00:45:05,766 --> 00:45:08,666
和声称的当前chunk大小相等
that matches what I claim my size is

632
00:45:10,666 --> 00:45:14,100
这是关于内存相邻的校验
and so this is about locality in memory

633
00:45:15,700 --> 00:45:18,500
第二个校验
this second check this validation step

634
00:45:18,533 --> 00:45:21,900
是关于双链表的
this is about the doubly linked list

635
00:45:22,300 --> 00:45:28,000
它检查前一个chunk的后向指针是否等于自己
it does the back pointer of my forward pointer equal me

636
00:45:28,600 --> 00:45:33,100
然后检查后一个chunk的前向指针是否等于自己
and does the forward pointer of my back pointer equal me

637
00:45:34,600 --> 00:45:41,800
听起来好像无法通过这个校验
that sounds like something that you wouldn't be able to satisfy or to pass this validation step

638
00:45:42,166 --> 00:45:44,466
但它实际上要求了什么
but what is it really asking for

639
00:45:44,900 --> 00:45:50,900
它实际是要某处指针的值是当前chunk的地址
it's asking for a pointer where a specific offset is the address of the chunk

640
00:45:51,500 --> 00:46:00,500
还有在另一处的指针的值也要是当前chunk地址
and then another pointer where the address at a specific offset is the address of the chunk

641
00:46:01,766 --> 00:46:04,133
这些前向后向指针
now these pointers forward and back

642
00:46:04,133 --> 00:46:05,966
如果我们能控制他们
if we have control over them

643
00:46:06,000 --> 00:46:10,066
他们不一定非得指向一个合法的chunk
these don't necessarily have to point to valid chunks

644
00:46:10,233 --> 00:46:17,033
只要指向要卸载的chunk地址就行
they just have to point somewhere where the offset is the address of the chunk I'm trying to unlink

645
00:46:18,100 --> 00:46:21,400
所以要满足这个要求是有可能的
and it is possible to satisfy that constraint

646
00:46:24,100 --> 00:46:26,700
这些是局部的
again these are about locality

647
00:46:27,066 --> 00:46:29,866
所以当我们说下一个和上一个chunk时
so when we say next chunk or previous chunk

648
00:46:29,866 --> 00:46:32,333
说的时内存中相邻的上下
we're talking about where in memory

649
00:46:32,400 --> 00:46:35,133
当我们说前向和后向指针时
when we're talking about forward and backward pointers

650
00:46:35,266 --> 00:46:39,833
说的是bin链表中的前后
we're talking about the list of the bins

651
00:46:43,500 --> 00:46:47,500
所以我们可以找到内存中的下一个chunk
so we said that we can find the next physical chunk

652
00:46:47,800 --> 00:46:52,100
只需要将当前chunk的地址加上chunk大小
by taking the address of the current chunk and adding the chunk size

653
00:46:52,500 --> 00:46:55,000
那我们能找到上一个chunk吗
well can we find the previous chunk

654
00:46:55,700 --> 00:47:02,400
上一个chunk地址等于当前chunk地址减去prev_size
the previous chunk is defined as the beginning of the current chunk minus the previous size

655
00:47:02,500 --> 00:47:06,533
但请记住，prev_size有效的前提是
but remember the previous size is only valid

656
00:47:06,900 --> 00:47:12,966
上一个chunk没在使用中
if the previous chunk is not in use

657
00:47:13,133 --> 00:47:14,666
它得是空闲的
if it's currently free

658
00:47:14,900 --> 00:47:18,900
那我们如何知道它是否是空闲的
and how do we know if the previous chunk is currently free

659
00:47:19,400 --> 00:47:27,300
可以查看当前chunk大小的最低有效位
it is in the least significant bits of the current size of the current chunk size

660
00:47:28,300 --> 00:47:32,700
我们在之前的模块中讲过
now we saw in earlier modules

661
00:47:32,800 --> 00:47:35,066
如果能堆溢出
that if you have an overflow

662
00:47:35,066 --> 00:47:37,800
你就可以覆盖chunk大小的值
you can overwrite that size value

663
00:47:38,600 --> 00:47:48,600
当初是用来在tcache中创建重叠分配的
we did this to create some overlapping allocations with tcache chunks

664
00:47:50,200 --> 00:47:54,500
在某些情景中，你能覆盖chunk的大小
so there are scenarios where you can overwrite the size of a chunk

665
00:47:54,900 --> 00:47:59,700
如果找到溢出方法，溢出点要在chunk size前
that is in front of a chunk that you have write access to if you have some type of overflow 

666
00:48:01,600 --> 00:48:03,400
如果能覆盖chunk大小
and if I could overwrite the size 

667
00:48:03,500 --> 00:48:07,366
那肯定已经能覆盖prev_size了
I have already written past the previous size

668
00:48:08,166 --> 00:48:10,300
所以在堆溢出情况
so in an overflow scenario 

669
00:48:10,466 --> 00:48:15,566
是可以设置或清除prev_inuse位
it is possible to set or clear the previous in use

670
00:48:15,666 --> 00:48:19,000
以及prev_size的
and set or clear the previous size

671
00:48:19,100 --> 00:48:25,200
由于prev_size决定了上一个chunk的位置
and since the previous size determines where the previous chunk is

672
00:48:26,300 --> 00:48:31,100
故有2种不同方法操纵堆
there's two different ways to manipulate the heap

673
00:48:31,500 --> 00:48:36,200
可以在内存中操纵它
you can manipulate it in physical space right here

674
00:48:36,533 --> 00:48:39,133
只需修改size和prev_size
by messing with size and previous size

675
00:48:39,266 --> 00:48:45,200
这将弄混chunk的起始和终止地址
and that's going to mess up where chunks begin and where chunks end

676
00:48:45,966 --> 00:48:49,500
也可通过指针操纵它
you can also mess up the heap with pointers

677
00:48:49,800 --> 00:48:53,500
就通过操纵这些前向后向指针
based on these forward and back pointers in manipulating them

678
00:48:53,700 --> 00:49:02,300
有的chunk是从这些指针控制的地址中创建出来的（eg.从topchunk取）
so as such that a chunk is created from an address that is defined by these pointers

679
00:49:02,700 --> 00:49:07,600
而不一定非得通过unlink_chunk函数
not specifically from the unlink_chunk function For Your Info

680
00:49:08,700 --> 00:49:11,700
所以原则上通过操纵前向和后向指针
in principle by manipulating the forward and back pointers

681
00:49:11,766 --> 00:49:13,200
也可以创建chunk
you can also create a chunk

682
00:49:13,200 --> 00:49:17,900
故有2种不同堆攻击方法
and so there's two different avenues to kind of attack the heap

683
00:49:17,900 --> 00:49:21,100
都能让堆行为异常并对你有利
and get the heap to misbehave in a manner that's beneficial to you

684
00:49:22,333 --> 00:49:24,666
这些就是要考虑的全部内容
and so that is all stuff to think about

685
00:49:24,933 --> 00:49:27,800
但真正的漏洞利用是什么样的呢
but what are the actual exploits

686
00:49:30,100 --> 00:49:34,233
可以在这个网站找到漏洞利用
exploits can be found at this website

687
00:49:34,700 --> 00:49:40,900
github.com/shellphish/how2heap
github.com/shellphish/how2heap 

688
00:49:41,300 --> 00:49:45,500
这个资源大概是我能为你们找到的最好的一个
this is probably the best single resource I can point you to

689
00:49:45,900 --> 00:49:49,000
我在这节课开始的时候提到过
I mentioned at the beginning of this lecture that

690
00:49:49,533 --> 00:49:53,100
堆漏洞严重依赖于libc版本
heap exploits are heavily dependent on libc versions

691
00:49:53,100 --> 00:49:55,966
所以当人们在网上发布writeup时
and so when people do writeups and post them online

692
00:49:56,133 --> 00:50:00,933
很容易就过时而无法使用
it's very easy to come across outdated or incorrect information

693
00:50:01,600 --> 00:50:09,400
这个git仓库定期更新堆利用技巧
this repository is a regularly updated list of heap exploitation techniques

694
00:50:09,600 --> 00:50:14,300
并根据libc版本管理并验证
that are organized sorted and verified by libc versions

695
00:50:15,800 --> 00:50:18,300
这些漏洞利用是用C写的
these exploitation techniques are written in C

696
00:50:18,466 --> 00:50:21,866
有可用的PoC
with working examples of the proof of concept

697
00:50:22,200 --> 00:50:28,700
会在malloc、覆盖、溢出等之间
they print out kind of what the idea is between the mallocs and

698
00:50:29,100 --> 00:50:31,933
输出解释性文本
the overwrites or overflows or what is going on

699
00:50:31,933 --> 00:50:34,400
解释正在使用的基础利用方法
to try to explain the primitives that are at work

700
00:50:35,700 --> 00:50:36,866
所以你可以运行它们
so you can run them 

701
00:50:36,966 --> 00:50:42,466
看看它在你的系统或你的libc上的实际效果
and see it in action that it does work on your system or on your libc

702
00:50:43,300 --> 00:50:46,800
上面还有一个按钮可以让你运行交换式的web终端
it also has a button where you can run interactive web terminal

703
00:50:47,033 --> 00:50:53,100
所以如果你没有Linux机器来尝试这些堆利用
so if you do not have a Linux box to do heap exploitation and playing around with these

704
00:50:53,366 --> 00:50:57,300
你可以在交互式web shell上，尝试这里大多数的利用方法
you can run a lot of them on an interactive web shell

705
00:50:58,600 --> 00:51:02,800
关于堆利用学习
on the topic of just generally learning about heap exploitation

706
00:51:02,900 --> 00:51:04,900
你会遇到的一个问题是
one of the problems that you run into is 

707
00:51:04,900 --> 00:51:08,600
堆利用方法在其它libc版本的效果
you want to see how exploits work on other versions of libc

708
00:51:09,100 --> 00:51:12,500
这个git仓库：glibc-all-in-one
this repository here glibc-all-in-one

709
00:51:12,866 --> 00:51:14,833
提供了一个非常方便的工具
provides a pretty handy tool that 

710
00:51:14,900 --> 00:51:21,000
可以直接告诉它要下载2.32版本的libc
you can just say download libc version 2.32 

711
00:51:21,266 --> 00:51:23,766
它就会帮你下载
and it will go out and fetch it for you

712
00:51:24,000 --> 00:51:27,333
构建，编译，并确保它可以正常运行
build it compile it and make sure that it's good to go

713
00:51:28,100 --> 00:51:30,600
如果你对堆利用感兴趣
so if you are interested in heap exploitation

714
00:51:30,600 --> 00:51:34,000
您肯定希望手边有多个版本的libc
you'll definitely want to have more than one version of libc handy

715
00:51:34,100 --> 00:51:37,000
它是获取多版本libc的好工具
and this is a great tool to retrieve them

716
00:51:38,800 --> 00:51:42,133
总结一下
so in conclusion here 

717
00:51:44,333 --> 00:51:48,200
会用到的堆利用方法
the heap exploits that we are going to be working with

718
00:51:48,533 --> 00:51:52,133
都能在shellphish/how2heap中找到
will be found in shellphish/how2heap

719
00:51:53,266 --> 00:51:56,333
就是这个git仓库
and this is the repository

720
00:51:56,600 --> 00:52:02,200
能看到一系列的堆利用技术
and so we see there is a list of exploitation techniques

721
00:52:02,700 --> 00:52:04,066
这是对它们的描述
there's a description of them

722
00:52:04,266 --> 00:52:06,066
支持的最新libc版本
what is the latest libc version

723
00:52:06,066 --> 00:52:06,966
是否有对应补丁
was it patched

724
00:52:07,166 --> 00:52:11,033
有没有使用了这个漏洞利用方法的CTF题目
are there examples of CTF challenges that use this exploit

725
00:52:12,800 --> 00:52:17,700
但对于本课程，我们将使用libc 2.35
but for this class we're going to be on libc version 2.35

726
00:52:18,400 --> 00:52:26,500
这些是在libc 2.35上可用的利用方法
so these are the exploitation techniques that work on libc 2.35

727
00:52:27,600 --> 00:52:28,966
有很多
there's a number of them

728
00:52:30,700 --> 00:52:35,866
他们都依赖一些基础利用方法
and they all require some type of primitive

729
00:52:36,466 --> 00:52:39,433
我们打开一个
and so if we were to open one 

730
00:52:39,666 --> 00:52:43,300
查看一下示例代码
and take a look the example code

731
00:52:43,800 --> 00:52:48,200
可能假设目标程序存在双重释放
may assume that you have for instance a double free

732
00:52:48,400 --> 00:52:52,100
可能假设有缓冲区溢出
where it may assume you have a buffer overflow

733
00:52:52,400 --> 00:52:55,000
可能假设有释放重用UAF
it may assume that you have a use after free

734
00:52:55,066 --> 00:52:56,500
即有chunk被free后
that a chunk gets freed

735
00:52:56,566 --> 00:52:59,433
你还能对其写入，进而修改元数据
and you can still write to it to modify the metadata

736
00:52:59,600 --> 00:53:05,800
所以要考虑这些利用方法依赖哪些基础方法
and so you need to be thinking about what primitives do these exploits require

737
00:53:05,900 --> 00:53:10,000
还有这些利用方法能提供哪些新利用效果
and then what primitives does this exploit grant me

738
00:53:10,966 --> 00:53:13,666
因为这些利用方法
because what these techniques do 

739
00:53:13,733 --> 00:53:16,666
能将你提供的基础利用方法
is they take something that you have

740
00:53:16,933 --> 00:53:19,766
比如重叠分配
like overlapping allocations 

741
00:53:19,900 --> 00:53:25,200
转换成一个任意读或任意写
and turns it into an arbitrary read or an arbitrary write

742
00:53:25,900 --> 00:53:31,033
因此，堆利用就变成了将基础利用方法
and so heap exploitation becomes about turning primitives 

743
00:53:31,266 --> 00:53:34,300
不断转换成另一种利用方法
into other primitives into other primitives

744
00:53:34,400 --> 00:53:37,800
直到你最终达成你的目标
until you ultimately accomplish what it is that you need

745
00:53:38,300 --> 00:53:41,566
所以想要完成这个模块
so to be successful in this module 

746
00:53:41,733 --> 00:53:48,500
你需要关注这个git仓库
you will need to pay attention to this repository right here

747
00:53:49,200 --> 00:53:56,600
因为这将是理解堆利用的最佳资源
because that is going to be your best resource  for understanding what you can do with heap exploitation

