1
00:00:00,300 --> 00:00:04,200
欢迎回到格式化字符串漏洞系列
welcome back to our series here on format strings and format string exploits

2
00:00:04,200 --> 00:00:05,833
在这个视频中我们要讨论
in this video we're going to discuss 

3
00:00:05,900 --> 00:00:10,100
printf如何使用格式化字符串来写数据
how format strings can be used with printf to write data

4
00:00:10,400 --> 00:00:14,200
用printf来写数据，这听起来确实很怪
now writing data with the print function certainly sounds a little bit strange

5
00:00:14,300 --> 00:00:15,900
怎么做呢
so how do we do it

6
00:00:16,300 --> 00:00:21,100
printf实现了一个%n的替换符
well it turns out printf implements a substitution percent n 

7
00:00:21,366 --> 00:00:24,566
%n会对传入的指针解引用
and percent n will dereference a pointer from the stack

8
00:00:24,733 --> 00:00:28,366
然后把已输出字符串的字节数写到该地址
and write the number of bytes written so far to that address

9
00:00:28,566 --> 00:00:29,800
我们来看一下这个例子
so if we look at this example

10
00:00:29,800 --> 00:00:31,366
有一个整型变量namelength
we have an integer namelength

11
00:00:31,400 --> 00:00:34,600
然后调用printf("%s%n"
then we call printf percent s percent n

12
00:00:34,866 --> 00:00:36,900
之后第一个参数是name
where the first parameter is name

13
00:00:36,900 --> 00:00:40,900
第二个参数是namelength的地址
 and the second parameter is a reference to namelength

14
00:00:41,400 --> 00:00:43,933
printf运行时
when this printf command is ran

15
00:00:44,566 --> 00:00:46,600
会输出name到标准输出
name will be displayed at standard out

16
00:00:47,000 --> 00:00:48,966
并且已输出字节
and the number of bytes written

17
00:00:48,966 --> 00:00:51,700
本例中，name的长度
which in this case is just the length of name

18
00:00:51,966 --> 00:00:54,400
将写入namelength
will be stored in namelength

19
00:00:55,266 --> 00:00:57,533
这样当第二次调用printf时
that way when printf is called a second time

20
00:00:57,533 --> 00:01:00,066
namelength肯定是正确的
the namelength will always be correct

21
00:01:00,533 --> 00:01:02,866
因为它是在第一次调用printf时被设置好的
because it is being set in the first printf 

22
00:01:02,966 --> 00:01:04,933
在第二次printf时使用
and used in the second printf

23
00:01:06,700 --> 00:01:09,800
有的程序会正常用%n
you also see applications where percent n makes sense

24
00:01:09,800 --> 00:01:12,300
当尝试实现任意一种动态格式化字符串时
when you're doing any type of dynamic formatting

25
00:01:12,300 --> 00:01:14,500
你都可能会输出一些用户提供的内容
you may be printing some user provided input

26
00:01:14,566 --> 00:01:17,033
但你不一定知道它有多长
and you don't necessarily know how long it is

27
00:01:17,200 --> 00:01:18,766
使用%n
by using percent n 

28
00:01:18,933 --> 00:01:22,800
我们就可以在输出的同时，记录它的长度
we can display it and store the length at the same time

29
00:01:22,900 --> 00:01:25,266
所以这个功能是有合理用途的
so there are legitimate use cases for this

30
00:01:25,466 --> 00:01:28,800
然而，%n也适用于漏洞利用
however percent n is also right for exploitation

31
00:01:29,066 --> 00:01:31,966
我们用一个例子来看一下它的厉害
so let's take a look at why this is bad in a demo

32
00:01:32,900 --> 00:01:37,200
我从之前视频中的代码开始
so I'm gonna start off with the same code example that we had in the prior video

33
00:01:37,500 --> 00:01:39,500
我要把它改成
and I'm gonna change this to be

34
00:01:39,733 --> 00:01:44,700
一个能通过写入数据来获取flag的例子
an example where writing data will get us the flag

35
00:01:44,700 --> 00:01:51,400
要做到这一点，我需要一个print_flag值
and to do that I'm going to have a print_flag value

36
00:01:57,100 --> 00:02:00,700
初始值设为0
and we will initially set it to be 0

37
00:02:06,800 --> 00:02:07,666
现在
now if

38
00:02:11,066 --> 00:02:13,266
不管什么原因，如果它不是0
for whatever reason it is not 0

39
00:02:14,600 --> 00:02:16,300
我们就打开/flag
then we will open the flag

40
00:02:24,566 --> 00:02:26,700
将它读入某个缓冲区
read it into some buffer

41
00:02:29,466 --> 00:02:33,066
然后输出到标准输出
and then we will write it to standard out

42
00:02:38,266 --> 00:02:40,800
现在我们需要设置缓冲区
now we'll need to set the buffer

43
00:02:40,933 --> 00:02:43,066
在这声明定义一个buf
we define the buf declare it here

44
00:02:43,966 --> 00:02:46,900
就把它放在栈上
so it can just be here on the stack

45
00:02:48,366 --> 00:02:51,466
我们还需要包含一些额外的头文件
and we'll need to include some additional header files

46
00:03:11,933 --> 00:03:13,733
现在编译它
so now if we compile this

47
00:03:17,166 --> 00:03:21,100
传入一个%x，还能看到beef1337
and we pass it percent x we still get beef1337

48
00:03:21,133 --> 00:03:23,133
而且不会得到flag
and we don't get a flag

49
00:03:24,766 --> 00:03:26,966
这里我们不会传入很多%p
so rather than spamming percent p 

50
00:03:27,066 --> 00:03:31,100
再去猜哪个是print_flag指针
and trying to guess what where is this print_flag pointer

51
00:03:31,333 --> 00:03:32,500
我们直接用GDB
we're going to use GDB

52
00:03:32,500 --> 00:03:35,266
调试一下，看看能不能算出来
and explore the binary and see if we can calculate it

53
00:03:35,400 --> 00:03:36,400
我们开始吧
so let's do that

54
00:03:38,266 --> 00:03:40,200
我们在GDB中运行程序
we will run the binary in GDB

55
00:03:41,766 --> 00:03:43,500
我们在main处设置一个断点
we'll set a break point at main

56
00:03:45,800 --> 00:03:52,300
现在我们在main的最开始
now right now we are at the very beginning of main

57
00:03:52,566 --> 00:03:53,666
如果我们看一下
and if we look

58
00:03:56,100 --> 00:03:59,466
在开始推理前，需要先执行完这个序言
we need this prologue to happen before we can start reasoning about it 

59
00:03:59,533 --> 00:04:03,100
因为我们想在main的栈帧中
because we want to be in the function frame of main

60
00:04:03,300 --> 00:04:08,500
所以我先让它执行几条指令
so I'm going to move forward several instructions 

61
00:04:08,666 --> 00:04:11,266
把RBP和RSP设置好
so that RBP and RSP are set

62
00:04:14,533 --> 00:04:16,766
现在如果我们反汇编main
so now if we disassemble main

63
00:04:18,700 --> 00:04:22,200
我想找到在哪里发生的这个比较
I want to find where in the binary is this comparison happening

64
00:04:22,266 --> 00:04:24,200
在哪里检查的print_flag
where are we checking print_flag

65
00:04:25,333 --> 00:04:28,300
我们从这里往上看
and as we look up from here

66
00:04:28,966 --> 00:04:30,566
我们看到这一串的open read write
we see the open read write

67
00:04:30,566 --> 00:04:32,200
所以还要再上面
so it's going to be above this

68
00:04:32,900 --> 00:04:35,533
看到了test eax, eax
and we have test EAX EAX

69
00:04:36,366 --> 00:04:38,866
这里大概就是比较的位置
so this is very likely where that's occurring

70
00:04:38,900 --> 00:04:39,800
这里检查eax是否为0
that's the check

71
00:04:39,800 --> 00:04:45,400
这里跳转到输出或是不输出flag的代码块
and this is the jump that either reads the flag out or it does not

72
00:04:46,300 --> 00:04:47,700
我们可以看到
and we see that

73
00:04:48,200 --> 00:04:54,200
EAX为RAX, RAX为RBP-0x220
EAX is RAX and RAX is RBP-0x220

74
00:04:54,400 --> 00:05:00,700
那我们输出RBP - 0x220
so let's print RBP - 0x220

75
00:05:01,500 --> 00:05:04,300
另一个我感兴趣的值是RSP
and the other value I'm interested in is RSP

76
00:05:07,100 --> 00:05:10,300
如果我们看这两个位置之间的距离
and if we look at the distance between these two locations

77
00:05:25,900 --> 00:05:27,133
是0x20
it's hex twenty

78
00:05:27,666 --> 00:05:31,900
当printf向前寻找参数时
now when printf is marching forward looking for arguments

79
00:05:32,133 --> 00:05:34,166
步长为8字节（一个参数8字节）
they are all of sought length 8

80
00:05:34,600 --> 00:05:40,800
用0x20除以8，得到4
which means we take 0x20 and divided by 8.  we get 4

81
00:05:41,300 --> 00:05:48,900
而且第六个参数是第一个栈上参数（不算格式化字符串）
we also know that the sixth argument is the first one on the stack

82
00:05:49,266 --> 00:05:51,300
就是printf返回后的RSP
that would be RSP

83
00:05:51,766 --> 00:05:53,700
6 + 4 = 10
so 6 + 4 is 10

84
00:05:53,866 --> 00:05:56,266
我们可以认为
so we would assume that

85
00:05:56,500 --> 00:06:04,900
从printf的角度看，print_flag是它的第10个参数
the print_flag value is the 10th argument from printf or from printf's perspective here

86
00:06:06,766 --> 00:06:08,166
我们来验证一下
so let's verify that

87
00:06:09,133 --> 00:06:10,900
我们执行a.out
we'll run a.out

88
00:06:13,500 --> 00:06:21,300
再给几个字节，接着%10$n
and we will give it just some bytes followed by percent 10 $ n

89
00:06:21,666 --> 00:06:25,800
这里的a，用来随便输出几个字节
now the a(s) are here so that some bytes are written out

90
00:06:27,300 --> 00:06:30,833
如果是a%10$n
if I just do a percent 10 n

91
00:06:31,066 --> 00:06:39,700
将会把1写入printf第10个参数处
this should write 1 to the address that is the 10th argument of Printf

92
00:06:43,000 --> 00:06:45,266
事实确实如此
and we see that that is what happened

93
00:06:45,933 --> 00:06:47,133
我们输出了a
we output a

94
00:06:47,900 --> 00:06:53,400
然后将1写入到了printf的第十个参数处
we then write one to the pointer that is the 10th argument to printf

95
00:06:53,400 --> 00:06:58,400
在这里，就是这个指针print_flag
which in this case is this pointer right here print_flag

96
00:06:59,133 --> 00:07:01,366
把它的值设为了1
which sets the value to be 1 

97
00:07:01,700 --> 00:07:03,333
就通过了检查
which passes this check

98
00:07:04,166 --> 00:07:06,266
这就是为什么我们看到了flag
and that is why we see flag

99
00:07:07,100 --> 00:07:08,566
其余部分
the rest of this output 

100
00:07:08,800 --> 00:07:16,100
是buf中的未初始化数据
is because write is just running on past what was in the flag file

101
00:07:20,666 --> 00:07:21,666
在这个示例中
now in that demo

102
00:07:21,866 --> 00:07:25,500
碰巧有一个指针指向我们想要修改的值
we happen to have a pointer that was pointing to the exact value we wanted to set

103
00:07:25,700 --> 00:07:28,666
而且也不远，所以很容易找到
and it wasn't that far away and so it was pretty easy to find

104
00:07:28,800 --> 00:07:30,800
这很好
and that was great

105
00:07:31,400 --> 00:07:36,000
但如果是其它情况，我们还有哪些利用策略
but what other strategies might we want to consider if that isn't the case

106
00:07:37,500 --> 00:07:39,600
要考虑的一件事是
well one thing to think about is

107
00:07:39,700 --> 00:07:43,000
如果格式化字符串缓冲区在栈上呢
what if our format string buffer is sitting on the stack

108
00:07:43,466 --> 00:07:45,666
我们能控制格式化字符串缓冲区
well we control the format string buffer

109
00:07:45,900 --> 00:07:48,900
因为它是一个格式化字符串漏洞
that's why it's a format string exploit

110
00:07:48,900 --> 00:07:51,500
我们可以在格式化字符串缓冲区中写入一个指针
so we could put a pointer in the format string

111
00:07:51,533 --> 00:07:53,366
它指向我们想要的
and then reference ourselves

112
00:07:53,966 --> 00:07:56,900
或者栈上有一个指针
alternatively there could be a pointer on the stack

113
00:07:56,900 --> 00:07:59,000
它可能不是直接指向我们需要的
it may not point to exactly what we want

114
00:07:59,000 --> 00:08:02,200
但指向一些我们想要影响的
but it may point to something that we might want to influence

115
00:08:02,400 --> 00:08:07,966
因此，看看能访问的指针，还是有必要的
so it's still worth considering in looking at what pointers are available to be accessed 

116
00:08:08,233 --> 00:08:09,566
最后一点
and then lastly

117
00:08:09,566 --> 00:08:12,100
想一想RBP的原理
let's think about how base pointers work

118
00:08:12,900 --> 00:08:17,400
栈上保存的RBP指向前一个栈帧的RBP
a saved base pointer points to the prior saved base pointer

119
00:08:17,500 --> 00:08:21,300
能在格式化字符串漏洞利用时，利用这一点
and we can exploit this fact when writing a format string exploit

120
00:08:22,000 --> 00:08:28,800
找到到第一个保存的RBP，这里的ebp1，的距离
by finding the offset to the first saved base pointer in this case ebp one

121
00:08:29,800 --> 00:08:34,900
ebp1将指向一个地址，此处为ebp2
ebp one will be a pointer to a known location in this case ebp two

122
00:08:35,166 --> 00:08:38,133
由此我们可以编写一个格式化字符串漏洞利用
and so we can write a format string exploit

123
00:08:38,400 --> 00:08:46,000
写入数据到ebp1指向的地址，即ebp2
that sets the value that is pointed to by EBP1 to write the value at ebp two

124
00:08:46,700 --> 00:08:52,700
然后，我们就可找到到ebp2的距离（找写入值在第几个参数）
we can then find the format string offset to EBP2

125
00:08:54,400 --> 00:08:59,900
再写入数据到ebp2指向的地址
and write to the address that is pointed to by EBP2

126
00:09:00,400 --> 00:09:04,700
这个地址是我们通过ebp1写入的
which is a value that we wrote from EBP1

127
00:09:05,000 --> 00:09:09,900
我们通过ebp1，将真正想要写入的地址，写到ebp2
and so we use EBP1 to write the address that we really want to write to at ebp2

128
00:09:10,200 --> 00:09:15,100
再通过ebp2写入数据到我们选定的地址
and then use ebp2 to write to anywhere in memory that we decide

129
00:09:15,300 --> 00:09:17,066
通过利用这一点
and by leveraging this

130
00:09:17,400 --> 00:09:20,733
尽管有ASLR，我们还是能写
we have a write that works despite ASLR

131
00:09:21,700 --> 00:09:22,766
我们回过头来
but let's go back 

132
00:09:22,866 --> 00:09:28,700
看看格式化字符串缓冲区在栈上会怎样
and look at what happens if our buffer is on the stack

133
00:09:28,700 --> 00:09:30,866
我们可以写入一个指针
and we can put a valid pointer into it

134
00:09:30,900 --> 00:09:33,866
在这个关于ebp的例子中
so in this example here with the base pointers

135
00:09:33,866 --> 00:09:35,766
我们在栈上往回找
we are looking up the stack

136
00:09:35,766 --> 00:09:39,000
查看了前一个栈帧
we are looking at prior stack frames

137
00:09:39,600 --> 00:09:41,533
但当printf被调用时
but when printf is called

138
00:09:41,866 --> 00:09:43,000
发生了什么
what happens

139
00:09:43,700 --> 00:09:47,300
格式化字符串下会有一个栈帧（不是紧挨着）
there's going to be a stack frame below the format string

140
00:09:47,300 --> 00:09:48,666
这意味着
and what this means is that 

141
00:09:48,733 --> 00:09:55,200
应该能找到从RSP到格式化字符串缓冲区的偏移量
we should be able to find an offset from RSP to the format string buffer

142
00:09:55,966 --> 00:09:58,400
我不打算在这个视频中解决这个问题
now I'm not going to solve this problem in this video

143
00:09:58,400 --> 00:10:02,200
但是这和我们寻找返回地址的时候很相似
but it's going to be very similar to when we are finding return addresses

144
00:10:02,266 --> 00:10:05,166
和缓冲区溢出时找，到返回地址的偏移，相似
or offsets to a return address in a buffer overflow

145
00:10:05,366 --> 00:10:08,200
那时我们用的pwncyclic
in that case we used pwncyclic

146
00:10:08,366 --> 00:10:11,266
pwncyclic并不能解决这个问题
now pwncyclic will not solve this exact problem

147
00:10:11,266 --> 00:10:13,100
但逻辑是相通的
but a similar type of logic will

148
00:10:15,400 --> 00:10:18,800
使用%n时，演示中没展示的，另一个问题
another problem with using percent n that wasn't in the demo

149
00:10:18,866 --> 00:10:21,766
是%n默认只能写4字节
is that percent n by default writes 4 bytes

150
00:10:21,800 --> 00:10:24,000
但如果我想写8字节呢
what if I want to set 8 bytes 

151
00:10:24,166 --> 00:10:25,966
我可以用%ln
well I could use percent ln 

152
00:10:26,200 --> 00:10:28,033
要是想写2字节呢
or I need to set 2 bytes

153
00:10:28,600 --> 00:10:30,266
则可用%hn
well that would be percent hn

154
00:10:30,266 --> 00:10:32,200
写一个字节呢
and if I need to just write a single byte

155
00:10:32,200 --> 00:10:33,266
只改一字节
just change one

156
00:10:33,333 --> 00:10:35,666
可用%hhn
I could use percent hhn

157
00:10:37,300 --> 00:10:40,066
如何控制写入内容
now how do we control what to write

158
00:10:40,166 --> 00:10:42,300
在演示中，我们只写了一个字节
in the demo we just wrote a single byte

159
00:10:42,300 --> 00:10:43,366
就一个a
there is a single a

160
00:10:43,533 --> 00:10:45,966
如果我想写入一个指定的值呢
what if I need to write a very specific value

161
00:10:46,700 --> 00:10:50,200
我们需要利用printf的另一个特性
well we need to take advantage of another one of Printf's features

162
00:10:50,366 --> 00:10:51,533
也就是填充
which is padding

163
00:10:51,766 --> 00:10:53,000
我们没做这个的ppt
we don't have a slide on this

164
00:10:53,200 --> 00:10:57,333
建议参考printf的man page
so I'd strongly recommend referencing the Printf Man pages

165
00:10:57,333 --> 00:10:59,433
命令为 man 3 printf
which is man 3 printf

166
00:11:00,500 --> 00:11:02,666
现在的情况是
but what we have going on here is 

167
00:11:02,766 --> 00:11:04,066
我们有一个char缓冲区
we have a character buffer

168
00:11:04,266 --> 00:11:09,466
还有printf后跟着 % 一个很大的数 x
and then we have printf followed by percent very large number x

169
00:11:09,700 --> 00:11:13,033
这一首个替换符表示
now this first substitution is saying 

170
00:11:13,266 --> 00:11:17,366
打印，或者说解析字符数组buf
print or interpret buf which is a character array

171
00:11:17,366 --> 00:11:19,366
字符数组也是一个指针
and a character array is a pointer

172
00:11:20,166 --> 00:11:23,000
把它按十六进制输出
and we're going to interpret it as a hexadecimal value

173
00:11:23,066 --> 00:11:24,466
因为用的是%x
which is why it's x

174
00:11:24,700 --> 00:11:28,100
同时我们提供了一个很长的填充
and we're going to provide it with this very large amount of padding

175
00:11:28,200 --> 00:11:32,900
所以这会在十六进制数前，输出大量的空白字符
so there's going to be a bunch of white space before this hexadecimal value

176
00:11:33,600 --> 00:11:37,133
这些都会输出到标准输出
and we're going to display all of that to standard out

177
00:11:38,200 --> 00:11:43,100
这里printf的第二个替换符是%1$n
the second printf substitution here is percent 1 $ n

178
00:11:43,500 --> 00:11:49,300
这个%1$表示引用第一个参数，即buf
and so the percent 1 $ is we want to reference the first parameter which again is buf

179
00:11:49,933 --> 00:11:51,866
但因为后面是 n
but because we are doing n

180
00:11:52,700 --> 00:11:59,200
所以这个替换符将把已输出字节长度，写入buf
this substitution is writing this number of bytes to buf

181
00:12:00,800 --> 00:12:07,100
这将导致ABCD被写入buf
and this should result in ABCD being set or being written to buf

182
00:12:07,900 --> 00:12:10,566
但这样做肯定是有代价的
but there is certainly a cost to doing this

183
00:12:11,266 --> 00:12:13,400
我们快速看一下
let's take a quick look at it

184
00:12:14,566 --> 00:12:17,400
我这里有一样的示例代码
so I have that exact demo code over here

185
00:12:17,900 --> 00:12:21,500
有char数组 buf
we have our character array buf

186
00:12:22,300 --> 00:12:23,700
有我们的printf
we have our printf

187
00:12:24,000 --> 00:12:28,300
美观起见，我多打印了几个换行符
I'm printing out a few new lines just for prettiness sake

188
00:12:28,733 --> 00:12:31,400
然后输出buf的内容
and then we're going to write out the contents of buf

189
00:12:32,333 --> 00:12:33,733
编译一下
so let's compile that

190
00:12:35,566 --> 00:12:36,933
运行它
and we're going to run this

191
00:12:37,100 --> 00:12:40,700
我不确定录屏能不能录到
now I'm not sure that this captures on video 

192
00:12:40,966 --> 00:12:42,833
但在我的终端底部
but at the bottom of my terminal 

193
00:12:43,000 --> 00:12:47,166
光标完全失控了，到处乱跳
the cursor is just going utterly wild and bouncing all over the place

194
00:12:47,900 --> 00:12:51,200
我们没有宕机（三连）
and we're not hanging we're not thinking we're not stuck

195
00:12:51,500 --> 00:12:55,533
我们在等这些填充的空格
what we're waiting on is for all of the white space from this padding

196
00:12:56,066 --> 00:12:59,533
在输出十六进制数前，输完
to display on the terminal before a hexadecimal value

197
00:12:59,733 --> 00:13:03,933
我们只能先等输出结束
and so we're just waiting for that output

198
00:13:05,000 --> 00:13:06,200
这里我们看到
and here we see

199
00:13:07,300 --> 00:13:11,233
babbba74
babbba74 

200
00:13:11,666 --> 00:13:18,000
这是buf指针的十六进制输出
this right here is the hexadecimal interpretation of the buf pointer

201
00:13:19,500 --> 00:13:21,333
然后接着几个换行符
then I have a couple new lines

202
00:13:21,666 --> 00:13:23,133
我看到了ABCD
and I see ABCD

203
00:13:23,500 --> 00:13:28,000
这个ABCD是写入buf内容
the ABCD output is the output from writing the contents of buf

204
00:13:28,066 --> 00:13:29,900
所以我们能设置指定的值
so we were able to set that

205
00:13:30,066 --> 00:13:32,600
但能看到这很耗时
but you could see that that took quite a while

206
00:13:33,166 --> 00:13:35,600
这还只是写4字节
and that was only to write 4 bytes

207
00:13:36,366 --> 00:13:39,400
要是我们要写8字节，该怎么办
so what do we do if we need to write 8 bytes

208
00:13:39,433 --> 00:13:41,200
需要写一个完整的地址
I need to write a full address

209
00:13:41,300 --> 00:13:44,166
我们如何处理这些情况
how do we handle some of these other scenarios

210
00:13:45,600 --> 00:13:51,200
答案是结合前面看到的printf的特性
the answer is to combine some of the features that we've seen previously with printf

211
00:13:51,900 --> 00:13:56,666
这是一个printf格式化字符串
so here is a printf format string 

212
00:13:56,833 --> 00:14:00,533
它和前面的例子效果完全一样
that does the exact same thing as the previous example

213
00:14:00,533 --> 00:14:01,700
只是它
except it's going to do it 

214
00:14:01,866 --> 00:14:06,200
不需要输出那么多的填充空白字符
without outputting nearly as much noise and padding and white space bytes to the terminal

215
00:14:06,700 --> 00:14:08,933
我们快速看一下
let's take a quick look and see how it works

216
00:14:09,333 --> 00:14:12,200
首先是%65x
first we have percent 65 x

217
00:14:12,300 --> 00:14:19,500
它填充65字节，后跟着一个十六进制值
this is going to be 65 bytes of padding followed by a hexadecimal value

218
00:14:20,000 --> 00:14:24,733
然后是%1$hhn
then we're going to percent 1 $ hhn

219
00:14:24,733 --> 00:14:28,666
将值65写入1字节的buf[0]内
so we're going to write a single byte with the value 65

220
00:14:28,700 --> 00:14:33,100
65恰好是大写字母A的ASCII值
now 65 happens to be the numerical representation of capital A

221
00:14:34,233 --> 00:14:39,000
然后重复%c输出1字节，%hhn写一字节
then we are going to repeatedly write percent C followed by writing a byte

222
00:14:39,000 --> 00:14:42,100
这样能让已输出字节总数递增
so that is going to increment the total number of bytes written

223
00:14:42,266 --> 00:14:49,200
最后依次写下 65 66 67 68，即ABCD
so we will be writing 65666768 in sequence which is ABCD

224
00:14:50,366 --> 00:14:52,700
示例代码在这
now I have the example code right here

225
00:14:53,166 --> 00:14:54,366
我们编译它
if we compile it

226
00:14:56,133 --> 00:14:57,400
执行
and give it a run

227
00:14:57,700 --> 00:15:02,600
能看到结果和上一个非常相似
we see that we get the very similar output to the first example 

228
00:15:02,866 --> 00:15:07,900
但终端上没了一页又一页的空白填充符号
except I don't get pages and pages of padding and white space flooding across my terminal

229
00:15:07,900 --> 00:15:13,700
但还是能看到ABCD被写到buf中了
but we still see that ABCD is the value written to buf

230
00:15:15,966 --> 00:15:18,900
速度快了很多，垃圾数据少了很多
just significantly faster with much less noise

231
00:15:19,300 --> 00:15:24,400
值得注意的一点是，ABCD是递增的
now one of the things worth noting here is ABCD is a series of increasing values

232
00:15:24,400 --> 00:15:28,300
这样构造格式化字符串相对很简单
so that's relatively easy to construct a format string that will write this

233
00:15:29,000 --> 00:15:34,000
要是我想写DCBA，一串递减的值呢
what if I wanted to write DCBA which would be a series of decreasing bytes

234
00:15:34,266 --> 00:15:36,400
这里需要一点创意
I might have to get a little bit more creative

235
00:15:36,400 --> 00:15:38,900
我们要把它留给观众作为练习（$）
but we're going to leave that as an exercise to the viewer

236
00:15:40,400 --> 00:15:44,400
就在你以为我们讨论完了printf的特性时
and just when you thought we are done talking about the many features of printf

237
00:15:44,466 --> 00:15:46,300
还有一个要讨论的
we have one more to discuss

238
00:15:46,400 --> 00:15:48,533
就是动态填充大小
and that is dynamic padding size

239
00:15:48,800 --> 00:15:51,700
动态填充大小用*指定
dynamic padding size is specified with the star character

240
00:15:52,166 --> 00:15:53,866
它能让你
and what it allows you to do is

241
00:15:54,066 --> 00:15:57,566
不再依靠硬编码指定填充长度
instead of hard coding the number of padding bytes that you need

242
00:15:57,800 --> 00:16:06,500
你能在另一个参数中指定填充长度
you can say the number of padding bytes for this particular substitution is located in another parameter

243
00:16:06,533 --> 00:16:08,133
拿上面的这个例子来说
and so in the example above here

244
00:16:08,133 --> 00:16:11,000
%*10$c
we have percent star 10 $ c

245
00:16:11,400 --> 00:16:14,500
它会把第10个参数当作一个数字
this will take the 10th parameter interpret it as a number

246
00:16:14,500 --> 00:16:16,733
表示需要的
that represents the amount of padding that is needed 

247
00:16:16,833 --> 00:16:21,333
在%c表示的单字符前的，填充长度
for the single character that would normally be displayed with percent c

248
00:16:21,933 --> 00:16:24,700
会输出这么多的字节到终端
will output that many bytes to the terminal

249
00:16:25,600 --> 00:16:28,766
下一个是%11$n
next we have percent 11 $ n

250
00:16:29,666 --> 00:16:31,900
这和%n一样
that is going to work just like percent n 

251
00:16:31,900 --> 00:16:36,300
会将已输出的字节数写入到给定地址
which will write the number of bytes that were printed out to the terminal

252
00:16:36,700 --> 00:16:41,600
这会把这个计数写到第11个参数指定的地址
we're going to write that count to the memory pointed to by the 11th parameter

253
00:16:42,000 --> 00:16:45,800
这直接能拷贝内存了（10th的值拷到了11th的地址处）
the end result of this interaction is a direct memory copy

254
00:16:46,000 --> 00:16:46,900
但请记住这一点
but keep in mind that 

255
00:16:46,966 --> 00:16:49,733
这里不好一次只写一字节
we are not being clever here writing one byte at a time

256
00:16:49,800 --> 00:16:53,100
如果我们要尝试用这种技术复制整个地址
so if we are going to try and copy a whole address using this technique

257
00:16:53,200 --> 00:16:56,333
会输出大量内容
we're going to dump so much content to standard out

258
00:16:56,333 --> 00:16:59,266
使用起来完全不现实
that it becomes completely unrealistic to use

259
00:16:59,766 --> 00:17:03,266
但还是值得注意的，因为你可能会看到它
however it is worth noting because you may see it

