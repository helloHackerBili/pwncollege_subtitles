1
00:00:00,566 --> 00:00:02,499
你好黑客
hello hackers

2
00:00:02,500 --> 00:00:03,900
今天我们要讲的是
today we're going to be talking about

3
00:00:03,900 --> 00:00:07,200
格式字符串和格式字符串漏洞
format strings and format string vulnerabilities

4
00:00:07,400 --> 00:00:11,500
格式字符串漏洞存在于许多函数中
now format string vulnerabilities exist in a number of functions

5
00:00:11,600 --> 00:00:14,833
但是我们今天要看的函数是printf
but the function that we're going to look at today is printf

6
00:00:14,966 --> 00:00:19,700
这是，在讨论这类漏洞时，最常讲的函数
which is the common case that is used when discussing these type of vulnerabilities

7
00:00:20,333 --> 00:00:21,899
printf是怎么用的呢
so how does printf work

8
00:00:21,900 --> 00:00:24,900
printf可接受可变数量的参数
well printf can take a variable number of arguments

9
00:00:24,966 --> 00:00:27,666
第一个参数是一个格式化字符串
the first argument is considered a format string

10
00:00:27,800 --> 00:00:31,300
你可以直接给printf传一个hello这样的字符串
now you could just pass printf with a string like printf hello

11
00:00:31,300 --> 00:00:33,800
这将输出hello到标准输出
and this would display hello to standard out

12
00:00:34,300 --> 00:00:37,500
但printf通常都会和其它参数一起使用
but printf is typically used with some additional arguments

13
00:00:37,733 --> 00:00:39,533
这些其它参数
and these additional arguments

14
00:00:39,533 --> 00:00:44,833
是你想要按格式并替换到格式化字符串中的值
are the values that you want to be formatted and kind of substituted in the format string

15
00:00:45,100 --> 00:00:46,733
看一下第二个例子
so if we look at the second example here 

16
00:00:46,800 --> 00:00:49,566
是 Hello %s   name
we have hello percent s name

17
00:00:49,866 --> 00:00:52,666
这里的name应该是一个字符串
now name should be in this case a string

18
00:00:52,666 --> 00:00:54,999
假设它的值是：pwn.college
so let's say it's pwn college

19
00:00:55,266 --> 00:00:58,699
这里printf的执行结果
the result of calling printf percent s name

20
00:00:58,966 --> 00:01:01,299
将是 Hello pwn.college
would be Hello Pwn College

21
00:01:01,400 --> 00:01:10,100
printf会把%s，这个速记，替换成字符串值，即name
and printf is going to substitute that percent shorthand of percent s with the string value that is name

22
00:01:11,366 --> 00:01:12,366
在第三个例子中
in the third example

23
00:01:12,366 --> 00:01:14,766
能看到可以替换的不仅仅是字符串
we see that we can substitute things that are not just strings

24
00:01:14,800 --> 00:01:18,166
还能替换整数和浮点数
but even integer values or floats right

25
00:01:18,366 --> 00:01:21,266
这里的 %d lights ,5
so there are percent d lights 5

26
00:01:21,533 --> 00:01:25,566
这里将会把整数5转换成数字5的字符
this is going to take the integer 5 convert it to the number 5 as a string

27
00:01:25,566 --> 00:01:27,966
然后替换掉%d
and then substitute that in for percent d

28
00:01:28,500 --> 00:01:32,800
正如在第四个例子中看到的，printf可以替换多个值
now printf can do this for multiple values which is what we see in the fourth example

29
00:01:33,100 --> 00:01:37,600
The average of %d, %d, %d is %f
the average of percent d percent d and percent d is percent f

30
00:01:37,900 --> 00:01:41,900
格式化字符串外的前三个参数是整数
the first three additional arguments passed in are integers

31
00:01:42,066 --> 00:01:44,766
第4个是浮点数
and the fourth argument is in fact a float

32
00:01:44,900 --> 00:01:48,600
printf会处理好这些不同数据类型的值
and printf will take care of formatting these distinct data types

33
00:01:48,600 --> 00:01:52,100
然后把它们插入到格式化字符串中合适的位置
and inserting them into the string in the appropriate location

34
00:01:52,300 --> 00:01:54,500
用起来很方便
and that this is a very handy thing to have

35
00:01:54,700 --> 00:01:58,300
但printf怎么知道应有多少参数的
but how does printf know how many arguments there should be

36
00:01:58,300 --> 00:02:03,100
printf盲目地相信格式化字符串中的记号
well printf just blindly trusts the format string that initial argument

37
00:02:03,400 --> 00:02:08,300
那么，如果用户控制了格式化字符串呢
so what happens if the user controls the format string value

38
00:02:08,800 --> 00:02:11,900
我们能创建任意多的%记号
we could have an arbitrary number of these percent shorthands 

39
00:02:12,000 --> 00:02:14,166
事情可能会变得有点失控
and things could get a little out of hand

40
00:02:15,800 --> 00:02:19,400
格式化字符串决定了printf期待的参数
so the format string determines what arguments printf is expecting

41
00:02:19,466 --> 00:02:21,599
那这些参数都存在哪里呢
but where are these arguments located

42
00:02:22,333 --> 00:02:25,766
printf可以接受任意数量的参数
if printf can take an arbitrary number of arguments

43
00:02:25,900 --> 00:02:29,600
它是否遵循我们已知的标准调用约定呢
does it follow the same standard calling convention that we already know

44
00:02:30,166 --> 00:02:33,933
这些例子中，参数都是对应好的
in these examples everything kind of lines up

45
00:02:34,133 --> 00:02:37,333
在 hello % s 中
we have printf hello percent s 

46
00:02:37,500 --> 00:02:40,166
我们只给了一个字符串name参数
and we give it one argument name which is a string

47
00:02:40,333 --> 00:02:41,999
但是如果我们
but what happens if we say

48
00:02:42,100 --> 00:02:46,500
在格式化字符串中写入大量的%s
hello percent s percent s percent s and we keep passing percent s

49
00:02:47,066 --> 00:02:49,866
占用所有x64调用约定规定的寄存器
eventually we're going to run out of registers right

50
00:02:50,733 --> 00:02:53,466
但我们没有传入足够的参数给printf
if we don't pass enough arguments to the function

51
00:02:53,466 --> 00:02:56,499
它仍然要试着找到对应的值
it's still going to have to try and find that value

52
00:02:56,600 --> 00:03:00,300
来替换%s
it's going to have to find something to substitute percent s with

53
00:03:00,733 --> 00:03:02,133
为了弄明白这个
and so to kind of make sense of this 

54
00:03:02,333 --> 00:03:04,766
我们需要深入C代码之下
we have to look a little bit deeper than the C code

55
00:03:05,133 --> 00:03:09,466
会看看调用printf时的汇编代码
and so we're going to take a look at the assembly here when we do call printf

56
00:03:09,800 --> 00:03:14,000
实际上这和我们习惯的调用约定没有不同
because there isn't in fact a different calling convention than what we are used to

57
00:03:14,000 --> 00:03:22,900
我们熟悉的调用约定会按顺序用到 RDI RSI RDX RCX R8 R9
we should be familiar with the standard calling convention of RDI RSI RDX rcx r8 R9

58
00:03:23,300 --> 00:03:28,733
但若要传递更多参数，来替换到格式化字符串中
but what happens if we need to have more values to substitute into the format string

59
00:03:29,000 --> 00:03:30,766
这些参数存储在哪里
 where these values located

60
00:03:31,000 --> 00:03:32,733
答案就是：栈
it turns out it's on the stack

61
00:03:32,900 --> 00:03:33,666
我们来看一看
let's take a look

62
00:03:34,900 --> 00:03:38,333
为了探索这个问题，我们要
to explore this what we're going to do is

63
00:03:38,866 --> 00:03:41,933
我们创建一个C文件
we're going to make a C file

64
00:03:41,933 --> 00:03:43,366
调用printf
and we are going to call printf

65
00:03:43,500 --> 00:03:46,466
然后在GDB中查看
and then take a look at it in GDB 

66
00:03:46,700 --> 00:03:49,466
看看到底发生了什么
to see what is going on under the hood

67
00:03:49,700 --> 00:03:51,866
我们 include <stdio.h>
so we'll include stdio.h

68
00:03:52,033 --> 00:03:54,799
这是调用printf的必要条件
which is necessary to call printf

69
00:03:55,300 --> 00:03:58,100
这里写一个标准的main函数
we'll do a kind of a standard main function here

70
00:03:58,500 --> 00:04:02,700
参数是argc和argv
with argc and argv

71
00:04:07,700 --> 00:04:16,400
我们将调用printf，带7个整数
we're going to call printf uh 7 integers

72
00:04:20,300 --> 00:04:25,700
把整数命名为a到g
we will just name the integers a through g

73
00:04:29,866 --> 00:04:40,066
我们让它们递增1
and we will make each one of them a slightly higher number

74
00:04:40,700 --> 00:04:46,700
然后把它们传给printf
and we'll pass each one of them to printf

75
00:04:48,133 --> 00:04:52,066
所以我们会看到1 2 3 4 5 6 7
so we would expect to see 1 2 3 4 5 6 7

76
00:04:52,533 --> 00:04:55,533
我们编译并运行它
so let's compile this and run it

77
00:04:55,733 --> 00:04:58,766
我们看到了1 2 3 4 5 6 7
we do see 1 2 3 4 5 6 7

78
00:04:58,766 --> 00:05:01,733
但在末尾有些垃圾数据
but we have some kind of garbage here at the end

79
00:05:02,000 --> 00:05:06,100
这是因为没在末尾加上换行符
and that is because we are not ending this with a new line

80
00:05:07,066 --> 00:05:08,699
我们再来一次
so if we do that again

81
00:05:10,166 --> 00:05:13,333
现在干净了，能看到1到7
now it is clean and we see 1 through 7 as expected

82
00:05:13,933 --> 00:05:16,133
所以底层到底放生了什么呢？
so what's happening under the hood

83
00:05:16,133 --> 00:05:18,666
我们在GDB中打开它
we open this up in GDB

84
00:05:19,700 --> 00:05:23,500
反汇编一下main
we can disassemble the main function

85
00:05:23,933 --> 00:05:25,366
我们想看看
and we want to take a look at

86
00:05:25,400 --> 00:05:29,500
跳转到printf前，是如何设置参数的
how are these arguments set up before we go into printf

87
00:05:29,966 --> 00:05:32,299
能看到printf在这里被调用
and we see printf is called right here

88
00:05:32,666 --> 00:05:37,299
我们在main + 115处设置一个断点
so we'll set a breakpoint at main plus 115

89
00:05:38,666 --> 00:05:40,099
运行它
we run it 

90
00:05:40,500 --> 00:05:42,700
我们看看寄存器里都有啥
let's take a look at what's in the registers

91
00:05:43,300 --> 00:05:47,700
基于我们已知的调用约定
now based upon our kind of existing knowledge of calling conventions

92
00:05:47,900 --> 00:05:52,400
我们预计RDI是格式化字符串
we would expect RDI to be the format string

93
00:05:52,466 --> 00:05:55,799
能看到RDI像个地址
and we see that RDI looks like an address

94
00:05:55,800 --> 00:05:58,766
检查一下这个地址的字符串
so let's examine the string at that address

95
00:05:59,133 --> 00:06:02,066
这里确实是格式化字符串
and we do in fact see the format string located there

96
00:06:02,666 --> 00:06:05,999
剩下的参数是a到g
now the remaining arguments a through G

97
00:06:06,500 --> 00:06:08,133
按照调用约定
we follow through calling conventions

98
00:06:08,433 --> 00:06:16,333
能看到RSI是1，RDX是2，RCX是3，R8是4，R9是5
we see RSI is 1 rdx is 2 RCX is 3 r8 is 4 r9 is 5

99
00:06:16,700 --> 00:06:21,900
现在传给printf的6和7，f和g的值，在哪里
now where are the 6 and 7 the f and g values that are passed in here via printf

100
00:06:22,066 --> 00:06:25,133
如果我们看一些栈上的东西
and if we take a look at what is on the stack

101
00:06:27,500 --> 00:06:33,766
就会看到RSP指向6，RSP+8指向7
we'll see that RSP points to 6 and that RSP+ 8 is 7

102
00:06:36,100 --> 00:06:38,500
这就是printf获取这些值的地方
and so that is where printf is getting these values from

103
00:06:39,200 --> 00:06:40,766
现在我们使用整数
now we used integers

104
00:06:41,400 --> 00:06:43,800
因为在寄存器或内存中找它们的时候
because that was kind of an easy thing to identify 

105
00:06:43,800 --> 00:06:47,266
这样比较容易识别
when we're looking at what's in a register or what's sitting in memory

106
00:06:47,400 --> 00:06:49,666
但不一定非得是整数
but it doesn't have to all be integers

107
00:06:50,000 --> 00:06:52,600
printf可以接受各种数据类型
printf can take a variety of data types

108
00:06:52,800 --> 00:06:56,200
只要和格式化字符串中对应就行
as long as you specify it correctly in the format string

109
00:06:56,700 --> 00:07:00,200
如果我们给一个char*
so if we give it a char star

110
00:07:04,133 --> 00:07:06,266
然后传入name，值为pwn.college
give it the name pwn college

111
00:07:07,000 --> 00:07:10,600
在格式化字符串中加入%s换行符
we'll add a % s followed by a new line

112
00:07:14,700 --> 00:07:20,500
把name作为下一个参数传入
and we pass that in right there as the next argument

113
00:07:20,500 --> 00:07:25,000
我们将看到，1到7，换行，pwn.college
so we would expect to see 1 through 7 a new line followed by Pwn College

114
00:07:29,166 --> 00:07:30,999
这就是我们所看到的
and that is in fact what we see

115
00:07:31,933 --> 00:07:34,166
GDB中发生了什么
and what goes on in GDB

116
00:07:38,000 --> 00:07:41,400
设置断点在调用printf之前
set the break point right before printf is called

117
00:07:42,266 --> 00:07:43,899
运行它
we run it

118
00:07:44,966 --> 00:07:47,899
看一下栈
and let's take a look at what is on the stack

119
00:07:52,000 --> 00:07:53,900
这是一个字符串值
this is a string value 

120
00:07:53,900 --> 00:07:56,266
所以ASCII字符串本身不在这里
so the ASCII characters themselves aren't located here

121
00:07:56,566 --> 00:08:00,500
这是一个指向字符串的指针
this is a pointer to the string

122
00:08:00,600 --> 00:08:03,700
我们可以查看这个地址处的字符串
so we can examine the string that is at that address

123
00:08:03,700 --> 00:08:05,600
能看到pwn.college
and now we see Pwn College

124
00:08:06,500 --> 00:08:12,100
这引出了printf有意思的一点
and this kind of introduces one of the interesting things about printf is

125
00:08:12,400 --> 00:08:15,466
到目前为止，格式化字符串和参数都是对应的
so far I've specified everything correctly

126
00:08:15,566 --> 00:08:16,899
在一些情况下
in some of the you know

127
00:08:17,266 --> 00:08:18,733
下个视频我们将探讨
next videos we'll explore 

128
00:08:18,733 --> 00:08:21,633
如果传递的类型
what happens if the type that is passed 

129
00:08:21,733 --> 00:08:27,133
和在格式化字符串中指定的不匹配，会怎样
doesn't match the type that is specified in the format string

130
00:08:28,400 --> 00:08:30,966
令人惊讶的是，这并不罕见
it's surprisingly not that uncommon 

131
00:08:31,133 --> 00:08:35,699
传给printf的格式化字符串能被用户控制
for the user to have control of the format string that is then passed to printf 

132
00:08:35,700 --> 00:08:37,400
竟是一个常见的错误
it's a pretty common mistake

133
00:08:38,000 --> 00:08:41,900
特别是考虑到内存破坏的存在
especially when you consider scenarios where memory corruption may be at play

134
00:08:42,266 --> 00:08:44,466
通过利用这些格式字符串
and by abusing these format strings

135
00:08:44,633 --> 00:08:46,833
我们可以泄漏甚至控制内存
we can leak and even control memory

136
00:08:47,400 --> 00:08:52,300
这就是格式化字符串漏洞存在所需的全部条件
now this right here is all that it takes for a format string vulnerability to exist

137
00:08:52,533 --> 00:08:57,266
唯一的需求就是用户能控制传给printf的首个参数
the only requirement is that the user has control of that first argument to printf

138
00:08:57,400 --> 00:08:58,700
即，格式化字符串
 that format string

139
00:08:59,066 --> 00:09:00,533
能看到
now you'll note that

140
00:09:00,533 --> 00:09:04,133
这里的printf没有传入其它的参数
there are no additional values or arguments being passed to this printf

141
00:09:04,166 --> 00:09:06,399
这是因为printf实际上并不关心
and that's because printf actually doesn't care

142
00:09:06,766 --> 00:09:08,866
printf只是盲目地相信
printf just blindly trusts that 

143
00:09:08,866 --> 00:09:11,133
每一个%d，都有一个对应的整数
for every percent d there'll be an integer

144
00:09:11,133 --> 00:09:13,733
每个%s，都有一个对应的字符串
for every percent s there'll be a string

145
00:09:13,800 --> 00:09:16,766
如果我们不在c代码中指出
and if we don't specify it in the c

146
00:09:17,000 --> 00:09:21,400
printf就会查看寄存器或栈上的相关位置
printf is just going to go and check the register or check the location on the stack

147
00:09:21,900 --> 00:09:23,900
假设要的值就在这里
and just assume that the value is there 

148
00:09:24,100 --> 00:09:28,133
然后按照格式化字符串解读它
and interpret it as it was intended from the format string

149
00:09:28,466 --> 00:09:30,766
这就是漏洞所在
and that's where the vulnerability lies

150
00:09:31,500 --> 00:09:35,800
有趣的是，printf在循环中是图灵完备的
interestingly printf is turing complete when it's in a while loop

151
00:09:36,200 --> 00:09:37,866
hexhive的这个项目
this project here by hexhive

152
00:09:37,866 --> 00:09:39,766
是brainf**k的一个实现
is an implementation of brain f**k

153
00:09:39,766 --> 00:09:42,766
它基于运行在while循环中的printf
that runs on top of a printf while loop

154
00:09:43,000 --> 00:09:44,933
这绝对是件有趣的事
definitely an interesting thing if you have time

155
00:09:45,166 --> 00:09:46,066
有时间，去看看吧
go check it out

