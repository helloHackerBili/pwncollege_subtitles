1
00:00:00,400 --> 00:00:02,766
现在我们已经看了格式化字符串
so now that we've taken a look at format strings 

2
00:00:02,933 --> 00:00:07,166
以及它应该如何在函数如printf中使用
and how format strings are supposed to be used with functions such as printf

3
00:00:07,300 --> 00:00:11,300
我们来探索如何用它来泄露数据
let's start exploring how we can abuse format strings to leak data

4
00:00:11,333 --> 00:00:13,266
当然，这不是它最初的用途
that may not have originally been intended

5
00:00:14,733 --> 00:00:17,266
请记住，使用格式化字符串时
now keep in mind when we're using format strings

6
00:00:17,266 --> 00:00:21,466
我们能控制如何展示泄露数据
we have control over how the data being leaked is represented

7
00:00:21,600 --> 00:00:26,800
我们能用%c来作为单个字符展示
so we could use percent C to display data as a single character

8
00:00:27,200 --> 00:00:28,933
这样能泄露1字节
that would give us a single byte

9
00:00:28,966 --> 00:00:30,800
如果这就是我们要的，那很好
if that's all we need then that's great

10
00:00:31,133 --> 00:00:33,400
但是如果我们想泄漏的不止1字节
but if we wanted to leak more than a single byte

11
00:00:33,400 --> 00:00:35,966
我们可以用%d或%i
we could use percent d or percent i

12
00:00:36,133 --> 00:00:39,833
这会以十进制整数形式泄露4字节
and that would leak four bytes displayed as a decimal integer

13
00:00:40,066 --> 00:00:42,533
如果十六进制更容易处理的话
if hexadecimal was easier to work with

14
00:00:42,533 --> 00:00:44,133
我们就可以用%x
we could use percent x

15
00:00:44,166 --> 00:00:46,166
可以泄露同样的4字节
and we could leak those same 4 bytes

16
00:00:46,166 --> 00:00:49,000
但是会用十六进制来展示
but get it displayed in hexadecimal format

17
00:00:49,300 --> 00:00:54,000
%s，用于显示字符串
now percent s which is intended to be used to display a string

18
00:00:54,066 --> 00:00:55,666
特别强大
is particularly powerful

19
00:00:55,800 --> 00:00:57,133
因为它的作用是
because what it does is 

20
00:00:57,166 --> 00:01:00,966
解引用指针，并读出任意个字节
it dereferences a pointer and reads out an arbitrary number of bytes

21
00:01:00,966 --> 00:01:03,300
这些字节可能是可显，或不可显的
now these bytes may be printable or not printable

22
00:01:03,300 --> 00:01:04,966
都会被读出
but they will still be read out

23
00:01:05,200 --> 00:01:08,500
直到遇到null字节
and they will continue to be read out until a null byte is encountered

24
00:01:09,400 --> 00:01:14,100
格式化字符串也能用大小前缀，或叫大小修饰符
format strings also utilize size prefixes or size modifiers

25
00:01:14,466 --> 00:01:18,100
这里能看到，%x一般泄露4字节
here we see that percent x normally leaks out 4 bytes

26
00:01:18,100 --> 00:01:20,466
如果加上h前缀
however if you prefix it with h

27
00:01:20,466 --> 00:01:23,700
你会得到2字节的16进制数
you would get a hexadecimal representation of only 2 bytes

28
00:01:23,933 --> 00:01:28,300
hhx 则会泄露1字节的16进制数
hhx would leak 1 byte as a hexadecimal value

29
00:01:28,666 --> 00:01:31,000
如果想泄露更多
now if we wanted to leak a larger amount

30
00:01:31,266 --> 00:01:34,300
可以用%l，这是long的缩写
we can use percent l which is shorthand for long

31
00:01:34,366 --> 00:01:37,366
这样可以泄露8字节，也可用%lx
so we could leak 8 bytes or long hex

32
00:01:37,566 --> 00:01:38,466
我们来看一看
let's take a look

33
00:01:39,100 --> 00:01:40,633
为了探索这个问题
so in order to explore this 

34
00:01:40,900 --> 00:01:44,133
我们写一个有漏洞的c程序
let's write a vulnerable C program

35
00:01:45,000 --> 00:01:48,300
我们include <stdio.h>
we're going to include stdio.h

36
00:01:48,866 --> 00:01:51,066
因为我们想调用printf
cause we want to call printf

37
00:01:58,533 --> 00:02:01,966
我们给printf传入个格式化字符串
we're going to call printf on some format string

38
00:02:02,300 --> 00:02:04,666
然后返回
and then just return 0

39
00:02:05,500 --> 00:02:07,666
这个格式化字符串
now the format string

40
00:02:10,400 --> 00:02:13,600
就放在栈上
is just gonna be here on the stack

41
00:02:16,500 --> 00:02:24,800
把argv[1]拷贝到该格式化字符串
we will copy whatever is in argv[1] to that format string

42
00:02:26,000 --> 00:02:30,400
然后追加个换行符
and then we'll append a new line on there

43
00:02:31,400 --> 00:02:33,966
这样就不会看到垃圾数据了
so that we don't have the garbage

44
00:02:35,300 --> 00:02:42,000
给printf传入0xBEEF1337 （leet）
and let's pass this value of BEEF1337

45
00:02:43,200 --> 00:02:44,266
然后
and then

46
00:02:47,133 --> 00:02:50,200
我们在栈上放一个任意字符串
let's put an arbitrary string on the stack here

47
00:02:50,200 --> 00:02:53,800
我们声明一个 secret_value
so we'll have secret value

48
00:03:03,766 --> 00:03:06,366
然后让编译器满意
and then make the compiler happy 

49
00:03:06,466 --> 00:03:10,866
我们把需要的头文件都引入
we will include a couple more header files

50
00:03:17,000 --> 00:03:18,966
如果我们编译好这个
and if we compile this

51
00:03:21,800 --> 00:03:23,000
再给它
and we'll give it

52
00:03:28,266 --> 00:03:31,333
%d，会得到一个很小的负数
percent d. we get a giant negative number

53
00:03:31,533 --> 00:03:33,933
传入%c，会得到7
if we do percent C we just get 7

54
00:03:34,466 --> 00:03:35,900
这没问题
well this does make sense 

55
00:03:35,900 --> 00:03:38,266
最后一个字节不是7
like 7 isn't the end of this

56
00:03:38,500 --> 00:03:41,133
最后一个字节是37
and the last byte here is 37

57
00:03:41,300 --> 00:03:49,000
%c将最低有效字节，这里的37，作为一个字符解读
percent C interprets the least significant byte which in this case is 37 as a character 

58
00:03:49,166 --> 00:03:51,733
0x37就是字符7
and hex 37 is the character 7

59
00:03:51,733 --> 00:03:53,733
所以我们才会看到这个
which is why we see this here

60
00:03:54,300 --> 00:03:56,800
%d 显示一个很小的负数
now percent d shows us a giant negative number

61
00:03:56,866 --> 00:03:58,600
这看不出什么
which isn't particularly useful

62
00:03:58,966 --> 00:04:01,666
如果改用 ld
if we did a long decimal

63
00:04:01,666 --> 00:04:04,700
一下值就变正的了
well now all of a sudden the value is positive

64
00:04:06,100 --> 00:04:10,266
这是因为最高有效位是0
and that's because the most significant bit is not set

65
00:04:10,766 --> 00:04:12,966
所以它突然变成了正数
so it is suddenly a positive number

66
00:04:13,400 --> 00:04:18,266
通常会用的是%x
often times what you want to see is percent x

67
00:04:18,800 --> 00:04:21,600
我们已经习惯了十六进制格式
we're used to seeing things in hexadecimal format

68
00:04:21,933 --> 00:04:26,900
如果输出 leak: 0x%x
so if you were to do something like leak 0x percent x

69
00:04:27,100 --> 00:04:33,200
结果会很像我们在GDB或IDA中看到的
this is now very similar to the type of things that we'd see in GDB or in IDA

70
00:04:33,300 --> 00:04:34,966
特别是说到内存地址
 when we're talking about memory addresses

71
00:04:34,966 --> 00:04:37,166
或者内存地址的值
or we're talking about looking at values at the memory

72
00:04:37,900 --> 00:04:41,266
除了x，还可以用 lx
now instead of just x we could do lx

73
00:04:41,466 --> 00:04:47,566
这个例子中，因为值不够大，没更高字节了
now in this case because there are no higher bytes in this number

74
00:04:47,800 --> 00:04:49,266
所以结果不会变
the value doesn't change

75
00:04:50,600 --> 00:04:54,366
不止这些，现在只是正常查看这个值
but not only that because right now we're just looking at the intended value

76
00:04:54,600 --> 00:04:59,500
这里只放了一个格式记号
we just have one format specifier here

77
00:04:59,900 --> 00:05:03,300
有一个我喜欢用的，ppt没写的，%p
now one that I like to use that isn't in the slides is percent P

78
00:05:03,366 --> 00:05:05,166
这是指针的简写
which is shorthand for pointer

79
00:05:05,200 --> 00:05:06,900
如果我们用%p
and so if we do percent P 

80
00:05:06,966 --> 00:05:11,366
得到的还是0xbeef1337
we still get 0xbeef1337

81
00:05:12,200 --> 00:05:14,700
但它比lx少输入一个字符
but it's one less character than lx

82
00:05:15,600 --> 00:05:17,700
我们可以指定多个记号
we can specify multiple of these

83
00:05:19,966 --> 00:05:21,833
这就开始有趣了
and now it's kind of interesting 

84
00:05:22,033 --> 00:05:29,033
因为现在能看到原来printf中没有的值了
cause now we're starting to see values that are not in the original printf call

85
00:05:30,066 --> 00:05:32,500
因为我们能控制这个格式化字符串
because we control this format string

86
00:05:32,600 --> 00:05:34,600
如果我们一直写%p
if we just keep putting percent p

87
00:05:37,500 --> 00:05:40,900
printf会持续输出指针
printf will just keep producing pointers

88
00:05:40,933 --> 00:05:43,800
我不用知道它们指向的是什么
now I don't necessarily know what these are pointers to

89
00:05:45,366 --> 00:05:48,800
有beef1337，有1a
cause we have beef1337 we have 1a

90
00:05:49,066 --> 00:05:53,333
这泄露出 RDX的值是1a
now this 1a is a leak of what is in RDX

91
00:05:54,700 --> 00:05:59,100
所以我们获得了关于程序内部状态的信息
so we are gaining information about what is kind of the internal state of the program

92
00:05:59,333 --> 00:06:02,000
但如果我想拿到我的secret_value呢
but what if I want to get my secret value

93
00:06:02,000 --> 00:06:07,766
secret_value是一个局部变量
well my secret value is a local variable

94
00:06:08,066 --> 00:06:10,966
它在main里面，也就是说它在栈上
it's inside main which means it is on the stack

95
00:06:11,200 --> 00:06:13,966
如果我一直%p
so if I just keep doing percent p

96
00:06:15,133 --> 00:06:20,833
我应该能遇到一个像栈地址的值
I should come across something that looks like a stack address

97
00:06:20,900 --> 00:06:21,633
确实遇到了
and I do

98
00:06:22,266 --> 00:06:27,033
这个5560 看起来像一个栈指针
this 5560 this right here looks like a stack pointer

99
00:06:27,700 --> 00:06:29,866
这是倒数第三个
and that is third from the end here

100
00:06:30,133 --> 00:06:31,066
不对，倒数第二个
no second from the end

101
00:06:31,066 --> 00:06:33,366
它应该是这个值
so it should be this value right here

102
00:06:34,166 --> 00:06:36,166
如果我把p换成s
if I change that p to an s

103
00:06:36,166 --> 00:06:38,200
就会解引用这个指针
we're now going to dereference that address

104
00:06:38,200 --> 00:06:42,100
并打印出null前的所有字节
and print out all of the bytes until a terminating null byte is encountered

105
00:06:43,300 --> 00:06:49,000
一下，就从这个程序中泄露出了secret_value
and so suddenly we've leaked out my secret value from this binary

106
00:06:49,100 --> 00:06:54,300
尽管只给printf传了0xbeef1337
despite the fact that printf is only supplied with 0xbeef1337

107
00:06:57,866 --> 00:06:58,633
在这个例子中
so in that example 

108
00:06:58,766 --> 00:07:01,900
我们只是一直用%p，直到找到有趣的东西
we just spammed percent p until we found something interesting

109
00:07:01,900 --> 00:07:03,533
再从那里开始探索
and then kind of explored it from there

110
00:07:03,700 --> 00:07:06,900
要是我们准确知道感兴趣的是哪个参数呢
but what if we know exactly what parameter we're interested in

111
00:07:07,000 --> 00:07:12,300
我想把第32个参数按16进制字符打印出来
I want to print the 32nd parameter as a hex string

112
00:07:12,300 --> 00:07:16,300
我能做到吗，或者是否需要32个%p
can I do that or do I need to have 32 percent P's to get there

113
00:07:16,766 --> 00:07:19,766
你可以做的更简单
well you can do something a little bit more concise

114
00:07:20,100 --> 00:07:24,900
你可以在格式化字符串中用 $
and that is you can take advantage of the dollar sign operator inside your format string

115
00:07:25,300 --> 00:07:29,900
$ 能让我们指定感兴趣的参数
the dollar sign operator allows us to specify what parameter we're interested in

116
00:07:30,200 --> 00:07:34,766
在这张幻灯片中的 %7$x
so in the slide here we have percent 7$x

117
00:07:34,900 --> 00:07:39,900
这指的是，按16进制打印第7个参数
which specifies that we want to print the 7th parameter as a hexadecimal value

118
00:07:39,933 --> 00:07:42,600
我们知道第7个参数在栈上
now we know that the 7th parameter is on the stack

119
00:07:42,900 --> 00:07:47,700
所以就可以泄露想要的栈上的值了
so we can start leaking stack values that we target

120
00:07:47,700 --> 00:07:50,800
看看能不能用在这个例子上
so let's see if we can use that on the example that we have here

121
00:07:51,333 --> 00:07:55,066
我对这个字符串值很感兴趣
so I was interested in this string value

122
00:07:55,966 --> 00:07:59,866
我们数一下，这是第几个参数
so let's count and see how many arguments along was it

123
00:08:00,366 --> 00:08:04,766

1 2 3 4 5 6 7 8

124
00:08:05,366 --> 00:08:06,533
看起来是9
looks like nine

125
00:08:07,200 --> 00:08:09,600
我可以执行 a.out
so I can do a.out

126
00:08:11,066 --> 00:08:13,300
还是输出 leak:
we'll still have a leak

127
00:08:13,500 --> 00:08:17,800
%9$s
percent 9 $ s

128
00:08:20,166 --> 00:08:22,733
现在不会输出这些垃圾数据了
and now I don't have all of that garbage

129
00:08:22,900 --> 00:08:26,700
我能指定我感兴趣的参数
I was able to target the specific parameter that I was interested in

130
00:08:27,900 --> 00:08:34,100
我们能在下个视频中看到这是多么强大
and this is surprisingly powerful coz we'll see in the next video here

131
00:08:35,200 --> 00:08:37,533
我刚刚讲的例子
now the example that I just ran through 

132
00:08:37,633 --> 00:08:41,800
漏洞很严重，因为用户能完全控制格式化字符串
is somewhat trivial in the sense that the user has full control of the format string

133
00:08:41,900 --> 00:08:43,766
并能设置成他们想要的任意值
and can set it to whatever they desire

134
00:08:44,000 --> 00:08:46,700
这种情况市面上确实有
however that does happen sometimes in the wild

135
00:08:47,266 --> 00:08:50,800
还有些没这么严重的格式化字符串漏洞
there are less trivial format string vulnerabilities

136
00:08:51,200 --> 00:08:55,100
比如动态生成的格式化字符串
some examples would be like a dynamically generated format string

137
00:08:55,300 --> 00:08:58,500
用户不能直接提供格式化字符串
where the user may not provide the format string literally

138
00:08:58,666 --> 00:09:00,600
而是基于他们的行为
but based on actions they take

139
00:09:00,600 --> 00:09:05,300
构造一个特定的恶意格式化字符串
they can help construct a specific format string that is malformed

140
00:09:05,400 --> 00:09:11,100
可能导致printf错误解析数据
this may cause printf to be called that will interpret data incorrectly

141
00:09:11,100 --> 00:09:14,900
比如，用%s解析一个指针
for example calling percent s on a pointer that is in a string

142
00:09:14,966 --> 00:09:17,400
这会泄露大量的数据
that's going to leak a large amount of data

143
00:09:18,100 --> 00:09:22,100
还有其它printf之外的函数
now there are also other functions that are not printf 

144
00:09:22,300 --> 00:09:26,200
例如sprintf，它用格式化字符串来构建字符串
such as sprintf which uses a format string to build a string

145
00:09:26,400 --> 00:09:29,966
或snprintf，它限制了长度，但做的事一样
or snprintf which limits the length but does the same thing

146
00:09:30,533 --> 00:09:33,733
还有被用于输入的格式化字符串
we also see format strings being used to take an input

147
00:09:33,733 --> 00:09:37,000
例如sscanf或scanf
such as sscanf or scanf

148
00:09:37,200 --> 00:09:40,900
最后，还有用于日志的
and lastly we have format strings being used for logging

149
00:09:40,900 --> 00:09:43,666
比如常见的fprintf
this is somewhat common where you see fprintf

150
00:09:43,800 --> 00:09:47,200
这个会根据格式化字符串构建字符串
which is going to construct a string from a format string

151
00:09:47,200 --> 00:09:48,933
然后写到文件中
and then write it out to a file

152
00:09:49,300 --> 00:09:54,100
这些依赖格式化字符串的函数都是潜在的可利用对象
any one of these functions that rely on format strings are potentially exploitable

153
00:09:54,300 --> 00:09:56,733
接下来我们应牢记这一点
and so we should keep that in mind going forward

