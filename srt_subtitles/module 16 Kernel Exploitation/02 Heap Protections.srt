1
00:00:00,866 --> 00:00:03,599
现在我们对内核堆的工作原理有了一些了解
now that we have some idea of how the kernel heap works

2
00:00:03,600 --> 00:00:05,766
我们来看一些
let's take a look at some of the

3
00:00:05,766 --> 00:00:07,699
内核堆保护机制
kernel heap Protection mechanisms

4
00:00:07,700 --> 00:00:09,766
它们可以编译到内核中
that can be compiled into the kernel

5
00:00:09,866 --> 00:00:13,133
使攻击者更难以利用内核漏洞
to make it more difficult for an attacker to exploit it

6
00:00:13,866 --> 00:00:16,733
第一个值得一提的保护机制
now the first mitigation that is worth mentioning 

7
00:00:16,766 --> 00:00:19,199
就是所谓的空闲链表随机化
is something that's called freelist randomization

8
00:00:19,666 --> 00:00:20,799
默认情况下
by default 

9
00:00:21,166 --> 00:00:23,199
当创建一个新的slab时
when a fresh slab is created

10
00:00:23,200 --> 00:00:26,700
空闲列表默认是有序的
the free list will default to being in order

11
00:00:26,700 --> 00:00:28,533
我说的“有序”是什么意思呢
what I mean when I say in order 

12
00:00:28,700 --> 00:00:30,666
对于一个新的slab
is for a fresh slab

13
00:00:30,800 --> 00:00:38,000
第一个被分配出去的slot
the first slot that will be used to satisfy an allocation

14
00:00:38,466 --> 00:00:41,899
会是slab上的第一个slot
will be the first slot on the slab

15
00:00:42,100 --> 00:00:48,700
第二次调用kmalloc或kmem_cache_alloc时
then with a for instance kmalloc or kmem_cache_alloc were called a second time

16
00:00:49,333 --> 00:00:52,766
总之第二次从这个slab中分配内存时
that drew from this slab

17
00:00:53,266 --> 00:00:56,266
将把第二个slot分配出去
the second allocation would come from the second slot

18
00:00:56,300 --> 00:00:58,666
第三次分配会分配出去第三个slot
the third allocation would come from the third slot

19
00:00:58,800 --> 00:01:00,300
这是有序的
this would be in order

20
00:01:00,400 --> 00:01:05,466
默认情况下新的slab的分配是有序的
the kind of default freelist is in order for a brand new slab

21
00:01:06,533 --> 00:01:09,566
这对攻击者是有利的
now this is beneficial to an attacker 

22
00:01:09,566 --> 00:01:12,099
因为攻击者很容易得知
because an attacker can easily know

23
00:01:13,333 --> 00:01:17,099
内存中已分配对象之间的位置关系
where in memory allocated objects relate to each other

24
00:01:17,166 --> 00:01:18,199
一般说来
in generally speaking 

25
00:01:18,333 --> 00:01:24,266
攻击者的目标是在内存中获得两个相邻的对象
an attacker's goal is to get two objects right next to each other in memory

26
00:01:24,266 --> 00:01:27,799
或者在内存中有预谋地放置对象
or to strategically place objects in memory

27
00:01:28,133 --> 00:01:30,099
比如有一些属性
such that there is some property

28
00:01:30,100 --> 00:01:33,066
但攻击者进攻的关键
but the kind of key for the attacker 

29
00:01:33,066 --> 00:01:37,099
就是知道这些已分配对象在内存中的位置
is to know where these objects are being allocated in memory

30
00:01:37,133 --> 00:01:42,866
然后利用这些位置之间的关系
to then take advantage of the relationship between those locations

31
00:01:43,933 --> 00:01:46,066
把这些对象按顺序排列
so by having this in order

32
00:01:46,066 --> 00:01:48,066
攻击者就很容易知道
it's easy for an attacker to know

33
00:01:48,100 --> 00:01:52,333
新slab上分配对象之间的关系
the relationship between allocations on a fresh slab

34
00:01:52,700 --> 00:01:54,166
freelist随机化
so freelist randomization

35
00:01:54,166 --> 00:01:56,566
就像名字说的
does exactly kind of what the name implies

36
00:01:56,666 --> 00:02:00,566
freelist随机化配置选项
the freelist randomization configuration option

37
00:02:01,466 --> 00:02:03,166
会随机化freelist
randomizes the freelist

38
00:02:03,166 --> 00:02:04,899
有什么效果呢
so what is the impact here

39
00:02:05,900 --> 00:02:07,366
对于一个新的slab
for a fresh slab

40
00:02:07,366 --> 00:02:10,966
你无法得知哪个slot会被返回
you have no guarantees about which slot will be returned

41
00:02:10,966 --> 00:02:14,333
以满足那些最先从这个slab分配内存的请求
for those initial allocations that are drawing from the slab

42
00:02:14,333 --> 00:02:17,133
因此，第一次可能分配出去了slot 0
so the first allocation may draw from slot 0

43
00:02:17,300 --> 00:02:21,066
第二次可能分配出去了slot 14
but then the second allocation may draw from slot 14

44
00:02:21,200 --> 00:02:22,600
就是我们这里看到的
which is what we see here

45
00:02:22,800 --> 00:02:25,700
第三次针对这个slab的请求
the third allocation against this slab

46
00:02:25,866 --> 00:02:29,566
可能分配出去slot 16
maybe that draws from slot 16

47
00:02:29,566 --> 00:02:36,533
针对一个新的slab的初始分配顺序是随机的
the order of the initial allocations against a fresh slab is randomized

48
00:02:36,600 --> 00:02:39,400
这种随机化的实现方式
now the way that this randomization is done

49
00:02:39,666 --> 00:02:42,333
是在最开始针对该cache
is for the cache initially

50
00:02:42,466 --> 00:02:46,166
生成一个随机化的索引列表random_seq
a random_seq of indexes is generated

51
00:02:46,166 --> 00:02:48,499
这些索引都是整数
these indexes are integers

52
00:02:49,466 --> 00:02:56,033
它们存储在kmem_cache.random_seq
and they are stored in the kmem_cache.random_seq location 

53
00:02:56,066 --> 00:02:59,699
作为kmem_cache的一个链表成员
so it's stored as a member of the kmem_cache as a linked list

54
00:02:59,700 --> 00:03:01,966
这就是这个链表
and so there's this linked list

55
00:03:02,900 --> 00:03:10,533
它表示默认freelist的顺序
that represents the order of the default freelist order

56
00:03:12,400 --> 00:03:17,966
但是回想一下，空闲链表本质上是一个单链表
but recall that the free list is essentially a singly linked list

57
00:03:18,500 --> 00:03:23,333
这个单链表添加空闲对象时，用的头插法
and freed objects of a singly linked list are pushed to the head of the list

58
00:03:23,700 --> 00:03:27,366
在创建slab时顺序会随机化一次
now the order may be randomized once at slab creation

59
00:03:27,533 --> 00:03:29,299
在slab第一次出现的时候是随机化的
when the slab is first brought in

60
00:03:29,566 --> 00:03:33,966
但如果攻击者有能力分配许多对象
but if an attacker has the ability to allocate many objects

61
00:03:35,000 --> 00:03:39,466
比如攻击者可以分配完整个slab
then the attacker can allocate the entire slab let's say

62
00:03:39,766 --> 00:03:44,533
之后攻击者可以按照自己想要的顺序释放它们
and then the attacker could free them in whatever order the attacker desires

63
00:03:44,966 --> 00:03:49,866
这意味着攻击者可以决定空闲列表的顺序
and that means that the attacker can determine the order of the free list 

64
00:03:49,966 --> 00:03:53,799
或者说攻击者可以设置空闲列表的顺序
or the attacker can set the order of the free list 

65
00:03:53,933 --> 00:04:00,466
根据攻击者释放分配对象的顺序，来决定它的顺序
based upon the order that the attacker frees the objects that were allocated previously

66
00:04:00,700 --> 00:04:04,266
这对攻击者来说仍然是一个挑战
now this still presents a challenge to the attacker

67
00:04:04,600 --> 00:04:08,133
因为攻击者可能能分配所有这些对象
because the attacker may be able to allocate all of these objects

68
00:04:08,133 --> 00:04:12,599
但是攻击者不知道
but the attacker doesn't know by default

69
00:04:13,666 --> 00:04:15,666
默认情况这些对象是如何相互关联的
how these objects relate to each other

70
00:04:15,733 --> 00:04:18,933
这就给攻击者带来了额外的挑战
and so this creates an additional challenge for the attacker

71
00:04:18,933 --> 00:04:20,199
因为攻击者
because the attacker

72
00:04:20,333 --> 00:04:25,333
必须使用其他类型的漏洞
must use some other type of vulnerability

73
00:04:26,300 --> 00:04:31,766
来弄清楚这些内核对象是如何相互关联的
to figure out how these kernel objects relate to each other

74
00:04:32,133 --> 00:04:36,299
因为在典型的漏洞利用场景中
because in a typical exploitation scenario here

75
00:04:36,333 --> 00:04:38,266
攻击者不在内核中
the attacker isn't in the kernel 

76
00:04:38,266 --> 00:04:43,733
所以攻击者不能获取这些原始指针
so the attacker isn't the one that is getting these raw pointers

77
00:04:43,733 --> 00:04:49,033
攻击者不是获取这些内核对象的人
the attacker isn't the one that is obtaining these kernel objects 

78
00:04:49,166 --> 00:04:56,866
相反，攻击者只是促使内核分配这些内核对象
instead the attacker is encouraging the kernel to allocate these kernel objects

79
00:04:56,866 --> 00:04:59,899
攻击者通常在用户空间的某个地方
the attacker is typically somewhere in userland

80
00:04:59,900 --> 00:05:00,800
他们使用
and they are using 

81
00:05:00,833 --> 00:05:02,399
例如syscall
for instance syscalls 

82
00:05:02,400 --> 00:05:05,300
或通过ioctl使用内核设备
or they're calling ioctl on a kernel device

83
00:05:05,400 --> 00:05:10,333
内核设备触发内核内的内存申请
and that is triggering the allocations inside of the kernel

84
00:05:10,900 --> 00:05:13,166
这样攻击者就看不到
and so the attacker doesn't get to see

85
00:05:13,600 --> 00:05:16,366
对象的原始内存地址
the raw memory addresses of the object

86
00:05:16,466 --> 00:05:20,299
攻击者只知道他们确实创建了一个对象
the attacker just knows that they did create an object

87
00:05:20,933 --> 00:05:25,299
基于他们触发了内核内的哪种东西
based upon what they have triggered inside of the kernel to occur

88
00:05:26,000 --> 00:05:27,966
那么攻击者怎么弄清楚
so how does an attacker figure out

89
00:05:28,000 --> 00:05:30,366
这些内存分配之间的关系
how these allocations relate to each other

90
00:05:30,766 --> 00:05:32,566
攻击者可以
well the attacker can

91
00:05:32,600 --> 00:05:35,866
依靠我们在前面堆内容中看到的策略
rely on a strategy that we've seen in earlier heap content

92
00:05:35,933 --> 00:05:41,166
例如，攻击者可以依靠UAF
an attacker can rely on for instance a use after free bug

93
00:05:41,300 --> 00:05:44,966
如果攻击者有指向空闲slot的指针
if the attacker has a pointer into a freed slot

94
00:05:45,000 --> 00:05:50,133
这个slot不是空闲列表的最后一个slot
and that slot is not the last slot of the free list

95
00:05:50,533 --> 00:05:53,866
那么这个slot将包含一个next指针
then that slot is going to contain a next pointer

96
00:05:54,533 --> 00:05:56,966
所以在UAF的情况下
so in a use after free scenario

97
00:05:57,133 --> 00:06:00,199
攻击者可以构建这里展示的利用原语
the attacker can build a primitive as shown here

98
00:06:00,566 --> 00:06:03,699
攻击者有一个指针，例如指向slot0
where the attacker has a pointer to for instance slot 0

99
00:06:03,700 --> 00:06:07,100
slot0里有一个next指针
which slot 0 contains a next pointer 

100
00:06:07,100 --> 00:06:10,500
它记录了slot1的地址（用UAF获得了slot1的地址）
that identifies the address of slot 1

101
00:06:11,333 --> 00:06:14,333
然后攻击者可以malloc两次
the attacker could then malloc twice 

102
00:06:14,600 --> 00:06:17,566
然后释放slot2
and then for instance free slot 2

103
00:06:17,900 --> 00:06:20,166
然后释放slot0
then free slot zero

104
00:06:21,100 --> 00:06:22,733
然后用相同的原语
then use this same primitive

105
00:06:22,800 --> 00:06:26,400
读取slot2的地址
to read the address of slot 2

106
00:06:26,533 --> 00:06:27,533
此时
at which point

107
00:06:27,866 --> 00:06:32,333
攻击者知道了这两个分配之间的关系
now the attacker knows the relationship between those two allocations

108
00:06:32,333 --> 00:06:36,133
因为他们可以比较泄露的这两个地址的距离
because they can compare the distance between the two pointers that were read

109
00:06:37,600 --> 00:06:41,333
因此，UAF对攻击者来说是很好的
so a use after free scenario would be great for an attacker

110
00:06:41,333 --> 00:06:43,699
但内核还有另一种保护机制
but the kernel has another mitigation strategy 

111
00:06:43,800 --> 00:06:47,266
这使得这种情况更加困难
that makes this scenario more difficult

112
00:06:47,533 --> 00:06:49,933
这就是所谓的freelist加固
and that is something that's called freelist hardening

113
00:06:50,400 --> 00:06:52,900
在我描述前面的情况时
when I describe the scenario here above

114
00:06:52,900 --> 00:06:56,300
用UAF泄漏next指针
with the use after free and kind of leaking next pointers

115
00:06:56,400 --> 00:06:58,633
希望这能让你们回想起
hopefully this reminded you a little bit about 

116
00:06:58,700 --> 00:07:02,166
tcache的链表是如何工作的
how tcache's linked list works

117
00:07:02,933 --> 00:07:06,766
因为这仍然是一个依赖于next指针的单链表
because it is still a singly linked list that relies on next pointers

118
00:07:06,766 --> 00:07:10,066
tcache是如何保护next指针的
and how did tcache protect next pointers

119
00:07:10,066 --> 00:07:12,899
他使用了一种叫safe linking的东西
tcache used something that was called safe linking

120
00:07:13,133 --> 00:07:17,399
用一个特定的值与next异或，来模糊它
where they xor specific values with the pointer to obscure it

121
00:07:17,566 --> 00:07:19,533
这样如果next指针
so that way if the next pointer

122
00:07:19,566 --> 00:07:22,933
被攻击者看到
happened to be visible or leaked to an attacker

123
00:07:23,533 --> 00:07:27,866
泄露的值不会提供任何有用的信息
the initial value that's leaked doesn't provide any useful information

124
00:07:28,300 --> 00:07:35,100
freelist加固的工作原理与tcache的safe linking非常相似
well freelist hardening works very similar to safelinking on the tcache side

125
00:07:35,700 --> 00:07:40,133
思路是用一些值和next指针异或
the logic is we're going to xor some values with the pointer

126
00:07:40,366 --> 00:07:41,633
这应该会模糊它
and this should obscure it 

127
00:07:41,666 --> 00:07:44,999
使它在功能上对攻击者无用
to make it functionally useless to the attacker

128
00:07:45,733 --> 00:07:52,699
safe linking在异或时有一个有趣的机制
now safe linking had kind of an interesting mechanism as far as how the xoring was done

129
00:07:52,733 --> 00:07:57,333
与next异或的值是next的地址右移12位
it was the pointer with the address of the pointer bit shifted 

130
00:07:57,433 --> 00:08:01,199
我们在tcache模块中肯定见过这个
and we definitely took a look at that in the tcache module

131
00:08:03,300 --> 00:08:07,566
freelist加固的工作方式略有不同
the freelist hardening works slightly differently as far as

132
00:08:07,566 --> 00:08:11,399
究竟是怎么模糊next的
what is exactly occurring to obscure the pointer

133
00:08:12,333 --> 00:08:14,699
不再做位左移了
instead of doing some bit shifting

134
00:08:15,600 --> 00:08:18,166
会有3个值异或
there are three values that are being xored

135
00:08:18,200 --> 00:08:19,966
next自己
there's the pointer itself

136
00:08:20,866 --> 00:08:22,733
next的地址
there's the address of the pointer

137
00:08:22,933 --> 00:08:26,366
还有一个随机的cache相关值
and then there is a random cache specific value

138
00:08:26,700 --> 00:08:28,700
它来引入随机性
which is just referred to as random

139
00:08:28,766 --> 00:08:32,033
我们在代码片段中看到
and we see here in the code snippet 

140
00:08:32,133 --> 00:08:37,766
这个随机值在kmem_cache中
that random is attached to the kmem_cache

141
00:08:38,066 --> 00:08:42,666
所以这个随机值是kmem_cache的成员
so there's this random value that is a member of the kmem_cache

142
00:08:42,766 --> 00:08:44,133
这个随机值
and that random value 

143
00:08:44,166 --> 00:08:46,166
会和next指针异或
is xored with the pointer 

144
00:08:46,266 --> 00:08:49,366
以及next指针的地址异或
as well as the address of the pointer

145
00:08:50,666 --> 00:08:52,366
这样就能模糊next指针
and so that this would obscure it

146
00:08:53,733 --> 00:08:58,533
所以现在攻击者不能用这个原语了
so now the attacker can't work just off of this primitive

147
00:08:58,533 --> 00:08:59,399
或者他们能
or can they

148
00:09:00,133 --> 00:09:03,266
我们来思考一下这里发生了什么
well let's think a little bit about what's going on here

149
00:09:03,500 --> 00:09:05,066
情况是这样的
so here's our scenario

150
00:09:05,500 --> 00:09:10,800
攻击者有和之前相同UAF
and the attacker has that same use after free primitive

151
00:09:11,366 --> 00:09:13,133
攻击者能泄露什么呢
well what can the attacker leak

152
00:09:13,200 --> 00:09:14,800
在这个情况下
well in this scenario

153
00:09:14,966 --> 00:09:17,966
攻击者可以泄漏编码后的值
the attacker can leak the encoded value 

154
00:09:18,033 --> 00:09:19,566
就是我们在这里看到的
which is what we saw right here

155
00:09:19,566 --> 00:09:21,499
编码后的值就是
the encoded value is the pointer

156
00:09:21,600 --> 00:09:23,400
指针异或上指针地址
xored with the pointer's address

157
00:09:23,700 --> 00:09:25,766
再异或上一个随机值
xored with the random value

158
00:09:26,166 --> 00:09:28,099
在这种情况下
and so in this scenario

159
00:09:28,300 --> 00:09:29,966
就是之前的情况
which is where we were earlier 

160
00:09:30,033 --> 00:09:36,333
攻击者可以读取指针与指针地址和随机值的异或结果
the attacker can read address of pointer xored with pointer xored with random

161
00:09:36,400 --> 00:09:38,400
不是特别有用
not particularly useful

162
00:09:39,200 --> 00:09:43,266
但是攻击者可以识别出
but what an attacker can recognize

163
00:09:44,133 --> 00:09:46,399
如果有UAF
they can if they have a use after free

164
00:09:46,400 --> 00:09:48,866
并且他们有能力影响
and they have the ability to influence

165
00:09:49,100 --> 00:09:52,133
空闲列表的状态
the kind of state of the free list

166
00:09:52,333 --> 00:09:54,566
他们就可以创造这样的场景
they can create this scenario

167
00:09:55,566 --> 00:10:02,166
如果UAF指针的next为null
what happens if the use after free's next pointer is null

168
00:10:03,500 --> 00:10:06,333
这和我们最初的情况非常相似
it's very similar to what we had initially

169
00:10:07,566 --> 00:10:12,333
如果我们创建一个next为null的场景
if we were to create the scenario where there is no pointer value

170
00:10:12,900 --> 00:10:18,000
那么攻击者可以读出，指针地址异或上随机值的结果
then the attacker can read the address of the pointer xored with the random value

171
00:10:19,366 --> 00:10:24,066
这两个单独拿出来都没有用
now neither of these are useful really on their own 

172
00:10:24,066 --> 00:10:25,866
这么说并不完全正确
well that's not entirely true

173
00:10:27,166 --> 00:10:37,066
它两单独拿出来都没法帮攻击者弄清slot地址
but they don't help the attacker know the location of any of the slots on their own

174
00:10:38,666 --> 00:10:39,766
但放在一起
but together

175
00:10:40,600 --> 00:10:42,366
这两个值
these two values

176
00:10:44,133 --> 00:10:47,466
能让攻击者泄露next指针
allow the attacker to reveal that pointer

177
00:10:47,933 --> 00:10:49,899
首先得到的是
so the first thing that they can obtain is 

178
00:10:49,966 --> 00:10:52,366
这个场景中被模糊的next指针
this obscured pointer from this scenario here

179
00:10:53,066 --> 00:10:55,699
第二个可以得到的是
the second thing that the attacker could obtain

180
00:10:55,700 --> 00:10:58,000
我们让next指针为null的结果
is what if we made the pointer null right

181
00:10:58,000 --> 00:10:59,500
我们这样设置
we set it up such that

182
00:10:59,800 --> 00:11:05,666
UAF指向的slot是空闲列表中最后的一个
the use after free is the last item in the free list 

183
00:11:05,733 --> 00:11:08,599
在这种情况下，它的next指针为空
in which case its next pointer is null

184
00:11:09,533 --> 00:11:11,499
那么攻击者就可以得到它
well then the attacker can obtain that

185
00:11:11,500 --> 00:11:14,000
指针地址异或上随机值的结果
address of the pointer xored with the random value

186
00:11:14,400 --> 00:11:16,733
如果攻击者可以获得这两个
if the attacker can obtain both of these

187
00:11:16,733 --> 00:11:19,166
那攻击者就能将它们异或
then the attacker could xor them together

188
00:11:19,300 --> 00:11:22,800
此时攻击者就得到了next指针
at which point the attacker has revealed the pointer

189
00:11:23,700 --> 00:11:25,500
这就足够了
and so that is sufficient 

190
00:11:25,500 --> 00:11:29,000
不仅仅是能解码一个模糊后的值
not only to decode an obscured value

191
00:11:29,233 --> 00:11:31,466
就像我们刚刚展示的
which is what we've just shown right here

192
00:11:32,133 --> 00:11:34,799
同时这里第二个值
but this second value right here 

193
00:11:34,966 --> 00:11:38,766
指针地址 ^ nulll ^ 随机值
the address of pointer xored with null xored with random

194
00:11:39,100 --> 00:11:43,333
足以用它去编码一个next指针
is sufficient to encode a pointer

195
00:11:45,933 --> 00:11:48,933
这就是攻击者需要的一切
and so this is everything an attacker needs

196
00:11:50,066 --> 00:11:52,366
就可以影响空闲列表
to influence the free list 

197
00:11:52,633 --> 00:12:00,166
既可以解码出空闲列表中slot的位置
to either reveal the location of slots that are on the freelist 

198
00:12:00,433 --> 00:12:04,166
也可以更改空闲列表中slot的next指针
or overwrite pointers on the freelist

199
00:12:04,333 --> 00:12:12,266
控制从该cache返回的内存地址
to redirect what values will be returned from requesting an allocation from this cache

200
00:12:15,133 --> 00:12:18,299
攻击者可能利用的另一个场景
another scenario that attacker may take advantage of

201
00:12:18,400 --> 00:12:20,700
是越界访问场景
is an out of bounds access scenario

202
00:12:20,733 --> 00:12:23,466
我们看一下我们设置了什么
so let's take a look at what we have set up here

203
00:12:23,766 --> 00:12:26,733
如果slab的构造是这样的
well what if the slab is configured such that

204
00:12:26,733 --> 00:12:29,333
有一个被分配的有效对象
there is a valid object that is allocated

205
00:12:29,400 --> 00:12:33,166
有一个合法的指针指向这个对象
and there's a valid pointer to this object because it was allocated

206
00:12:33,600 --> 00:12:36,166
紧接着这个合法对象
now immediately after the valid object

207
00:12:36,166 --> 00:12:38,399
正好有一个空闲slot
there happens to be a free slot

208
00:12:38,400 --> 00:12:42,000
当这个空闲slot恰好有一个next指针时
when this free slot happens to contain a next pointer

209
00:12:42,266 --> 00:12:44,266
这个next指针可能有被编码
now this next pointer could be encoded

210
00:12:44,266 --> 00:12:46,166
此时攻击者必须
at which point the attacker has to

211
00:12:46,800 --> 00:12:49,333
进行前面描述的步骤
involve the steps that were described earlier 

212
00:12:49,433 --> 00:12:53,199
但我们先假定它没被编码
but right now let's imagine that it's not encoded

213
00:12:54,800 --> 00:12:57,466
数据传输的典型方式
well the way that data is typically transferred

214
00:12:57,800 --> 00:13:00,933
从用户空间到内核，或从内核到用户空间
from userland to the kernel or from kernel to userland

215
00:13:01,100 --> 00:13:04,966
通过函数copy_to_user或copy_from_user
is via the functions copy_to_user or copy_from_user

216
00:13:05,166 --> 00:13:09,666
那么，如果这个对象会
so what if this object is supposed to be in normal functionality

217
00:13:09,966 --> 00:13:14,533
复制到用户空间，或从用户空间复制到内核
copied to userland or copied from userland to the kernel

218
00:13:15,400 --> 00:13:19,666
如果攻击者不操纵指针
well if the attacker instead of manipulating the pointers that are involved

219
00:13:19,733 --> 00:13:23,533
而是以某种方式控制拷贝的字节数
somehow gains control of the number of bytes to copy

220
00:13:23,933 --> 00:13:27,066
那攻击者可以访问或影响
then the attacker can access or influence

221
00:13:27,166 --> 00:13:31,599
该内核对象以外的数据
bytes that are outside of the kernel object that was allocated

222
00:13:32,066 --> 00:13:40,666
那当攻击者能复制超出预计长度的数据到用户空间
so in the event the attacker can copy to the user more than the intended number of bytes

223
00:13:40,700 --> 00:13:41,566
会发生什么?
what would happen

224
00:13:42,066 --> 00:13:45,699
如果正常可以复制整个对象
well the attacker would be able to copy this entire object

225
00:13:46,000 --> 00:13:49,266
然后假设攻击者设法把长度翻倍了
and then let's say that they somehow manage to double it

226
00:13:49,300 --> 00:13:52,800
那他会泄露出整个对象，外加
well they would leak this entire object plus

227
00:13:53,466 --> 00:13:58,766
内存中下一个对象的所有字节
all of the bytes of the object that is next in memory here

228
00:13:59,600 --> 00:14:01,500
在内存中相邻的
that follows it in memory

229
00:14:01,566 --> 00:14:02,333
按这个例子
in this case

230
00:14:02,466 --> 00:14:05,566
我们会泄漏位于slot1中的对象
we would be leaking the object that is located in slot 1 

231
00:14:05,666 --> 00:14:10,466
以及空闲slot2的所有数据
as well as all of the bytes of the freed slot 2

232
00:14:10,566 --> 00:14:13,699
在这个例子中，它包含一个next指针
and in this case that contains a next pointer

233
00:14:13,700 --> 00:14:17,100
现在攻击者获得了一些
and so now the attacker has gained some information

234
00:14:17,766 --> 00:14:23,933
关于这个slab中正在使用的地址的信息
about the addresses that are being used in this slab

235
00:14:24,066 --> 00:14:26,499
如果攻击者可以做相反的事情呢
now what if the attacker can do the reverse

236
00:14:26,500 --> 00:14:30,533
攻击者可以从用户空间复制到内核
and the attacker can copy from userland to the kernel

237
00:14:31,166 --> 00:14:32,633
这种情况
so this would be a scenario 

238
00:14:32,633 --> 00:14:39,399
内核对象会装一些用户空间数据
where the kernel object is intended to contain some userland data

239
00:14:41,300 --> 00:14:43,566
我们再假设攻击者
and again let's pretend that the attacker

240
00:14:43,566 --> 00:14:46,933
设法将拷贝的长度翻了一倍
somehow manages to double the size of that copy

241
00:14:46,933 --> 00:14:49,733
那么攻击者就可以写入整个对象
well then the attacker can write this entire object

242
00:14:49,933 --> 00:14:53,266
外加后面这个空闲slot
plus all of the bytes of the freed slot after

243
00:14:53,400 --> 00:14:54,666
这样的话
and if that is the case 

244
00:14:54,733 --> 00:14:58,233
攻击者可以覆盖next指针
then the attacker can overwrite this next pointer

245
00:14:58,233 --> 00:15:00,099
这会影响
which would then influence

246
00:15:00,300 --> 00:15:06,066
以后这个slab返回的内存地址
what pointers would be returned from future allocations against this slab

247
00:15:06,266 --> 00:15:09,399
这是一个一般的越界访问场景
so this is a general out of bounds access scenario

248
00:15:09,566 --> 00:15:13,566
我们描述了越界读和越界写
we described both in out of bounds read as well as an out of bounds write

249
00:15:15,266 --> 00:15:20,666
对于那些要用对象
for those objects that are intended to be used

250
00:15:21,066 --> 00:15:24,966
在用户空间和内核之间拷贝数据的
for copying data between userland and the kernel

251
00:15:25,600 --> 00:15:29,200
可以配置一种保护机制
there's an additional mitigation that can be configured

252
00:15:29,600 --> 00:15:31,733
称为用户拷贝加固
called Hardened Usercopy

253
00:15:32,633 --> 00:15:35,333
这些有问题的拷贝进或出内核
so these mistaken copying back and forth from the kernel 

254
00:15:35,433 --> 00:15:38,966
能导致这些越界访问或信息泄露
can result in these out of bound accesses or information being leaked

255
00:15:39,066 --> 00:15:40,366
这不是想要的
that wasn't intended

256
00:15:41,333 --> 00:15:44,133
这个保护机制使得
what this mitigation enables

257
00:15:45,366 --> 00:15:50,299
cache中增加了2个成员
is the cache now has an additional two members

258
00:15:50,333 --> 00:15:53,099
一个 offset变量
it has an offset member

259
00:15:53,233 --> 00:15:55,499
和一个 size变量
and it has a size value

260
00:15:55,900 --> 00:16:00,600
这两个值代表了
and these two values represent the region of memory

261
00:16:00,866 --> 00:16:03,533
在这片内存中
that is allowed to be copied

262
00:16:03,733 --> 00:16:08,066
允许在用户空间和内核之间拷贝的范围
and transferred back and forth from user land to the kernel

263
00:16:08,400 --> 00:16:11,500
所以这些值可以用来校验
so these values can be used to verify

264
00:16:12,133 --> 00:16:16,799
进出内核的数据
that the bytes that are being transferred to and from the kernel 

265
00:16:16,800 --> 00:16:20,100
是否在预计范围内
are within the intended range

266
00:16:20,533 --> 00:16:23,166
我们可以看看它是什么样子的
we can take a look at what that looks like

267
00:16:23,166 --> 00:16:24,666
所以在前面这里
so up above here 

268
00:16:24,733 --> 00:16:28,899
有这个内核对象
we had this kernel object

269
00:16:29,266 --> 00:16:30,133
我们说
and we said well

270
00:16:30,133 --> 00:16:31,899
它们可以复制整个内核对象
they could copy this entire kernel object

271
00:16:31,966 --> 00:16:36,233
如果不能从开头拷贝数据
well what if instead of starting the copy at the beginning 

272
00:16:36,233 --> 00:16:39,566
该内核对象的正常使用方法
the intended use of this kernel object

273
00:16:39,766 --> 00:16:44,866
是只能拷贝整个内核对象的一小部分
was to just copy a small sub section of the entire kernel object

274
00:16:45,533 --> 00:16:51,166
我们可以用offset和size来定义它
well we can define that with these offset and size values

275
00:16:52,466 --> 00:16:54,599
如果这里是对象的起点
where if this is the start of the object

276
00:16:54,600 --> 00:16:57,800
我们不能拷贝
we can't copy anything between the start of the object 

277
00:16:57,866 --> 00:17:00,499
对象起点到起点+offset之间的东西
and the start of the object plus offset

278
00:17:00,866 --> 00:17:04,866
我们不能拷贝
and we can't copy anything

279
00:17:04,866 --> 00:17:10,166
起点+offset+size后的
past the size added to the offset added to the start of the object

280
00:17:10,933 --> 00:17:13,133
我们只能拷贝
so we are only allowed to copy

281
00:17:14,666 --> 00:17:17,199
这个区域内的
this region shown right here

282
00:17:17,700 --> 00:17:23,066
如果攻击者能够操纵写入大小
if somehow the attacker was able to manipulate these values 

283
00:17:23,066 --> 00:17:25,766
让copy_to_user或copy_from_user
so that copy_to_user or copy_from_user

284
00:17:25,866 --> 00:17:33,899
访问了内核对象规定范围之外的内存
was accessing a memory outside of this specifically defined range of the kernel object

285
00:17:35,000 --> 00:17:36,666
那么它就会失败
then it would fail

286
00:17:37,933 --> 00:17:40,399
这行得通的原因是
the reason that this can work

287
00:17:40,500 --> 00:17:42,966
正如你记得的
is because a cache as you'll recall

288
00:17:43,166 --> 00:17:46,766
cache中的slot大小是固定的
is created with a specific size slot in mem

289
00:17:46,933 --> 00:17:49,799
我们在这里做的是，在创建cache时
so what we're doing here is we're creating a cache

290
00:17:49,800 --> 00:17:53,166
不光规定了slot大小
not only with a specific size slot in mem

291
00:17:53,166 --> 00:17:57,533
还设置了一个特定的对象
but we're creating a cache with a specific object in mem

292
00:17:58,100 --> 00:18:05,066
偏移量和大小值存储在kmem_cache结构体中
and the offset and size values are stored inside the kmem_cache struct 

293
00:18:05,500 --> 00:18:11,366
这意味着所有依据这个cache分配的内核对象
so that means that all kernel objects that are allocated against the cache

294
00:18:11,600 --> 00:18:16,566
都会启用用户拷贝加固检查
will have this hardened user copy check occur

295
00:18:17,100 --> 00:18:22,633
如果正确实现了这个，攻击者该怎么做呢
so what does an attacker do if this is properly implemented 

296
00:18:22,733 --> 00:18:28,066
攻击者感兴趣的内核对象启用了用户拷贝加固
in the kernel objects that the attacker is interested in have hardened usercopy

297
00:18:28,133 --> 00:18:32,466
它们是从正确启用了这个的cache中分配的
and they're being allocated against a cache that is properly employing this

298
00:18:33,066 --> 00:18:35,399
攻击者会考虑
well what an attacker would question 

299
00:18:35,566 --> 00:18:40,433
这些值究竟是在哪里检查的
is well where exactly are these values being checked

300
00:18:40,566 --> 00:18:44,866
我一开始描述这种情况时提到的一件事
well one of the things that I mentioned when I kind of initially described this scenario 

301
00:18:45,000 --> 00:18:48,533
copy_to_user和copy_from_user
was well copy_to_user and copy_from_user

302
00:18:48,600 --> 00:18:50,466
算是
are kind of the default ways 

303
00:18:50,533 --> 00:18:55,066
用户空间和内核之间传递数据的默认方式
that data is transferred from userland to the kernel and from kernel to userland

304
00:18:56,333 --> 00:18:59,266
这基本是正确的
and that is broadly speaking true

305
00:19:01,566 --> 00:19:05,766
在copy_from_user和copy_to_user内
inside copy_from_user and copy_to_user

306
00:19:05,966 --> 00:19:08,499
会调用kmem_cache_create_usercopy
they call kmem_cache_create_usercopy

307
00:19:08,500 --> 00:19:11,866
这时会拷贝数据
and so they separate copy is created

308
00:19:11,866 --> 00:19:16,299
在这个过程中会调用__check_heap_object
and during that process __check_heap_object is called

309
00:19:16,800 --> 00:19:18,533
你可以看一下Linux源代码
you can definitely check out the Linux source

310
00:19:18,533 --> 00:19:21,333
如果你想看一下这个调用栈
if you want to follow the call stack here

311
00:19:21,766 --> 00:19:23,733
这个__check_heap_object
but this __check_heap_object

312
00:19:23,733 --> 00:19:28,266
会对这些值进行比较和验证
is where these values are actually compared and verified

313
00:19:28,700 --> 00:19:33,100
如果调用了copy_from_user
and so if copy_from_user is utilized

314
00:19:33,100 --> 00:19:34,300
校验会发生
the check will happen

315
00:19:34,333 --> 00:19:37,333
如果使用了copy_to_user
if copy_to_user is used 

316
00:19:37,400 --> 00:19:38,766
校验会发生
the check will happen

317
00:19:39,166 --> 00:19:43,733
但不是所有拷贝内存的操作
but not all operations that copy memory

318
00:19:44,700 --> 00:19:47,666
都校验这些值
verify these values

319
00:19:48,933 --> 00:19:49,966
例如
for example

320
00:19:50,166 --> 00:19:51,266
如果
what happens if 

321
00:19:51,266 --> 00:19:57,166
没用标准的copy_from_user和copy_to_user
instead of using kind of the approved standard of copy_from_user and copy_to_user

322
00:19:57,600 --> 00:20:01,466
内核中有些功能使用了memcpy
there is functionality in the kernel that uses memcpy

323
00:20:01,733 --> 00:20:06,233
memcpy不知道要去这里
memcpy has no idea that it's supposed to go 

324
00:20:06,300 --> 00:20:13,133
查看slab分配器的cache
and look at a slab allocators cache

325
00:20:14,200 --> 00:20:16,900
找到偏移量和大小
and then find this offset and size 

326
00:20:16,900 --> 00:20:19,333
然后做一些校验
and do some type of verification step

327
00:20:19,566 --> 00:20:21,466
memcpy只知道
memcpy just

328
00:20:21,800 --> 00:20:23,000
我要从这里开始
here's where I start

329
00:20:23,133 --> 00:20:24,366
拷贝这么多
here's how far I go

330
00:20:24,766 --> 00:20:26,599
到某个地方
copy go brr 

331
00:20:26,600 --> 00:20:27,366
好的
right

332
00:20:27,600 --> 00:20:33,300
所以攻击者会找内核中
and so an attacker would be very interested in finding locations in the kernel

333
00:20:33,600 --> 00:20:36,633
从用户空间到内核
that copy from userland to the kernel 

334
00:20:36,633 --> 00:20:38,733
或者从内核到用户空间
or from kernel to userland

335
00:20:38,966 --> 00:20:42,366
在拷贝时用的这两种方法之外的其他方法
via other methods than these two

336
00:20:42,533 --> 00:20:44,499
这种情况确实存在
and these certainly do exist

337
00:20:45,533 --> 00:20:47,733
我要讲的最后一个保护机制
the last mitigation that I'm going to talk about 

338
00:20:47,800 --> 00:20:50,100
是我们应该很熟悉的东西
is something that we should already be familiar with

339
00:20:50,133 --> 00:20:51,966
就是KASLR
and that's KASLR

340
00:20:52,266 --> 00:20:55,666
它代表内核地址空间布局随机化
which stands for Kernel Address Space Layout Randomization

341
00:20:55,866 --> 00:20:59,799
KASLR的工作原理与用户空间的ASLR非常相似
now KASLR works very similar to userland ASLR

342
00:21:00,566 --> 00:21:03,666
ASLR是做什么的
in the sense that what does ASLR do

343
00:21:03,666 --> 00:21:07,566
ASLR会随机化内存地址中的一些字节
ASLR randomizes some bytes in memory addresses

344
00:21:07,566 --> 00:21:10,566
这使得攻击者难以知道
which makes it more difficult for an attacker to know

345
00:21:10,866 --> 00:21:13,299
东西在内存中的位置
where things are located in memory

346
00:21:13,533 --> 00:21:15,666
用户空间的ASLR
now in Userland ASLR

347
00:21:16,000 --> 00:21:20,800
每次执行一个新进程，就随机化一次
these addresses are randomized every time we execute a new process

348
00:21:21,700 --> 00:21:29,066
内核内存空间不能重新随机化
but we don't have that same opportunity to re-randomize with kernel memory 

349
00:21:29,066 --> 00:21:30,966
因为内核内存
because the kernel memory

350
00:21:31,733 --> 00:21:36,399
在系统启动的时候就建立好了
gets kind of stood up when the system first starts up

351
00:21:36,400 --> 00:21:38,966
我们不能在运行时重新随机化
we can't re-randomize in the middle of running

352
00:21:39,566 --> 00:21:44,899
因此KASLR只在每次启动时将这些地址随机化
and so KASLR randomizes these addresses per boot

353
00:21:45,333 --> 00:21:50,866
这些地址被随机化，或说得到它们的随机字节
the addresses are randomized or obtain their randomized bytes

354
00:21:51,133 --> 00:21:52,766
发生在系统启动时
when the system first starts up

355
00:21:53,033 --> 00:22:00,400
从启动到关机它一直是一个常量
and it's going to be a constant from the time that the system has booted until the system shuts down

356
00:22:00,400 --> 00:22:04,400
然后下次系统启动时，它会被重新随机化
and then it would be re-randomized next time the system starts up

357
00:22:04,766 --> 00:22:09,333
攻击者对抗KASLR的策略
now the attacker's general strategy for combating KASLR 

358
00:22:09,433 --> 00:22:13,266
和对抗ASLR是一样的
is the exact same thing as combating ASLR

359
00:22:13,600 --> 00:22:15,300
就是找到一个信息泄露漏洞
the strategy is get a leak

360
00:22:15,766 --> 00:22:17,166
知道一个地址
where you know what it is

361
00:22:17,533 --> 00:22:19,899
计算到基址
compute an offset to a base address

362
00:22:20,166 --> 00:22:20,966
然后
and then

363
00:22:21,166 --> 00:22:22,899
基于那个基址
based on that base address

364
00:22:22,900 --> 00:22:26,800
你可以知道东西在内存中的位置
you can suddenly know where things are located in memory

365
00:22:30,133 --> 00:22:34,333
那么如何从内核得到泄漏呢
so how do you get a leak from the kernel

366
00:22:34,766 --> 00:22:36,466
一种泄露方式是
one way that you can get a leak

367
00:22:36,533 --> 00:22:40,199
利用所谓的内核oops
is by taking advantage of something that is known as a kernel oops

368
00:22:40,666 --> 00:22:44,599
内核运行时当然会遇到错误
so the kernel certainly can encounter errors right

369
00:22:44,600 --> 00:22:46,466
可能有一个不好的内核模块
there could be a bad kernel module

370
00:22:46,600 --> 00:22:50,800
我们不希望每次出现一个小bug
and we don't want the kernel to drastically fail

371
00:22:51,366 --> 00:22:55,533
内核就直接崩溃
every time a small bug occurs

372
00:22:57,333 --> 00:22:59,466
所以如果内核遇到错误
so if the kernel encounters an error

373
00:22:59,466 --> 00:23:02,399
只要识别出是非致命的
that it recognizes is non fatal

374
00:23:03,500 --> 00:23:05,466
它将试图从中恢复
it will attempt to recover from it

375
00:23:07,066 --> 00:23:09,166
如果内核设置成
if the kernel is configured

376
00:23:10,100 --> 00:23:13,666
oops消息输出
such that oops messages will be output

377
00:23:14,133 --> 00:23:15,333
错误的详细信息
the error details

378
00:23:15,333 --> 00:23:17,766
包括寄存器信息
including the register information

379
00:23:18,500 --> 00:23:23,566
都可以通过dmesg命令打印出来
will be printed out inaccessible via dmesg

380
00:23:23,933 --> 00:23:28,999
所以你可以在dojo虚拟机上运行dmesg
so on the dojo Vms you could run dmesg 

381
00:23:29,000 --> 00:23:30,400
然后在虚拟机外面
and then from outside the vm

382
00:23:30,400 --> 00:23:31,333
我推荐在外面
which is what I'd encourage

383
00:23:31,333 --> 00:23:36,299
你可以用vm logs命令查看相同的信息
you can see that same information by using the vm logs command

384
00:23:37,600 --> 00:23:43,700
所以通过在内核内触发一个非致命错误
and so by triggering an error inside of the kernel that's non fatal

385
00:23:43,700 --> 00:23:46,766
内核认为它可以恢复的错误
that the kernel identifies as something it can recover from

386
00:23:46,966 --> 00:23:49,333
就可以泄漏寄存器信息
it can leak register information

387
00:23:49,900 --> 00:23:51,366
包括内核地址
including kernel addresses

388
00:23:51,433 --> 00:23:57,599
如果内核地址碰巧在错误发生时存储在寄存器中的话
if a kernel address happens to be stored in a register at the time of the error

389
00:24:00,266 --> 00:24:04,899
内核也可以设置成遇到oops情况时panic
now the kernel can also be configured to panic on oops

390
00:24:05,600 --> 00:24:07,333
什么是内核恐慌
now what's a kernel panic

391
00:24:07,366 --> 00:24:10,599
内核oops是指遇到的错误非致命
well a kernel oops was if the error was non fatal 

392
00:24:10,666 --> 00:24:14,566
例如，它是某种类型的内存访问错误
it was for instance some type of memory access

393
00:24:14,566 --> 00:24:16,399
在内核中识别到
in the kernel just identified

394
00:24:16,400 --> 00:24:18,666
我们正在尝试访问一个无效的内存地址
we're trying to access an invalid memory address

395
00:24:18,666 --> 00:24:21,666
我们不需要使整个内核崩溃
we don't need to fail the entire kernel

396
00:24:22,066 --> 00:24:24,766
我们只需要报告这个错误就可以
we just need to report this error and we can

397
00:24:24,766 --> 00:24:25,966
我们可以继续运行
we can carry out 

398
00:24:26,066 --> 00:24:27,399
我们可以从这个错误中恢复过来
we can recover from this error

399
00:24:27,400 --> 00:24:29,766
这触发的就是一个oops
that is what triggers an oops

400
00:24:30,000 --> 00:24:32,800
但如果一个错误是灾难性的
but if an error is so catastrophic 

401
00:24:32,933 --> 00:24:36,066
内核无法从中恢复
that the kernel isn't capable of recovering from it

402
00:24:36,166 --> 00:24:38,766
那么内核就会panic
then the kernel will do something that's called kernel panic 

403
00:24:39,333 --> 00:24:42,366
内核panic与oops非常相似
kernel panic is very similar to an oops

404
00:24:42,533 --> 00:24:45,099
在都会输出错误信息这方面
in the sense that an error message can be output

405
00:24:45,733 --> 00:24:50,133
但panic输出信息后，系统会锁住无法继续执行
but then the system essentially locks up and execution cannot continue

406
00:24:50,200 --> 00:24:53,866
内核识别到进入了无法恢复的状态
the kernel identifies that it is entered a non recoverable state

407
00:24:54,500 --> 00:24:56,733
它就停止运作了
and it ceases to operate

408
00:24:56,733 --> 00:24:58,766
这就是所谓的内核panic（吓呆了）
and this is what's known as a kernel panic

409
00:25:00,300 --> 00:25:02,700
内核可以设置成
now the kernel can be configured

410
00:25:02,700 --> 00:25:07,133
将原来遇到非致命错误时输出oops消息
so that these non fatal errors that typically output in oops

411
00:25:07,133 --> 00:25:10,799
改成内核panic
will instead result in a kernel panic

412
00:25:12,200 --> 00:25:13,500
在这种情况下
in that type of a scenario

413
00:25:13,600 --> 00:25:18,533
让内核泄漏内核地址要困难得多
it's a lot harder to get the kernel to leak kernel addresses

414
00:25:18,600 --> 00:25:24,133
因为不能触发oops机制了
because we no longer have this kind of oops mechanism to trigger that

415
00:25:25,800 --> 00:25:28,000
有一件事要记住
one thing to keep in mind

416
00:25:28,133 --> 00:25:31,999
内核会响应所有的进程
is that the kernel responds to all processes

417
00:25:33,933 --> 00:25:36,966
有一些panic检查
and some of the panic checks

418
00:25:38,333 --> 00:25:42,733
发生在某个特定进程
occur within the context of a specific process

419
00:25:43,133 --> 00:25:45,166
比如我有一个过程
so like if I had a process 

420
00:25:45,366 --> 00:25:51,433
它故意向内核中注入非法地址
that is deliberately injecting bad addresses into the kernel 

421
00:25:51,500 --> 00:25:55,066
并让内核解引用它
and then causing the kernel to dereference them

422
00:25:56,133 --> 00:25:58,733
这样内核可以识别到
that is something that the kernel could identify

423
00:25:58,733 --> 00:26:01,933
这个进程打算利用这些坏地址
this process intends to utilize these bad addresses

424
00:26:01,933 --> 00:26:05,566
这个进程打算访问这些坏地址
and this process intends on accessing these bad addresses

425
00:26:05,700 --> 00:26:07,733
内核可以识别
the kernel can identify

426
00:26:07,733 --> 00:26:10,099
回顾之前的执行
you look back at previous execution

427
00:26:10,200 --> 00:26:11,700
并确定其意图
and kind of identify the intent

428
00:26:11,700 --> 00:26:14,466
这注定要发生了
and say that this is clearly what was meant to happen

429
00:26:15,266 --> 00:26:16,999
是无法恢复了
and this is unrecoverable

430
00:26:18,700 --> 00:26:22,366
但一些panic检查是可以避免的
but some of these panic checks may be avoided

431
00:26:23,900 --> 00:26:27,000
如果不是全都在一个进程中做
if instead of doing all of that in one process

432
00:26:27,900 --> 00:26:34,066
触发非法访问的
the triggering access

433
00:26:35,266 --> 00:26:37,899
在一个单独的进程
occurs in a separate process

434
00:26:38,566 --> 00:26:42,799
而不是在建立的进程
than the process that's setting up

435
00:26:43,900 --> 00:26:46,400
我故意在这里说得有点模糊
I'm purposely being a little bit vague here

436
00:26:46,733 --> 00:26:49,599
通过利用多进程
but by leveraging multiple processes

437
00:26:49,800 --> 00:26:52,633
你可以让内核
you can get the kernel

438
00:26:53,766 --> 00:27:00,666
不执行一些可能导致panic的检查
to not perform some of the checks that would result in a panic

439
00:27:04,933 --> 00:27:08,099
这绝对是值得考虑的
so that's something that is definitely worth considering

440
00:27:08,366 --> 00:27:13,599
当你在遇到oops就panic的系统上
if you are trying to get a leak to defeat KASLR

441
00:27:14,366 --> 00:27:18,833
尝试获得泄漏，以击败KASLR时
on a system that is configured to panic on oops

442
00:27:19,100 --> 00:27:22,166
当你获得了内核泄漏
so once you've obtained a kernel leak

443
00:27:22,866 --> 00:27:24,866
你想要做的下一件事是
the next thing that you want to be able to do is

444
00:27:24,866 --> 00:27:28,233
确定你泄露的地址
to determine whether or not the address that you've leaked 

445
00:27:28,500 --> 00:27:32,433
是否对识别内核基址有用
is useful for identifying the kernel base address

446
00:27:32,600 --> 00:27:35,966
可以用这个地址来击败KASLR吗
can I use this address to defeat KASLR

447
00:27:36,766 --> 00:27:39,899
有几种方法可以做到这一点
and there's a couple ways that you could probably do this

448
00:27:39,900 --> 00:27:41,200
我要展示的方式
but the way that I'm going to show 

449
00:27:41,333 --> 00:27:45,233
是利用GDB和ptdump插件
is to utilize GDB and the ptdump plugin 

450
00:27:45,333 --> 00:27:49,466
对你得到的值进行推理
to reason about the value that you've obtained

451
00:27:50,133 --> 00:27:52,966
左边的终端在虚拟机里
so my terminal on the left hand side is inside the vm

452
00:27:53,400 --> 00:27:56,466
右边的终端在虚拟机外
my terminal on the right hand side is outside of the vm

453
00:27:57,000 --> 00:28:03,500
在这个演示中，我不会触发内核oops
now I'm not going to trigger a kernel oops for this demonstration

454
00:28:03,700 --> 00:28:08,300
我把它留给学习者做练习
I'm going to leave the oopsing as an exercise for the learner

455
00:28:08,733 --> 00:28:10,599
我们会
but we will instead

456
00:28:11,166 --> 00:28:14,099
输出/proc/kallsyms
cat /proc/kallsyms

457
00:28:14,266 --> 00:28:19,499
查找init_cred
and we will grep for a init_cred

458
00:28:19,500 --> 00:28:22,566
我们假设这个是我们泄露的
and we'll pretend that this is our leak

459
00:28:22,733 --> 00:28:26,366
输出kallsyms需要root权限
it is necessary to be root when you cat kallsyms

460
00:28:26,433 --> 00:28:29,066
否则你得到的全是0，就像这里一样
or else you will get the zeros as you see right here

461
00:28:29,100 --> 00:28:30,233
所以我们假设
so we'll pretend that 

462
00:28:30,366 --> 00:28:36,999
这个地址是我通过内核oops获得的
this address right here I've somehow managed to obtain via a kernel oops

463
00:28:37,000 --> 00:28:41,333
或者其他类型的泄漏
or some other type of leak

464
00:28:42,766 --> 00:28:44,266
一旦我完成泄露
now once I've done that

465
00:28:44,666 --> 00:28:49,199
在虚拟机之外，我将运行sudo vm debug
outside of the vm I'm going to run sudo vm debug

466
00:28:49,200 --> 00:28:53,133
一般来说，你不需要以root身份运行GDB
now generally speaking you don't need to run GDB as root

467
00:28:53,133 --> 00:28:56,166
然而，为了能正常使用这个插件
however for this specific plugin to work correctly

468
00:28:56,300 --> 00:28:58,866
你需要是root
you will want to be root

469
00:29:01,133 --> 00:29:05,399
花点时间让GDB从内核加载符号
take a moment for GDB to load the symbols from the kernel

470
00:29:05,533 --> 00:29:09,199
现在我们有一个调试器附加在
and now we have a debugger attached to the kernel

471
00:29:09,533 --> 00:29:11,299
左边这个内核实例上
instance that's running on the left

472
00:29:12,700 --> 00:29:18,100
我们可以展示这里启用了KASLR
now we can show that KASLR is enabled here

473
00:29:18,333 --> 00:29:20,099
如果问GDB
because if we ask GDB

474
00:29:20,933 --> 00:29:25,299
init_cred位于哪里
where is init_cred located

475
00:29:25,666 --> 00:29:29,933
它会告诉我一个错误的地址
it's actually going to give me the wrong address

476
00:29:30,100 --> 00:29:31,600
我们看到82a
we see 82a 

477
00:29:31,833 --> 00:29:37,099
而这里是a8e
and over here we see a8e

478
00:29:38,400 --> 00:29:42,066
所以这些字节是随机化后的
and so these bytes are randomized

479
00:29:44,333 --> 00:29:46,733
这就有点问题了
and so that is a bit of a problem

480
00:29:48,066 --> 00:29:51,666
但是我们可以依靠/proc/kallsyms
but we can rely on /proc/kallsyms

481
00:29:51,766 --> 00:29:54,499
来得到我们感兴趣的符号的地址
to get the address of symbols that we're interested in

482
00:29:55,200 --> 00:29:56,000
所以
so

483
00:29:57,000 --> 00:29:58,400
在调试时
while debugging that is

484
00:29:59,800 --> 00:30:03,000
如果我想使用这个ptdump命令
so if I want to use this ptdump command

485
00:30:03,200 --> 00:30:05,766
它位于dojo环境的
it is located on the dojo

486
00:30:05,900 --> 00:30:07,333
它位于
it's located in

487
00:30:08,366 --> 00:30:10,099
/opt/pt-dump
/opt/pt-dump

488
00:30:10,333 --> 00:30:12,866
源代码文件
in the file that you are interested in sourcing

489
00:30:13,266 --> 00:30:15,466
是pt.py
is pt.py

490
00:30:15,466 --> 00:30:17,066
已经装在dojo环境了
so it's already there on the dojo

491
00:30:17,066 --> 00:30:19,299
不用从github上pull
don't worry about trying to pull it in from github

492
00:30:20,466 --> 00:30:22,533
要使用这个插件
to utilize the plugin

493
00:30:22,533 --> 00:30:25,966
可以source 跟着文件路径
if the GDB prompt we can source that exact path

494
00:30:26,333 --> 00:30:28,666
/opt/pt-dump /pt.py
/opt/pt-dump/pt.py

495
00:30:29,200 --> 00:30:32,500
我们现在可以用PT命令了
we now have access to the PT command

496
00:30:32,600 --> 00:30:37,533
你会注意到这输出了一堆内存区域
you'll notice that this outputs a bunch of regions of memory

497
00:30:37,666 --> 00:30:41,933
该输出与gef中的vmmap命令非常相似
this output is very similar to the vmmap command from gef 

498
00:30:42,066 --> 00:30:47,166
不同之处在于vmmap只会显示用户空间地址
the difference is vmmap is going to show me user land addresses

499
00:30:47,400 --> 00:30:51,933
ptdump将显示所有地址
where ptdump is going to show me all addresses

500
00:30:52,100 --> 00:30:54,733
包括我们在这里看到的用户空间
including user space which we see right here

501
00:30:54,766 --> 00:30:58,566
这里是正在使用的用户空间地址
and so here's the user space addresses that are in use

502
00:31:00,166 --> 00:31:04,299
另一个值得注意的区域是physmap
another region that is notable here is physmap

503
00:31:04,500 --> 00:31:06,566
我们可能与之互动过
which we may have interacted with

504
00:31:07,100 --> 00:31:10,200
在pwn学院之前的一个模块中
in an earlier module here on pwn College

505
00:31:10,400 --> 00:31:12,933
使用physmap可以做一些有趣的事情
there are some fun things to do with physmap

506
00:31:13,733 --> 00:31:17,999
如果我们一直来到这个输出的最后
and if we get all the way back to the tail end of this output

507
00:31:18,166 --> 00:31:23,466
我们可以看到内核在内存中的加载位置
we do see where the kernel is loaded in memory

508
00:31:25,300 --> 00:31:29,933
我怎么知道我泄露的地址在哪里
so how do I know where my leak is

509
00:31:30,800 --> 00:31:32,733
如果我们复制泄露的地址
if we copy our leak

510
00:31:33,666 --> 00:31:36,066
我们可以使用PT命令
we can use the PT command 

511
00:31:36,066 --> 00:31:38,733
传给它 -has
and pass it has 

512
00:31:38,966 --> 00:31:41,799
然后接着我们感兴趣的地址
and then the address that we're interested in

513
00:31:41,966 --> 00:31:44,499
ptdump会告诉我们
and ptdump will show us

514
00:31:46,500 --> 00:31:52,600
这个地址或指针所对应的内存区域
the region of memory that this address or this pointer corresponds to

515
00:31:52,666 --> 00:31:57,599
所以这个地址位于内核内存的这个区域
so this address is located in this region of the kernel's memory

516
00:31:58,533 --> 00:32:01,999
下面我们可能想验证的是
now the next thing that we would probably want to verify is

517
00:32:02,600 --> 00:32:07,866
这些内存区域是连续的吗
well is are these regions of memory contiguous 

518
00:32:07,866 --> 00:32:09,999
中间有空隙吗 
are there gaps here

519
00:32:11,933 --> 00:32:16,933
我们可以通过简单的计算来确定
and we can determine that by doing some pretty simple math here

520
00:32:17,466 --> 00:32:19,866
如果我们从内核基址开始
if we start off with the kernel base address

521
00:32:19,866 --> 00:32:23,299
然后加上第一个区域的大小
and then we add the size of this first region

522
00:32:24,200 --> 00:32:28,300
然后加上第二个区域的大小
we could then add the size of the second region

523
00:32:29,666 --> 00:32:33,899
然后加上第三个区域的大小
and then we could add the size of the third region

524
00:32:34,533 --> 00:32:36,199
我想你知道这是怎么回事了
I think you see where this is going

525
00:32:36,866 --> 00:32:40,499
然后加上第四个区域的大小
we're then going to include the size of the 4th region

526
00:32:40,500 --> 00:32:42,966
现在只要这个加法的结果
now as long as the result of this addition

527
00:32:43,133 --> 00:32:44,266
=
equals

528
00:32:44,600 --> 00:32:47,733
第5个区域的起始地址
the starting address of the 5th region here

529
00:32:47,733 --> 00:32:51,733
那么我们就知道这些都是连续内存
then we know this is all contiguous memory

530
00:32:52,100 --> 00:32:54,966
这里加法的结果是
and what we see here is the result of the addition is

531
00:32:55,033 --> 00:32:57,299
0x98ad 0000
98ad 0000

532
00:32:57,400 --> 00:33:00,666
这就是内核最后一个内存区的基址
and that is the base address of this last section of the kernel

533
00:33:02,333 --> 00:33:05,699
如果我们在往后一个内存区
now if we were to go one section further

534
00:33:10,566 --> 00:33:11,466
我们看到结果是
we see

535
00:33:12,500 --> 00:33:16,800
a9c 5个0
a9c and then five zeros

536
00:33:16,800 --> 00:33:18,333
内核之后是什么呢
well what comes after the kernel

537
00:33:18,433 --> 00:33:21,499
实际上是这个内核模块
well it's actually this kernel module

538
00:33:21,666 --> 00:33:26,666
所以内核模块与内核并不相邻
and so kernel modules are not contiguous with the kernel

539
00:33:26,700 --> 00:33:32,300
但所有内核中的地址都是连续的
but all addresses from the kernel are contiguous with the kernel

540
00:33:32,900 --> 00:33:33,666
这意味着
so what that means 

541
00:33:33,666 --> 00:33:36,133
当我运行这个PT命令的时候
is when I run this PT has command

542
00:33:36,300 --> 00:33:41,066
只要这里写的是kernel
as long as this section lists kernel

543
00:33:41,566 --> 00:33:44,499
我们就知道我们在这五个内存区中的一个
then we know that we're in one of these five sections

544
00:33:44,500 --> 00:33:50,200
还有这个地址有一个固定的偏移量
and the address should have a constant value or a constant offset

545
00:33:50,200 --> 00:33:52,333
到内核的基址
to the base address of the kernel

546
00:33:52,800 --> 00:33:56,066
我们可以计算出这个偏移值
we can compute that constant offset

547
00:33:56,600 --> 00:33:58,700
只需要做一些简单的减法
by doing some simple subtraction

548
00:33:59,200 --> 00:34:02,866
我们用设法获得的泄露地址
we'll take the leak that we've managed to obtain

549
00:34:03,000 --> 00:34:05,000
减去
and then we will subtract

550
00:34:05,666 --> 00:34:09,999
内核的基址
the base address of the kernel

551
00:34:12,133 --> 00:34:13,666
就在这下面
I have it right down here

552
00:34:16,066 --> 00:34:19,899
这就得到了一个神奇的常数
and that now gives me a magic constant

553
00:34:22,600 --> 00:34:27,333
我们先来看看这个神奇的常数
we're just going to hang on to the magic constant for a moment

554
00:34:29,466 --> 00:34:30,633
我们要证明
we want to prove 

555
00:34:30,700 --> 00:34:35,100
我们可以用这个偏移量
that we can use this offset 

556
00:34:35,200 --> 00:34:39,333
计算出代码的基址
to compute the base address of the code

557
00:34:40,066 --> 00:34:42,199
所以我们退出GDB
so let's get out of GDB

558
00:34:44,100 --> 00:34:46,566
重启虚拟机
let's vm restart

559
00:34:47,166 --> 00:34:51,466
重启虚拟机的原因是
the reason I'm doing vm restart is because KASLR

560
00:34:51,900 --> 00:34:53,866
KALSR只在启动时随机化
randomizes on boot

561
00:34:54,133 --> 00:34:57,066
所以我现在重启虚拟机
so now what I'm doing is I'm rebooting the vm

562
00:34:59,733 --> 00:35:03,666
这个重新随机化也会发生在
and this is the same type of re-randomization that would occur

563
00:35:03,933 --> 00:35:06,333
你从练习模式
if you started off in practice mode

564
00:35:06,333 --> 00:35:10,133
切换到挑战模式，应用你的利用脚本时
and then you wanted to apply your exploit in challenge mode

565
00:35:11,733 --> 00:35:13,799
我们在这里做同样的事情
we'll do the same thing here

566
00:35:14,133 --> 00:35:16,433
我左上角的终端
where my terminal on the upper left here 

567
00:35:16,566 --> 00:35:19,066
会连接上虚拟机
is going to connect to the vm

568
00:35:22,800 --> 00:35:28,466
然后执行命令cat /proc/kallsyms
and we will sudo cat /proc/kallsyms

569
00:35:28,666 --> 00:35:32,533
我们再次搜索init_cred
and we'll grep again for a init_cred

570
00:35:35,933 --> 00:35:40,333
我们可以看到这里有bda
well we should see this has bytes bda

571
00:35:40,800 --> 00:35:43,566
我们滑倒上面
we were to scroll up a little bit here

572
00:35:43,766 --> 00:35:45,599
能看到确实变了
we see that it did change right

573
00:35:45,700 --> 00:35:47,400
它随机化了
it has randomized

574
00:35:48,700 --> 00:35:55,866
我要证明的是，用泄露的指针和计算出的常量
now my claim is by using my leaked pointer and our magic constant

575
00:35:56,133 --> 00:35:57,666
我们可以预测
we can predict

576
00:35:58,300 --> 00:36:01,266
内核的基址是什么
what the kernel base address will be

577
00:36:01,800 --> 00:36:04,133
我们现在要验证这个
but we do need to be able to verify that

578
00:36:04,666 --> 00:36:09,066
我们继续，sudo vm debug
so let's go ahead and sudo vm debug

579
00:36:09,300 --> 00:36:11,933
我们将在GDB中进行计算
and we'll just do our math inside of GDB

580
00:36:14,366 --> 00:36:20,699
我用泄露出的地址值
so if I take my leak that I somehow managed to obtain

581
00:36:21,133 --> 00:36:22,933
减去
and then I subtract

582
00:36:24,133 --> 00:36:26,866
我计算出的神奇常数
the magic constant that I've computed

583
00:36:28,466 --> 00:36:30,399
这就是我计算出的
this is where I think

584
00:36:31,500 --> 00:36:35,833
内核基址
the kernel base address is

585
00:36:36,733 --> 00:36:39,366
我们引入ptdump
let's bring in ptdump

586
00:36:43,666 --> 00:36:46,966
看看对不对
and let's see if we can be a little bit cheeky

587
00:36:49,900 --> 00:36:54,100
我们用pt查看哪个内存区包含这个地址
and say what section contains this address

588
00:36:54,100 --> 00:36:55,033
我们看到
and what we see

589
00:36:55,033 --> 00:36:59,299
我预测的内核基址
is the address that I predicted to be the base address of the kernel

590
00:36:59,566 --> 00:37:04,199
实际上位于可执行区
is in fact located in the executable section

591
00:37:04,866 --> 00:37:05,899
能看到
which we saw

592
00:37:09,533 --> 00:37:14,966
它是内核加载到的起始地址
was the beginning of where the kernel was loaded into memory

593
00:37:14,966 --> 00:37:19,166
这证明我能计算出内核基址
so I was able to compute the base address of the kernel

594
00:37:19,366 --> 00:37:21,533
一旦有了内核的基址
once I have the base address of the kernel

595
00:37:21,733 --> 00:37:23,999
定位其他对象
locating other objects

596
00:37:24,900 --> 00:37:27,733
或者感兴趣的内存地址
or interesting locations in memory

597
00:37:27,733 --> 00:37:33,066
就和通过内存基址计算固定偏移量一样简单
is as easy as computing the magic offset from the base address of the kernel

598
00:37:33,300 --> 00:37:37,833
到我感兴趣的点
to the point of interest that I am interested in

599
00:37:38,200 --> 00:37:43,366
这适用于定位ROP gadget
that would apply to locating ROP gadgets

600
00:37:43,366 --> 00:37:49,066
适用于定位数据段中感兴趣的区域
that would apply to locating interesting regions in the data segment

601
00:37:49,666 --> 00:37:51,299
内核中的任何东西
anything in the kernel

602
00:37:51,766 --> 00:37:53,099
都可以计算出来
can be computed

603
00:37:53,100 --> 00:37:58,700
通过找到到内存基址的偏移量
by finding some magic constant to the base address of where the kernel is loaded into memory

604
00:37:59,766 --> 00:38:02,533
希望这能给你们一些思路
so hopefully that gives you some idea of what to do

605
00:38:02,600 --> 00:38:07,333
关于泄露了内存地址之后做什么
once you've managed to obtain a leak of kernel addresses

