1
00:00:00,800 --> 00:00:02,233
我们来谈谈内核堆
let's talk about kernel heap 

2
00:00:02,400 --> 00:00:04,266
以及slab分配器的工作原理
and how slab allocators work

3
00:00:04,466 --> 00:00:08,733
我们在之前的模块中花了很多时间讨论堆
now we've spent a lot of time talking about the heap in prior modules

4
00:00:08,733 --> 00:00:12,066
但我们讨论的都是用户空间的堆
but everything we've talked about has been specific to userland heap

5
00:00:12,066 --> 00:00:12,899
准确的说
and beyond that

6
00:00:12,900 --> 00:00:17,333
是特定于glibc实现版本的，用户空间的堆
it's been specific to glibc's implementation of a userland heap

7
00:00:17,333 --> 00:00:20,333
这是许多Linux系统的通常情况
now that is the common case for a lot of Linux systems

8
00:00:20,333 --> 00:00:22,999
所以讨论它是有意义的
so it makes sense to talk about this

9
00:00:23,000 --> 00:00:25,166
我们有一整个模块讲的tcache
we had a whole module dedicated to tcache

10
00:00:25,166 --> 00:00:28,966
它是出于性能优化的缓存层
which is like the performance optimization caching layer 

11
00:00:29,200 --> 00:00:35,166
大量的动态内存请求，可通过它得到满足
that a lot of dynamic memory requests can be satisfied via

12
00:00:35,733 --> 00:00:40,533
所以它绝对是值得讨论和探索的
and so it's definitely worth talking about and exploring how that works

13
00:00:40,733 --> 00:00:43,066
如果tcache满足不了的话
now if something can't be satisfied by the tcache

14
00:00:43,066 --> 00:00:45,199
就会深入更大的堆
it goes into kind of the greater heap

15
00:00:45,200 --> 00:00:48,266
这里就要说到bins了
and that's where we have to deal with this concept of bins

16
00:00:48,266 --> 00:00:49,366
有unsorted bin
we have the unsorted bin

17
00:00:49,366 --> 00:00:52,766
有large bins、small bins和fast bins
we have the large bins the small bins the fast bins

18
00:00:53,033 --> 00:00:58,099
空闲chunk会在这些bins中传递
and we see that free chunks kind of move between these different bins

19
00:00:58,200 --> 00:01:00,200
这取决于
depending upon what's going on

20
00:01:00,733 --> 00:01:03,799
可用的动态内存
in as far as dynamic memory that is available

21
00:01:03,800 --> 00:01:06,500
和请求的动态内存
in what is being requested in dynamic memory

22
00:01:06,766 --> 00:01:10,266
Linux内核使用完全不同的实现
but the Linux kernel uses a completely different implementation

23
00:01:10,400 --> 00:01:15,200
我想问的一个问题是。为什么？
and one of the questions that I mean I certainly ask is why

24
00:01:15,533 --> 00:01:19,399
为什么Linux内核需要一个完全不同的堆
why does the Linux kernel need an entirely different heap

25
00:01:20,266 --> 00:01:23,033
我们来想想内核是怎么工作的
well let's think about how the kernel works 

26
00:01:23,133 --> 00:01:26,966
以及内核的独特约束
and kind of the unique constraints of the kernel

27
00:01:28,066 --> 00:01:31,333
首先内核在意性能
so above all the kernel cares about performance

28
00:01:31,666 --> 00:01:33,699
用户空间程序也关心性能
userland cares about performance as well

29
00:01:33,733 --> 00:01:41,566
但两者的影响是不能相提并论的
but there's a very different impact of a slow path in user land versus a slow path in the kernel

30
00:01:41,600 --> 00:01:43,866
如果我写一些慢的用户空间程序
if I write some slow user land program

31
00:01:43,866 --> 00:01:47,099
唯一慢的是我的用户空间程序
the only thing that's slow is my user land program

32
00:01:47,533 --> 00:01:50,699
如果内核的代码很慢
now if the kernel has a slow code path

33
00:01:50,700 --> 00:01:53,533
这会减慢系统上的每个程序
that slows down every program on the system

34
00:01:53,700 --> 00:01:55,166
原因是
and the reason for that is because

35
00:01:55,166 --> 00:01:59,299
程序只有依赖内核，才能完成有意义的工作
every program relies on the kernel to get any type of like real work done

36
00:01:59,966 --> 00:02:01,066
现在我们来想想
now let's think about

37
00:02:01,200 --> 00:02:07,266
用户空间glibc堆实现中的一些操作
some of the operations or actions that occur inside the Userland glibc heap implementation

38
00:02:07,466 --> 00:02:14,499
用户空间堆花了很多时间读写元数据
well the user land heap spends a decent amount of time reading and writing metadata 

39
00:02:14,500 --> 00:02:16,666
比如prev_size、size
like previous size or the size 

40
00:02:16,666 --> 00:02:19,933
large bins用的fd_nextsize、bk_nextsize
next pointers previous pointers for large bins

41
00:02:19,933 --> 00:02:23,133
要额外的指针来索引到
there's additional pointers to try and navigate to free chunks

42
00:02:23,266 --> 00:02:25,699
堆管理的空闲chunk
that are being tracked by the heap

43
00:02:26,066 --> 00:02:28,499
对于这些空闲chunk
and on the topic of these free chunks

44
00:02:28,566 --> 00:02:30,499
glibc实现的堆
the glibc implementation of the heap

45
00:02:30,500 --> 00:02:32,300
花了不少时间
spends a decent amount of time

46
00:02:32,700 --> 00:02:36,400
在这些不同bins之间转移空闲chunk
moving free chunks between all of these different bins

47
00:02:36,400 --> 00:02:38,066
unsorted bin中的某个chunk
I may have something in the unsorted bin 

48
00:02:38,200 --> 00:02:40,566
后面可能要转移到large bin中
then needs to go to the large bin

49
00:02:41,100 --> 00:02:44,800
这需要额外的工作
right and there is additional work that needs to occur

50
00:02:44,800 --> 00:02:47,900
要额外的工作
it's additional cycles that are occurring

51
00:02:48,966 --> 00:02:53,399
来计算或记录它
in order to kind of do that accounting or track that

52
00:02:54,266 --> 00:02:58,266
如果我尝试malloc些东西会发生什么
or what happens if I try malloc something

53
00:02:58,300 --> 00:03:00,266
假设有一个够大的空闲chunk
and there is a free chunk that is large enough

54
00:03:00,266 --> 00:03:01,766
但有点太大了（超过了请求大小）
but it's a little bit too large

55
00:03:02,166 --> 00:03:04,266
glibc堆实现
well the glibc heap implementation

56
00:03:04,500 --> 00:03:06,500
可能会将它切成两份
may break that chunk in two

57
00:03:07,066 --> 00:03:11,999
然后得整理那个剩下的
and then have to sort the second half of the original chunk

58
00:03:12,500 --> 00:03:15,200
这又要做更多的工作
again that's more work that is being done

59
00:03:15,466 --> 00:03:20,066
换一个堆的实现可能可以避免它
that maybe a different implementation of the heap could otherwise avoid

60
00:03:21,066 --> 00:03:24,099
另外，内核是一直运行的
additionally the kernel essentially runs forever

61
00:03:24,100 --> 00:03:26,933
只要系统启动，内核就在运行
because the kernel runs as long as the system is up

62
00:03:26,966 --> 00:03:28,499
它不像用户空间程序
it isn't like a user land program 

63
00:03:28,500 --> 00:03:31,500
可以启动，停止，重启它
where we can start it up stop it and then restart it

64
00:03:31,666 --> 00:03:35,366
重启内核等同于重启电脑
restarting the kernel is essentially rebooting your computer

65
00:03:36,000 --> 00:03:38,566
所以内核必须高效利用内存
so the kernel has to be memory efficient

66
00:03:38,566 --> 00:03:43,099
不能丢失内存或泄漏内存
it can't lose track of memory or have memory leaks

67
00:03:43,266 --> 00:03:46,999
我们讨论了可能会用到的额外内存
now we already talked about the additional memory that's kind of used potentially 

68
00:03:47,433 --> 00:03:51,533
用来在用户空间堆中存储元数据的
from storing metadata in the user land heap representation

69
00:03:52,333 --> 00:03:53,866
能避免的话
well if we can avoid that 

70
00:03:53,966 --> 00:03:55,866
就节省了空间
that is a space savings

71
00:03:55,900 --> 00:03:57,800
我们可以做的另一件事
the additional thing that we can do

72
00:03:59,200 --> 00:04:00,866
是
is something that

73
00:04:01,133 --> 00:04:05,866
讨论用户空间堆时，没细讲到的
we didn't really talk about in detail talking about the user land heap

74
00:04:05,866 --> 00:04:11,866
就是glibc堆实现容易产生内存碎片
but the glibc heap implementation is susceptible to memory fragmentation

75
00:04:12,000 --> 00:04:14,333
我说的内存碎片是什么意思
what do I mean when I say memory fragmentation

76
00:04:14,533 --> 00:04:18,933
我们想一下幻灯片右边的三行代码
well let's consider the three lines of code on the right hand side of this slide

77
00:04:19,566 --> 00:04:21,566
malloc 0x80字节
we malloc hex 80 bytes

78
00:04:21,566 --> 00:04:23,866
然后释放这0x80字节
we then free those hex 80 bytes

79
00:04:23,866 --> 00:04:26,799
再malloc 0x60字节
then we malloc Hex 60 bytes

80
00:04:27,100 --> 00:04:29,366
这里我们忽略tcache
now let's ignore the tcache right now

81
00:04:29,366 --> 00:04:32,699
想一下堆的深处发生了什么
and just think about what goes on kind of deeper into the heap

82
00:04:32,866 --> 00:04:34,799
因为这是一个人为的例子
because this is a contrived example

83
00:04:34,966 --> 00:04:36,999
我们忽略tcache
and so we're going to ignore tcache here

84
00:04:38,800 --> 00:04:41,533
很有可能
well there's a reasonable chance

85
00:04:41,866 --> 00:04:45,066
在第二次malloc 0x60字节时
that the second malloc of hex 60 bytes

86
00:04:45,066 --> 00:04:51,133
会返回上行代码释放的chunk
will be satisfied by the free chunk that we just freed in the line above

87
00:04:52,133 --> 00:04:53,733
这样做
now by doing so

88
00:04:54,333 --> 00:04:58,466
我们会取到较大的那个chunk
we take the larger chunk

89
00:04:58,566 --> 00:05:00,533
我们把空闲chunk掰成两份
and we break it into two pieces 

90
00:05:00,533 --> 00:05:03,566
返回0x60字节的chunk
and we return the allocation of hex 60 

91
00:05:03,566 --> 00:05:08,999
最后剩下一个空闲的0x20字节的chunk
and we'll end up with a unused chunk of size hex 20

92
00:05:09,933 --> 00:05:12,666
如果我一直持续这个操作
now if I were to like repeat this operation here

93
00:05:12,666 --> 00:05:14,066
这3行代码
these three 3 lines of code

94
00:05:14,066 --> 00:05:16,099
把它放入while循环或for循环中
throw it in a while loop or in a for loop

95
00:05:16,100 --> 00:05:18,266
运行好几次
you know and ran it several several times

96
00:05:19,466 --> 00:05:23,999
我们会看到，每次执行
what we would see is every iteration of this 

97
00:05:24,000 --> 00:05:30,100
就创建一个代码不用的0x20字节的chunk
is creating one of these hex 20 chunks that the code isn't using

98
00:05:30,300 --> 00:05:39,000
运行的代码一直不需要，不用这0x20字节的chunk
at no point does the code that is actually running need or use this hex 20 size chunk

99
00:05:39,533 --> 00:05:46,666
所以我们创造了很多无用的0x20字节大小的chunk
and so we're creating all of these hex 20 size chunks that serve no purpose

100
00:05:47,666 --> 00:05:50,699
这显然是一个刻意的例子
now this is a contrived example obviously

101
00:05:50,700 --> 00:05:54,100
你不会让它在死循环中运行
that you wouldn't want to run this in an infinite loop

102
00:05:55,200 --> 00:05:57,866
但是从内核的角度来看
however from the kernel's perspective

103
00:05:57,866 --> 00:06:03,866
这一系列分配和释放的发生是完全合理的
it's totally plausible for this series of allocations and frees to occur

104
00:06:04,566 --> 00:06:07,199
内核需要一直运行
and the kernel needs to run indefinitely

105
00:06:07,500 --> 00:06:13,933
所以这些没用的小chunk
so these little kind of unused chunks that create

106
00:06:14,800 --> 00:06:17,666
按这种方式创建的
that get created from this pattern

107
00:06:18,166 --> 00:06:20,099
会随着时间累积
would build up over time

108
00:06:20,133 --> 00:06:24,899
导致内存碎片化，基本无法使用
and result in fragmented memory that is essentially useless

109
00:06:25,200 --> 00:06:28,166
这当然是内核想要避免的
and that is certainly something that the kernel wants to avoid

110
00:06:28,900 --> 00:06:31,566
Linux内核的堆实现
the Linux kernel's heap implementation

111
00:06:31,566 --> 00:06:34,799
依赖于slab分配器
relies on something that's known as a slab allocator

112
00:06:34,966 --> 00:06:38,766
slab这个词在这个领域有重叠
now the term slab is overloaded within this domain

113
00:06:39,166 --> 00:06:43,899
所以它有2个意思
so there are two usages of the word slab

114
00:06:44,766 --> 00:06:47,699
如果是小写slab
slab if it is lowercase 

115
00:06:47,700 --> 00:06:52,100
就是指一块连续的内存区
implies a contiguous region of memory 

116
00:06:52,166 --> 00:06:54,333
一块内存
a slab of memory

117
00:06:54,666 --> 00:06:56,266
或者指块内存分配器
or a slab allocator 

118
00:06:56,266 --> 00:07:00,199
使用slab概念的分配器
an allocator that uses this concept of slabs 

119
00:07:00,466 --> 00:07:04,333
但如果是全大写的SLAB
however if the word slab is all capitalized

120
00:07:04,500 --> 00:07:11,100
这指一种特定的slab分配器实现
this refers to a specific implementation of a generic slab allocator

121
00:07:12,800 --> 00:07:17,666
Linux使用过三种不同的slab分配器实现
now there's three different implementations of slab allocators that have been used in Linux

122
00:07:17,900 --> 00:07:19,166
第一个是SLOB
the first is SLOB

123
00:07:19,166 --> 00:07:21,899
它是"简单一列内存块"的首字母缩写
which is an acronym for a Simple List Of Blocks

124
00:07:21,900 --> 00:07:23,600
我这里写着已弃用
I list this is deprecated 

125
00:07:23,600 --> 00:07:28,466
然而，它在内存受限的环境中仍有使用
however it does still see some use in memory constrained environments

126
00:07:28,666 --> 00:07:29,933
比如在嵌入式系统中
so like on embedded systems

127
00:07:29,933 --> 00:07:33,933
可能有SLOB的slab分配器实现
there may be a SLOB implementation of a slab allocator

128
00:07:34,333 --> 00:07:38,199
还有SLAB的slab分配器实现
there is also the SLAB implementation of a slab allocator 

129
00:07:38,200 --> 00:07:43,200
就是这里与slab重复了
this is where that kind of redundant use of the word slab

130
00:07:43,200 --> 00:07:45,100
让人有点困惑
can get a little confusing

131
00:07:45,500 --> 00:07:47,700
Linux源代码允许
the Linux source code does allow

132
00:07:47,866 --> 00:07:51,066
编译时选择SLAB库实现
for compiling with this SLAB implementation

133
00:07:51,466 --> 00:07:56,599
但它不是默认选项，已经很久不是了
however it is no longer default and hasn't been for quite some time

134
00:07:57,066 --> 00:08:02,299
linux的默认slab分配器实现
the default kind of Linux kernel implementation of a slab allocator

135
00:08:02,333 --> 00:08:04,466
叫SLUB
is known as SLUB

136
00:08:04,766 --> 00:08:08,699
U表示非队列的
which is an acronym for an unqueued slab allocator

137
00:08:09,100 --> 00:08:12,266
这张幻灯片后
right and so everything past this slide

138
00:08:12,566 --> 00:08:18,199
slab分配器指的都是的SLUB
will be referring to the SLUB implementation of a slab allocator

139
00:08:21,733 --> 00:08:23,766
内核的堆实现
the kernel's heap implementation

140
00:08:24,166 --> 00:08:29,899
与用户空间glibc堆实现有很大的不同
differs quite a bit from what we've seen in userland with glibc's heap implementation

141
00:08:30,266 --> 00:08:32,499
因为实现方式不同
and since the implementation is quite different

142
00:08:32,500 --> 00:08:35,133
所以用了不同的术语
we have different terminology that is used

143
00:08:35,366 --> 00:08:42,366
在讨论slab分配器时说chunk是不准确的
it would be technically incorrect to refer to chunks when talking about a slab allocator

144
00:08:43,100 --> 00:08:45,800
这里我们经常用到的术语有
so the terms that we're going to kind of be throwing around here

145
00:08:45,800 --> 00:08:47,966
首先cache
first is cache

146
00:08:47,966 --> 00:08:53,866
当我们讨论这些分配器时，cache是最高级别的概念
now a cache is kind of the highest level concept when we're talking about these allocators

147
00:08:53,966 --> 00:08:57,366
一个cache管理一个指定大小内存
a cache is created for a specific size

148
00:08:57,466 --> 00:09:04,299
所以内核分配器中用到了很多cache
so there's many different caches that are used within the kernels allocator

149
00:09:04,700 --> 00:09:09,066
有管理256B对象的cache
there's a cache for 256 byte objects 

150
00:09:09,066 --> 00:09:13,333
有管理512B对象的cache
there's a cache for 512 byte objects

151
00:09:13,566 --> 00:09:17,899
如果堆要管理一些特定大小的内存
if there is some specific size that needs to be managed by the heap

152
00:09:18,066 --> 00:09:21,999
就会创建一个cache，管理该大小内存
a cache is created specific to that size

153
00:09:22,933 --> 00:09:27,133
cache管理一种叫做slab的东西
now caches manage something called slabs

154
00:09:27,133 --> 00:09:31,466
这是slab分配器名字的由来
and this is where the generic term of slab allocator comes from

155
00:09:32,366 --> 00:09:35,366
一个slab是一块连续的内存
a slab is a continuous region of memory

156
00:09:35,733 --> 00:09:38,066
它可以占一个或多个内存页
that can be one or more pages in size

157
00:09:38,066 --> 00:09:42,966
这取决于要管理的资源有多大
it kind of depends on what is being managed to source how large is a slab

158
00:09:44,000 --> 00:09:48,100
slab由一连串slot组成
and these slabs consist of a series of slots

159
00:09:48,300 --> 00:09:55,266
slot是slab中的内存区域
where the slot is a region of memory within the slab

160
00:09:55,766 --> 00:09:59,499
slot的大小是cache管理的大小
that is the size being managed by the cache

161
00:09:59,766 --> 00:10:03,999
如果我们有一个cache管理256B
so if we have a 256 byte cache

162
00:10:04,800 --> 00:10:10,900
那在slab中的slot的大小就是256B
then these slots that are on the slab will be 256 bytes in size

163
00:10:12,300 --> 00:10:15,533
slot中装着对象
now slots can contain objects

164
00:10:15,533 --> 00:10:21,066
如果slot的大小是256B
so if the slot is the region of memory that is 256 bytes in size

165
00:10:21,866 --> 00:10:27,266
那malloc发生时，这里在内核中是kmalloc
what happens when a malloc occurs or kmalloc in the case of the kernel

166
00:10:27,733 --> 00:10:30,199
返回的指针
is the pointer that is returned

167
00:10:30,266 --> 00:10:34,066
指向某个可用的空闲slot
is a pointer to one of these available slots

168
00:10:34,266 --> 00:10:37,866
当这个slot被使用后
and once that available slot is being used

169
00:10:38,266 --> 00:10:42,133
我们会说那个slot中包含一个对象或内核对象
we would say that that slot contains an object or a kernel object

170
00:10:42,366 --> 00:10:43,966
我们在这里看到
and so we see here 

171
00:10:43,966 --> 00:10:50,799
调用kmalloc或其它方式申请内存后，返回的指针
that a pointer that was returned from calling kmalloc or somehow getting an allocation

172
00:10:51,266 --> 00:10:55,899
是一个指向slab内存中的一个指针
would be a pointer into the region of memory of the slab

173
00:10:57,533 --> 00:11:04,899
指向的slot现在装着一个对象
and specifically pointing to a slot that now contains an object

174
00:11:06,333 --> 00:11:11,299
使用这种slab分配器方法的好处之一是
now one of the kind of benefits of using this slab allocator approach

175
00:11:11,666 --> 00:11:14,933
对象初始化之后
is that once objects are initialized

176
00:11:15,466 --> 00:11:19,566
初始化的数据，只要有可能，就可重用
that initialized data can be reused when possible

177
00:11:19,900 --> 00:11:23,933
回想一下glibc堆是如何实现的
so if we think about how the glibc heap implementation worked

178
00:11:23,933 --> 00:11:25,966
我们调用malloc，然后调用free
we called malloc and then free

179
00:11:26,200 --> 00:11:27,700
然后再malloc
and then malloc again

180
00:11:27,766 --> 00:11:34,466
无法保证返回内存中的值是多少
we have no guarantee about the values of the memory that is returned to us

181
00:11:35,366 --> 00:11:38,033
然而，在这个slab实现中
however with this slab implementation 

182
00:11:38,233 --> 00:11:42,633
如果为特定对象类型专门创建了cache
if a cache is created for a specific object type 

183
00:11:42,733 --> 00:11:44,566
该对象有专门的数据结构
for a specific data structure

184
00:11:45,366 --> 00:11:48,533
可能有些静态值
and there are kind of static values

185
00:11:49,700 --> 00:11:56,066
然后，当所有slot都用该静态值初始化后
then once all of the slots have been initialized with that static value

186
00:11:56,366 --> 00:12:03,133
就可以假定这个数据在返回slot时就存在了
we can assume that that data is already there when we obtain the allocation

187
00:12:03,333 --> 00:12:07,166
因为这些内存的唯一用途
because the only thing that these regions or memory are being used for

188
00:12:07,500 --> 00:12:11,066
就是装该数据结构
are those specific data structures

189
00:12:13,700 --> 00:12:15,066
右边的示意图
so the diagram on the right

190
00:12:15,066 --> 00:12:17,499
是偏概念性，而非技术细节
is more conceptual than it is technical

191
00:12:17,666 --> 00:12:22,899
一个更准确的内核堆实现示意图
a more technically accurate representation of the kernel heap implementation 

192
00:12:23,000 --> 00:12:23,933
在这里
is shown here 

193
00:12:23,933 --> 00:12:26,566
这里我们展示了
where we are specifically calling out 

194
00:12:26,766 --> 00:12:29,499
实际用到的数据结构
the actual data structures that are used

195
00:12:29,900 --> 00:12:33,300
最高级别的数据结构是kmem_cache
so the highest level data structure is the kmem_cache

196
00:12:33,333 --> 00:12:36,966
有一个kmem_cache管理256B对象
and so there's a kmem_cache for 256 byte objects

197
00:12:37,066 --> 00:12:42,399
有一个kmem_cache管理512B对象
there's a kmem_cache for 512 byte objects right

198
00:12:42,400 --> 00:12:47,533
所以kmem_cache在概念上和我们的cache是相同的
and so the kmem_cache is conceptually the same thing as our cache

199
00:12:47,766 --> 00:12:51,199
但是在cache实现中
however in the caches implementation

200
00:12:51,566 --> 00:12:54,466
它还使用了另外两种数据结构
it uses these two other data structures

201
00:12:54,466 --> 00:12:56,533
一个是kmem_cache_cpu
it has the kmem_cache_cpu

202
00:12:56,533 --> 00:12:59,399
一个是kmem_cache_node
and it has this kmem_cache_node

203
00:12:59,900 --> 00:13:04,333
我们可以像这样分开考虑
now we can think about this split here as follows 

204
00:13:04,933 --> 00:13:07,766
左边的数据结构用于表示
the data structures on the left here are represented to kind of 

205
00:13:07,833 --> 00:13:14,299
被某个cpu使用的slab
the working set or the working slab that is in use for a specific CPU

206
00:13:14,600 --> 00:13:16,900
右边的数据结构
where the data structures on the right here

207
00:13:17,266 --> 00:13:24,399
记录着未被CPU使用的slab
contain information about slabs that are not being used by the current CPU

208
00:13:24,766 --> 00:13:27,933
为什么要做这样的区分
so why why do we have this this kind of division

209
00:13:28,066 --> 00:13:33,066
这与glibc堆中使用的tcache类似
well this is very similar to what we have with tcache in the glibc heap

210
00:13:33,166 --> 00:13:35,999
tcache表示线程本地存储
tcache represented thread local storage

211
00:13:36,066 --> 00:13:40,799
获取这里的chunk
there are allocations that the thread

212
00:13:41,500 --> 00:13:47,966
线程可以不阻塞，不用等待底层堆
can obtain without having to kind of block and wait for the greater heap

213
00:13:48,033 --> 00:13:50,533
如果有多个线程试图malloc
if there are multiple threads that are trying to malloc something

214
00:13:50,600 --> 00:13:53,466
我们不希望所有这些线程都在相互等待
we don't want to have all of these threads waiting on each other 

215
00:13:53,466 --> 00:13:55,366
这里也是类似的概念
it's a similar idea here

216
00:13:55,600 --> 00:13:57,500
在内核堆实现中
with the kernel heap implementation

217
00:13:58,333 --> 00:14:01,099
不对线程上锁
except instead of locking on a thread

218
00:14:01,200 --> 00:14:06,733
我们处于特定于CPU的预留级别
we are on a CPU specific kind of reservation level

219
00:14:06,933 --> 00:14:10,333
左边的数据结构
so the data structures on the left hand side

220
00:14:10,500 --> 00:14:15,700
是为当前cpu预留的
are what the current CPU has reserved 

221
00:14:15,700 --> 00:14:18,166
可以直接访问它，从这里获取内存
and it can access and allocate from 

222
00:14:18,166 --> 00:14:22,766
不用担心与其他cpu争
without worrying about having contention with other CPUs

223
00:14:25,166 --> 00:14:26,666
对于每个cache
so for every cache 

224
00:14:26,766 --> 00:14:28,099
对于每个CPU
for every CPU

225
00:14:28,133 --> 00:14:30,633
有一个激活的使用中的slab
there is an active working slab

226
00:14:30,700 --> 00:14:34,266
有这么一个CPU正在与之交互的工作集
there's this working set that the CPU is interacting with

227
00:14:34,300 --> 00:14:36,333
就是我们看到的绿色部分
that's what we see here in green

228
00:14:36,900 --> 00:14:38,733
但当需要新的slab时
but when a new slab is needed

229
00:14:38,733 --> 00:14:41,099
可以放partial slab进去
partial slabs can be swapped in

230
00:14:41,500 --> 00:14:42,966
如果我们考虑一下
so like if we consider 

231
00:14:43,100 --> 00:14:46,566
我们在左边有这个工作集
we have this working set over here on the left hand side

232
00:14:46,566 --> 00:14:49,133
当所有slot都满了
what happens when all of the slots are full

233
00:14:49,333 --> 00:14:53,533
我们又要申请一个对象时
and we need to allocate another object

234
00:14:54,066 --> 00:14:57,999
kmem_cache来到右边
well the kmem_cache can go over to the right hand side

235
00:14:58,400 --> 00:15:01,533
找到一个有空闲slot的slab
find a slab that has open slots

236
00:15:01,733 --> 00:15:03,733
该slab中可能有些slot已经分配出去了
it may have some slots allocated

237
00:15:04,366 --> 00:15:07,199
但它要有空闲的slot
but it should have some open or free slots

238
00:15:07,466 --> 00:15:12,999
它可以将那个slab，或说内存
and it can kind of claim ownership of that slab or that region of memory 

239
00:15:13,066 --> 00:15:17,533
当作它要用的新工作集
as its new working set that it is going to use

240
00:15:18,733 --> 00:15:21,766
partial slabs记录在链表中
now partial slabs are tracked in the linked list

241
00:15:21,966 --> 00:15:26,933
由kmem_cache_node中的nr_partial指针记录
they are in this nr_partial pointer in the kmem_cache_node

242
00:15:29,100 --> 00:15:31,233
完整的slab实际上不会记录
full slabs actually aren't tracked at all 

243
00:15:31,400 --> 00:15:34,733
除非内核被专门编译为这样做
unless the kernel is compiled specifically to do so

244
00:15:34,733 --> 00:15:40,599
所以当一块slab全被分配出去时
so when we fully allocate a kind of backing region of memory

245
00:15:41,166 --> 00:15:43,299
内核可以不管它
we the kernel can just forget about

246
00:15:43,466 --> 00:15:45,366
因为内核相信
because the kernel trusts

247
00:15:45,600 --> 00:15:50,066
内核代码能正确地管理它
that kernel code will manage that properly

248
00:15:50,366 --> 00:15:53,066
它会在某刻释放出来
at some point it will be freed

249
00:15:53,066 --> 00:15:56,366
当它被释放后，才需要再次记录它
and when this freed is when it needs to be tracked again

250
00:15:56,466 --> 00:16:02,099
所以如果有一个slab全部都分配出去
and so if we have a slab that is fully allocated

251
00:16:02,966 --> 00:16:04,799
我们不知道它在哪里
we don't even know where it is 

252
00:16:04,800 --> 00:16:06,200
内核并不关心
the kernel doesn't care

253
00:16:06,366 --> 00:16:09,866
但是一旦其中一个对象被释放
but as soon as one of those objects are freed

254
00:16:09,866 --> 00:16:13,499
它就变成了一个部分分配的slab
it becomes a partially allocated slab

255
00:16:13,500 --> 00:16:15,100
它就是一个partial slab了
it's a partial slab 

256
00:16:15,100 --> 00:16:20,766
在它的第一个对象被释放时
and it is at the time of when the first object is freed

257
00:16:20,800 --> 00:16:24,733
这个slab将被添加到右边的元数据中
that that slab will be added to the metadata over on the right hand side

258
00:16:24,733 --> 00:16:27,766
因为它至少有一个空闲slot
because suddenly it at least has one slot

259
00:16:27,766 --> 00:16:31,066
所以它可以用在工作集中
and so it could be used in a working set

260
00:16:32,733 --> 00:16:34,833
不会记录全分配出去的slab的位置
there are no tracking of full slabs 

261
00:16:34,833 --> 00:16:37,166
除非它被显式编译成这样做
unless it's explicitly compiled to do so

262
00:16:38,533 --> 00:16:41,299
堆相关内容很多
now that was a lot of components to show in a single slide 

263
00:16:41,366 --> 00:16:43,566
但幸运的是，就我们的题目而言
but fortunately for the challenges 

264
00:16:43,666 --> 00:16:46,333
就我们在这个模块要探索的概念而言
kind of concepts that we're exploring in this module

265
00:16:46,333 --> 00:16:51,066
我们只需关注支撑slab的内存
we really only need to focus on the memory that is backing the slab

266
00:16:51,133 --> 00:16:54,299
以及slab中的slots
as well as the slots that exist within that region of memory

267
00:16:54,566 --> 00:16:56,666
我们首先要看的是
what we're primarily going to be looking at is 

268
00:16:56,800 --> 00:17:01,666
对象是如何在slab的slots中分配的
how the objects are allocated on the slab in those slots 

269
00:17:01,766 --> 00:17:04,066
以及这些slots之间的关联
and how those slots relate to each other

270
00:17:05,533 --> 00:17:07,566
专注于slab内存
so focusing on the slab's memory

271
00:17:07,666 --> 00:17:09,733
我们可以把它想象成一个连续的内存区域
we can think of this as a contiguous region of memory 

272
00:17:09,833 --> 00:17:11,766
它由固定大小的slot组成
that's made up of fixed size slots 

273
00:17:11,766 --> 00:17:14,399
要么是空闲可分配的
that are either free and available for allocation

274
00:17:14,400 --> 00:17:18,333
要么是已经分配给该大小的内核对象了
or the slot currently contains some kernel object of that size 

275
00:17:18,600 --> 00:17:22,566
slab上的所有slot都是大小固定的
recall that all slots on a slab are a fixed size 

276
00:17:22,566 --> 00:17:25,899
因为一个slab支持一种特定的cache
because that slab is supporting a specific cache

277
00:17:25,900 --> 00:17:29,166
一个cache中的所有内容都是大小固定的
and everything from one cache has a fixed size

278
00:17:29,600 --> 00:17:33,166
这样分配的对象不需要元数据，避免内存浪费
no space is wasted on metadata for allocated objects

279
00:17:33,966 --> 00:17:37,166
那么当我们释放一个对象时会发生什么呢
so what happens when we free an object

280
00:17:37,200 --> 00:17:39,200
这和tcache类似
well very similar to tcache

281
00:17:39,266 --> 00:17:42,066
释放的对象被压入单链表
freed objects are pushed onto a singly linked list

282
00:17:42,333 --> 00:17:46,066
SLUB实现的slab分配器中
for the SLUB implementation of the slab allocator

283
00:17:46,300 --> 00:17:48,533
这个空闲链表是一个单链表
this free list is a singly linked list

284
00:17:48,533 --> 00:17:50,899
和我们在tcache中看到的非常相似
very similar to what we see in tcache

285
00:17:51,300 --> 00:17:55,033
这里空闲链表中有一个slot
so here there is one slot on the free list 

286
00:17:55,166 --> 00:17:57,333
它的next指针为空
and the next pointer is null

287
00:17:57,533 --> 00:18:01,333
那么如果我们释放这个第4个slot会发生什么呢
so what would happen if we were to free this 4th slot 

288
00:18:01,433 --> 00:18:03,466
这个slot里面有个内核对象
which currently contains a kernel object

289
00:18:03,800 --> 00:18:06,066
和我们平常讨论单链表时
well we would do the same thing that we normally do

290
00:18:06,400 --> 00:18:08,700
做的一样
when we're talking about singly linked lists

291
00:18:08,700 --> 00:18:11,300
我们会把它作为空闲链表的头节点
we would push this onto the head of the free list

292
00:18:11,300 --> 00:18:13,100
然后更新next指针
and then update the next pointer

293
00:18:13,100 --> 00:18:15,066
事实就是如此
and that's exactly what happens

294
00:18:15,400 --> 00:18:18,166
如果我们释放了第四个slot
if we were to free this fourth slot

295
00:18:18,733 --> 00:18:22,699
空闲列表的头指针现在指向第四个slot
the freelist head pointer now points to the fourth slot

296
00:18:22,700 --> 00:18:29,533
往第四个slot中放了一个next指针，指向第三个slot
and a next pointer is placed inside the fourth slot that points to the third slot

297
00:18:30,366 --> 00:18:34,333
然后第三个slot的next指针为空
and then the next pointer of the third slot is null

298
00:18:34,366 --> 00:18:36,733
表示链表结束
indicating the end of the linked list

299
00:18:37,800 --> 00:18:40,566
如果我们要分配一个对象
if we were to then allocate an object

300
00:18:40,733 --> 00:18:43,199
我们只需取出空闲列表的头节点
we would simply pull from the head of the free list

301
00:18:43,200 --> 00:18:45,466
这将返回第四个slot
and that would return the fourth slot 

302
00:18:45,500 --> 00:18:47,533
我们之后会把内核对象放在那里
where we would place that kernel object

303
00:18:47,666 --> 00:18:50,966
我们会更新空闲列表的头指针，为头节点的next
we would update the head of the free list to be head next 

304
00:18:50,966 --> 00:18:53,266
于是下次返回的空闲列表的头节点
and so the head of the free list returns

305
00:18:53,266 --> 00:18:55,199
将是这个第三个slot
to become that third slot

306
00:18:57,166 --> 00:19:01,266
考虑这个链表时，有一个重要的区别
one important difference to be aware of when thinking about this linked list 

307
00:19:01,266 --> 00:19:03,166
就是next指针的位置
is the location of the next pointer

308
00:19:03,533 --> 00:19:06,333
tcache中单链表
when we took a look at tcaches single linked list

309
00:19:06,333 --> 00:19:09,866
的next指针位于被释放内存的起始位置
the next pointers were located at the beginning of the freed allocation

310
00:19:10,333 --> 00:19:11,533
而在内核堆中
with the kernel heap

311
00:19:11,533 --> 00:19:15,399
next指针位于释放slot的中间位置
the next pointer is located midway through the freed slot

312
00:19:15,500 --> 00:19:16,500
在这个例子中
so in this example

313
00:19:16,500 --> 00:19:21,900
我们使用的slot的大小是0x100B，即256B
we're working with slots of size hex 100 bytes or 256 bytes

314
00:19:22,333 --> 00:19:27,566
next指针位于开头偏移0x80B处
so the next pointer would be offset 128 bytes or hex 80 bytes 

315
00:19:27,566 --> 00:19:30,933
即slot开头偏移128B处
from the beginning of the free slot

316
00:19:31,800 --> 00:19:34,466
这样做是为了防止
this is done to hopefully prevent 

317
00:19:34,466 --> 00:19:40,099
小的越界写入损坏next指针
the scenario where a small out of bounds write would corrupt the next pointer

318
00:19:41,866 --> 00:19:46,533
可以通过kmem_cache_create函数创建cache
caches can be created via the kmem_cache_create function

319
00:19:46,600 --> 00:19:49,866
你可能想为一个内核对象创建专门的cache
now you may want to create a dedicated cache for a kernel object

320
00:19:49,933 --> 00:19:54,299
因为你需要分配大量这样的对象
because you know you're going to suddenly be needing to allocate a large number of these objects

321
00:19:54,300 --> 00:19:57,000
你想要有一定的性能属性
and you want to have certain performance characteristics

322
00:19:57,066 --> 00:20:03,166
因此你为该特定的内核对象大小设置专用cache
and so you'll find more reliability by having a dedicated cache for that specific kernel objects size

323
00:20:03,466 --> 00:20:04,699
它也可以用来
it can also be used to

324
00:20:04,800 --> 00:20:09,600
将这些对象与在通用cache中找到的对象隔离开来
isolate those objects from the objects that are found on the general purpose cache

325
00:20:10,366 --> 00:20:13,066
要从一个专用cache中分配内存
now in order to allocate from a specific cache

326
00:20:13,066 --> 00:20:15,666
要使用kmem_cache_alloc函数
you use the kmem_cache_alloc function

327
00:20:15,700 --> 00:20:19,566
这能让你从指定cache中获取一个对象
this allows you to specify the cache from which you are obtaining an object from

328
00:20:20,100 --> 00:20:22,166
因为cache有一个已知的大小
since caches have a known size

329
00:20:22,166 --> 00:20:26,399
所以你不用指定要获取的对象的大小
you actually do not specify the size of the object you are trying to obtain

330
00:20:26,400 --> 00:20:28,900
因为它已经被cache定义了
because it's already defined by the cache itself

331
00:20:30,266 --> 00:20:33,733
然而，常见的情况是使用kmalloc
the common case however is to use kmalloc

332
00:20:33,900 --> 00:20:36,466
它用于常规内核堆分配
which is used for general kernel allocations

333
00:20:36,466 --> 00:20:38,533
如果我们看一下这里的函数声明
and if we look at the function signature here

334
00:20:38,533 --> 00:20:42,133
kmalloc与用户空间的malloc非常相似
kmalloc is very similar to userland malloc

335
00:20:42,133 --> 00:20:45,733
kmalloc接受一个size和flags参数
kmalloc takes a size as well as a flags parameter

336
00:20:46,166 --> 00:20:47,799
kmalloc会
now what kmalloc does

337
00:20:47,800 --> 00:20:50,500
会使用通用cache
is it will use the general purpose caches

338
00:20:50,866 --> 00:20:54,899
它会根据请求的大小选择一个合适的
and it will choose which one is appropriate based upon the requested size

339
00:20:55,266 --> 00:20:58,766
这些通用cache有一个命名约定
now these general purpose caches have a naming convention

340
00:20:59,133 --> 00:21:01,066
比如kmalloc-8k
such as kmalloc-8k 

341
00:21:01,233 --> 00:21:05,799
其中8K是该cache提供的slot的大小
where 8K is the size of the slot that is offered by that cache

342
00:21:05,800 --> 00:21:08,100
所以有kmalloc-256
so there is a kmalloc-256 

343
00:21:08,166 --> 00:21:09,666
kmalloc-512
there's a kmalloc-512

344
00:21:09,900 --> 00:21:14,100
kmalloc-多种slot大小
there's a kmalloc for a large number of slot sizes

345
00:21:14,266 --> 00:21:17,899
当你调用kmalloc
and when you call kmalloc in the general sense here

346
00:21:18,133 --> 00:21:21,433
它会使用这些通用cache中的一个
it's going to use one of these general purpose caches 

347
00:21:21,433 --> 00:21:23,933
来完成分配请求
to fulfill that allocation request

348
00:21:24,666 --> 00:21:26,799
最近增加的一个flag
now one of the more recent additions

349
00:21:26,933 --> 00:21:30,599
GFP_KERNEL_ACCOUNT标志
is the addition of the GFP_KERNEL_ACCOUNT flag

350
00:21:30,866 --> 00:21:33,299
这是专门用来标记
this is used specifically to note 

351
00:21:33,466 --> 00:21:38,633
分配内存将放一些不一定可信的内核对象
that the allocation is going to be some kernel object that isn't necessarily trusted

352
00:21:38,766 --> 00:21:43,766
比如，包含用户空间数据的内核对象
like say it's some kernel object that also contains userland data

353
00:21:43,966 --> 00:21:47,933
我们会把用户空间数据复制到这个内核对象中
we're going to copy userland data into this kernel object

354
00:21:48,333 --> 00:21:51,366
通过指定GFP_KERNEL_ACCOUNT
by specifying GFP_KERNEL_ACCOUNT

355
00:21:51,800 --> 00:21:55,700
这些分配请求将去专门的cache中找
these allocations will go to a dedicated cache

356
00:21:55,700 --> 00:21:59,900
这些专门的cache差不多镜像了通用cache
that kind of mirrors the general purpose kmalloc caches

357
00:22:00,333 --> 00:22:03,199
所以不会去，比如kmalloc-8k中分配
so instead of going to for instance kmalloc-8k

358
00:22:03,200 --> 00:22:07,466
而是去叫kmalloc-cg-8k的cache中分配
it would go to a cache named kmalloc-cg-8k

359
00:22:07,466 --> 00:22:10,666
这就是不可信的分配可以存放的地方
and this is where these untrusted allocations can residen

360
00:22:11,166 --> 00:22:14,366
这也是为了进一步分离
this is again to further separate concerns

361
00:22:14,666 --> 00:22:16,566
纯粹的内核数据
data that is purely in the kernel 

362
00:22:16,666 --> 00:22:18,666
放入通用cache
can go into general purpose caches

363
00:22:18,666 --> 00:22:24,366
可能受内核之外因素影响的数据
and data that may be influenced by factors outside of the kernel

364
00:22:24,566 --> 00:22:28,699
放入kmalloc-cg系列cache
can go to this kmalloc-cg series of caches

365
00:22:30,466 --> 00:22:31,133
作为收场
to wrap up 

366
00:22:31,133 --> 00:22:36,866
我们看一下dojo系统上一些可用的cache
let's take a look at some of the caches that are available on the dojo system

367
00:22:37,500 --> 00:22:41,933
这里，我已经ssh连入dojo环境
so over here I am already ssh into the dojo

368
00:22:41,933 --> 00:22:44,899
并且我已经运行了VM connect命令
and I have already ran the VM connect command

369
00:22:44,900 --> 00:22:49,200
所以我在挑战题实例中的一个虚拟机上
so I am inside a VM on my challenge instance

370
00:22:50,366 --> 00:22:57,766
如果我运行sudo cat /proc/slabinfo
if I were to run the command sudo cat /proc/slabinfo

371
00:22:58,466 --> 00:23:01,333
我们应该能看到相当多的输出
we should see quite a bit of output here 

372
00:23:01,333 --> 00:23:01,999
确实如此
and we do

373
00:23:03,200 --> 00:23:06,600
我们去到它的开头
we go up to the beginning of it

374
00:23:08,200 --> 00:23:13,166
我们能看到slabinfo version 2.1
what we'll see here is slab info version 2.1

375
00:23:13,800 --> 00:23:15,766
然后是表头信息
we then have some header information

376
00:23:16,133 --> 00:23:21,299
我们看看这些输出都是什么
so let's take a look and see what this output is

377
00:23:21,933 --> 00:23:25,066
第一列是cache的名称
the first column is the name of the cache

378
00:23:25,166 --> 00:23:26,166
我们看到
and so we see that 

379
00:23:26,233 --> 00:23:30,399
有些cache以特定的内核对象命名
there are caches that are named after specific kernel objects

380
00:23:30,400 --> 00:23:33,333
例如，我们有这个kheap_obj
we have for instance this kheap_obj or

381
00:23:33,400 --> 00:23:36,333
或这个ip6-frags对象
this ip6-frags object

382
00:23:36,600 --> 00:23:40,100
所以肯定有一些对象有专门的cache
so there are definitely objects that have dedicated caches

383
00:23:40,166 --> 00:23:41,899
如果我们向下滚动
and if we were to scroll down

384
00:23:43,066 --> 00:23:46,999
接近这个输出的底部
closer to the bottom of this output

385
00:23:47,666 --> 00:23:48,699
我们会看到
we will see

386
00:23:50,133 --> 00:23:52,933
下面是通用cache
here are the general purpose caches

387
00:23:52,933 --> 00:23:53,766
我们有
so we have

388
00:23:53,900 --> 00:24:00,000
例如kmalloc-8k或kmalloc-256 kmalloc-96
for instance that kmalloc-8k or kmalloc-256 kmalloc-96

389
00:24:00,366 --> 00:24:07,766
这些是用于kmalloc的通用cache
these are general purpose caches that are used for kmalloc 

390
00:24:07,966 --> 00:24:09,999
如果只是一个常规内存分配请求
if it's just like a general allocation

391
00:24:10,000 --> 00:24:13,666
我们没有指定特定的cache
we aren't specifying a specific cache

392
00:24:13,666 --> 00:24:16,066
它就会用这些通用cache中的一个
it's going to use one of these kind of generic ones

393
00:24:16,600 --> 00:24:21,366
如果使用了GFP_KERNEL_ACCOUNT标志
now I said if we use the GFP_KERNEL_ACCOUNT flag 

394
00:24:21,466 --> 00:24:25,533
那么kmalloc会使用这些cache的一个
then kmalloc will use one of these caches here 

395
00:24:25,533 --> 00:24:28,733
kmalloc-cg跟着大小
where it's kmalloc-cg and then a size

396
00:24:29,066 --> 00:24:32,966
我们看到这些cache也存在于这个系统中
and we see these caches also exist on this system

397
00:24:34,466 --> 00:24:36,333
现在我们回到最上面
now if we go back up to the top

398
00:24:36,466 --> 00:24:37,866
接着看表头
let's check the header data

399
00:24:38,533 --> 00:24:44,699
我们可以看到cache中存在的对象数量
we get to see the number of objects that exist within that cache

400
00:24:45,800 --> 00:24:47,533
对象的大小
the size of the object

401
00:24:48,366 --> 00:24:52,466
还有每个slab能装的对象数量
as well as number of objects per slab

402
00:24:53,300 --> 00:24:55,600
以及每个slab占用的内存页数
and pages per slab

403
00:24:55,700 --> 00:25:00,666
我们说的slab并不等同于一个内存页
as we call a slab is not necessarily equal to a page

404
00:25:00,666 --> 00:25:05,766
一个slab可以占用多个连续内存页
a slab can have a backing region of memory that is multiple pages

405
00:25:05,900 --> 00:25:08,600
我们可以看到第二个cache就是这种情况
and we see that is the case here on this second cache

406
00:25:08,600 --> 00:25:11,466
这个9p-fcall-cache
for this 9p-fcall-cache

407
00:25:12,600 --> 00:25:14,300
看起来
it looks like the objects

408
00:25:14,300 --> 00:25:17,666
从这个cache返回的对象非常大
that are returned from this cache are quite large in size

409
00:25:17,666 --> 00:25:20,133
大约131,000字节
about 131,000 bytes

410
00:25:20,300 --> 00:25:24,600
它的每个slab上只有一个对象
and so there's one object per slab

411
00:25:24,766 --> 00:25:29,966
对于这个cache，一个slab占64页
that a slab is 64 pages for this particular cache

412
00:25:29,966 --> 00:25:33,399
我不知道这个内核对象是什么
I have no idea what this kernel object is 

413
00:25:34,100 --> 00:25:36,200
这个cache要支持的对象
that the cache is meant to support

414
00:25:36,200 --> 00:25:38,566
但它显然很大
but it's clearly quite large

415
00:25:40,266 --> 00:25:44,299
如果我们看一下表头的最右边
if we look over to the far right of the header data

416
00:25:44,300 --> 00:25:46,000
这个绕到下一行开头了
it looks like this does wrap around

417
00:25:46,366 --> 00:25:48,866
另一条我觉得很有趣的信息
the other piece of information that I find quite interesting 

418
00:25:48,866 --> 00:25:50,166
是slab的数量
is the number of slabs

419
00:25:50,166 --> 00:25:54,133
这里的倒数第二个值
so this is going to be the second to the end value here

420
00:25:54,500 --> 00:25:55,466
我们看到
and so we see right now 

421
00:25:55,566 --> 00:25:59,666
有些cache实际上没有slab
there's some caches that actually have zero slabs right

422
00:26:00,066 --> 00:26:03,333
它们有0个对象
they have 0 objects 

423
00:26:04,166 --> 00:26:08,399
然后它们有0个slab
and in turn they have 0 slabs

424
00:26:09,333 --> 00:26:10,633
这也说的通
which makes some sense

425
00:26:11,333 --> 00:26:18,566
如果不需要用它，为啥要占用slab呢，对吧
why keep the slab around if it doesn't need to be used for anything

426
00:26:19,200 --> 00:26:21,333
我们可以划到下面这里看看
and we can scroll down here and we see

427
00:26:21,333 --> 00:26:25,966
有些cache有不止一个slab
well there are some caches that have more than one slab

428
00:26:26,500 --> 00:26:30,466
以nfs_read_data为例
this nfs_read_data for instance

429
00:26:30,700 --> 00:26:34,133
每个slab占2页
it is two pages per slab

430
00:26:34,566 --> 00:26:37,799
它有4个slab
and it has four slabs

431
00:26:37,800 --> 00:26:40,366
也就是说
so that means that there's eight pages

432
00:26:40,566 --> 00:26:45,733
为这个nfs_read_data cache预备了8页内存
backing the data of this nfs_read_data cache

433
00:26:47,000 --> 00:26:53,366
它有36个对象，每个大小为896B
it has 36 objects of 896 bytes in size

434
00:26:54,866 --> 00:26:58,799
这很有趣
and so this is very interesting 

435
00:26:58,933 --> 00:27:04,366
这是一个很容易的，查看系统上的cache的方法
and this is an easy way to kind of see these caches on your system

