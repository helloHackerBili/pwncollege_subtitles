1
00:00:01,300 --> 00:00:04,800
我们看过了FILE结构体正常是怎么用的
so now that we've seen how file structure used during normal operation

2
00:00:04,900 --> 00:00:07,600
现在探讨一下FILE结构是如何被滥用
let's explore how file structs can be abused

3
00:00:07,600 --> 00:00:09,800
实现任意读或任意写
to gain arbitrary read or write

4
00:00:11,066 --> 00:00:12,366
之前我们提到过
previously we mentioned that 

5
00:00:12,433 --> 00:00:14,766
FILE结构体内有8个指针
there are 8 pointers inside of the file struct

6
00:00:14,833 --> 00:00:17,999
它们主要用于维持缓冲区状态
that are predominantly used to maintain a buffer state

7
00:00:18,200 --> 00:00:25,066
这个缓冲区位于程序调用的字符串函数(如fwrite)
and this buffer sits in between the program calls to the string functions such as fwrite

8
00:00:25,266 --> 00:00:27,733
与底层系统调用write之间
and the underlying syscall write

9
00:00:28,600 --> 00:00:31,300
或者是底层系统调用read
or between the underlying syscall read

10
00:00:32,166 --> 00:00:38,299
程序调用对应的字符串函数fread
and the program calling the corresponding string function fread

11
00:00:39,333 --> 00:00:43,166
这些指针指示着缓冲区的状态
and these pointers indicate the state of that buffer

12
00:00:43,200 --> 00:00:45,466
这些指针
and so the state of the pointers

13
00:00:45,533 --> 00:00:49,033
确定是否需要，例如，刷新缓冲区
determines whether or not we need to for instance flush out a buffer 

14
00:00:49,033 --> 00:00:52,133
或者缓冲区是否需要重新填充
or whether that buffer needs to get refilled

15
00:00:52,133 --> 00:00:54,599
我们需要调用read并用新数据填充它
we need to call read and fill it in with new data

16
00:00:54,600 --> 00:00:55,900
如果它是一个读缓冲区的话
if it's a read buffer

17
00:00:56,933 --> 00:01:00,333
我们还提到了在FILE结构体中有一个flags字段
now we also mentioned that there's a flags field in the file struct

18
00:01:01,466 --> 00:01:04,566
这有一些你可以在flags字段中找到的值
some of the values that you can find in the flags field are shown here

19
00:01:05,100 --> 00:01:07,933
flags字段的几个高有效位一直都是
the upper bits of the flags field will always contain

20
00:01:07,966 --> 00:01:10,999
常量0xFBAD
the magic number 0xFBAD 

21
00:01:11,433 --> 00:01:13,866
所以当你第一次调用fopen
and so when you first call fopen

22
00:01:13,966 --> 00:01:17,499
你会在flags的高有效位看到这个
this is what you'll find in the flags field for the upper bits

23
00:01:17,900 --> 00:01:21,533
较低有效位决定了该文件的操作模式
the lower bits determine the kind of the mode of operation for that file

24
00:01:21,866 --> 00:01:24,199
我们可以设置成不设缓冲区
so we could have a file that's unbuffered

25
00:01:24,266 --> 00:01:25,499
在这种情况下
in which case

26
00:01:25,600 --> 00:01:29,600
我们不会利用到之前描述的缓冲
we wouldn't even take advantage of that buffering that we described so far

27
00:01:30,466 --> 00:01:33,166
还有操作模式
there are also modes of operation

28
00:01:33,400 --> 00:01:36,100
有不能读或不能写的设置
where you cannot read or cannot write

29
00:01:36,766 --> 00:01:37,866
它们存在的原因是
and the reason for that

30
00:01:38,100 --> 00:01:42,333
当你考虑到这些记录着缓冲区状态的指针
is when you think about the pointers that exist to track the buffer state

31
00:01:42,766 --> 00:01:46,899
如果你可以随意读写任何文件
if you could just arbitrarily read and write on any file

32
00:01:47,533 --> 00:01:50,199
这些指针很容易混淆
it would be very easy for these pointers to get mixed up

33
00:01:50,300 --> 00:01:52,333
然后进入非法状态
and get into an invalid state

34
00:01:52,866 --> 00:01:58,199
所以在flags中存在显式的标志位
and so there are explicit mode bits that are exist in the flag

35
00:01:58,333 --> 00:02:00,933
来拒绝读或写
that deny reading or deny writing

36
00:02:01,700 --> 00:02:05,033
这并不是一个flags值的完整列表
now this is not an exhaustive list of values that can be found in the flag

37
00:02:05,100 --> 00:02:07,633
所以一定要看看幻灯片底部的链接
so definitely check out the link at the bottom of the slide 

38
00:02:07,900 --> 00:02:09,866
你可以在那里找到源代码
where you can find the source code

39
00:02:09,866 --> 00:02:12,466
然后查看所有可能的值
and see all the possible values yourself

40
00:02:13,800 --> 00:02:16,900
还有一个我们之前没有提到的成员变量
now one of the other fields that we did not mention

41
00:02:17,000 --> 00:02:19,200
但现在绝对值得一提
but is definitely worth mentioning now

42
00:02:19,333 --> 00:02:21,466
就是_fileno 文件描述符变量
is the file number field

43
00:02:21,466 --> 00:02:23,099
在FILE结构体中
so within the file struct

44
00:02:23,100 --> 00:02:24,900
还有一个_fileno
there is also a file number

45
00:02:24,933 --> 00:02:28,133
这个变量保存着文件描述符
and this file number holds the file descriptor

46
00:02:29,266 --> 00:02:33,499
它用来记录目标文件
that exist there underpins kind of the file

47
00:02:34,166 --> 00:02:36,533
所以当我们要写入文件时
so when we write to a file

48
00:02:36,600 --> 00:02:37,700
先填充了这个缓冲区
it fills this buffer

49
00:02:37,700 --> 00:02:39,100
缓冲区被填满时
when the buffer is filled

50
00:02:39,166 --> 00:02:41,166
我们要flush数据到文件中
we need to flush it and write it out

51
00:02:41,666 --> 00:02:42,799
我们调用write时
and when we call write

52
00:02:43,000 --> 00:02:45,266
还是需要与文件描述符交互
we still need to interact with a file descriptor

53
00:02:45,566 --> 00:02:50,933
所以与这个文件交互时要用到的文件描述符
so the file descriptor that will be used when interacting with this file

54
00:02:51,066 --> 00:02:54,499
就是一个数字，存储在FILE结构体中
is stored just as a number in the file struct

55
00:02:55,500 --> 00:02:56,566
记住这一点
keep that in mind

56
00:02:58,166 --> 00:03:01,666
现在我们描述一下，我们想要获得任意的读写
now we describe that we want to gain arbitrary read and write

57
00:03:01,733 --> 00:03:05,099
我们考虑一下这个流库是如何工作的
when we think about how the kind of streaming library works

58
00:03:05,100 --> 00:03:06,100
它做了什么
what does it do

59
00:03:06,600 --> 00:03:09,666
它要么从文件读到内存
well it either reads from a file to memory

60
00:03:09,933 --> 00:03:12,966
读到在内存中的缓冲区
reads into that buffer that's located in memory

61
00:03:13,166 --> 00:03:16,966
要么从内存中的缓冲区向外写入文件
or it writes from the buffer in memory out to a file

62
00:03:17,900 --> 00:03:21,800
是否会读，以及读什么
and whether or not it reads and what it reads

63
00:03:21,800 --> 00:03:24,500
或者是否会写，以及写什么
or whether or not it writes and what it writes

64
00:03:24,500 --> 00:03:28,766
完全由这些缓冲区指针的状态决定
is determined entirely by the state of these buffer pointers

65
00:03:28,933 --> 00:03:32,299
所以如果我们可以覆盖，或控制这些缓冲区指针
so if we can overwrite or gain control of these buffer pointers

66
00:03:32,300 --> 00:03:35,566
我们就可以控制读写哪里
we can control where the read or write occurs

67
00:03:35,633 --> 00:03:37,266
以及是否读写
and whether it occurs

68
00:03:39,733 --> 00:03:43,766
要将文件读到任意内存
to read from a file to arbitrary memory

69
00:03:44,500 --> 00:03:47,733
我们必须让缓冲区进入一个特定的状态
we have to get the buffer into a very specific state

70
00:03:48,966 --> 00:03:50,833
我们必须设置flags值
we have to set the flag values

71
00:03:50,900 --> 00:03:54,066
使文件允许读取
such that the file allows for reading

72
00:03:54,500 --> 00:03:55,733
这说的通
that makes some sense

73
00:03:56,166 --> 00:04:00,266
要将read_ptr设置为read_end
we need to set the read_ptr equal to the read_end

74
00:04:01,500 --> 00:04:03,833
我们还要设置buf_base
we also need to set the buf_base

75
00:04:03,833 --> 00:04:06,966
指向我们想要读到的位置
to be the location that we want to read into

76
00:04:07,900 --> 00:04:13,200
buf_end必须是将要读取的结束点
the buf_end must be the end point of where we are going to read

77
00:04:14,100 --> 00:04:14,866
最后
and finally 

78
00:04:15,066 --> 00:04:17,099
buf_end 减去 buf_base
buf_end minus buf_base 

79
00:04:17,100 --> 00:04:21,700
是缓冲区的大小，对于所有敏感的目标
which is the size of the buffer for all intensive purposes

80
00:04:21,866 --> 00:04:22,999
它必须大于
must be larger than

81
00:04:23,100 --> 00:04:25,533
我们想要读取的字节数
the number of bytes that we want to read

82
00:04:26,100 --> 00:04:29,466
因为如果缓冲区相较于要读入的东西不够大
because if the buffer isn't big enough to read something in

83
00:04:30,066 --> 00:04:33,399
库就会分配一个足够大的新缓冲区来执行此操作
the library will allocate a new buffer that is large enough to do so

84
00:04:34,066 --> 00:04:34,999
所以我们要确保
so we want to make sure 

85
00:04:35,100 --> 00:04:40,300
buf_end - buf_base足够执行这个读操作
that buf_end minus buf_base is big enough to perform this read

86
00:04:44,166 --> 00:04:48,699
这是正常操作时读的样子
so this is what reading looks like during normal operation

87
00:04:49,533 --> 00:04:51,766
read_base等于read_buf
read_base is equal to read buff

88
00:04:52,100 --> 00:04:54,200
read_end等于buf_end
read_end is equal to buf_end

89
00:04:54,400 --> 00:04:56,466
read_ptr在中间
and read_ptr is somewhere in the middle

90
00:04:56,466 --> 00:04:57,866
因为我们已经读过了一些东西
because we've read something

91
00:04:57,866 --> 00:04:59,333
还有东西要读
and we still have ways to go

92
00:05:00,166 --> 00:05:01,933
那么发生什么
so what happens

93
00:05:01,933 --> 00:05:03,899
或者说我们要如何处理这些指针
or what do we have to do with these pointers

94
00:05:03,900 --> 00:05:05,700
让它们进入一种状态
to get them into a state

95
00:05:05,700 --> 00:05:08,666
使我们能将数据读到我们选择的位置
where we can read into a location of our choosing

96
00:05:09,966 --> 00:05:11,866
这里有很多要求
there were a lot of requirements here

97
00:05:12,566 --> 00:05:15,866
我们可以一条一条的过
so we could go line by line and move them around and see

98
00:05:15,866 --> 00:05:18,533
但实际上我们不需要这么做
but in practice we don't have to actually do that

99
00:05:19,000 --> 00:05:21,666
它可以是这样的
instead it can just look like this

100
00:05:22,933 --> 00:05:26,366
每个指针都可以被设置为null
every pointer can get set to null

101
00:05:26,700 --> 00:05:30,400
除了buf_base和buf_end
except for buf_base and buf_end

102
00:05:31,866 --> 00:05:36,266
buf_base指向我们想要读入的位置的开头
buf_base should point to the beginning of where we want to read into

103
00:05:36,600 --> 00:05:43,600
buf_end指向我们要读入的位置的末尾
buf_end should point to the end of where we want to read into

104
00:05:44,400 --> 00:05:47,333
这就可以满足所有的条件
and this will satisfy all of the requirements

105
00:05:49,133 --> 00:05:51,133
我们来看看实际情况
so let's see that in action

106
00:05:51,900 --> 00:05:55,800
这里有一个有漏洞的c程序
so right here I have a vulnerable C program

107
00:05:55,800 --> 00:05:58,700
我会很快地看一遍，以便理解发生了什么
will run through it real quick to understand what's going on

108
00:05:59,566 --> 00:06:02,399
我们有一个全局win变量，默认设置为0
we have a global win variable by default it set to 0

109
00:06:02,566 --> 00:06:05,099
我们有一个win函数，会打印出你赢了
we have a win function that prints out you win

110
00:06:05,100 --> 00:06:06,766
如果它碰巧被调用的话
if it happens to get called

111
00:06:07,133 --> 00:06:08,099
在main中
inside of main

112
00:06:08,100 --> 00:06:12,300
我们直接泄露了win变量的地址
we are just given a leak of the win_var address

113
00:06:12,666 --> 00:06:14,199
win_var的位置
the location of win_var

114
00:06:15,600 --> 00:06:19,300
程序本身将调用fopen
the program itself is going to call fopen 

115
00:06:19,433 --> 00:06:21,933
打开一个名为secret_file的文件
and open a file named secret_file

116
00:06:22,766 --> 00:06:24,599
打开它以供读取
it's going to be open for reading

117
00:06:26,166 --> 00:06:30,466
然后立即给了我们覆盖FILE结构体的能力
we are then immediately given the ability to overwrite this file pointer

118
00:06:31,600 --> 00:06:37,133
然后程序会fread这个文件
the program will then call fread on that file here

119
00:06:38,266 --> 00:06:42,199
它将读入10个大小为1字节的成员
and it is going to read in 10 members of size 1

120
00:06:42,266 --> 00:06:44,199
所以它会读取10个字节
so it's going to read in 10 bytes

121
00:06:44,233 --> 00:06:46,366
它会把它读入缓冲区
and it's going to read it into a buffer

122
00:06:46,466 --> 00:06:49,499
缓冲区就在栈上
that is sitting here on the stack

123
00:06:49,733 --> 00:06:51,999
如果win_var碰巧发生了变化
in the event win_var happens to have changed

124
00:06:52,000 --> 00:06:53,000
就会调用win函数
will call win

125
00:06:53,000 --> 00:06:55,066
否则程序将退出
otherwise the program will exit

126
00:06:55,400 --> 00:06:56,966
如果我们编译这个
so if we compile this

127
00:06:58,333 --> 00:06:59,333
然后运行它
and run it

128
00:07:00,666 --> 00:07:01,799
它会直接退出
it exits cleanly 

129
00:07:01,900 --> 00:07:04,566
如果我们给它一个足够长的值
and if we give it a long enough value

130
00:07:04,566 --> 00:07:05,866
它会发生段错误
it will seg fault

131
00:07:06,766 --> 00:07:12,199
我们来写一下利用脚本
so let's write and exploit for this

132
00:07:12,600 --> 00:07:15,766
我们先开始一些样板代码
so we're gonna start off with some boiler plate code

133
00:07:18,966 --> 00:07:20,699
导入pwn
from pwn import *

134
00:07:20,966 --> 00:07:24,199
设置架构为amd64
context arch amd64

135
00:07:24,800 --> 00:07:27,433
创建一个进程p
we're going to have some process p

136
00:07:27,433 --> 00:07:30,799
它与a.out交互
that is going to interact with a.out

137
00:07:31,133 --> 00:07:32,633
我要做的第一件事是
and the first thing I want to do is

138
00:07:32,666 --> 00:07:35,733
获得泄露的信息
I want to grab the leak

139
00:07:36,400 --> 00:07:42,600
所以我们会recv_until到
so we will receive until at

140
00:07:43,300 --> 00:07:50,900
然后win_var_leak等于p.recvline
we will then say win_var_leak is equal to p receive line 

141
00:07:51,033 --> 00:07:52,766
我们去掉换行符
we drop the new line

142
00:07:59,266 --> 00:08:02,799
以16进制数读入
and we read it in as hex

143
00:08:02,966 --> 00:08:04,299
接下来我们要做的是
so next thing that we want to do is 

144
00:08:04,300 --> 00:08:08,766
我们想覆盖FILE结构体
we want to overwrite the file struct

145
00:08:10,800 --> 00:08:12,333
那么我们要做什么呢
and so what do we do there

146
00:08:12,466 --> 00:08:16,866
pwntools有一个非常有用的功能
well pwntools has an extremely helpful feature

147
00:08:16,866 --> 00:08:18,866
我要马上用它
that I'm just going to use right out the gate

148
00:08:20,800 --> 00:08:24,066
你可以调用FileStructure
so you can call file structure

149
00:08:24,133 --> 00:08:30,599
这会返回一个python对象，它能表示FILE结构体
and this will give you a Python object that represents the file struct

150
00:08:30,700 --> 00:08:33,900
我们在ipython中看一下
let's take a look at that in ipython here

151
00:08:34,266 --> 00:08:37,699
这样你们就能明白我在说什么了
so you can kind of see what I'm talking about

152
00:08:39,300 --> 00:08:42,100
我们写一个一样的东西
so we're gonna just write that exact same thing

153
00:08:46,066 --> 00:08:50,799
能看到这个FP对象
and we see that this FP object has all of the same members 

154
00:08:50,966 --> 00:08:54,899
有和FILE结构体一样的成员变量
as the file struct that is used by the streams library

155
00:08:55,300 --> 00:08:57,666
我们可以设定值
and we can set values

156
00:09:04,700 --> 00:09:07,700
然后能在对象中看到它
then we see that is reflected in the object

157
00:09:08,100 --> 00:09:11,200
如果我想导出这个FILE结构体的字节数据
now if I want to dump out the bytes of this file struct 

158
00:09:11,266 --> 00:09:13,266
我们可以调用bytes
we can call bytes on it

159
00:09:13,666 --> 00:09:16,766
这就是原始字节，它能放到payload中
and there is the raw bytes that would be in a payload

160
00:09:17,700 --> 00:09:21,466
我们可以这样使用这个文件结构对象
and so we can use this file structure object in this way

161
00:09:21,466 --> 00:09:23,966
前提是如果我们需要自定义一些东西
if we need to set up something custom and specific

162
00:09:24,400 --> 00:09:29,600
但利用文件结构体有一些常见的目的
but there's a couple common things that are done with file structure exploits

163
00:09:29,866 --> 00:09:32,966
比如我们现在讨论的任意读和写
such as the reading write that we're talking about right now

164
00:09:33,533 --> 00:09:37,966
所以我们还可以更简单
and so we can actually do one thing easier than this

165
00:09:38,533 --> 00:09:41,333
我们需要发送一个payload
we're going to need to send some kind of a payload

166
00:09:44,166 --> 00:09:51,366
这个payload的定义只需通过fp.read
all this payload can be defined by doing a file structure read

167
00:09:51,666 --> 00:09:55,099
我们想读到win_var_leak
and we want to read to the win_var_leak

168
00:09:56,400 --> 00:10:01,966
下一个参数是想要读取的字节长度
and the next value is the number of bytes that I want to read

169
00:10:02,300 --> 00:10:06,533
这个值需要大一点
now this value needs to be larger

170
00:10:07,166 --> 00:10:09,199
要比读取的值大
than the fread value

171
00:10:10,866 --> 00:10:13,266
要读取的值长度是10
so the fread value is 10

172
00:10:14,500 --> 00:10:16,400
我们就设一个20吧
so let's set this to 20

173
00:10:19,366 --> 00:10:21,766
然后执行p.interactive
then we'll do a p.interactive

174
00:10:23,133 --> 00:10:24,366
然后调用它
and call it good

175
00:10:25,800 --> 00:10:31,166
我们先给利用脚本可执行权限
so let's make that exploit script executable

176
00:10:36,300 --> 00:10:38,533
运行一下
and let's run it

177
00:10:39,700 --> 00:10:42,000
我们看到了Calling fread
and we see there was calling fread

178
00:10:42,000 --> 00:10:43,733
但这个程序没退出
but the program hasn't exited

179
00:10:43,733 --> 00:10:46,066
现在我阻塞在这个提示这里
right now I'm blocked on the prompt here

180
00:10:46,533 --> 00:10:48,266
那么发生了什么
so what's happening

181
00:10:49,933 --> 00:10:52,399
如果我输入足够多的a
well if I type enough a's

182
00:10:53,166 --> 00:10:55,199
它就会输出“你赢了”
it says you win

183
00:10:57,366 --> 00:10:59,799
为什么要打这些a呢
okay so why did I need to type those a's

184
00:11:02,366 --> 00:11:06,299
因为这个文件结构的默认值中
well the default value for a file structure here

185
00:11:07,900 --> 00:11:10,266
_fileno的值是0
for the file number is 0

186
00:11:11,466 --> 00:11:13,333
如果我们打印出
so if we print out

187
00:11:16,266 --> 00:11:17,499
_fileno
the file number

188
00:11:22,766 --> 00:11:23,866
再运行一次
we run this again

189
00:11:27,566 --> 00:11:30,666
我们看到_fileno是0
we see that the file number is 0 

190
00:11:30,766 --> 00:11:32,299
这表示标准输入
which is going to be standard in

191
00:11:32,566 --> 00:11:34,133
所以对于这个fread
so this fread

192
00:11:35,066 --> 00:11:38,666
尽管代码中的FILE指针
even though this file pointer here in the source

193
00:11:38,900 --> 00:11:42,366
指向打开的secret_file
was opened was opening secret_file

194
00:11:42,900 --> 00:11:44,600
通过修改_fileno
by setting the file number

195
00:11:44,933 --> 00:11:47,866
我们让这个read读取标准输入
we made this read come from standard in

196
00:11:48,900 --> 00:11:53,266
然后不再读入到栈上的这个缓冲区
and then instead of writing to this buffer here that sitting on the stack

197
00:11:54,400 --> 00:11:58,966
我们这样修改这些指针后
we are able to change the pointers such that

198
00:12:01,666 --> 00:12:03,133
让它覆盖了win_var变量
it overwrote this win_var

199
00:12:06,966 --> 00:12:09,566
现在如果你想看它的细节
now if you want to see the specifics of it

200
00:12:09,600 --> 00:12:18,866
我们可以在我们的利用脚本中输出这个文件结构
we can print out the file structure right here in our exploit ahead of time

201
00:12:19,333 --> 00:12:20,966
我们看到发生了什么
and what do we see happened

202
00:12:21,366 --> 00:12:24,233
flags的值并不重要
well the flags value didn't matter 

203
00:12:24,300 --> 00:12:25,266
我们不需要设置它
we didn't have to set it

204
00:12:26,766 --> 00:12:29,366
所有这些指针都被设为0
all of these pointers were set to zero

205
00:12:30,133 --> 00:12:33,933
唯一重要的是buf_base和buf_end
the only ones that mattered were buf_base and buf_end

206
00:12:36,400 --> 00:12:38,766
它们被设置成我们需要的地址
those got set to the address that we need

207
00:12:39,400 --> 00:12:41,200
所以当fread被调用时
so then when fread was called

208
00:12:42,000 --> 00:12:45,333
我们从fileno 0读入
we read from the file number here 0 

209
00:12:45,400 --> 00:12:47,166
所以我们从标准输入读入
so we read from standard in

210
00:12:47,166 --> 00:12:52,899
然后我们读入到这个缓冲区，这个攻击者指定的缓冲区
and we read it in to this buffer this buffer that we defined

211
00:12:53,566 --> 00:12:54,366
很酷
pretty cool

212
00:12:56,100 --> 00:13:01,900
任意写非常类似
so so we can do something very similar here with writing

213
00:13:02,900 --> 00:13:04,700
所以我们有一个需求清单
so we have a list of requirements

214
00:13:04,866 --> 00:13:08,066
我们需要设置flags以允许写入
we need to set the flag value to allow for writing

215
00:13:08,300 --> 00:13:11,100
我们需要将write_base设置为
we need to set the write_base equal to the

216
00:13:11,100 --> 00:13:13,800
我们要写入内存的开头
beginning of memory that we want to write out

217
00:13:14,500 --> 00:13:19,600
write_ptr指向试图写入内存区的末尾
the write_ptr terminates that region of memory that we're trying to write out

218
00:13:20,900 --> 00:13:24,566
因为从write_base到write_ptr的距离
because remember the distance from write_base to write_ptr

219
00:13:24,733 --> 00:13:26,966
在正常的缓冲区中
in a normal functioning buffer

220
00:13:27,100 --> 00:13:29,100
表示已经写入
is the bytes that have already been written

221
00:13:29,100 --> 00:13:31,366
但还没有保存到文件的数据
but haven't been flushed out to the file

222
00:13:31,400 --> 00:13:35,000
我们想定义我们想泄漏的
and so we want to define what we want to leak

223
00:13:35,166 --> 00:13:36,866
或者说我们想写出到文件的
or what we want to write out to the file

224
00:13:37,100 --> 00:13:41,066
在write_base和write_ptr这两个指针之间
in between those two pointers write_base and write_ptr

225
00:13:41,400 --> 00:13:45,666
第四个条件看起来有点武断
now this fourth requirement is a little bit arbitrary

226
00:13:45,733 --> 00:13:47,666
基于我们所展示的
like based upon what we've kind of shown

227
00:13:47,766 --> 00:13:50,233
这些指针在缓冲区的作用
as far as what the pointers do with the buffer

228
00:13:50,366 --> 00:13:54,133
但在实现代码中
but in the implementation

229
00:13:55,466 --> 00:14:01,566
read_end在写缓冲区中，有一种特殊的用途
read_end has kind of a special use case for write buffers

230
00:14:02,300 --> 00:14:04,466
所以我们只能接受
and so we're just kind of accept

231
00:14:04,500 --> 00:14:08,133
read_end必须等于write_base
that read_end must equal write_base

232
00:14:08,266 --> 00:14:10,399
有一个特定的检查
there's a specific check that occurs

233
00:14:10,466 --> 00:14:15,366
我们要确保这个检查返回true
and we want to make sure that this holds true

234
00:14:16,300 --> 00:14:18,866
才能flush缓冲区数据
to cause the buffer to flush

235
00:14:19,666 --> 00:14:21,199
最后一点
and then lastly

236
00:14:22,166 --> 00:14:24,199
buf_end - buf_base
buf_end minus buf_base

237
00:14:24,333 --> 00:14:27,266
必须大于我们想要写入的字节数
must be larger than the number of bytes that we want to write

238
00:14:27,700 --> 00:14:30,400
在实现代码中
again in the implementation

239
00:14:30,400 --> 00:14:34,066
buf_end减去buf_base是预留缓冲区的大小
buf_end minus buf_base is the size of the reserve buffer

240
00:14:34,066 --> 00:14:36,733
所以我们要确保缓冲区足够大
and so we want to make sure that the buffer is big enough 

241
00:14:37,500 --> 00:14:38,533
在理论上
in theory

242
00:14:38,933 --> 00:14:41,566
我们表示的理论上的缓冲区
our theoretical buffer here that we're representing

243
00:14:41,566 --> 00:14:45,999
足够容纳我们要写的东西
is big enough to hold what it is we're trying to write out

244
00:14:46,466 --> 00:14:48,766
所以这个也必须成立
and so that this must hold true as well

245
00:14:49,666 --> 00:14:50,799
在写的情况
in the case of writing

246
00:14:51,400 --> 00:14:54,066
这是正常的缓冲区
so here's our normal operating buffer

247
00:14:54,066 --> 00:14:57,966
我们看到buf_end是结束，buf_base是开始
we see that buf_end is the end buf_base is the beginning

248
00:14:58,000 --> 00:15:01,966
我们需要足够大的缓冲区来容纳我们要写的内容
so we need the buffer to be large enough to hold what we're trying to write

249
00:15:02,600 --> 00:15:05,533
write_base为开始，write_end为结束
write_base is the beginning write_end is the end

250
00:15:05,666 --> 00:15:08,566
write_ptr在中间的某个地方
and write_ptr is chilling somewhere here in the middle

251
00:15:09,066 --> 00:15:10,099
因为我们假设
because we're assuming 

252
00:15:10,233 --> 00:15:15,799
已经向缓冲区写了一些要被flush到文件的数据
that we're in a state where we have written some bytes to the buffer that need to be flushed out

253
00:15:15,966 --> 00:15:19,933
但仍然有空间写入额外的字节
but there's still room to write additional byte

254
00:15:20,733 --> 00:15:25,699
那么要控制这个需要发生什么呢
so what needs to happen in order to control this and

255
00:15:25,933 --> 00:15:29,399
让它写入到我们选择的地址
write out a memory address of our choosing

256
00:15:30,733 --> 00:15:33,799
这并不难
once again it's not that hard

257
00:15:34,166 --> 00:15:39,399
它并不像你最初认为的那样复杂
it's not nearly as complicated as the requirements might make you think initially

258
00:15:40,333 --> 00:15:43,966
我们设置read_end和write_base
if we set read_end and write_base

259
00:15:44,066 --> 00:15:48,133
都指向要写入内存的开头
to the beginning of the memory that we want to write out

260
00:15:49,000 --> 00:15:53,066
将write_ptr置为该值的末尾
we set write_ptr to the end of that value

261
00:15:53,966 --> 00:15:55,733
其他都为零
and everything else to null

262
00:15:57,466 --> 00:16:02,699
我们就可以写出一个secret值或我们选择的值
then we will be able to write out a secret value or a value of our choosing

263
00:16:03,966 --> 00:16:07,099
我们快速看一下
so let's take a quick look at that

264
00:16:08,666 --> 00:16:12,266
这儿有一个有写漏洞的程序
here we have a vulnerable write example

265
00:16:12,900 --> 00:16:14,700
我们有一个全局的secret_message
we have a global secret_message

266
00:16:14,700 --> 00:16:16,200
这是栈上的一个字符串
that is a string on the stack here

267
00:16:16,200 --> 00:16:18,900
就是SECRET_FLAG_VALUE
it just says secret flag value

268
00:16:19,200 --> 00:16:20,366
在main中
inside of main

269
00:16:20,366 --> 00:16:23,999
给我们泄漏了secret_message地址
we are given a leak of the address of secret_message

270
00:16:25,166 --> 00:16:30,599
程序本身将打开/dev/null进行写入
the program itself will open /dev/null for writing

271
00:16:31,433 --> 00:16:32,899
用fopen打开它
just going to open it with fopen

272
00:16:32,966 --> 00:16:36,399
所以我们在这里使用了流函数
so we are using that streams functionality here

273
00:16:36,500 --> 00:16:39,666
它返回一个FILE结构体指针
which returns a file struct pointer

274
00:16:40,500 --> 00:16:44,000
然后就让我们能覆盖这个结构体
we're then allowed to immediately overwrite that file struct

275
00:16:45,366 --> 00:16:51,533
然后程序将fwrite它
the program will then call fwrite on the file pointer

276
00:16:52,000 --> 00:16:56,900
它将读入40个大小为1字节的成员
and it's going to read in 40 members of size 1 

277
00:16:57,033 --> 00:16:59,466
所以它会读取40字节
so it's going to read in 40 bytes

278
00:17:00,666 --> 00:17:01,966
然后它就会退出
and then it will exit

279
00:17:02,200 --> 00:17:07,366
我们在这里编写一个利用脚本
so let's write an exploit script here

280
00:17:08,000 --> 00:17:12,066
我们从样板代码开始
we'll start off with our typical boiler plate

281
00:17:20,333 --> 00:17:22,333
要有一个进程p
we're gonna have some process p

282
00:17:30,333 --> 00:17:32,533
我应该先编译一下这个
I should probably compile this

283
00:17:40,400 --> 00:17:41,966
如果我们运行它
if we run it

284
00:17:43,733 --> 00:17:45,799
与第一个例子非常相似
very similar to the first example

285
00:17:45,800 --> 00:17:48,566
如果我们给它足够的输入，它就会出现段错误
if we give it enough input it will seg fault

286
00:17:49,400 --> 00:17:52,166
我要做的第一件事是捕捉泄漏
now the first thing I want to do is capture the leak

287
00:17:53,166 --> 00:17:56,333
所以我们会recvuntil
so we'll receive until at

288
00:17:57,933 --> 00:18:01,066
然后recvline
then we will receive line

289
00:18:01,200 --> 00:18:02,666
去掉换行符
drop the new line

290
00:18:02,933 --> 00:18:04,766
转成int
convert it to an INT

291
00:18:06,500 --> 00:18:07,233
按16进制解析它
as hex

292
00:18:07,866 --> 00:18:10,199
它就是
and that is going to be

293
00:18:11,333 --> 00:18:15,966
secret_val_leak
the secret_val_leak

294
00:18:16,900 --> 00:18:17,966
现在我们有了这个
now that we have that

295
00:18:18,066 --> 00:18:22,766
我们需要覆盖文件结构体
we need to overwrite the file struct

296
00:18:24,900 --> 00:18:26,966
同样，我们可以使用pwntools
again we can use pwntools

297
00:18:30,966 --> 00:18:34,333
和之前非常类似
and very similar to

298
00:18:35,366 --> 00:18:37,999
之前我们用的fp.read
before we had fp.read

299
00:18:38,300 --> 00:18:40,333
实际上还有一个fp.write
there is in fact an fp.write

300
00:18:40,533 --> 00:18:43,766
我们可以指定写在哪里
where we can specify where we want to write

301
00:18:46,500 --> 00:18:48,400
写多少字节
and then how many bytes

302
00:18:49,166 --> 00:18:53,599
在这个例子中，程序想写40
in this case the challenge wants to write 40

303
00:18:54,966 --> 00:18:57,566
所以这里写60
so we'll write 60 there

304
00:18:59,733 --> 00:19:01,299
这就是我们的payload
that will be our payload

305
00:19:03,100 --> 00:19:07,500
然后我们发送payload
and then we will send the payload

306
00:19:11,166 --> 00:19:13,799
然后开转成交互式会话
have a interactive session

307
00:19:14,866 --> 00:19:15,666
所以
so

308
00:19:17,566 --> 00:19:19,399
我们给这个利用脚本可执行权限
we make the exploit executable

309
00:19:20,500 --> 00:19:22,166
运行这个利用脚本
we run the exploit

310
00:19:22,466 --> 00:19:23,899
我们在这里看到
and we see here that

311
00:19:25,500 --> 00:19:26,500
很抱歉
sorry about that

312
00:19:27,000 --> 00:19:28,000
我们运行这个脚本
we run the exploit 

313
00:19:28,100 --> 00:19:32,633
我们看到秘密值泄露出来了
and we see that the secret value is leaked out 

314
00:19:32,700 --> 00:19:36,100
以及紧跟其后的大量字节
along with a large number of bytes that immediately follow it

315
00:19:38,066 --> 00:19:43,133
所以我们可以构造一个FILE结构体
and so we were able to craft a file structure

316
00:19:43,366 --> 00:19:45,733
它将让这个fwrite调用
that turned this fwrite call

317
00:19:46,533 --> 00:19:53,099
不再将这个缓冲区内容写入到/dev/null
instead of writing this empty buffer to /dev/null

318
00:19:54,133 --> 00:19:56,466
我们可以把它改成
we were able to change it such that

319
00:19:57,200 --> 00:20:02,066
让这个fwrite，输出这个secret_message到屏幕
this fwrite wrote out this secret_message or secret flag value

320
00:20:02,500 --> 00:20:04,866
为了完整起见
and then just for completeness sake

321
00:20:04,900 --> 00:20:13,600
我们也打印出用在payload的文件结构体
let's also print out the file structure here that we used for our payload

322
00:20:15,866 --> 00:20:19,666
我们看到这和之前描述的完全一致
and we see that this follows exactly what was described earlier 

323
00:20:19,900 --> 00:20:22,533
设置了flags
the flag values are set

324
00:20:24,100 --> 00:20:27,400
read_end 等于write_base
read_end equals write_base

325
00:20:28,200 --> 00:20:33,200
然后write_ptr在write_base之后一段距离处
and then the write_ptr is some distance after write_base

326
00:20:33,333 --> 00:20:37,899
这实际上就是这里的60指定的
that's actually what the 60 here is specifying

327
00:20:38,300 --> 00:20:41,166
我说的这个值需要稍大一些
when I say that this value needs to be larger

328
00:20:41,300 --> 00:20:47,700
这是在定义大小
this is defining the size or the distance I should say

329
00:20:48,400 --> 00:20:52,466
或者说write_base和write_ptr之间的距离
between write_base and write_ptr

330
00:20:52,466 --> 00:20:55,366
因为输出的东西
because remember what is actually getting dumped out

331
00:20:55,500 --> 00:20:57,333
是从write_base开始
is starting at write_base

332
00:20:57,333 --> 00:20:59,133
到write_ptr结束
and then ending at write_ptr

333
00:20:59,366 --> 00:21:03,299
这就是这里需要一个size值的原因
and so that's why that size value is needed here

334
00:21:03,666 --> 00:21:05,399
但我们能看到
but we see that 

335
00:21:05,733 --> 00:21:10,566
FILE结构体利用的核心思路非常直接
file structure exploits at their core are pretty straightforward

336
00:21:10,666 --> 00:21:14,866
当使用像pwntools这样的工具时，实现起来也很简单
and relatively simple to pull off when you're using something like pwntools

