1
00:00:00,800 --> 00:00:01,700
在这个视频中
in this video

2
00:00:01,700 --> 00:00:03,000
我们来看看
we're going to take a look at

3
00:00:03,000 --> 00:00:06,333
FILE结构体和标准IO流函数
file structs and the standard io streaming functions

4
00:00:06,500 --> 00:00:07,900
到目前为止
so up until this point

5
00:00:07,900 --> 00:00:09,733
当我们想要与文件交互时
when we've wanted to interact with a file

6
00:00:09,733 --> 00:00:12,666
使用的都是系统调用read和write
we've used the raw syscalls read and write

7
00:00:13,500 --> 00:00:14,766
read和write
now read and write

8
00:00:14,766 --> 00:00:17,400
操作的都是文件描述符
operate on something that's known as a file descriptor

9
00:00:17,600 --> 00:00:18,733
通常
and typically

10
00:00:18,766 --> 00:00:22,266
文件描述符是通过open系统调用获得的
a file descriptor is obtained through the use of the open syscall

11
00:00:22,333 --> 00:00:26,733
比如像这样open /home/hacker/class_notes.txt
so we may do something like open /home/hacker/class_notes.txt

12
00:00:26,933 --> 00:00:29,200
这会返回一个文件描述符
and that's going to return a file descriptor

13
00:00:29,566 --> 00:00:31,766
看看我们的示例代码
now looking at our code example here

14
00:00:31,800 --> 00:00:35,300
可以看到文件描述符是一个整数
we see that the file descriptor is an integer

15
00:00:35,500 --> 00:00:40,266
实际上我们可以printf输出它的值
in fact we can even call printf on that integer to figure out what the value is

16
00:00:40,866 --> 00:00:42,766
大多数时候，在你的代码中
most of the time in your own code

17
00:00:42,766 --> 00:00:44,400
打开的第一个文件
the first file that you open

18
00:00:44,566 --> 00:00:46,733
会返回文件描述符3
is going to return the file descriptor 3

19
00:00:46,966 --> 00:00:48,866
这意味着什么
so what is the significance of this

20
00:00:48,866 --> 00:00:51,933
而且为什么我要把这个3传回给内核
and why do I need to pass this 3 back to the kernel

21
00:00:51,933 --> 00:00:53,800
在我要用这个文件的时候
when I want to interact with this file

22
00:00:54,966 --> 00:00:56,566
在内核内部
well inside the kernel

23
00:00:56,600 --> 00:01:00,400
每个进程都有一个进程文件表
for every process there is a process file table

24
00:01:00,466 --> 00:01:04,700
这个进程文件表一边是一个整数列表
and this process file table is a listing of these integer values

25
00:01:04,966 --> 00:01:07,533
每一个整数值
and for every one of these integer values

26
00:01:07,533 --> 00:01:10,400
对应着一个指向file结构体的指针
there is a pointer to a file struct

27
00:01:10,733 --> 00:01:13,866
这个file结构放在另一个的表中
and this file struct exists in a separate table

28
00:01:13,933 --> 00:01:15,766
叫全局文件表
known as the global file table

29
00:01:15,966 --> 00:01:17,500
全局文件表
now the Global File table

30
00:01:17,600 --> 00:01:21,933
对系统上打开的每个文件都有一个条目
has an entry for every file that is currently open on the system

31
00:01:23,000 --> 00:01:26,600
全局文件表中的file结构体
and the file struct inside the Global File table

32
00:01:26,866 --> 00:01:29,600
是文件在内核中的表示形式
is kind of the kernels representation of the file

33
00:01:30,166 --> 00:01:31,800
所以它记录了
so it's going to have information

34
00:01:31,966 --> 00:01:33,666
像文件路径
like the path

35
00:01:33,966 --> 00:01:36,200
以及在文件中的偏移量
as well as the offset into the file

36
00:01:36,966 --> 00:01:38,333
这个文件中的偏移量是什么
now what is the offset

37
00:01:38,566 --> 00:01:42,866
好，若一个进程read一次后，再次read该文件
well what happens if a process calls read on a file and then calls read again

38
00:01:43,033 --> 00:01:44,900
我们希望第二次read
we would expect the second read

39
00:01:44,900 --> 00:01:47,333
能从第一次读到的位置继续
to continue from where the first one ended

40
00:01:47,566 --> 00:01:50,700
这个文件内偏移量记录着
the offset keeps track of where into the file

41
00:01:50,700 --> 00:01:52,400
当前访问到了文件中的哪个位置
are we currently accessing

42
00:01:53,300 --> 00:01:56,000
file结构体中还有一个字段
now one of the additional fields that's in a file struct

43
00:01:56,000 --> 00:01:57,733
inode指针
is the inode pointer

44
00:01:57,933 --> 00:02:01,333
inode指针指向一个inode结构体
now the inode pointer points to an inode struct

45
00:02:01,766 --> 00:02:04,500
如果你上过文件系统取证的课
if you've taken a File Systems for forensics class

46
00:02:04,500 --> 00:02:08,100
你可能对inode进行了更深入的研究
you may have explored the inode in a bit greater depth

47
00:02:08,300 --> 00:02:09,100
我们可以简单地认为
we're just going to say

48
00:02:09,166 --> 00:02:12,200
inode表示一些底层信息
that the inode represents some of the lower level information

49
00:02:12,466 --> 00:02:16,366
关于文件以及如何在硬件层面访问它
about the file and how it is accessed on hardware

50
00:02:16,466 --> 00:02:19,133
它会有类似扇区、块之类的信息
so it's going to have information like kind of the sector block 

51
00:02:19,200 --> 00:02:20,400
还有字节偏移量
and then byte offset

52
00:02:20,400 --> 00:02:23,333
表示数据物理上存储在哪里
where the physical bytes are located on the back media

53
00:02:24,200 --> 00:02:26,266
所以每次我们调用read
so every time that we call read

54
00:02:27,133 --> 00:02:30,100
我们都会做上下文切换，切换到内核
we are going to do a context switch into the kernel

55
00:02:30,266 --> 00:02:32,966
然后内核必须
the kernel then has to perform this translation

56
00:02:33,533 --> 00:02:36,200
将文件描述符，转换成file结构体
from the file descriptor to the file struct

57
00:02:36,466 --> 00:02:37,800
找到inode
to the inode

58
00:02:37,800 --> 00:02:40,533
从物理介质中拿数据
to then grab the bytes off of the physical media

59
00:02:40,600 --> 00:02:43,733
再切换上下文，回到用户空间
to then context switch back to userland

60
00:02:43,733 --> 00:02:45,133
然后我们就可以
where we can then

61
00:02:45,366 --> 00:02:48,733
处理我们从文件中获取的字节
work with the bytes that we're trying to access from the file

62
00:02:49,400 --> 00:02:51,533
这不是一个小工作量
this is a non trivial amount of work

63
00:02:51,533 --> 00:02:54,866
而且每次调用read或write都会经历
and this occurs every time that we call read or write

64
00:02:55,133 --> 00:02:56,133
我们能做得更好吗?
can we do better

65
00:02:56,800 --> 00:03:00,333
libc有性能更高的一类函数
so libc has a class of functions that can be more performant

66
00:03:00,566 --> 00:03:03,000
这些标准IO流函数
these standard io streaming functions

67
00:03:03,100 --> 00:03:06,200
包括fopen fread和fwrite
include fopen fread and fwrite 

68
00:03:06,333 --> 00:03:07,733
还有更多
and there's many more

69
00:03:08,333 --> 00:03:10,066
这两者之间有何不同
and now what's different about them

70
00:03:10,266 --> 00:03:12,200
首先我们看看fopen
well first if we look at fopen

71
00:03:12,366 --> 00:03:14,133
它不返回文件描述符
it doesn't return a file descriptor

72
00:03:14,133 --> 00:03:16,166
它返回一个文件指针
it returns a file pointer

73
00:03:16,400 --> 00:03:18,500
fread和fwrite
similarly fread and fwrite

74
00:03:18,566 --> 00:03:21,066
的参数也不再是文件描述符了
also don't work on file descriptors

75
00:03:21,066 --> 00:03:23,266
它们依靠这些文件指针
they're working on these file pointers

76
00:03:23,400 --> 00:03:25,466
我们来看看他们的表现
so lets take a look at their performance

77
00:03:25,466 --> 00:03:27,133
然后我们会讨论它们是如何工作的
and then we'll talk about how they work

78
00:03:29,666 --> 00:03:31,133
好的
okay so

79
00:03:31,733 --> 00:03:35,966
这里有一个C程序叫做read_loop.c
up here I have a C program called read_loop.c

80
00:03:36,500 --> 00:03:37,733
在main中
inside of main

81
00:03:38,000 --> 00:03:41,500
我们有一个大小为0x1000字节的缓冲区
we have a buffer of size hex 1000 bytes

82
00:03:41,566 --> 00:03:44,733
然后我们open /dev/urandom
we're then going to call open on /dev/urandom

83
00:03:44,733 --> 00:03:47,566
所以我们会读入随机字节
so we're going to be reading in random bytes

84
00:03:48,166 --> 00:03:48,966
在for循环中
inside of a for loop

85
00:03:49,033 --> 00:03:50,133
我们调用read
we call read 

86
00:03:50,266 --> 00:03:54,900
我们每批次读取0x20字节
and we are reading in batches of hex 20 bytes

87
00:03:54,900 --> 00:03:57,366
我们会读入0x20字节的随机值
we're going to read in hex 20 random bytes

88
00:03:57,366 --> 00:04:00,333
我们总共要做5万次
and we're going to do this 50 thousand times

89
00:04:00,766 --> 00:04:04,400
我们编译read_loop.c
so let's compile read_loop.c

90
00:04:07,133 --> 00:04:10,666
看看运行它需要多长时间
and let's see how long that takes to run

91
00:04:12,966 --> 00:04:17,733
能看到大约是0.014 - 0.015秒
we see here it's about 0.014 0.015 seconds

92
00:04:19,133 --> 00:04:19,933
好的
okay

93
00:04:20,366 --> 00:04:24,900
我还有第二个C程序fread_loop.c
now I have a second C program called fread_loop.c

94
00:04:25,400 --> 00:04:26,800
非常相似
which is very similar

95
00:04:27,000 --> 00:04:29,200
有0x1000字节的缓冲区
we have a buffer of hex 1000 bytes

96
00:04:29,200 --> 00:04:33,100
我们将用fopen打开/dev/urandom
we're going to call fopen on /dev/urandom

97
00:04:33,600 --> 00:04:36,800
在for循环中，我们将调用fread
inside of our for loop we're going to call fread

98
00:04:37,300 --> 00:04:41,500
每次读入0x20字节
and we're going to fread hex 20 bytes

99
00:04:41,700 --> 00:04:46,600
同样，我们将循环5万次
and again we're going to do this for 50 000 iterations inside of our for loop

100
00:04:47,133 --> 00:04:50,900
那么我们编译fread_loop.c
so let's compile fread_loop.c

101
00:04:54,666 --> 00:04:56,600
看看这需要多长时间
let's see how long this takes to run

102
00:05:00,866 --> 00:05:01,133
好吧
okay

103
00:05:01,133 --> 00:05:05,300
我们看到0.004 0.005
so we see 0.004 0.005

104
00:05:05,333 --> 00:05:09,333
运行时间大概是之前的三分之一
so roughly it's about a third of the the run time

105
00:05:10,066 --> 00:05:13,700
我想先展示一件事
now there's one more thing that I'd like to kind of show

106
00:05:13,933 --> 00:05:17,300
在下面几张幻灯片中，我们会深入研究其中的原因
and we'll delve into why in the next couple slides

107
00:05:17,300 --> 00:05:19,266
但现在值得一看
but it's worth looking at right now

108
00:05:20,100 --> 00:05:20,700
我要做的是
what I'm going to do is 

109
00:05:20,766 --> 00:05:25,366
strace这两个程序
I'm going to strace each program

110
00:05:25,500 --> 00:05:28,600
我们把错误输出重定向到标准输出
we're going to redirect standard error to standard out

111
00:05:28,666 --> 00:05:30,066
方便我们grep它
so that I can grep it

112
00:05:31,866 --> 00:05:33,100
我感兴趣的东西是
and what I'm interested in

113
00:05:33,400 --> 00:05:39,300
每个程序调用read系统调用的次数
is how many times does each program call the syscall read

114
00:05:40,100 --> 00:05:43,100
左边这个是我们的read_loop
so the one on the left here which was our read_loop

115
00:05:43,933 --> 00:05:47,700
调用了5万次read
calls read 50 thousand times all about

116
00:05:47,966 --> 00:05:48,700
这没问题
and that makes sense 

117
00:05:48,733 --> 00:05:53,100
因为我们在一个循环中调用了5万次read
because we're calling read 50 thousand times in a loop

118
00:05:54,133 --> 00:05:55,266
在这里
well this one here

119
00:05:55,700 --> 00:05:59,400
我们在for循环中调用50,000次read
we're calling read inside a for loop of 50,000

120
00:05:59,400 --> 00:06:01,966
可以预计会调用50,000次read
so we'd expect about 50,000 read calls

121
00:06:02,400 --> 00:06:05,966
现在在第二个程序中，fread_loop
now in the second program fread_loop 

122
00:06:05,966 --> 00:06:07,933
我们做同样的事情
let's do that same thing

123
00:06:08,733 --> 00:06:11,400
我们strace fread_loop
we're going to strace fread_loop

124
00:06:12,200 --> 00:06:14,766
把错误输出重定向到标准输出
we'll redirect standard error to standard in

125
00:06:15,200 --> 00:06:16,600
这样我们就可以grep它了
so that we can grep it

126
00:06:16,733 --> 00:06:20,000
我们感兴趣的是read开头的行
and I'm interested in the lines that begin with read

127
00:06:22,000 --> 00:06:26,333
找到了392个这样的行
and we see that we have 392 instances

128
00:06:26,733 --> 00:06:28,666
数量大大减少了
and that's significantly less

129
00:06:28,666 --> 00:06:31,600
每次我们调用read
remember every time that we call read

130
00:06:32,066 --> 00:06:35,533
都会进行从用户空间到内核的上下文切换
we are doing that context switch from user space to the kernel

131
00:06:35,533 --> 00:06:38,533
然后我们在这些表之间进行转换
then we're doing that translation across those tables

132
00:06:38,533 --> 00:06:42,400
然后访问硬盘拿到数据
to then go touch the hardware to get the bytes

133
00:06:42,533 --> 00:06:46,366
然后切换会用户空间
and then translate or context switch back to user land

134
00:06:46,600 --> 00:06:50,200
当我们调用read时，这做了5万次
and we're doing that 50 thousand times when we call read 

135
00:06:50,566 --> 00:06:51,900
但用fread时
but use an fread

136
00:06:52,266 --> 00:06:54,666
我们只做了392次
we're only doing that 392 times

137
00:06:54,866 --> 00:06:58,800
这就是运行时间差异的原因
and that is the reason for this run time difference

138
00:06:59,333 --> 00:07:02,900
我们来看看为什么会这样
so let's take a look at why exactly that is

139
00:07:04,366 --> 00:07:06,500
这些函数作用于 FILE结构体
so these functions work on file structs

140
00:07:06,500 --> 00:07:08,200
而不是文件描述符
instead of file descriptors

141
00:07:08,200 --> 00:07:11,133
FILE结构体包含一堆指针
and the file struct contains a bunch of pointers

142
00:07:11,133 --> 00:07:15,800
用来缓冲用户的读写请求
that are used to buffer the reading and writing that's requested by user

143
00:07:16,266 --> 00:07:21,333
因为我们减少了实际发生的原始读写次数
and because we reduce the number of raw reads and writes that actually occur

144
00:07:22,300 --> 00:07:23,733
减少了上下文切换
there's less context switching

145
00:07:23,733 --> 00:07:25,900
就提升了性能
which results in increased performance

146
00:07:26,933 --> 00:07:30,933
我刚说了FILE结构体有一堆用于缓冲的指针
now I said that the file struct contains a bunch of pointers that are used for buffering

147
00:07:31,400 --> 00:07:35,133
这些是我们将在本节课讨论的
here's some of them that we're going to talk about in this lecture

148
00:07:35,766 --> 00:07:38,566
如果你对FILE结构体的完整样子感兴趣
if you are interested in the file struct as a whole

149
00:07:38,566 --> 00:07:42,666
我强烈建议你看看这张幻灯片底部的链接
I would highly suggest that you check out the link at the bottom of this slide

150
00:07:42,933 --> 00:07:47,100
里面有FILE结构体完整定义的源码
which contains the source with the io file struct definition

151
00:07:47,766 --> 00:07:49,466
但说到缓冲
but to talk about buffering

152
00:07:49,466 --> 00:07:51,733
我们只关注这些值
we're just going to focus on these values here

153
00:07:52,333 --> 00:07:53,866
第一个是flags值
the first is the flags value

154
00:07:54,300 --> 00:07:58,333
flags的几个高有效位是定值
now the higher order bits of the flags value is a magic value

155
00:07:58,400 --> 00:08:01,566
剩下的部分用来做标志
and the rest of it is used for flags

156
00:08:01,566 --> 00:08:02,800
这些标志表明
now these flags indicate

157
00:08:02,800 --> 00:08:07,166
例如，打开文件是为了读还是写
for instance whether or not the file is open for reading or writing

158
00:08:07,533 --> 00:08:10,800
我记得代码中定义的是
I believe in the source the actual definition used is

159
00:08:10,933 --> 00:08:13,333
不读，不写
no read and no write

160
00:08:13,366 --> 00:08:16,466
所以如果想写，要设置不读
so if I wanted to write I would set no read

161
00:08:16,533 --> 00:08:19,133
如果想读，设置不写
if I wanted to read I would set no write

162
00:08:19,533 --> 00:08:20,266
但重点是
but the point is 

163
00:08:20,500 --> 00:08:24,666
flags值决定如何设置缓冲
the flags value determines how the buffering is going to be set up

164
00:08:24,666 --> 00:08:29,800
以及我们该怎样理解它是如何与文件交互的
and how we need to think about how we're going to interact with this file conceptually

165
00:08:31,133 --> 00:08:33,066
下面有8个指针
next we have 8 pointers

166
00:08:33,400 --> 00:08:35,600
前三个与读有关
the first three are related to reading

167
00:08:36,266 --> 00:08:39,300
有一个ptr、一个end和一个base
there's a ptr an end and a base

168
00:08:40,266 --> 00:08:42,600
然后有三个和写有关
then there are three related for writing

169
00:08:42,733 --> 00:08:47,400
也有一个ptr、一个end和一个base
where there's again a ptr an end and a base

170
00:08:47,933 --> 00:08:48,966
最后有2个指针
and then we have two

171
00:08:48,966 --> 00:08:51,866
它们与整个缓冲区有关
that are related to the buffer as a whole

172
00:08:51,866 --> 00:08:54,700
分别是base和end
which has a base and an end

173
00:08:55,400 --> 00:08:56,933
这里的顺序
now the order here

174
00:08:57,266 --> 00:08:58,300
有点奇怪
is a little weird

175
00:08:58,333 --> 00:09:00,966
但这是它在源文件中的定义
but this is how it's defined in the source

176
00:09:01,366 --> 00:09:02,700
可以这样想
the way to think about it

177
00:09:02,766 --> 00:09:05,900
base是这片区域的开头
is the base is the beginning of a region

178
00:09:05,933 --> 00:09:08,300
end是结尾
the end is the end of a region

179
00:09:08,766 --> 00:09:14,800
ptr是当前的处理到的
then the ptr is kind of the current location that we're working with

180
00:09:15,533 --> 00:09:19,166
在下面几张幻灯片，我们会看到这些指针移来移去
now we'll see these pointers kind of move around in the next couple slides

181
00:09:19,266 --> 00:09:21,300
以理解它们是如何使用的
to get an idea of how they're used

182
00:09:23,100 --> 00:09:24,933
当调用fread时
so when fread is called

183
00:09:25,500 --> 00:09:28,600
你可能会认为，你在从一个文件中读取数据
you would think that you're going to be reading from a file

184
00:09:28,600 --> 00:09:30,200
文件系统上的文件
like a file on the file system

185
00:09:30,200 --> 00:09:32,266
但事实并非如此
but that's not actually what occurs

186
00:09:32,266 --> 00:09:33,866
在你调用fread时
when you call fread

187
00:09:33,900 --> 00:09:35,800
这个函数会立马尝试
the function is going to immediately 

188
00:09:35,800 --> 00:09:38,733
与内存中的缓冲区进行交互
try and interact with this buffer in memory

189
00:09:38,966 --> 00:09:41,733
这里应该保存了目标文件的数据
that should be holding bytes of the file

190
00:09:42,066 --> 00:09:44,166
这个缓冲区
and this buffer gets loaded

191
00:09:44,566 --> 00:09:47,166
会在需要时载入文件数据
when it when needed with the bytes of the file

192
00:09:48,133 --> 00:09:49,200
所以一开始
so initially

193
00:09:50,800 --> 00:09:53,400
在我们以读的方式打开文件时
when we open the file for reading

194
00:09:53,766 --> 00:09:57,233
会在堆上分配一个缓冲区
a buffer should be allocated on the heap

195
00:09:57,733 --> 00:10:00,100
应该是一个内存页大小
and it should be about a page in size

196
00:10:00,233 --> 00:10:02,366
大概是0x1000字节
so it's going to be about hex 1000 bytes

197
00:10:03,366 --> 00:10:07,100
缓冲区的开头由buf_base定义
the beginning of this buffer is defined by buf_base

198
00:10:07,200 --> 00:10:10,500
缓冲区的结尾由buf_end定义
and the end of this buffer is defined by buf_end

199
00:10:11,166 --> 00:10:13,000
因为我们是读取数据
and since we're going to be reading

200
00:10:13,333 --> 00:10:15,866
这个缓冲区完全用于读
this buffer is used entirely for reading

201
00:10:16,066 --> 00:10:18,933
所以缓冲区的开头也是read_base
so the beginning of the buffer is read_base

202
00:10:19,066 --> 00:10:21,533
缓冲区的末尾也是read_end
and the end of the buffer is read_end

203
00:10:22,566 --> 00:10:23,733
到目前为止一切正常
so far so good

204
00:10:24,166 --> 00:10:27,733
现在我们读取了0字节
now we've actually read 0 bytes so far

205
00:10:27,800 --> 00:10:30,600
我们只是载入了文件开头一页的数据到缓冲区
we've just filled the buffer with the beginning of the file

206
00:10:31,133 --> 00:10:33,133
这就是为什么我们的读指针
and that's why our read pointer

207
00:10:33,666 --> 00:10:36,866
它可以理解成我们当前在文件中的位置
which kind of represents where are we currently in the file

208
00:10:36,866 --> 00:10:38,700
还在缓冲区的开头
is at the beginning of the buffer

209
00:10:39,266 --> 00:10:41,966
当我们调用fread
now once we call fread

210
00:10:42,533 --> 00:10:45,333
我们消耗了一些缓冲区中的数据
we've consumed some of these bytes from the buffer

211
00:10:47,400 --> 00:10:53,500
此时，read_ptr向前移动到我们读完的位置
when that occurs the read pointer advances past all of the bytes that we've read

212
00:10:53,700 --> 00:10:55,733
所以fread会返回
and so what's returned from fread

213
00:10:55,766 --> 00:11:01,133
read_base和read_ptr之间的所有内容
is everything between read_base and read pointer

214
00:11:01,266 --> 00:11:03,366
这些是已经读了的数据
and so those are the bytes that have already been read

215
00:11:04,000 --> 00:11:05,866
下一次调用fread时
now the next time read is called

216
00:11:06,266 --> 00:11:09,966
会返回read_ptr指向的位置
it'll begin returning bytes from where read pointer is

217
00:11:11,000 --> 00:11:12,600
依次类推
and this will continue

218
00:11:12,600 --> 00:11:15,800
直到我们读完这个缓冲区
until we've read everything that is in this buffer

219
00:11:16,366 --> 00:11:17,466
这时候
and at that point

220
00:11:17,533 --> 00:11:20,133
read_ptr指向缓冲区的末尾
read pointer has reached the end of the buffer

221
00:11:20,133 --> 00:11:22,133
到达了read_end
and it has also reached read end

222
00:11:22,400 --> 00:11:26,966
表示我们消耗完了读缓冲区中的数据
and so now we've consumed all of the bytes that are in the read buffer

223
00:11:27,733 --> 00:11:30,800
此时，我们需要刷新读缓冲区
at this point we need to refresh the read buffer

224
00:11:31,066 --> 00:11:34,466
我们通过执行read系统调用来实现它
and we do that by performing the syscall read

225
00:11:34,466 --> 00:11:36,066
这就是幕后发生的事情
this is what happens under the hood

226
00:11:36,066 --> 00:11:38,500
在你调用fread时，这对你是不可见的
it's invisible to you when you're calling fread

227
00:11:38,566 --> 00:11:39,800
但在幕后
but under the hood

228
00:11:40,100 --> 00:11:42,600
该函数将调用系统调用read
the function is going to call the syscall read

229
00:11:42,766 --> 00:11:47,800
用下一个0x1000未读字节，重填这个缓冲区
and refill this buffer with on the next hex 1000 unread bytes

230
00:11:47,900 --> 00:11:51,266
然后会重置read_ptr指向read_base
and then it will reset the read pointer back to read base

231
00:11:51,266 --> 00:11:53,533
这样我们就可以重复这个过程
so that we can repeat this process

232
00:11:53,666 --> 00:11:58,800
所以每读0x1000字节，才调用read系统调用
so we're only calling the syscall read every hex 1000 bytes

233
00:11:58,933 --> 00:12:02,900
这在我们每次只读取少量数据时，非常有效
which is significantly more efficient if we're doing smaller reads

234
00:12:04,200 --> 00:12:05,533
在某个时刻
now at some point

235
00:12:06,500 --> 00:12:08,933
我们将到达文件的末尾
we're going to reach the end of the file 

236
00:12:09,200 --> 00:12:11,766
所以我们从文件中读取的
and so we may read from the file

237
00:12:11,766 --> 00:12:13,666
不能填满缓冲区
but not fill the buffer

238
00:12:14,133 --> 00:12:15,666
此时
and when we reach that point

239
00:12:16,666 --> 00:12:18,666
所发生的是，我们读入数据
what happens is we read in the bytes

240
00:12:18,766 --> 00:12:25,633
将read_end指向文件数据在缓冲区中的结束位置
and we set read_end to be the location in the buffer where the file ends

241
00:12:26,333 --> 00:12:29,000
read_ptr依然指向read_base
and read pointer is still back at read base

242
00:12:29,000 --> 00:12:33,166
因为我们刚将文件的最后一块加载到缓冲区中
because we just loaded the last chunk of the file into the buffer here

243
00:12:33,800 --> 00:12:37,500
这样read_ptr指向到read_end时
so then read pointer could advance until read_end

244
00:12:37,766 --> 00:12:39,866
就是文件的结尾
and that would be the end of the file

245
00:12:43,500 --> 00:12:46,900
对于写入，我们会调用fwrite
now for writing we're going to call fwrite

246
00:12:47,966 --> 00:12:49,333
调用write时
when you call write

247
00:12:50,066 --> 00:12:51,900
通常是写入到一个文件
normally it goes write to a file

248
00:12:52,033 --> 00:12:53,766
但当我们调用fwrite时
but if we call fwrite

249
00:12:53,966 --> 00:12:56,400
它不会直接到文件中
it's not going to go directly to the file

250
00:12:56,400 --> 00:13:00,566
我们实际上是在和中间的缓冲内存进行交互
there's this intermediary buffery memory that we're actually interacting with

251
00:13:00,733 --> 00:13:02,700
所以我们可以这样想
and so when we think about it

252
00:13:02,700 --> 00:13:06,566
fwrite会直接写入缓冲区，而不是文件
fwrite is going to write to a buffer not to a file

253
00:13:06,700 --> 00:13:08,366
我们看看它是如何工作的
let's see how that works

254
00:13:09,566 --> 00:13:11,066
非常类似fread
very similarly

255
00:13:11,166 --> 00:13:15,300
buf_base是这个缓冲区的开头
buf_base is the beginning of this buffer

256
00:13:15,300 --> 00:13:17,266
buf_end是缓冲区的末尾
buf_end is the end of the buffer

257
00:13:17,266 --> 00:13:18,933
它大概有一内存页那么大
again it's about a page in size

258
00:13:19,033 --> 00:13:20,800
0x1000字节
so hex 1000 bytes

259
00:13:21,166 --> 00:13:23,100
write_base是缓冲区的开始
write base is the beginning of the buffer

260
00:13:23,100 --> 00:13:25,100
write_end是缓冲区的末尾
write end is the end of the buffer

261
00:13:25,500 --> 00:13:29,766
write_ptr记录着下一个字节写入的位置
write pointer tracks where should the next bytes be written

262
00:13:30,100 --> 00:13:32,133
因为我们还没有写任何东西
since we haven't written anything yet

263
00:13:32,133 --> 00:13:34,966
所以write_ptr指向缓冲区开头
write pointer points to the beginning of the buffer

264
00:13:35,466 --> 00:13:38,500
一旦我们调用了一次fwrite
now once we have called fwrite once

265
00:13:38,900 --> 00:13:41,966
会有一些字节被写入缓冲区
there'll be some bytes that get written into the buffer

266
00:13:42,133 --> 00:13:45,800
write_ptr会前进
and the write pointer advances to mark

267
00:13:45,866 --> 00:13:49,200
标记出写入字节的末尾在哪里
where is the end of the bytes that we have written

268
00:13:50,166 --> 00:13:52,300
下次调用fwrite时
now the next time that fwrite is called

269
00:13:52,666 --> 00:13:56,966
数据会直接写入到write_ptr指向的地址
those bytes will be written to the address to find by the write pointer

270
00:13:57,133 --> 00:13:58,100
所以我们在做的是
and so what we're doing

271
00:13:58,233 --> 00:14:04,533
用想要写入文件的数据，填充这个缓冲区
is we are slowly filling up this buffer with the bytes that we intend to write to the file

272
00:14:04,533 --> 00:14:06,133
不过，他们还没有填满缓冲区
they haven't gotten there yet though

273
00:14:06,133 --> 00:14:08,166
这些数据就放在缓冲区中
right now they're just sitting in this buffer

274
00:14:08,900 --> 00:14:10,666
当我们填满了缓冲区
now once we filled the buffer

275
00:14:10,733 --> 00:14:13,600
write_ptr到达write_end
and the write pointer reaches write end

276
00:14:14,300 --> 00:14:16,133
我们将flush(冲走)这些数据
we need to flush this out

277
00:14:16,133 --> 00:14:17,100
flush是指
and by flushing it

278
00:14:17,100 --> 00:14:19,133
我们会取出缓冲区的数据
we're going to take the bytes that are in the buffer

279
00:14:19,133 --> 00:14:22,466
将它们提交到磁盘
and actually commit them to disk or whatever it is

280
00:14:22,666 --> 00:14:26,533
或其他支撑文件存储的位置
that is backing the file

281
00:14:27,366 --> 00:14:28,966
在我们flush数据时
and so when we flush

282
00:14:29,300 --> 00:14:31,966
write_ptr会回到开头
the write pointer jumps back to the beginning

283
00:14:32,766 --> 00:14:36,733
下次我们用fwrite写入的字节
and the next bytes that we will write from fwrite

284
00:14:36,800 --> 00:14:38,666
会在缓冲区开头开始写
will start at the beginning of the buffer

285
00:14:38,833 --> 00:14:42,933
这会持续下去，直到缓冲区填满并flush数据
and this process can continue until we fill the buffer and flush 

286
00:14:43,166 --> 00:14:46,799
或调用fflush
or the function fflush is called

287
00:14:46,866 --> 00:14:49,300
这样可以手动冲走数据到文件中
so you can manually flush a file

288
00:14:51,200 --> 00:14:54,766
考虑这个的时候要记住一件事
now one thing to kind of keep in mind when you are thinking about this

289
00:14:54,966 --> 00:14:57,300
FILE结构体在哪里
is where is the file struct located

290
00:14:57,566 --> 00:15:00,166
它实际上位于用户空间
well it's actually located in userland

291
00:15:00,566 --> 00:15:02,466
这个缓冲区在哪里
where is this buffer located

292
00:15:02,866 --> 00:15:04,900
缓冲区也在用户空间
well the buffer is also in userland

293
00:15:04,900 --> 00:15:07,966
这些不是内核中的内存地址
these are not memory addresses that are in the kernel

294
00:15:08,066 --> 00:15:11,566
我们将在下个视频中探讨其中的一些含义
and we'll explore some of the implications of that in the next video

