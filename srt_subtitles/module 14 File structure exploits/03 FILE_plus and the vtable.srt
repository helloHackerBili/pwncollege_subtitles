1
00:00:00,700 --> 00:00:03,100
我们已经看了如何滥用FILE结构体
so we have seen how file structures can be abused 

2
00:00:03,100 --> 00:00:05,200
以获得任意读写利用原语
to gain arbitrary read and write primitives

3
00:00:05,200 --> 00:00:09,200
但还有一些涉及FILE结构体的其他利用方向
but there are some additional exploitation vectors that involve file structures

4
00:00:09,200 --> 00:00:10,566
值得讨论
that are worth discussing

5
00:00:10,900 --> 00:00:12,066
要讨论它们
in order to do so

6
00:00:12,066 --> 00:00:15,600
我们必须提到一个叫做_IO_FILE_plus的东西
we have to mention something called _IO_FILE_plus 

7
00:00:15,666 --> 00:00:18,366
_IO_FILE_plus是一个扩展
now _IO_FILE_plus is an extension

8
00:00:18,400 --> 00:00:21,966
对于我们一直说的传统FILE结构体
of the traditional file struct that we've referred to up until this point

9
00:00:22,666 --> 00:00:27,366
_IO_FILE_plus和FILE之间唯一的区别
however the only difference between _IO_FILE_plus and file 

10
00:00:27,533 --> 00:00:30,466
是在末尾追加了一个指针
is one additional pointer appended to the end

11
00:00:30,666 --> 00:00:32,166
就是我们在右边看到的
which we see here on the right

12
00:00:32,666 --> 00:00:36,866
这是指向vtable虚函数表的指针
now this is a pointer to a vtable or a virtual function table

13
00:00:37,300 --> 00:00:42,700
虚函数表是一个充满函数指针的表
now a virtual function table is a table that is full of function pointers

14
00:00:42,766 --> 00:00:47,100
它就是内存中一连串的函数指针
so it's just a bunch of function pointers in memory in series

15
00:00:47,733 --> 00:00:51,300
我们通常在c++二进制文件中找到这些函数表
we commonly find these function tables in C++ binaries

16
00:00:51,500 --> 00:00:54,700
因为它们能在运行时，动态解析函数
because they allow for dynamic function resolution at runtime

17
00:00:54,966 --> 00:00:58,233
这是你在高级语言中会遇到的问题
and this is a problem that you have in higher level languages

18
00:00:58,366 --> 00:01:02,566
高级语言中有类和对象
where you have classes and objects with

19
00:01:02,566 --> 00:01:05,733
继承、多继承和多态
inheritance and multiple inheritance and polymorphism

20
00:01:05,933 --> 00:01:07,733
你可以有一些对象
you can have some object

21
00:01:07,766 --> 00:01:09,166
你调用它的函数
where you need to call a method

22
00:01:09,166 --> 00:01:12,133
但它解析出的，实际要调用的函数
but the exact function that it's going to resolve to

23
00:01:12,133 --> 00:01:14,066
可能在编译时不知道
may not be known at compile time

24
00:01:14,100 --> 00:01:18,200
所以我们用虚函数表来解决这个问题
so we use these virtual function tables as a trick to get around that

25
00:01:21,133 --> 00:01:23,600
在FILE结构体的末尾
so at the end of the file structure

26
00:01:23,600 --> 00:01:27,000
我们有一个指向虚函数表的指针，如图所示
we have this pointer to a vtable as shown here

27
00:01:27,533 --> 00:01:30,366
实际被调用的函数
and the exact function that's called

28
00:01:30,366 --> 00:01:34,400
将由在vtable中的偏移量决定
will be determined by the offset from the vtable that specify

29
00:01:34,666 --> 00:01:38,133
我们能在许多io流函数中都看到了这一点
and we see this in a number of the streaming Io functions

30
00:01:38,366 --> 00:01:39,200
例如
for example

31
00:01:39,200 --> 00:01:42,166
在fwrite内能看到汇编指令
inside of fwrite we have the assembly instruction 

32
00:01:42,300 --> 00:01:46,366
call r15+0x38
call r15 plus hex 38

33
00:01:47,266 --> 00:01:50,000
在这个例子中，我们没写在幻灯片上的是
in this instance we didn't include it in the slides

34
00:01:50,066 --> 00:01:53,500
R15是虚函数表指针
R15 is the vtable pointer

35
00:01:53,866 --> 00:01:59,100
所以这个用R15偏移0x38字节
so this is taking R15 and offsetting it by hex 38 bytes

36
00:01:59,300 --> 00:02:01,300
最终会调用这个函数
this will ultimately call the function 

37
00:02:01,500 --> 00:02:04,366
_IO_new_file_xsputn
_IO_new_file_xsputn

38
00:02:06,933 --> 00:02:10,266
我们想一下如何利用这个vtable
let's formulate how we can exploit this vtable planner

39
00:02:10,366 --> 00:02:13,900
如果我们创建自己的vtable呢
well what if we created our own exploit vtable

40
00:02:14,066 --> 00:02:15,900
先不管把它放在哪里
and it doesn't matter where we put this

41
00:02:15,900 --> 00:02:16,866
可以在栈上
this could be on the stack 

42
00:02:16,866 --> 00:02:17,766
可以在堆上
this could be on the heap

43
00:02:17,766 --> 00:02:21,766
只要是我们有能力写的地方
this could just be somewhere that we have the ability to write

44
00:02:22,400 --> 00:02:24,800
于是我们创建了我们的用来利用的 vtable
and so we create our exploit vtable

45
00:02:25,133 --> 00:02:28,166
然后在期望的偏移量处
and then at the desired offset

46
00:02:28,166 --> 00:02:30,533
比如，设定我们的目标是fwrite
so like let's say we're targeting fwrite here

47
00:02:30,666 --> 00:02:34,166
在我们的vtable+0x38处
at our exploit vtable plus Hex 38

48
00:02:34,200 --> 00:02:38,100
可以放一个我们想要调用的地址
we could place an address that we want to call

49
00:02:39,100 --> 00:02:40,300
然后我们要做的就是
then all we have to do

50
00:02:40,300 --> 00:02:42,366
覆盖这个vtable指针
is overwrite this vtable pointer

51
00:02:42,366 --> 00:02:44,866
指向我们的vtable
to point to our exploit vtable

52
00:02:45,333 --> 00:02:47,766
然后当我们fwrite的时候
and then when we get to fwrite

53
00:02:47,900 --> 00:02:50,133
它会参考我们的vtable
it would reference our exploit vtable

54
00:02:50,133 --> 00:02:52,000
调用我们指定的地址
and call whatever we decided

55
00:02:52,866 --> 00:02:54,200
我们再想想
well let's also think about

56
00:02:54,200 --> 00:02:57,733
如果我们必须覆盖整个FILE结构体，会发生什么呢
what happens if we have to overwrite this whole file struct

57
00:02:57,733 --> 00:02:59,966
虚表在最后
the vtable is all the way at the end

58
00:03:00,066 --> 00:03:01,500
如果我们要重写它
so if we're going to overwrite it

59
00:03:01,500 --> 00:03:05,800
我们必须修改FILE结构体中的每一个值
we have to clobber every single value that is in the file struct

60
00:03:06,166 --> 00:03:09,066
我们已经看了任意读写的实现流程
now we've seen from the arbitrary read and write

61
00:03:09,133 --> 00:03:10,400
里面很多值
that a lot of these

62
00:03:10,533 --> 00:03:13,266
我们可以设置为null或一些默认值
we can set to null or some default value

63
00:03:13,266 --> 00:03:14,966
这并不会造成什么问题
and it doesn't really cause a problem

64
00:03:15,500 --> 00:03:18,166
但如果我们要覆盖整个FILE结构体
but if we're going to write all the way through the file struct

65
00:03:18,166 --> 00:03:21,100
有一个值可能会有问题
there is one value that can be problematic

66
00:03:21,800 --> 00:03:23,800
这就是锁
and that is the lock

67
00:03:25,133 --> 00:03:26,866
现在我们还没有谈到锁
now we haven't talked about the lock

68
00:03:27,166 --> 00:03:29,000
锁是一个指针
well the lock is a pointer

69
00:03:29,000 --> 00:03:32,733
它用于管理对文件的多线程访问
that is used to manage multithreaded access to a file

70
00:03:32,966 --> 00:03:37,500
请记住，文件实际上是内存中的缓冲区
remember that the file is really a buffer in memory

71
00:03:37,500 --> 00:03:41,966
所以如果有多个线程试图在同一时间点访问这个缓冲区
and so if we have multiple threads trying to access this buffer at the same point in time

72
00:03:42,200 --> 00:03:46,333
很可能会导致进入一些非法状态
it's very likely that will end up in some kind of invalid state

73
00:03:46,600 --> 00:03:48,800
例如，如果我们有多个线程
for instance if we have multiple writers

74
00:03:48,800 --> 00:03:51,466
试图将他们的数据写入缓冲区
trying to write their data into the buffer

75
00:03:51,600 --> 00:03:52,966
最后大家都写不完整
will actually get neither

76
00:03:53,600 --> 00:03:55,933
会得到一个混合在一起的混乱数据
will get some intermingled mix

77
00:03:56,666 --> 00:03:59,566
所以这个锁的值很重要
and so this lock value is important

78
00:04:00,066 --> 00:04:03,166
它是一个指针，指向某处可写内存
it's a pointer to somewhere in writable memory

79
00:04:03,400 --> 00:04:04,733
我们要确保
and we want to make sure

80
00:04:04,733 --> 00:04:07,000
它指向的值是0
that the value that it points to is 0

81
00:04:07,900 --> 00:04:10,300
锁的工作原理是
so the way that a lock works is

82
00:04:10,333 --> 00:04:12,900
得到锁的时候
when the lock is obtained

83
00:04:12,966 --> 00:04:16,466
我们将一个值写入那个内存地址
we write a value into that memory address

84
00:04:16,466 --> 00:04:18,133
然后当我们释放锁的时候
and then when we free the lock

85
00:04:18,366 --> 00:04:19,766
我们减少这个数字
we reduce that number

86
00:04:19,766 --> 00:04:21,666
这就像互斥锁一样
so this works just like a mutex

87
00:04:22,166 --> 00:04:24,566
所以我们希望它在某个可写的地方
and so we want it to be somewhere that is writable

88
00:04:24,566 --> 00:04:26,866
且它的值恰好是0
that also happens to have a value of 0

89
00:04:26,866 --> 00:04:29,933
因为这样我们就可以访问底层文件了
because that will allow us to then access the underlying file

90
00:04:29,933 --> 00:04:32,933
我们不会用这把锁把自己锁在外面
we won't lock ourselves out with the lock

91
00:04:33,333 --> 00:04:36,266
将锁指向无效的内存地址
pointing the lock to an invalid memory address

92
00:04:36,300 --> 00:04:38,600
会导致段错误
will result in a segfault

93
00:04:38,766 --> 00:04:40,666
所以我们必须解决这个问题
so we have to tackle this problem

94
00:04:42,466 --> 00:04:44,800
现在假设我们已经解决了锁的问题
now let's assume that we've dealt with that lock problem

95
00:04:44,866 --> 00:04:48,333
我们在内存中有自己的vtable
we have our own exploit vtable sitting somewhere in memory

96
00:04:48,400 --> 00:04:50,600
我们覆盖了FILE结构体
we've overwritten the file struct

97
00:04:50,700 --> 00:04:53,700
绕过了锁，并覆盖了虚表指针
past the lock and overwritten the vtable pointer

98
00:04:53,700 --> 00:04:58,066
我们让虚表指针指向我们的虚表
we've made the vtable pointer point to our exploit vtable

99
00:04:58,133 --> 00:05:01,333
我们明确地知道我们的目标是fwrite
and we specifically know that we are targeting fwrite

100
00:05:01,333 --> 00:05:04,166
所以我们伪造的vtable的值全是null
so our exploit vtable can be full of nulls

101
00:05:04,166 --> 00:05:07,333
除了0x38偏移处
except for the plus Hex 38 offset 

102
00:05:07,500 --> 00:05:09,366
是我们故意放在这里的
where we have strategically placed

103
00:05:09,366 --> 00:05:12,600
win函数的地址
the address of the very well known win function

104
00:05:13,366 --> 00:05:15,600
然后当fwrite被调用
then fwrite is called

105
00:05:16,066 --> 00:05:19,000
fwrite会调用R15+0x38
fwrite calls R15 plus hex 38 

106
00:05:19,000 --> 00:05:23,666
我们知道R15现在是我们的vtable
which we know R15 is now our exploit vtable 

107
00:05:23,666 --> 00:05:25,800
它加上0x38
and that plus hex 38

108
00:05:25,933 --> 00:05:27,200
指向win函数
points to win

109
00:05:28,500 --> 00:05:30,966
我们获得了执行的控制权吗？
did we gain control of execution

110
00:05:32,333 --> 00:05:33,133
没有
no

111
00:05:33,933 --> 00:05:38,400
现代libc对vtable指针做了一个检查
modern libc performs a validation step on the vtable pointer

112
00:05:38,400 --> 00:05:39,266
以确保
to make sure

113
00:05:39,300 --> 00:05:40,700
vtable指针
that the vtable pointer 

114
00:05:40,700 --> 00:05:46,800
指向libc专门为vtable预留的内存区域
points to a region of memory that libc has specifically set aside to contain vtables

115
00:05:46,900 --> 00:05:49,266
所以我们不能让 vtable指针
so we can't make the vtable pointer

116
00:05:49,800 --> 00:05:53,100
指向我们自己伪造的vtable
point to our own vtable that we have constructed

117
00:05:54,500 --> 00:05:57,966
然而，我们仍然可以影响虚表指针
we can however still influence that vtable pointer

118
00:05:58,133 --> 00:05:59,933
这里的新限制是
the new restriction here

119
00:06:00,033 --> 00:06:06,400
虚表指针必须指向虚表区域的某个地方
is that the vtable pointer must point to somewhere in the vtable area

120
00:06:06,566 --> 00:06:11,566
且在指针最初指向的地方，不是只有这一个虚表
and the vtable that it is initially pointing to is not the only vtable in that area

121
00:06:11,766 --> 00:06:14,866
这意味着我们可以修改虚表指针
this means that we can change the vtable pointer

122
00:06:15,700 --> 00:06:17,700
让它指向一个不同的虚表
to point to a different vtable

123
00:06:17,833 --> 00:06:20,300
甚至是一个奇怪的偏移处
or even a strange offset

124
00:06:20,300 --> 00:06:24,600
所以我们多少可以控制要调用的函数
so we have some control and influence over what function will be called

125
00:06:24,600 --> 00:06:30,166
但我们被限制在这个虚表区域内的函数
but we are restricted to mostly functions that are inside this vtable area

126
00:06:30,900 --> 00:06:34,366
这意味着有很多有趣的候选函数
so that means that there are a number of interesting candidates

127
00:06:34,366 --> 00:06:38,533
FILE结构体漏洞利用中，常用的一个是
now one of the ones that is commonly used for file structure exploits

128
00:06:39,400 --> 00:06:42,800
这个IO_wfile_overflow
is to try and call this IO_wfile_overflow

129
00:06:42,866 --> 00:06:47,400
想调用IO_wfile_overflow的原因
and the reason that we want to try and get IO_wfile_overflow called

130
00:06:47,400 --> 00:06:50,066
是因为它调用了do_allocbuf
is because it calls do_allocbuf

131
00:06:50,700 --> 00:06:53,900
do_allocbuf有什么用
okay what's the big deal about do_allocbuf

132
00:06:54,100 --> 00:06:55,933
do_allocbuf
well do_allocbuf

133
00:06:56,900 --> 00:06:58,966
使用了另一个虚表
uses another vtable 

134
00:06:59,100 --> 00:07:06,566
它位于FILE结构体的wide_data成员中
that is located in the wide_data member of the file structure

135
00:07:06,700 --> 00:07:11,533
它访问这个虚表时，不需要验证
and it accesses this vtable without that verification step

136
00:07:12,933 --> 00:07:14,666
那么wide_data是什么呢
so what is wide_data

137
00:07:15,100 --> 00:07:17,400
我们一直在提到新的字段
we just keep coming up with new fields here

138
00:07:17,800 --> 00:07:23,066
wide_data是现代FILE结构体中存在的另一个字段
well wide_data is yet another field that exists in modern file structs

139
00:07:23,566 --> 00:07:26,200
它用于处理宽字符流
it was created to handle wide character streams

140
00:07:26,333 --> 00:07:27,900
不光是Unicode
not specifically Unicode

141
00:07:28,166 --> 00:07:32,700
还包括别的多字节的流
but streams that involve characters that are multi byte

142
00:07:33,466 --> 00:07:36,666
wide_data的定义是
now the definition of the wide_data

143
00:07:36,666 --> 00:07:39,400
wide_data实际上是一个结构体
is the wide_data is in fact a struct in and of itself

144
00:07:39,400 --> 00:07:42,766
非常类似于
is very similar to the definition of the file struct

145
00:07:42,766 --> 00:07:46,766
我们在第一节课讨论过的FILE结构体的定义
that we discussed earlier in the first lecture

146
00:07:47,266 --> 00:07:51,800
它包含我们这节课提到的vtable指针
and that includes this vtable pointer that we just introduced in this lecture

147
00:07:52,066 --> 00:07:55,366
我强烈建议大家点击这张幻灯片上的链接
I'd highly encourage you to click the link in this slide

148
00:07:55,366 --> 00:07:58,533
查看wide_data结构体的源码定义
to see the literal definition of the wide_data struct

149
00:08:01,000 --> 00:08:04,866
我们现在有了完成这个攻击所需的所有信息
we now have all of the information necessary to pull off this exploit

150
00:08:05,266 --> 00:08:08,866
首先，我们要设置文件的wide_data
first we're going to set the file's wide_data

151
00:08:08,900 --> 00:08:10,600
指向内存中的某处
to be somewhere in memory

152
00:08:11,366 --> 00:08:13,966
这个wide_data有一个虚函数表
and that wide_data has a vtable

153
00:08:14,566 --> 00:08:19,400
我们将这个vtable指向我们的vtable
we're going to set that vtable to point to our exploit vtable

154
00:08:20,900 --> 00:08:24,666
接下来，我们覆盖FILE结构体的虚函数表
next we'll overwrite the file struct's vtable

155
00:08:25,000 --> 00:08:29,966
这样好让IO_wfile_overflow被调用
such that IO_wfile_overflow will get called

156
00:08:31,200 --> 00:08:32,600
当它被调用时
now when that gets called

157
00:08:32,900 --> 00:08:34,700
do_allocbuf就会被调用
do_allocbuf is called

158
00:08:35,100 --> 00:08:41,133
do_allocbuf将参考FILE的wide_data虚表
do_allocbuf will reference the file wide_data vtable

159
00:08:41,800 --> 00:08:45,066
然后调用写在那里的函数
to then call the function that is written there

160
00:08:45,066 --> 00:08:47,100
而且它调用时不会被检查
and it will do so with no check

161
00:08:47,600 --> 00:08:49,966
这涉及到了很多成员
now there's a lot of moving components here

162
00:08:50,066 --> 00:08:54,300
所以我不会在一节课上做一个完整的利用
so I don't want to do this full exploit here during a lecture

163
00:08:54,366 --> 00:08:57,133
但我至少可以在GDB中看看这个
but I can at least take a look at this in GDB

164
00:08:57,266 --> 00:08:59,366
这样我们就能知道发生了什么
so we can get an idea of what's going on

165
00:09:01,333 --> 00:09:04,666
好的，我们左边的是
all right so what we have here on the left hand side

166
00:09:04,666 --> 00:09:07,433
一个有漏洞的C程序
is a vulnerable C program 

167
00:09:07,433 --> 00:09:12,300
这个程序非常慷慨
this program is extremely generous

168
00:09:12,300 --> 00:09:15,700
这里我们有一个win函数
but what we have here is we have a vulnerable win function

169
00:09:16,466 --> 00:09:19,166
main会泄露win的地址
main is going to leak out the address of win

170
00:09:19,166 --> 00:09:22,500
它还会告诉我们libc中puts的地址
it's also going to tell us where puts is inside of libc 

171
00:09:22,700 --> 00:09:25,733
然后它将fopen /dev/null
it's then going to call fopen on /dev/null

172
00:09:27,866 --> 00:09:34,800
然后它让我们能写任意值到栈中
next it will allow us to read into the stack whatever we want

173
00:09:35,333 --> 00:09:39,000
栈上有一个巨大的缓冲区
there is a giant buffer sitting on the stack here

174
00:09:39,200 --> 00:09:44,300
它告诉我们这个缓冲区的位置
and it tells us the location of this buffer

175
00:09:44,733 --> 00:09:47,933
然后让我们可以把我们想写的东西写进去
and then allows us to write whatever we want into it

176
00:09:50,666 --> 00:09:54,266
最后程序会提示我们
lastly the program will let us know 

177
00:09:54,533 --> 00:09:57,266
我们可以覆盖FILE结构体
that we can overwrite the file struct 

178
00:09:57,533 --> 00:09:59,666
然后让我们这样做
and then allows us to do so

179
00:10:00,666 --> 00:10:03,733
然后调用fwrite这个FILE结构体
it then calls fwrite on the file struct

180
00:10:05,366 --> 00:10:06,866
然后调用exit
and then calls exit

181
00:10:06,866 --> 00:10:08,200
因为它调用了exit
now because it calls exit

182
00:10:08,200 --> 00:10:13,100
我们不能用任意写覆盖栈上的返回地址
we can't use an arbitrary write to overwrite the saved rip

183
00:10:13,533 --> 00:10:14,933
如果我们编译这个
and if we compile this 

184
00:10:14,933 --> 00:10:16,133
我们将会看到
we'll see 

185
00:10:19,233 --> 00:10:21,000
我们开启了完整的RELRO
that we also have full RELRO 

186
00:10:21,166 --> 00:10:25,400
所以我们针对GOT做一些花哨的操作
so we can't do anything fancy here with the GOT

187
00:10:27,366 --> 00:10:31,100
我们来看看这个程序正常是如何运行的
so let's look at how this program runs normally on its own

188
00:10:32,866 --> 00:10:33,700
我们开始
we do start 

189
00:10:34,200 --> 00:10:36,600
中断在main开头
now break at the beginning of main

190
00:10:37,266 --> 00:10:38,866
我感兴趣的是
what I'm interested in though 

191
00:10:38,933 --> 00:10:44,300
没使用利用payload时，fread正常是怎么样的
is what happens at fread just in normal operation without an exploit payload

192
00:10:44,533 --> 00:10:45,600
或者是fwrite
so or fwrite 

193
00:10:45,600 --> 00:10:48,666
我们在fwrite处设置一个断点
so let's set a breakpoint at fwrite

194
00:10:50,466 --> 00:10:51,800
然后继续
and continue forward

195
00:10:52,300 --> 00:10:54,466
遇到要输入的地方
anywhere that it's prompting for input

196
00:10:54,466 --> 00:10:56,333
我就敲回车
I'm just going to hit return

197
00:10:56,566 --> 00:10:59,566
现在我们在fwrite中
so now we are here in fwrite

198
00:10:59,566 --> 00:11:02,300
我们看一下它的汇编代码
and if we look at the disassembly of it

199
00:11:03,266 --> 00:11:06,066
我们往下划一点
we scroll down here a little bit

200
00:11:07,000 --> 00:11:08,200
我们应该能看到
we should see

201
00:11:10,100 --> 00:11:11,400
一个调用
a call 

202
00:11:11,900 --> 00:11:14,066
我们看到了一个call指令
we do we see a call instruction

203
00:11:14,133 --> 00:11:16,266
实际上这个调用指令
and in fact this call instruction

204
00:11:16,266 --> 00:11:19,466
和之前幻灯片上展示的是一个
is the same instruction that was shown in the slides earlier

205
00:11:19,933 --> 00:11:23,066
在fwrite + 179处
so at fwrite plus 179

206
00:11:23,666 --> 00:11:28,900
我们调用了R15+0x38
we will call whatever is at R15 plus hex 38

207
00:11:29,133 --> 00:11:32,666
所以我们在fwrite+179处设置一个断点
so let's set a breakpoint at fwrite plus 179

208
00:11:39,300 --> 00:11:43,066
现在我们在fwrite + 179
okay we are now at fwrite plus 179

209
00:11:43,266 --> 00:11:46,133
我们来看看R15是什么
and let's take a look at what is R15

210
00:11:51,966 --> 00:11:54,433
R15就是这个地址
so R15 is just kind of this address

211
00:11:54,533 --> 00:11:56,300
这对我们来说没什么意义
this doesn't have a whole lot of meaning to us

212
00:11:57,500 --> 00:12:01,133
但我们在调用栈中看到了
but we do see in the backtrace here

213
00:12:01,133 --> 00:12:08,266
我们把指向FILE结构体的指针，作为fwrite的参数
that we have the pointer to the file struct as an argument to fwrite

214
00:12:08,466 --> 00:12:10,666
我们可以打印这个FILE指针
so we can print this file pointer

215
00:12:11,133 --> 00:12:16,466
注意，GDB识别出这是一个指向FILE结构体的指针
now notice that GDB identifies that this is a pointer to a file struct

216
00:12:16,600 --> 00:12:17,400
这意味着
what this means 

217
00:12:17,500 --> 00:12:21,766
我们可以解引用FP
is that we can dereference FP 

218
00:12:21,833 --> 00:12:25,900
现在我们看到了结构体的各个字段
and now we see the fields of that struct

219
00:12:26,566 --> 00:12:30,733
有带有0xfbad的flags
we have the flags with 0xfbad

220
00:12:31,266 --> 00:12:34,566
以及我们之前讨论过的其他熟悉的东西
as well as other familiar things that we've talked about earlier

221
00:12:34,700 --> 00:12:38,500
现在我看不到的是vtable指针
now what I don't see here is the vtable entry

222
00:12:38,600 --> 00:12:40,866
因为虚表指针应该在这个的末尾
because the vtable entry should be at the end of this

223
00:12:41,366 --> 00:12:46,766
这是因为GDB将其视为FILE指针
and that's because GDB is treating this as a file pointer 

224
00:12:47,200 --> 00:12:49,200
所以我们需要对它进行强制转换
and so we'll need to cast it

225
00:12:55,300 --> 00:12:58,666
转成一个_IO_FILE_plus指针
to be an _IO_FILE_plus pointer

226
00:13:02,666 --> 00:13:07,900
现在我们看到FILE结构体
now we see the file struct that is embedded in the file

227
00:13:08,133 --> 00:13:10,066
以及vtable指针
as well as the vtable entry

228
00:13:10,600 --> 00:13:14,666
那么R15是什么呢
so what was that R15 again

229
00:13:15,300 --> 00:13:19,966
R15是FILE结构体中的虚表指针
R15 is this vtable entry from the file struct

230
00:13:19,966 --> 00:13:22,366
所以这是我们可以控制的
so this is something that we would have control over

231
00:13:23,900 --> 00:13:26,400
GDB中，虚表看起来是什么样的呢
now what does a vtable look like in GDB

232
00:13:27,300 --> 00:13:32,533
可以查看R15指向地址后的20个地址单位
we can examine 20 addresses at R15 

233
00:13:32,633 --> 00:13:34,200
我们看看有什么
let's see what's there

234
00:13:35,100 --> 00:13:36,100
现在我们看到
now we see

235
00:13:36,900 --> 00:13:41,266
这是_io_file_jumps虚表
this is the _IO_file_jumps vtable

236
00:13:41,333 --> 00:13:44,266
这些是它里面的所有函数
and these over here are all functions that are in it

237
00:13:45,600 --> 00:13:48,666
现在如果我打印更多的地址
now if I print more addresses

238
00:13:50,066 --> 00:13:54,300
我们立马能看到_IO_file_jumps虚表后
we'll see that immediately after the file jumps vtable 

239
00:13:54,533 --> 00:13:57,266
是_IO_str_jumps虚表
is an _IO_str_jumps vtable

240
00:13:57,866 --> 00:14:02,066
我们可以继续输出更多前面，或者后面的地址
and we could continue to dump out more addresses ahead or behind

241
00:14:03,166 --> 00:14:06,666
查看这个区域有什么函数
to see what functions are in this region

242
00:14:06,666 --> 00:14:09,833
这些都是有效的跳转目标
and all of these are valid jump targets

243
00:14:09,833 --> 00:14:14,300
能满足libc对vtable指针的合法性校验
as far as libc's vtable pointer validation is concerned

244
00:14:14,866 --> 00:14:18,100
所以我们可以修改虚表指针
so we could possibly change our vtable pointer

245
00:14:18,466 --> 00:14:22,966
不再指向_io_file_jumps的开头
instead of pointing to this _IO_file_jumps the beginning of that

246
00:14:23,100 --> 00:14:25,066
而是指向这里的任意位置
it could be anywhere in here

247
00:14:25,333 --> 00:14:27,400
控制实际调用的函数
to control what is actually called

248
00:14:27,966 --> 00:14:29,166
我们说过
now we said that

249
00:14:29,566 --> 00:14:30,766
程序的指令
the instruction

250
00:14:33,533 --> 00:14:37,700
会调用R15+0x38处
is the going to call whatever is at R15 plus hex 38

251
00:14:37,900 --> 00:14:39,000
我们看看这里有什么
so let's see what that is

252
00:14:43,266 --> 00:14:47,133
它会调用_IO_new_file_xsputn
well it's going to call _IO_new_file_xsputn

253
00:14:47,900 --> 00:14:51,766
我们应该在这里看到
which we should see right here

254
00:14:56,066 --> 00:14:59,100
之所以会调用这个函数
and the reason that this is the function that's called

255
00:14:59,366 --> 00:15:06,300
是因为它距离虚表开头0x38字节
is because it is hex 38 away from the vtable entry

256
00:15:06,333 --> 00:15:10,000
所以通过移动虚表指针
so by moving the vtable pointer to point somewhere else

257
00:15:10,066 --> 00:15:12,366
不管虚表指针指向哪里
wherever the vtable pointer points

258
00:15:12,466 --> 00:15:14,600
将之加0x38
if we add hex 38 to it

259
00:15:14,666 --> 00:15:18,333
就是将要执行或调用的函数
that is what function will get executed or called

260
00:15:19,066 --> 00:15:21,000
现在我们可以步入这个函数
now we can step inside this function

261
00:15:22,866 --> 00:15:24,400
但这不是很有趣
but this isn't very interesting

262
00:15:24,400 --> 00:15:27,700
这是它在开始应该有的行为
this is how it's supposed to behave kind of out the gate

263
00:15:28,300 --> 00:15:30,166
我们把这个执行完
so let's just finish this out

264
00:15:30,400 --> 00:15:32,300
我们看到它正常退出了
and we see that it exited normally

265
00:15:35,300 --> 00:15:38,133
现在我们要运行我的漏洞利用代码
now we are going to run my exploit code 

266
00:15:38,400 --> 00:15:40,400
看看它有什么不同的表现
and see how it behaves differently

267
00:15:45,700 --> 00:15:48,166
这是fwrite的开头
so here we are at the beginning of fwrite

268
00:15:48,566 --> 00:15:55,166
我们可以把断点设在fwrite + 179
and we can probably set that same breakpoint to be at fwrite plus 179

269
00:15:58,100 --> 00:15:59,466
现在我们回到这里
now we're back here

270
00:15:59,466 --> 00:16:02,000
这里有R15
we have R15

271
00:16:03,500 --> 00:16:07,000
我们应该有FILE指针
and we should have our file pointer

272
00:16:08,533 --> 00:16:13,166
你能注意到没有设置flags
now you'll note that I don't have the flags set

273
00:16:13,533 --> 00:16:18,000
这是因为我们在GDB中看到的这个FILE结构体
and that's because this file struct that we're seeing in GDB

274
00:16:18,300 --> 00:16:20,366
是利用脚本注入的FILE结构体
is my exploit file struct

275
00:16:22,700 --> 00:16:26,700
我们还是需要强制转换它，才能看到虚表
but we still need to cast it in order to see that vtable

276
00:16:40,033 --> 00:16:43,166
现在能看到我已经覆盖了虚表
now we see that I've overwritten the vtable entry

277
00:16:43,533 --> 00:16:47,733
这样它就会跳转到这个特定的地址
such that it will jump to this specific address

278
00:16:48,366 --> 00:16:50,166
这是虚表的位置
that's where the vtable is

279
00:16:50,566 --> 00:16:52,866
如果我们看一下
and if we look at

280
00:16:53,800 --> 00:16:56,300
这个地址加上0x38
this address plus HEX 38

281
00:17:02,166 --> 00:17:05,500
我精心设计了这个
I have crafted this such that

282
00:17:10,400 --> 00:17:13,266
当执行此调用指令时
when this call instruction is executed

283
00:17:13,666 --> 00:17:18,100
它将跳转到0x38 + 这个地址
it is going to jump to Hex 38 + this address

284
00:17:18,200 --> 00:17:23,933
这会把我转到IO_wfile_overflow
and that will send me to IO_wfile_overflow

285
00:17:24,166 --> 00:17:26,466
就是我们在幻灯片中提到的
which is what we mentioned in the slides

286
00:17:27,166 --> 00:17:28,400
我们步入它
so let's step into that

287
00:17:29,900 --> 00:17:33,533
现在我在wfile_overflow中
now here I am in wfile overflow

288
00:17:34,566 --> 00:17:36,300
如果继续执行
if we march forward here

289
00:17:41,600 --> 00:17:45,900
我们现在调用wdoallocbuf
we now call wdoallocbuf

290
00:17:47,900 --> 00:17:49,900
这是我们想要的
now this is where we want to be

291
00:17:52,766 --> 00:17:54,400
你会在这里看到
you'll see right here

292
00:17:54,800 --> 00:18:00,166
在解引用RDI+ 0xa0处
at this dereference of RDI+ 0xa0

293
00:18:00,800 --> 00:18:05,266
这是取RDI中的FILE结构体
this is taking the file struct which is what's in RDI

294
00:18:10,500 --> 00:18:12,633
并获取wide_data值
and grabbing the wide_data value

295
00:18:12,733 --> 00:18:17,900
它在FILE结构体内0xa0偏移处
which is 0xa0 into the file struct

296
00:18:18,933 --> 00:18:24,533
它把wide_data指针放入了RAX
so it's putting that wide_data pointer into RAX

297
00:18:26,133 --> 00:18:27,100
实际上是的
actually though yeah

298
00:18:27,933 --> 00:18:29,533
随着我们的前进
and as we move forward

299
00:18:38,266 --> 00:18:39,200
在这里
right here

300
00:18:39,866 --> 00:18:44,333
我们看到RAX，它是我们的wide_data指针
we see RAX which is our wide_data pointer

301
00:18:45,333 --> 00:18:50,766
加上偏移，以获得wide_data结构体的虚表
being offset to get the vtable of the wide_data struct

302
00:18:51,266 --> 00:18:54,533
它被放进RAX
and that is now being moved into RAX right here

303
00:18:56,566 --> 00:18:59,466
如果我们继续执行一个指令
so if we step one more

304
00:19:04,933 --> 00:19:11,233
这是wide_data结构体地址
this right here is my wide_data struct 

305
00:19:11,633 --> 00:19:13,166
我们应该能在我的FILE结构体中看到
we should see that

306
00:19:17,500 --> 00:19:21,800
7748，这里
7748 right here in my file struct

307
00:19:21,800 --> 00:19:23,066
我已经构造好了
I have constructed it

308
00:19:23,066 --> 00:19:25,866
这样wide_data指针就是这个值
such that the wide_data pointer is this value

309
00:19:26,500 --> 00:19:29,566
就是我们在RAX看到的
which is what we see right here in RAX

310
00:19:33,366 --> 00:19:35,066
我们再步入这个
so as we step through this

311
00:19:36,300 --> 00:19:39,100
我们现在要解引用或者说
we're now going to be dereferencing or

312
00:19:39,333 --> 00:19:44,700
从wide_data指针取出偏移量，以获取虚表
pulling an offset from the wide_data pointer to get the vtable

313
00:19:45,766 --> 00:19:47,666
现在这个RAX
so now this RAX

314
00:19:49,400 --> 00:19:55,500
是FILE结构体中wide_data的虚表
is my vtable in the wide_data struct that is in the file struct

315
00:19:56,666 --> 00:19:59,000
这里的这个call
and this final call here

316
00:19:59,966 --> 00:20:11,799
会来到wide_data虚表中偏移0x68处
is offsetting the vtable in the wide_data struct in the file struct by 0x68 

317
00:20:12,266 --> 00:20:15,966
我们看看我的利用脚本设置了什么
let's see what my exploit has that set to

318
00:20:22,933 --> 00:20:24,900
这会调用win函数
this is going to call the win function

319
00:20:25,733 --> 00:20:26,966
如果我们继续
and if we continue

320
00:20:29,900 --> 00:20:31,200
会报段错误
it segfaults

321
00:20:31,866 --> 00:20:34,000
但你知道段错误前它做了什么
but you know what it did before it segfaulted

322
00:20:35,100 --> 00:20:36,700
它输出了you win
it said you win

323
00:20:38,400 --> 00:20:39,766
所以我们能够
so we were able

324
00:20:40,533 --> 00:20:44,233
利用这些虚函数表
to take advantage of these virtual function tables 

325
00:20:44,366 --> 00:20:48,466
去执行任何我们想要执行的
to execute whatever we wanted

326
00:20:52,066 --> 00:20:55,466
我没有在演示中展示利用脚本的代码
now I didn't show the exploit code in the demo

327
00:20:55,766 --> 00:20:58,500
这是有原因的
and there was a good reason for that

328
00:20:58,900 --> 00:21:01,600
这个模块的很大一部分题目
a large part of the challenge of this module

329
00:21:01,866 --> 00:21:05,733
是思考如何满足这些要求
is reasoning about how to meet these requirements

330
00:21:06,000 --> 00:21:11,800
以在限制下完成虚表利用
to pull off a vtable exploit in a restricted environment

331
00:21:11,933 --> 00:21:14,866
以及如何思考结构体
and how do we think about structs

332
00:21:14,933 --> 00:21:17,700
如何考虑指向结构体的指针
or how do we think about a pointer to a struct

333
00:21:17,833 --> 00:21:21,500
以及指针指向结构体，它的成员变量又是指针的情况
or a pointer to a struct that has a member that is a pointer

334
00:21:22,000 --> 00:21:24,533
做这个内存探索
kind of doing this this memory map

335
00:21:24,700 --> 00:21:27,066
建立一个处理它的思考模型
and having a model of working with that

336
00:21:27,800 --> 00:21:30,666
对我来说，GDB是一个了不起的工具
now for me GDB is an amazing tool

337
00:21:30,666 --> 00:21:32,566
可以助我理清处理它的思路
to kind of march my way through this

338
00:21:32,800 --> 00:21:34,666
所以我强烈推荐
and so I'd strongly recommend

339
00:21:35,000 --> 00:21:39,566
如果你已经放弃GDB，请再试一次
that you give gdb another try if you have forsaken the tool

340
00:21:40,266 --> 00:21:45,466
因为我这个例子很慷慨
because my example challenge here was extremely gracious

341
00:21:45,466 --> 00:21:47,666
它给我们泄露了很多信息
it gave us a lot of leaks

342
00:21:47,666 --> 00:21:53,133
它给了我们一整页的内存，能放任何想放的东西
it gave us a whole page of memory for us to place whatever we'd like

343
00:21:54,133 --> 00:21:57,066
不是说我的利用脚本使用了这一整页内存
I'm not saying that my exploit used this whole page of memory

344
00:21:57,200 --> 00:22:00,933
但如果我写入一个完整的虚表
but if I wrote a whole vtable

345
00:22:01,300 --> 00:22:03,233
再来一个虚表
and then another vtable 

346
00:22:03,233 --> 00:22:05,266
再接着一个FILE结构体
and then a file struct 

347
00:22:05,266 --> 00:22:08,333
还有wide_data结构体
and then a wide_data struct

348
00:22:08,566 --> 00:22:10,700
如果我把这些都写在内存中
and I wrote all of that into memory

349
00:22:10,700 --> 00:22:13,600
我会使用相当大的空间
I'm going to start using quite a bit of space

350
00:22:14,600 --> 00:22:15,400
现在
now

351
00:22:16,900 --> 00:22:20,700
你可以成功实施虚表指针利用
you can still pull off a vtable pointer exploit

352
00:22:21,700 --> 00:22:24,333
或者说利用虚表指针
or exploit the vtable pointer 

353
00:22:24,333 --> 00:22:27,966
而不需要占用大量内存
without needing a massive amount of space

354
00:22:28,166 --> 00:22:31,966
方法是利用重叠结构体
and the way that you do that is by overlapping structs

355
00:22:32,500 --> 00:22:36,200
所以这个模块中，不光要求
so not only will this module ask you

356
00:22:36,533 --> 00:22:39,933
理解结构体和里面的偏移量
to reason about structs and the offsets into them

357
00:22:39,966 --> 00:22:42,766
以及一个指针指向一个结构体
and how a pointer to a struct 

358
00:22:42,766 --> 00:22:45,300
它的成员也是一个指针
and then an offset to it that is a pointer

359
00:22:45,300 --> 00:22:47,500
以及如何在内存中设置它
and how to kind of set that up in memory

360
00:22:48,133 --> 00:22:52,066
但随着限制越来越严格
but as the restrictions get a little bit tighter here

361
00:22:52,100 --> 00:22:55,000
你将必须使用一块小内存
you'll have to use a small memory region

362
00:22:55,000 --> 00:22:57,500
来表示一个以上的结构体
to represent more than one struct

363
00:22:58,066 --> 00:23:01,066
方法是
and the way that you do that is you recognize

364
00:23:01,266 --> 00:23:03,800
你要认识到，真正有用的值
that the only values that truly matter

365
00:23:04,200 --> 00:23:07,866
对于你的利用脚本来说
as far as the execution path that your exploit is going to take

366
00:23:08,200 --> 00:23:11,100
是实际要访问的值
are the values that are actually accessed

367
00:23:11,766 --> 00:23:14,533
假如在某处有一个结构体
if I say that there is a struct somewhere

368
00:23:14,533 --> 00:23:19,866
但唯一会被访问的是0x20偏移处
but the only value that's accessed is the struct plus hex 20

369
00:23:20,366 --> 00:23:23,666
那么这整个结构体中唯一有价值的值是
then the only value that matters in that entire struct

370
00:23:23,733 --> 00:23:28,066
0x20偏移处的值
is the bytes there that are written at the pointer plus hex 20

371
00:23:28,700 --> 00:23:30,866
所以你可以利用这一点
and so you can use this knowledge

372
00:23:30,866 --> 00:23:34,200
在内存中放置几个结构体
to place several structs in memory

373
00:23:34,600 --> 00:23:36,600
但实际上都在同一个地方
effectively in the same place

374
00:23:36,700 --> 00:23:41,900
因为只要这些结构体中会被访问的值不重叠就行
because the only values of those structs that are being accessed do not overlap

375
00:23:42,400 --> 00:23:48,133
这肯定需要一些实验和对GDB的使用
now this will definitely take a little bit of experimenting and playing around with GDB

376
00:23:48,466 --> 00:23:51,100
才能推出如何实现
to reason about how exactly this works

377
00:23:51,100 --> 00:23:55,600
但当你理解并应用在利用脚本中，它会是很强大的东西
but it's an extremely powerful thing to realize in apply in your exploits

378
00:23:57,266 --> 00:23:59,000
另一个要注意的
on an unrelated note

379
00:23:59,800 --> 00:24:01,700
FILE结构体是链在一起的
file structs are chained

380
00:24:01,700 --> 00:24:03,766
它们实际上在一个链表中
they're actually in a linked list

381
00:24:04,266 --> 00:24:05,900
原因是
and the reason for this

382
00:24:06,566 --> 00:24:13,733
有时缓冲区数据不会被flush掉
is because sometimes the buffers don't get flushed

383
00:24:13,733 --> 00:24:16,733
你可以调用fwrite，但这不能保证
you can call fwrite and that there's no guarantee

384
00:24:16,866 --> 00:24:21,200
当fwrite被调用时，数据会写到文件
that that gets flushed out to a file when fwrite is called

385
00:24:21,200 --> 00:24:22,966
写入的数据在缓冲区中
it could just be sitting in the buffer

386
00:24:23,133 --> 00:24:27,066
那么，如果调用fwrite后exit会怎样
so what happens if you call fwrite and then exit

387
00:24:27,800 --> 00:24:29,733
流函数
well the streaming functions

388
00:24:29,733 --> 00:24:31,933
或者说库的流组件
or the streaming components of the library here

389
00:24:32,000 --> 00:24:37,400
会确保这些数据被写入到文件中
have to make sure that that data does get flushed out to the file

390
00:24:37,966 --> 00:24:41,366
它会遍历这个链表
and so it will go through this linked list

391
00:24:42,400 --> 00:24:46,300
写入到所有对应文件
to flush all of the files and ensure that

392
00:24:46,600 --> 00:24:50,700
并确保写缓冲区代表的写入真的发生
all of the representative region wirtes have in fact occurred

393
00:24:51,500 --> 00:24:59,000
如果你看一下你程序打开文件的FILE链表
and if you explore the chain on a file that's opened  in like your user program 

394
00:24:59,000 --> 00:25:00,566
你会发现
you will find

395
00:25:01,066 --> 00:25:02,500
在链表最下面是
down the link list 

396
00:25:02,500 --> 00:25:05,266
标准输入，标准输出，标准错误
standard in standard out and standard err

397
00:25:07,366 --> 00:25:09,600
只是一种随机的??
just as a kind of random ??

398
00:25:10,500 --> 00:25:14,700
这个FILE结构体链表
so these chained file structs 

399
00:25:14,966 --> 00:25:17,866
的确有利用方法
do have a exploitation use

400
00:25:19,000 --> 00:25:25,200
我们知道每个为了写而打开的文件，都会flush入文件
if we know that every file that's open for writing needs to get flushed

401
00:25:25,300 --> 00:25:29,800
而且flush这个动作
and we know that the act of flushing the file stream 

402
00:25:29,866 --> 00:25:33,200
会用到虚函数和虚表
is going to use virtual functions and a vtable

403
00:25:33,366 --> 00:25:40,766
并且存在我们上面讨论的漏洞
and is vulnerable to the type of exploit that we discussed up here

404
00:25:45,333 --> 00:25:52,733
那么我们就可以对多个FILE结构体进行虚表漏洞利用
then we could perform a vtable exploit on multiple file structs

405
00:25:54,966 --> 00:25:59,766
这就不只是调用一个win函数了
such that instead of calling a win function

406
00:26:00,900 --> 00:26:07,266
每个FILE结构体都有一个虚表漏洞
each file struct has a vtable exploit 

407
00:26:07,266 --> 00:26:11,266
能当作一个ROPgadget
that runs one ROP gadget

408
00:26:13,500 --> 00:26:14,566
然后你就可以
you can then

409
00:26:16,100 --> 00:26:22,100
把每个关闭前flush的FILE，当作一个gadget
call one gadget for every file that is getting flushed at close

410
00:26:22,900 --> 00:26:30,966
并利用FILE结构体的清理过程，进行ROP
and effectively rop through the cleanup of the file structs

411
00:26:31,766 --> 00:26:34,600
这就是所谓的面向文件流编程
this is known as file stream oriented programming

412
00:26:37,200 --> 00:26:38,566
非常疯狂的东西
very crazy stuff

413
00:26:41,066 --> 00:26:43,633
说到文件结构体
so while on the topic of file structs

414
00:26:44,100 --> 00:26:48,500
和文件流，算是这种利用的厉害之处
and file streams kind of the power of this type of exploit

415
00:26:48,900 --> 00:26:53,966
尤其是针对FILE结构体的虚表指针的改动
particularly messing around with the file struct vtable pointer

416
00:26:54,400 --> 00:26:57,166
不得不提到一篇博客
it's worth mentioning a blog post

417
00:26:57,933 --> 00:27:00,700
它的标题为Angry FSROP
that is entitled Angry FS ROP

418
00:27:02,166 --> 00:27:08,266
这是亚利桑那州立大学seccomp实验室中一名博士生的博客文章
and this is a blog post by one of the ASU seccomp Labs PhD students

419
00:27:08,600 --> 00:27:09,366
Kylebot
Kylebot 

420
00:27:09,600 --> 00:27:12,766
你可能在pwn.college的discord频到中看到过他
you may have seen him in the pwn College Discord from time to time

421
00:27:13,366 --> 00:27:15,900
凯尔所做的是
and what Kyle did

422
00:27:16,400 --> 00:27:22,500
他意识到针对虚表指针的限制
is he realized that the limitation on the vtable pointer

423
00:27:23,133 --> 00:27:25,300
其实是一个很大的空间
is a innumerable space

424
00:27:25,933 --> 00:27:29,666
于是他决定用angr枚举它
and so he decided to use angr to enumerate

425
00:27:30,733 --> 00:27:35,400
看看有哪些可执行的
what possible execution states are there

426
00:27:36,533 --> 00:27:40,700
每个虚表指针
for every vtable entry

427
00:27:41,733 --> 00:27:43,466
将虚表指针设置为
for setting the vtable to be

428
00:27:43,966 --> 00:27:49,800
任何能通过libc内存校验的值
anything that it possibly could be within that validated libc memory region

429
00:27:50,733 --> 00:27:51,900
在这个过程中
while doing so

430
00:27:52,333 --> 00:27:57,933
他发现了这里存在的一些新的利用技术
he was able to discover some new exploitation techniques that exist there

431
00:27:58,266 --> 00:28:00,000
我就不剧透这篇博客了
I'm not going to spoil the blog post

432
00:28:00,000 --> 00:28:02,166
如果你有时间
so if you do have the time

433
00:28:02,266 --> 00:28:04,133
我强烈建议你去看看
I'd highly recommend to check it out

434
00:28:04,400 --> 00:28:06,133
因为这就在几个月前发出的
as this was just a few months ago

435
00:28:06,466 --> 00:28:10,733
全新的FILE结构体利用技术
a brand new file struct techniques being published

436
00:28:11,000 --> 00:28:12,533
肯定是很酷的东西
definitely some cool stuff

