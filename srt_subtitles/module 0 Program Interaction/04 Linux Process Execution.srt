1
00:00:00,533 --> 00:00:01,866
你好,学生
hello students

2
00:00:01,866 --> 00:00:02,533
我是Yan
I'm Yan

3
00:00:02,533 --> 00:00:04,466
今天我们继续
and today we're going to continue

4
00:00:04,466 --> 00:00:08,766
关于Linux进程的基础系列
 on our fundamentals series with Linux process run time

5
00:00:08,966 --> 00:00:13,466
前面我们看了一个程序/bin/cat
so previously we looked at how a program /bin/cat 

6
00:00:13,466 --> 00:00:18,500
但实际上是我们为了方便，写的自定义的cat
but really our custom version of cat that we wrote for simplicity

7
00:00:20,733 --> 00:00:21,700
是如何加载的
gets loaded 

8
00:00:21,700 --> 00:00:27,500
从像磁盘上的elf二进制文件那样的程序
goes from being a program like an elf binary on disk

9
00:00:28,466 --> 00:00:39,966
到进程虚拟内存空间的程序
to being a program in the virtual memory space of a process

10
00:00:40,200 --> 00:00:43,166
好了，我们谈谈下一步吧
all right let's talk about the next steps

11
00:00:43,166 --> 00:00:45,900
在加载完成，初始化后
so after it's loaded initialized etc

12
00:00:45,966 --> 00:00:47,400
就开始执行了
execution begins

13
00:00:48,400 --> 00:00:51,600
这是如何处理的，执行是如何开始的
how is that handled how does execution begin 

14
00:00:51,800 --> 00:00:56,666
它是用__libc_start_main函数来处理的
well it is handled using a function called __libc_start_main

15
00:00:56,666 --> 00:01:00,800
它是一个库函数，你的二进制文件会调用它
it's a library function that your binary will call

16
00:01:02,100 --> 00:01:04,400
然后它会调用你的main函数
and expect that to call your main function

17
00:01:04,533 --> 00:01:06,366
这个过程有点曲折
it's a bit of a convoluted process

18
00:01:06,933 --> 00:01:09,366
它这样子的原因有很多
for a number of reasons this is the way it is

19
00:01:11,200 --> 00:01:13,266
我们快速看一下
but let's take a quick look 

20
00:01:13,266 --> 00:01:16,400
我展示一下，然后接着往前
so I can show it to you and then you will move on

21
00:01:16,733 --> 00:01:19,700
上个视频中的示例我还开着呢
oops I still had this open from a previous demo

22
00:01:19,700 --> 00:01:20,866
好了
so all right

23
00:01:23,533 --> 00:01:28,266
我们快速看一下我们的cat
let's look at our cat program real quick

24
00:01:28,533 --> 00:01:29,300
简单明了
nice and simple

25
00:01:29,300 --> 00:01:30,966
只有一个main函数
just has a main function that

26
00:01:31,000 --> 00:01:33,266
cat会打开给定文件或标准输入
cats have either file or standard in 

27
00:01:33,266 --> 00:01:36,433
这取决于是否给了它参数
depending on whether arguments were given to it or not 

28
00:01:36,433 --> 00:01:39,400
当然，如果你记得这里
of course if you recall right here

29
00:01:40,700 --> 00:01:42,166
这是个检查
this is a check

30
00:01:42,166 --> 00:01:43,700
只要给了参数
if any arguments were given 

31
00:01:43,700 --> 00:01:45,133
一定是有argv[0]的
there will always be argv[0]

32
00:01:45,133 --> 00:01:46,400
正常情况下
I mean normally 

33
00:01:46,400 --> 00:01:49,766
你当然可以用空的argv启动进程
you can of course launch a process with a completely empty argv

34
00:01:49,966 --> 00:01:53,366
默认情况下，argv[0]里放的是程序名
by default your shell will put argv[0] as the name of the process

35
00:01:54,066 --> 00:02:01,733
或者是启动程序的命令（如python）
or the name of whatever command was invoked to end up running that program

36
00:02:02,600 --> 00:02:06,000
如果argc是2或者更多
otherwise if argc is you know two or more

37
00:02:06,333 --> 00:02:07,866
这意味着有argv[1]
that means there is an argv[1]

38
00:02:07,900 --> 00:02:09,866
argv数组里的第二个元素
a second argument in that array

39
00:02:09,933 --> 00:02:13,966
此时可以打开一个文件来读
and it'll be able to open a file for reading

40
00:02:13,966 --> 00:02:14,666
好的
all right

41
00:02:14,666 --> 00:02:15,700
开工吧
let's roll

42
00:02:16,933 --> 00:02:20,166
当我执行cat时，就像刚刚做的那样
when I execute cat as I just did up here obviously

43
00:02:21,800 --> 00:02:23,200
它输出了这个文件
it cats out the file

44
00:02:23,200 --> 00:02:25,800
但这个执行过程是怎么开始的
but how does that execution actually happen

45
00:02:26,500 --> 00:02:32,466
我创建了一个用于LD_PRELOAD的库
I created a little tiny library that will be able to LD_PRELOAD 

46
00:02:32,566 --> 00:02:36,466
它能替代__libc_start_main
to grab a hold of __libc_start_main

47
00:02:36,466 --> 00:02:37,599
在这之前
actually before we do that 

48
00:02:37,600 --> 00:02:38,666
我展示一下
let me show you

49
00:02:38,933 --> 00:02:42,766
如果用readelf看一下cat
if we do readelf on the cat binary

50
00:02:48,466 --> 00:02:50,866
你看这里
and you look right here

51
00:02:50,966 --> 00:02:56,000
这个10c0是程序的入口地址
this 10c0 is the entry point address of the program

52
00:02:56,099 --> 00:03:00,966
加载器（解释器）会来这里执行
right so this is where the loader will redirect execution 

53
00:03:00,966 --> 00:03:04,200
程序加载地址 +0x10c0
wherever it loaded plus 10c0

54
00:03:04,366 --> 00:03:09,000
当然，这是在加载器加载完cat依赖库等东西后
after it is done loading libraries and everything the cat depends on

55
00:03:10,133 --> 00:03:13,500
我们看一下这个位置有什么
let's take a look what is there at that location

56
00:03:13,600 --> 00:03:18,600
如果用objdump反汇编cat
so if we use objdump to disassemble cat 

57
00:03:18,866 --> 00:03:24,833
每次我都忘了用正确的汇编语法
and every time I forget to do it in the right assembly syntax 

58
00:03:24,966 --> 00:03:25,599
请记住
remember

59
00:03:25,900 --> 00:03:28,266
在x86架构上，用英特尔汇编风格
when on x86 use Intel assembly 

60
00:03:28,300 --> 00:03:31,133
因为AT&T的汇编风格看起来很别扭
because AT&T assembly just looks weird

61
00:03:32,900 --> 00:03:34,100
就是这个
here it is 

62
00:03:34,100 --> 00:03:39,733
这里是_start
we have our start right there and

63
00:03:43,333 --> 00:03:44,133
等一下
wait a second

64
00:03:44,666 --> 00:03:47,300
鼠标光标失控了
my mouse cursor just went crazy let me

65
00:03:50,266 --> 00:03:54,300
好了，start在0x10c0
okay we have start right here at 10c0 

66
00:03:54,300 --> 00:03:55,966
然后是
and then we have

67
00:03:57,700 --> 00:03:59,200
一系列设置操作
after a bunch of setup 

68
00:03:59,200 --> 00:04:02,466
这里用汇编指令call调用了__libc_start_main
we see an assembly call into __libc_start_main

69
00:04:02,800 --> 00:04:05,366
然后__libc_start_main接管执行流
and then __libc_start_main takes over execution

70
00:04:05,600 --> 00:04:07,300
我们看看
let's take a look at

71
00:04:13,866 --> 00:04:14,800
编译
compile

72
00:04:16,200 --> 00:04:19,066
我说过我们有个
so I mentioned we have our little

73
00:04:20,566 --> 00:04:22,266
这是另一节课的东西
that's from a different thing

74
00:04:22,600 --> 00:04:24,066
抱歉，有点不在状态
sorry it's been a long day

75
00:04:28,166 --> 00:04:29,300
看看这个
take a look at this

76
00:04:29,300 --> 00:04:33,533
我写这个是为了展示
I wrote this guy to showcase

77
00:04:34,600 --> 00:04:38,100
能通过LD_PRELOAD替换 __libc_start_main
that we can LD_PRELOAD __libc_start_main 

78
00:04:38,100 --> 00:04:40,466
和其它库函数一样
just like we can any other library 

79
00:04:40,466 --> 00:04:42,666
所以编译肯定没问题
so we can of course compile this

80
00:04:48,700 --> 00:04:55,533
现在执行cat时，可以加上LD_PRELOAD start_main.so
now we can LD_PRELOAD start_main.so when we do cat

81
00:04:59,733 --> 00:05:00,833
它输出了hello
it just types hello 

82
00:05:00,933 --> 00:05:02,199
我们再看一遍
we look at again

83
00:05:09,366 --> 00:05:11,333
看看写的代码
we look at what we wrote

84
00:05:11,800 --> 00:05:16,200
它覆盖了__libc_start_main
it overwrites __libc_start_main

85
00:05:16,733 --> 00:05:20,366
这是__libc_start_main的参数
this is the arguments that __libc_start_main takes

86
00:05:20,366 --> 00:05:21,400
都是比较特别的东西
it's some crazy stuff

87
00:05:21,400 --> 00:05:25,066
一个指向main函数的函数指针
it takes a function pointer to main

88
00:05:25,766 --> 00:05:30,500
你应该非常熟悉C中的函数指针
you should get very familiar with this function point syntax in C 

89
00:05:30,500 --> 00:05:32,733
这个参数名叫main
this is a argument called main 

90
00:05:32,733 --> 00:05:34,800
它是一个函数
which is actually a function

91
00:05:34,966 --> 00:05:36,900
它接收3个参数
which takes 3 arguments

92
00:05:37,266 --> 00:05:38,133
int型的argc
int argc 

93
00:05:38,133 --> 00:05:40,100
char**的argv
char** argv 

94
00:05:40,100 --> 00:05:42,466
还有char**的envp
and char** envp

95
00:05:43,999 --> 00:05:45,899
我们稍后会讨论envp
and we'll talk about envp in a sec

96
00:05:46,300 --> 00:05:47,600
还有参数
it takes an argument to

97
00:05:48,533 --> 00:05:49,700
实际的argc
the actual argc 

98
00:05:49,700 --> 00:05:50,800
实际的argv
the actual argv

99
00:05:51,700 --> 00:05:54,800
这是一堆用于初始化的函数指针
a bunch of function pointers to initializers

100
00:05:57,266 --> 00:06:00,566
像构造函数，析构函数等等
constructor destructors and so forth

101
00:06:00,566 --> 00:06:04,100
还有一个指向栈底的指针
and a pointer to where the stack ends

102
00:06:04,933 --> 00:06:08,166
我不清楚它是如何获得环境变量指针的
I have no idea how it gets the environment variable pointer

103
00:06:08,166 --> 00:06:09,100
我没深入调查
I didn't look into it 

104
00:06:09,100 --> 00:06:10,133
我这里直接传入了0
so I just passed that 0

105
00:06:10,133 --> 00:06:12,533
然后直接调用了main
but then we just call main 

106
00:06:12,533 --> 00:06:13,333
很酷
very cool

107
00:06:16,933 --> 00:06:18,366
所以当你LD_PRELOAD时
so when you LD_PRELOAD 

108
00:06:18,366 --> 00:06:19,066
它做的就是
all it does

109
00:06:19,500 --> 00:06:20,333
输出个你好
prints hello

110
00:06:20,566 --> 00:06:22,900
然后用main的返回码做退出码
then exits with the return code 

111
00:06:22,900 --> 00:06:23,800
而且这行得通
and it works

112
00:06:25,133 --> 00:06:25,933
很酷
cool stuff all right

113
00:06:25,933 --> 00:06:28,666
所以我们甚至可以覆盖这么基础的功能
so we can overwrite even this sort of base functionality

114
00:06:28,666 --> 00:06:30,266
好的，我们继续
all right let's move on

115
00:06:32,866 --> 00:06:33,900
下一步是什么?
what is next

116
00:06:34,866 --> 00:06:40,533
cat在启动后
so cat after it gets launched

117
00:06:40,599 --> 00:06:45,633
会从内存中读取参数和环境变量
it reads its arguments and environment from memory

118
00:06:45,966 --> 00:06:49,866
有两个参数argv和envp
we have these two arguments argv and envp

119
00:06:50,266 --> 00:06:55,100
我们看看这能拿到什么
let's look at what that entails right

120
00:06:55,266 --> 00:06:59,766
程序启动时，来自外部的唯一输入
again the only input from the outside world at program start

121
00:06:59,766 --> 00:07:01,199
就是这些参数
are these arguments

122
00:07:01,533 --> 00:07:05,500
其他的就是加载到内存中的二进制文件本身
everything else is just binaries loaded in memory

123
00:07:08,200 --> 00:07:12,266
什么是环境变量
what is actually an environment variable

124
00:07:13,266 --> 00:07:14,300
我们来看一看
let's take a look

125
00:07:15,200 --> 00:07:16,566
环境变量
an environment variable

126
00:07:17,000 --> 00:07:19,200
是LD_PRELOAD之类的东西
is something like this LD_PRELOAD thing

127
00:07:19,566 --> 00:07:22,833
它本质上就是个参数
it is an argument essentially 

128
00:07:22,833 --> 00:07:33,800
通过argv这组字符串参数之外的途径，传给程序的参数
an extra argument that you can pass outside of the argv set of strings to your program

129
00:07:33,800 --> 00:07:35,866
有很多环境变量
there's a lot of environment variables

130
00:07:36,466 --> 00:07:37,733
你可以用env
you can hit env

131
00:07:37,766 --> 00:07:41,266
列出此时所有的环境变量
to list out all the environment variables set for you at that time 

132
00:07:41,266 --> 00:07:42,666
这里有很多
there's a lot of them here

133
00:07:44,000 --> 00:07:48,733
如果你想的话，也可以编程查看
if you want of course you can ask them programmatically

134
00:07:48,733 --> 00:07:50,400
我写了一个小的env
I wrote a little env

135
00:07:50,866 --> 00:07:51,900
这是个系统工具
actual system utility

136
00:07:51,900 --> 00:07:54,200
我写了一个替代品
I also wrote a little replacement for it

137
00:07:54,500 --> 00:07:55,700
方便我们玩一玩
for us to play with

138
00:07:56,266 --> 00:07:57,366
先获取这个envp
you get this envp 

139
00:07:57,366 --> 00:07:59,733
然后遍历
and you can just iterate through 

140
00:07:59,733 --> 00:08:03,700
输出envp的各个条目
and print out every entry of envp

141
00:08:04,200 --> 00:08:09,566
直到遇到终止envp数组的空指针
until you hit a null pointer that terminates the envp array

142
00:08:10,900 --> 00:08:14,200
编译一下
so let's compile this

143
00:08:15,900 --> 00:08:17,733
好的，运行它
okay and run it 

144
00:08:18,400 --> 00:08:19,700
漂亮
boom nice and simple

145
00:08:20,266 --> 00:08:25,466
我们也可以传入环境变量
all right we can also pass it some environment variable

146
00:08:28,166 --> 00:08:30,399
在这里，它出现在了envp中
and here it is it shows up in our envp 

147
00:08:30,566 --> 00:08:31,299
我也可以
I can also 

148
00:08:31,700 --> 00:08:32,200
这
so this

149
00:08:32,466 --> 00:08:33,300
让我
let me just

150
00:08:34,000 --> 00:08:39,133
这可以让我传入多个环境变量
this lets me just send tons of environment variable 

151
00:08:39,300 --> 00:08:41,966
或者说给它加入多个环境变量
or add tons of variables to its environment

152
00:08:43,500 --> 00:08:44,566
用空格分隔
separated by spaces

153
00:08:44,566 --> 00:08:47,000
如果希望在环境变量中使用空格
if you want spaces in your environment variables

154
00:08:49,966 --> 00:08:51,000
你可以这么做
you can do this

155
00:08:53,966 --> 00:08:55,133
简单明了
nice and simple okay

156
00:08:55,466 --> 00:09:01,133
环境变量是传递参数的好方法
environment variables are good way to pass arguments to 

157
00:09:01,300 --> 00:09:08,966
例如，往LD_PRELOAD中的用于调试的库传参
for example little LD_PRELOAD libraries you designed to debug things

158
00:09:09,666 --> 00:09:17,300
因为很难拿到当时实际的命令行参数
because it's a pain in the butt to grab the actual command line arguments at that point

159
00:09:18,733 --> 00:09:26,299
环境变量还能改变你熟知工具的行为
they also changed the behavior of some normal utilities that you might be used to 

160
00:09:26,333 --> 00:09:27,966
我创建了这个test目录
so I created this test folder 

161
00:09:27,966 --> 00:09:29,200
在这个test目录中
inside this test folder 

162
00:09:29,266 --> 00:09:31,066
有五个文件
there are five files 

163
00:09:31,066 --> 00:09:35,766
分别叫1、 a、A、b、B
files called 1、 a、A、b、B

164
00:09:36,333 --> 00:09:37,533
执行ls -l
do an ls -l

165
00:09:37,600 --> 00:09:40,100
它会根据文件名排序
it sorts the files by name

166
00:09:40,900 --> 00:09:43,200
这里的结果看着很合理
and here we have something that looks reasonable 

167
00:09:43,333 --> 00:09:46,166

1、a、A、b、B

168
00:09:46,300 --> 00:09:48,166
但有趣的是
but the interesting thing is 

169
00:09:48,266 --> 00:09:53,466
在ASCII中，大写字母应该排在小写字母之前
in ASCII the upper case letters should go before the lower case letters

170
00:09:53,566 --> 00:09:55,700
A为0x41
A upper case is 0x41 

171
00:09:55,700 --> 00:09:58,166
B为0x42
and B upper case is 0x42

172
00:09:58,366 --> 00:10:01,600
a是0x61, b是0x62
a lower case is 0x61 and b is 0x62

173
00:10:02,533 --> 00:10:05,866
所以应该是用了别的配置
so they should be very differently configured 

174
00:10:06,033 --> 00:10:07,866
事实证明
it turns out that

175
00:10:10,000 --> 00:10:14,700
是因为这个默认设置的LANG环境变量
this LANG environment variable that's set by default is responsible

176
00:10:14,700 --> 00:10:16,300
这会告诉libc
this tells libc

177
00:10:17,533 --> 00:10:18,366
可能libc
probably libc 

178
00:10:18,466 --> 00:10:19,933
不是libc就是ls
either libc or ls 

179
00:10:19,966 --> 00:10:25,366
用别的方法对这些文件排序
to sort these file names differently

180
00:10:25,533 --> 00:10:28,466
如果我们将LANG设置为C
if we set the lang to capital c

181
00:10:28,733 --> 00:10:30,600
表示C语言
c the language

182
00:10:31,400 --> 00:10:36,266
这是ASCII的排序方式
this is the default like ASCII normal way of sorting it

183
00:10:38,300 --> 00:10:43,300
然后可以用ls -l看一下排序结果
then we can do ls -l and see the correct sorting so to say

184
00:10:44,100 --> 00:10:47,800
就是举个例子，说明环境变量有影响
just as an example that these variables have impact

185
00:10:48,166 --> 00:10:50,666
好的，我们讨论完了环境变量
all right we have talked about variables

186
00:10:50,666 --> 00:10:52,400
我们继续
let's move on

187
00:10:53,133 --> 00:10:55,766
cat能从环境中获取环境变量
so cat gets its variables from the environment

188
00:10:55,766 --> 00:10:59,966
一切都很好
everything is all super happy of course

189
00:10:59,966 --> 00:11:01,766
但它也需要和外界保持互动
it needs to keep interacting with outside world

190
00:11:01,833 --> 00:11:02,966
不只是一个单向的
it's not just like a one way

191
00:11:03,266 --> 00:11:05,466
不是说给它一堆参数，然后它自己做就好了
we just give it a bunch of arguments and does a thing

192
00:11:05,533 --> 00:11:07,533
它需要能打开文件之类的（和os交互）
it needs to be able to open files etc etc

193
00:11:09,333 --> 00:11:10,533
它是怎么做到的呢
so how does it do that 

194
00:11:10,666 --> 00:11:15,166
程序是如何实现它们的功能的
how do programs actually achieve their functionality

195
00:11:17,333 --> 00:11:19,866
特别是当这个功能特别复杂的时候
when that functionality can be pretty complex

196
00:11:21,533 --> 00:11:25,000
从范式的角度来说
well one kind of way paradigm speaking

197
00:11:25,000 --> 00:11:27,766
就是说，使用库函数
in terms of like paradigms is using library functions

198
00:11:27,766 --> 00:11:31,566
实际上，在你的一生中，应该努力
you should actually in your entire life strive to write as

199
00:11:31,800 --> 00:11:33,666
写尽量少的代码
little code as possible

200
00:11:34,300 --> 00:11:36,466
尽可能少写几行代码
few lines of code as you possibly can

201
00:11:36,500 --> 00:11:39,166
你可以用库函数实现这个目的
and you do that by using library functionality

202
00:11:39,400 --> 00:11:41,400
聪明点，学用库
be smart about it and use libraries

203
00:11:43,533 --> 00:11:44,400
库
libraries

204
00:11:45,333 --> 00:11:49,166
我们得费一番周折才能找到库
we have to go through a whole crazy thing to even find where the libraries are

205
00:11:49,166 --> 00:11:51,366
就像上节课讲的那样
as we talked about in the last lecture

206
00:11:52,200 --> 00:11:54,933
现在我们需要更进一步
now we need to go through a further thing 

207
00:11:54,933 --> 00:12:01,600
要找到用的库中某个函数的地址
to understand where in the library certain functions are that we're using

208
00:12:01,600 --> 00:12:02,966
这些被称为符号
these are called symbols

209
00:12:03,733 --> 00:12:06,300
就像二进制文件中的一些名字
as in like names of the binary 

210
00:12:06,300 --> 00:12:08,466
我们快速看一下
so let's take a quick look

211
00:12:09,066 --> 00:12:10,100
我要说的是
I'm gonna mention 

212
00:12:10,100 --> 00:12:14,166
我主要会讲历史背景中的这个过程
I'm mostly talking about this kind of in a historical context

213
00:12:14,166 --> 00:12:17,966
这曾经有
this used to be a massive surface of like

214
00:12:18,566 --> 00:12:20,166
一个巨大的攻击面
a massive attack surface

215
00:12:20,166 --> 00:12:23,666
因为过去可以改动进程的加载过程
because you used to be able to really mess with the loading process

216
00:12:24,466 --> 00:12:27,766
现在基本不行了
recently this is not really the case anymore

217
00:12:28,600 --> 00:12:34,400
过去，符号都是在要用的时候解析
it used to be that all of these symbols would be resolved on demand 

218
00:12:34,566 --> 00:12:37,899
比如，你的程序用了printf
so if your program used printf

219
00:12:38,133 --> 00:12:41,000
不会一开始就找到printf在libc中的位置
printf wouldn't actually be located inside libc

220
00:12:41,200 --> 00:12:42,866
只有在马上要调用printf时，才会找
until you went and called printf

221
00:12:42,900 --> 00:12:44,933
这是因为，一个复杂的程序
this is because of a complex program 

222
00:12:44,933 --> 00:12:47,866
可能用了成千上万的符号
that used maybe thousands and thousands of symbols

223
00:12:47,866 --> 00:12:50,200
而且运行的电脑也慢
and was loaded on a slow computer

224
00:12:50,200 --> 00:12:52,966
把这些都查一遍要花些时间
would actually take a while to look all of these up

225
00:12:52,966 --> 00:12:57,133
所以只想等用时，再费工夫
and you don't want to pay that cost until you actually use that functionality

226
00:12:59,966 --> 00:13:02,800
现在我们的电脑速度非常快
nowadays our computers are blazing fast

227
00:13:04,000 --> 00:13:08,633
而这种用时才查找的方式，有很多安全问题
this on demand lookup caused so many security problems 

228
00:13:08,700 --> 00:13:10,466
出了很多安全漏洞
and exposed so many security holes

229
00:13:10,566 --> 00:13:13,266
所以我们通常不这样做了
that we no longer normally do that

230
00:13:13,500 --> 00:13:20,800
现在符号解析都很快，且安全
nowadays things mostly get resolved at low time and protected

231
00:13:21,333 --> 00:13:27,766
我们将在内存错误模块，讨论曾经的符号解析方式
so we'll actually revisit this in the memory corruption section from a historical perspective

232
00:13:28,200 --> 00:13:33,266
但现在，我就展示一下二进制文件中的符号
but for now I'm just gonna show you what symbols look like in a binary 

233
00:13:33,333 --> 00:13:34,199
然后就继续往下
and then we'll move on

234
00:13:35,733 --> 00:13:38,900
我们的cat在这里
alright so we have our cat

235
00:13:40,766 --> 00:13:47,033
我们看一下cat导入的符号
let's look at the symbols that cat imports 

236
00:13:47,066 --> 00:13:56,933
这些是cat用到的各种库函数
so these are all of the various library functions that cat will use 

237
00:13:57,033 --> 00:14:01,833
当然不只是函数，也可以是库导出的全局符号
or not just functions that can also be globals exported by the library

238
00:14:03,200 --> 00:14:04,966
这里有__libc_start_main
you know __libc_start_main

239
00:14:04,966 --> 00:14:07,100
当然还有，open read write
of course we use open read and write

240
00:14:07,333 --> 00:14:13,600
这个，这是一个安全机制，将在内存错误中讨论它
this is a security feature we'll talk about in the memory corruption module

241
00:14:14,066 --> 00:14:18,866
这基本上防住了特定类型的攻击
that basically protects against certain expectation types

242
00:14:18,866 --> 00:14:20,066
这些是其他的
these are various other

243
00:14:20,966 --> 00:14:21,533
抱歉
sorry that 

244
00:14:21,533 --> 00:14:26,933
这些是其它的一些构造和析构的功能
these are various other functionality set up and tear down

245
00:14:27,800 --> 00:14:31,200
这些是cat导入的全部符号
and these are all the symbols that cat imports 

246
00:14:31,200 --> 00:14:33,266
cat导出的符号
the symbols that cat exports

247
00:14:34,900 --> 00:14:39,900
有_start，这是入口地址
are _start that's where our entry point is

248
00:14:41,000 --> 00:14:42,566
看看能不能找到main
let's see if you can find main

249
00:14:42,700 --> 00:14:43,433
main在这里
here's main 

250
00:14:43,433 --> 00:14:44,566
很酷
pretty cool stuff 

251
00:14:44,566 --> 00:14:48,333
我们还可以看看start_main库的符号
we can also look at our start_main library 

252
00:14:48,433 --> 00:14:49,499
它更有趣
that's more interesting

253
00:14:49,700 --> 00:14:53,066
它导出了__libc_start_main
it actually exports __libc_start_main

254
00:14:53,066 --> 00:14:53,900
它在哪里
where is that

255
00:15:06,200 --> 00:15:07,000
在这
there it is

256
00:15:08,066 --> 00:15:09,866
它导出了__libc_start_main
it exports __libc_start_main

257
00:15:09,866 --> 00:15:11,700
但如果你再看看cat
whereas if you look at cat again

258
00:15:12,366 --> 00:15:13,933
只看导入符号
just just the import 

259
00:15:13,933 --> 00:15:15,666
它导入了__libc_start_main
it'll import __libc_start_main 

260
00:15:15,800 --> 00:15:16,933
我用的是nm
I'm using nm

261
00:15:17,066 --> 00:15:19,866
它是查看二进制文件里符号的工具
it's a utility to look at symbols in binaries

262
00:15:22,666 --> 00:15:23,766
粗略地讲
roughly speaking

263
00:15:23,900 --> 00:15:25,566
这些标记着U的符号
these symbols that are U

264
00:15:25,566 --> 00:15:27,400
不是在该二进制文件中定义的
that are not defined in the binary

265
00:15:27,400 --> 00:15:30,866
会从其它文件导入
will be imported from somewhere else

266
00:15:31,000 --> 00:15:33,800
二进制文件中定义了的，有地址的符号
symbols that are defined in the binary that have an address

267
00:15:33,800 --> 00:15:36,933
就有可能导出给别的文件
will be potentially exported somewhere else

268
00:15:36,933 --> 00:15:40,933
现在，如果我们用file查看cat
in fact nowadays if we look at cat using file

269
00:15:41,666 --> 00:15:44,766
正如我在上一讲中提到的
as I mentioned earlier in the previous lecture 

270
00:15:44,966 --> 00:15:45,966
现在
nowadays

271
00:15:47,466 --> 00:15:50,100
所有这些动态链接的二进制文件
all these dynamicly-linked binaries 

272
00:15:50,100 --> 00:15:54,000
它们实际相当于自己的库
they are actually libraries of their own 

273
00:15:54,566 --> 00:15:58,666
能把cat当库放到LD_PRELOAD中用
I could LD_PRELOAD cat in

274
00:15:59,966 --> 00:16:01,633
这可能会造成一些混乱
that will probably cost some chaos 

275
00:16:01,633 --> 00:16:04,000
因为将会有2个main函数
because there would be two main functions

276
00:16:04,000 --> 00:16:06,900
但理论上，你可以把cat当成库加载
but you know theoretically you could load cat as a library

277
00:16:09,766 --> 00:16:11,166
这无关紧要
that's neither here nor there 

278
00:16:11,299 --> 00:16:13,066
我们继续吧
let's get back to work

279
00:16:13,066 --> 00:16:17,300
现在我们看了库函数
so now we've looked at library function

280
00:16:17,300 --> 00:16:19,266
它是一种与环境交互的方法
so that's one way of interacting with the environment

281
00:16:19,266 --> 00:16:20,633
另一种方法是什么
what is another way 

282
00:16:20,633 --> 00:16:22,266
我们还能怎么做呢
how else might we do it

283
00:16:22,533 --> 00:16:25,466
我们还可以用系统调用
well we do it using system calls

284
00:16:25,533 --> 00:16:28,833
我们在上个视频中，已经提到过2个了
we already mentioned two previously in the process loading 

285
00:16:29,033 --> 00:16:31,166
fork、clone，实际还有第三个execve
fork clone and actually a third execve

286
00:16:31,266 --> 00:16:32,333
这些都是系统调用
so these are all system calls

287
00:16:32,333 --> 00:16:36,000
这是你与Linux操作系统交互的方法
this is how you interact with Linux as an operating system 

288
00:16:36,000 --> 00:16:42,000
与外部世界交互的方法
with the world like all external interaction is going to be 

289
00:16:42,066 --> 00:16:47,866
至少要通过系统调用来启动
at least going to be initiated through system calls

290
00:16:48,100 --> 00:16:49,433
我们可以用strace
we can use strace 

291
00:16:49,433 --> 00:16:52,799
这个我们已经在加载的视频中见过了
which we already kind of a sneak peak in the loading

292
00:16:52,866 --> 00:16:55,766
用它查看执行时调用的系统调用
to look at these system calls as they execute

293
00:16:55,766 --> 00:16:56,900
我们来看一下
so let's check it out

294
00:16:58,200 --> 00:17:01,566
我们strace cat cat.c
let's say strace cat cat.c 

295
00:17:01,866 --> 00:17:04,466
你可以看到具体发生了什么
so you can see exactly what happens

296
00:17:04,533 --> 00:17:05,966
从起初的execve
starting from the execve

297
00:17:06,933 --> 00:17:12,200
然后进入各种初始化过程
and going onwards into various setup procedures

298
00:17:12,866 --> 00:17:17,300
比如为库映射虚拟内存之类的
you know mapping in space for libraries and so forth

299
00:17:19,166 --> 00:17:27,166
一直到打开我们想输出的文件
all the way through opening the file we want to cat out

300
00:17:28,066 --> 00:17:29,533
读取这个文件
reading that file

301
00:17:29,900 --> 00:17:31,333
这是我们读到的内容
so this is what is read

302
00:17:32,266 --> 00:17:33,666
读取了170字节
read a 170 bytes 

303
00:17:33,666 --> 00:17:37,466
如果我们检查一下这个文件的大小
and if we actually check how big that file is 

304
00:17:37,466 --> 00:17:39,400
正好是170字节
it is exactly 170 bytes

305
00:17:39,600 --> 00:17:41,000
然后把它写出来
and then writing it out

306
00:17:41,400 --> 00:17:44,566
我们在这里执行的write
so here we do the write and

307
00:17:45,866 --> 00:17:48,400
大小是170字节
with a 170 and of course the

308
00:17:49,700 --> 00:17:50,500
这是
this is

309
00:17:51,266 --> 00:17:54,866
strace在标准错误输出，输出系统调用
the strace prints out the system calls to standard error

310
00:17:56,066 --> 00:17:57,866
而二进制文件在标准输出，输出东西
while the binary is printing stuffs to standard out

311
00:17:57,966 --> 00:17:59,233
它俩都输出到一个终端
because it goes to the same terminal 

312
00:17:59,433 --> 00:17:59,933
所以我们都能看到
so we can

313
00:18:00,266 --> 00:18:01,333
哦，不是这个
oops wrong one

314
00:18:02,566 --> 00:18:04,166
我们可以重定向输出
we can redirect the output 

315
00:18:04,333 --> 00:18:05,866
现在看起来更清爽了
and now this looks a little cleaner

316
00:18:05,866 --> 00:18:07,366
或者可以重定向标准错误输出
or we can redirect standard error

317
00:18:07,666 --> 00:18:08,966
只看标准输出
and just see the original output

318
00:18:09,100 --> 00:18:10,733
好的，我们执行了read
alright so we do the read 

319
00:18:10,733 --> 00:18:11,766
然后write
we do the write

320
00:18:12,366 --> 00:18:15,133
又read了一次，返回结果为0
we do another read and we get 0 

321
00:18:15,133 --> 00:18:16,600
然后我们退出
and then we exit 

322
00:18:16,600 --> 00:18:21,966
如果我们看一下cat.c，就懂了
if we look at cat.c that makes exact sense

323
00:18:21,966 --> 00:18:24,166
这是那个while循环，表示
so here's the while loop says 

324
00:18:24,166 --> 00:18:27,466
在read时，read的返回值大于0
while we read our read returns greater than 0

325
00:18:27,533 --> 00:18:29,466
并且write的返回值大于0
and the write returns greater than 0

326
00:18:29,500 --> 00:18:30,366
就保持循环
keep looping

327
00:18:30,666 --> 00:18:34,566
这里，read返回值为0，就终止了循环
in this case the read returned 0 and we terminated

328
00:18:35,100 --> 00:18:35,900
好了
there you go 

329
00:18:35,900 --> 00:18:37,366
这就是系统调用
that is system call

330
00:18:37,366 --> 00:18:38,300
还有一件事
one more thing

331
00:18:38,566 --> 00:18:39,799
如果你执行 man syscall
if you man system call

332
00:18:39,900 --> 00:18:45,600
能看到很多关于系统调用原理的文档
this will give you a whole lot of documentation about how system calls work

333
00:18:46,100 --> 00:18:51,800
这是它们在不同架构上的调用约定
this is how their calling convention on different architectures

334
00:18:52,933 --> 00:18:54,000
很酷
it's very cool stuff

335
00:18:54,266 --> 00:18:56,933
你还可以单独查看某个系统调用
you can also look at a specific system call

336
00:18:57,966 --> 00:18:59,866
比如，open
this is open for example

337
00:19:00,333 --> 00:19:02,133
这是它的文档
with its documentation

338
00:19:03,766 --> 00:19:08,533
你能看到，我没include很多东西
you'll notice that I don't include stuff

339
00:19:08,533 --> 00:19:10,566
导致这里很多警告
and this leads to warnings everywhere

340
00:19:10,600 --> 00:19:11,866
我懒
I'm very lazy

341
00:19:11,933 --> 00:19:15,100
但man手册能告诉你要include什么
but you know man page will tell me what to include

342
00:19:15,100 --> 00:19:16,500
就可以解除这些警告
so that the warnings go away

343
00:19:16,766 --> 00:19:18,333
这很好，但我不会去做
which would be awesome but I'm not gonna do it

344
00:19:18,333 --> 00:19:19,966
好吧，很酷
all right cool

345
00:19:21,866 --> 00:19:22,766
还有一件事
one more thing 

346
00:19:22,900 --> 00:19:24,966
你在C中使用的这些系统调用
these system calls that you use in C

347
00:19:26,266 --> 00:19:29,766
它们实际就是被调用的C函数
they're actually C functions that get called 

348
00:19:29,766 --> 00:19:36,900
如果我们反汇编cat，然后看main
so if we disassemble cat and we look at main

349
00:19:38,700 --> 00:19:42,166
它调用了libc中的open
it's calling open inside libc

350
00:19:45,933 --> 00:19:50,499
不自己写汇编代码，很难让libc
it's very hard without writing custom assembly to actually get libc to

351
00:19:50,733 --> 00:19:55,200
或让gcc显示触发系统调用的代码
or to get GCC to emit code that triggers a syscall

352
00:19:57,666 --> 00:19:59,066
因为libc有很多封装
libc has wrappers for it

353
00:19:59,066 --> 00:20:01,000
它们会触发对应的系统调用
that will trigger the correct system call

354
00:20:02,000 --> 00:20:03,633
如果你不想用libc
if you don't want to use libc 

355
00:20:03,633 --> 00:20:05,133
想写不用libc的代码
if you want to write code that doesn't use libc

356
00:20:05,200 --> 00:20:11,366
你在shellcode模块某个作业中，写shellcode时
when you're writing shellcode in one of your assignments in the shellcoding module

357
00:20:11,366 --> 00:20:15,066
你需要手动触发系统调用
you will need to handcraft those system calls

358
00:20:17,466 --> 00:20:23,400
一个很好的系统调用资源是
one awesome resource for system calls is

359
00:20:25,200 --> 00:20:27,266
怎么更好的展示呢
how can I show this easily

360
00:20:30,000 --> 00:20:34,333
我会把它放到对应的模块里
I'll post it in the module instead alright

361
00:20:34,566 --> 00:20:35,733
酷
cool

362
00:20:36,933 --> 00:20:37,733
所以
so

363
00:20:39,500 --> 00:20:45,266
你还可以调用syscall
you can also do a syscall call

364
00:20:45,300 --> 00:20:48,133
它能让你指定号码，来调用系统调用
which allows you to specify the system call number

365
00:20:48,366 --> 00:20:50,299
每个系统调用对应了一个号码
each system call has a number 

366
00:20:50,433 --> 00:20:54,499
我们用strace时
so as we strace this

367
00:20:57,966 --> 00:21:00,300
我们实际能看到
what we would actually see

368
00:21:01,966 --> 00:21:03,366
strace的输出太友好了
because strace is too friendly

369
00:21:04,666 --> 00:21:06,100
每个系统调用都有一个号码
every system call has a number

370
00:21:06,100 --> 00:21:08,866
触发一个系统调用，实际上是
and what happens to trigger a system call

371
00:21:08,966 --> 00:21:11,466
我们将在shellcode模块中更详细地讨论这个
we'll talk about this actually more in the shellcoding module

372
00:21:11,500 --> 00:21:17,000
传入这个号码，就触发了对应的系统调用
is you pass that number and you trigger a system call

373
00:21:17,933 --> 00:21:19,133
为了展示给你看
to show you

374
00:21:20,333 --> 00:21:23,900
我搜一下系统调用号
let me look up the system numbers

375
00:21:31,333 --> 00:21:32,133
好的
all right

376
00:21:32,400 --> 00:21:35,266
比如，read的系统调用号是0
for example read is system call zero

377
00:21:35,800 --> 00:21:38,600
所以我们可以修改cat.c
so we can actually modify cat.c 

378
00:21:38,600 --> 00:21:39,766
不用read了
instead of read

379
00:21:40,000 --> 00:21:42,900
改用syscall 0 加上参数
we use syscall 0 with the argument

380
00:21:43,600 --> 00:21:44,400
好的
okay

381
00:21:44,966 --> 00:21:46,466
编译cat.c
compile cat.c

382
00:21:51,000 --> 00:21:52,866
执行cat cat.c
cat cat.c

383
00:21:53,000 --> 00:21:54,133
用上strace
do the strace

384
00:21:55,100 --> 00:21:56,666
效果看起来一模一样
and looks exactly the same

385
00:21:58,400 --> 00:21:59,766
write系统调用号是1
write is syscall 1

386
00:22:00,466 --> 00:22:01,900
所以我们可以这样
so we can do this here

387
00:22:06,700 --> 00:22:09,333
这让我们更接近
this gets us one step closer

388
00:22:10,366 --> 00:22:14,066
原本的样子
to what things would look like

389
00:22:14,500 --> 00:22:19,300
如果你在shellcode中手动用汇编调用系统调用
if you were writing syscalls manually in assembly in shellcode

390
00:22:19,500 --> 00:22:23,400
我们稍后再做最后一步
and we'll take the final step there a little later 

391
00:22:23,400 --> 00:22:23,866
让我
let me

392
00:22:25,866 --> 00:22:28,366
怎么展示呢
how would I show you

393
00:22:29,733 --> 00:22:31,800
我在哪里看到的系统调用号表
so where I get the syscall numbers

394
00:22:31,800 --> 00:22:33,533
哦，你可以在这边上看到
oh you can see it here on the side

395
00:22:34,466 --> 00:22:37,500
放在了最右边
but it is actually optimized for the slide

396
00:22:37,500 --> 00:22:38,866
你应该看不清
so you can't really see it

397
00:22:38,933 --> 00:22:46,100
这是一个由Ryan A. Chapman创建的Linux系统调用表
this is a Linux syscall table created by Ryan A. Chapman

398
00:22:46,100 --> 00:22:50,666
他是所有shellcoder的英雄
he is a hero of shellcoders everywhere

399
00:22:51,000 --> 00:22:58,766
你可以搜索Ryan A. Chapman x86系统调用表
you can just Google Ryan A. Chapman x86 syscall table

400
00:22:58,933 --> 00:23:00,133
非常有用
very useful all right

401
00:23:00,333 --> 00:23:01,300
回到幻灯片
back to slides

402
00:23:01,500 --> 00:23:02,666
我们继续
let's roll on

403
00:23:03,366 --> 00:23:05,900
这就是系统调用的工作原理
so that's how syscalls work 

404
00:23:05,900 --> 00:23:08,033
这是与环境互动的唯一方式吗
is that the only way to interact with environments

405
00:23:08,133 --> 00:23:09,066
用系统调用
I mean using syscalls

406
00:23:09,066 --> 00:23:11,233
我们可以做很多很多事情
we can do many many many things 

407
00:23:11,233 --> 00:23:17,266
我们可以open、read、write、fork、execve
we can open read write as we saw fork execve

408
00:23:18,333 --> 00:23:21,300
可以用wait来等待子进程终止
we can use wait to wait for a child process to terminate

409
00:23:21,300 --> 00:23:24,133
实际上，我们必须使用它来避免僵尸进程
we actually have to use it to avoid zombie process 

410
00:23:24,299 --> 00:23:25,199
我马上就会讲到它
that I'll talk about in a sec

411
00:23:26,666 --> 00:23:28,700
我们可以调用任意的系统调用
we can invoke arbitrary syscalls

412
00:23:28,700 --> 00:23:34,366
有的系统调用能让进程作为调试器，附加到别的进程
there are syscalls to attach to process as a debugger

413
00:23:34,533 --> 00:23:39,566
有的能打开网络链接
there are syscalls to open network connections

414
00:23:39,566 --> 00:23:42,966
有很多不同的系统调用
there are syscalls for quite a lot of various things

415
00:23:43,466 --> 00:23:49,766
可以用man syscall查看更多信息
you can again look at man syscalls for more information

416
00:23:51,766 --> 00:23:58,666
非常标准的操作系统接口
very standard interface for doing operating system stuff

417
00:23:58,766 --> 00:23:59,866
一般来说
generally speaking

418
00:24:00,533 --> 00:24:02,333
要在Linux中做任何事情
to do anything in Linux 

419
00:24:02,533 --> 00:24:06,066
你必须打开某种资源，然后与之互动
you have to open some sort of resource and then interact with it

420
00:24:06,100 --> 00:24:07,066
使用read和write
using read and write

421
00:24:07,066 --> 00:24:09,299
有时还有其它的系统调用
sometimes other syscalls other times

422
00:24:09,466 --> 00:24:13,599
我们将在内核模块中进一步探讨这一点
we will explore this even further in the kernel module

423
00:24:14,133 --> 00:24:14,933
好的
all right

424
00:24:16,333 --> 00:24:20,233
系统调用是一种调用进os的方法
syscalls are a way to call into the OS

425
00:24:20,333 --> 00:24:28,199
但当发生某事时，os不能这样进到你的进程
but the OS can't invoke a syscall into your process when something happens

426
00:24:28,866 --> 00:24:31,000
os该如何向你发声
how can the OS talk to you 

427
00:24:31,000 --> 00:24:34,800
或者说，外面的进程如何向你发声，引起你的注意
or someone externally talk to you and kind of to get your attention

428
00:24:35,533 --> 00:24:36,766
当然，你可以用系统调用
of course you can use syscalls to 

429
00:24:36,866 --> 00:24:40,599
不断读一个管道或文件，检查读到的数据
like read from a pipe constantly and check or read from a file

430
00:24:41,900 --> 00:24:43,900
但另一种方法是信号
but another way is to use signals 

431
00:24:44,166 --> 00:24:47,033
信号就是信号
a signal is a signal 

432
00:24:47,200 --> 00:24:51,066
基本上就是OS给你的进程打了个招呼
basically a hey that the OS sends to your process

433
00:24:51,066 --> 00:24:52,900
有很多不同种类的信号
there's a bunch of different signals

434
00:24:53,700 --> 00:24:56,566
你可以为其定义信号处理程序
that you can define signal handlers for

435
00:24:56,900 --> 00:25:00,200
你也可以发信号给别的进程或自己
and you can send to other processes or yourself

436
00:25:00,300 --> 00:25:02,666
如果你没有某个信号的处理程序
if you don't have a signal handler for a signal

437
00:25:02,666 --> 00:25:04,566
当你接收到这些信号时
and you receive one of these signals

438
00:25:05,533 --> 00:25:06,933
会采取默认的处理行为
the default action will be taken

439
00:25:07,033 --> 00:25:09,566
对于某些信号，默认行为是忽略
for some signals the default action is ignore

440
00:25:09,666 --> 00:25:11,700
其他的，则是退出
for others it is die

441
00:25:11,800 --> 00:25:12,866
你的进程将会退出
your process will die

442
00:25:15,100 --> 00:25:17,500
有两个信号是无法捕捉的
there are two signals that cannot be caught

443
00:25:17,500 --> 00:25:19,566
一个是SIGKILL
one is SIGKILL

444
00:25:19,700 --> 00:25:22,766
所以如果你在Linux中执行kill -9 某个进程
so if you ever kill -9 something in Linux 

445
00:25:22,900 --> 00:25:25,766
你这是在给目标进程发送信号9
that is what you're doing you're sending it signal 9

446
00:25:25,866 --> 00:25:32,500
二是SIGSTOP，信号19，它会把进程放到后台
and SIGSTOP signal 19 it'll background a process in Linux

447
00:25:33,200 --> 00:25:36,533
有趣的是，SIGSTOP有两种
interestingly there are two variants of SIGSTOP

448
00:25:36,733 --> 00:25:38,700
信号19、信号20
signal 19 signal 20

449
00:25:38,700 --> 00:25:41,366
在shell中按ctrl z，发送信号20
when you hit control Z in your shell it sends signal 20

450
00:25:41,366 --> 00:25:42,666
这个信号可以被捕获
which you can catch

451
00:25:42,733 --> 00:25:43,900
这挺烦的
which is really annoying

452
00:25:43,933 --> 00:25:46,133
信号19的话，你必须手动发送
signal 19 you have to send manually

453
00:25:46,500 --> 00:25:52,800
这是些常见的信号
all right this is kind of the common signals that you'll see

454
00:25:53,000 --> 00:25:56,400
SIGINT是按ctrl c时发送的
SIGINT is what is sent when you hit control C

455
00:25:58,733 --> 00:26:03,300
SIGQUIT，我记得大多数终端都是按ctrl 反斜杠(\)
and I think SIGQUIT for many terminals is control backslash

456
00:26:03,733 --> 00:26:05,133
还有很多其他的
various other ones

457
00:26:07,200 --> 00:26:14,700
如果你的某个子进程停了，会收到SIGCHLD
you can have a signal  if one of your children processes has stopped

458
00:26:15,766 --> 00:26:17,900
调整了终端窗口大小的话
with your terminal windows resized

459
00:26:17,900 --> 00:26:18,966
这个没列出来
that's not listed here

460
00:26:18,966 --> 00:26:20,766
也会发送个信号
but that sends a signal to the shell

461
00:26:21,300 --> 00:26:23,600
很酷
all sorts of cool stuff

462
00:26:23,600 --> 00:26:29,266
我们快速看一下信号
anyways let's take a quick look at signals

463
00:26:31,100 --> 00:26:34,866
我写了个程序能捕捉所有信号
so I wrote a crazy thing that catches all signals

464
00:26:35,300 --> 00:26:38,000
这个循环会遍历所有信号
so this loops through all of the signals

465
00:26:40,866 --> 00:26:46,366
然后用这个函数，为每个信号，登记信号处理程序
and it registers a signal handler using this signal function

466
00:26:46,766 --> 00:26:52,100
这个函数就是输出收到的信号量
and the signal handle just only prints out that

467
00:26:52,100 --> 00:26:54,100
收到信号后，啥也不做
it received the signal and does nothing

468
00:26:54,100 --> 00:26:56,133
然后这个程序就一直在这里循环
and then this thing sits there and loops forever

469
00:26:56,133 --> 00:26:57,900
这是个很让人无语的程序
it's a very frustrating program

470
00:27:01,966 --> 00:27:04,599
因为很难让他退出
because it's very hard to kill 

471
00:27:04,899 --> 00:27:08,066
如果我按Ctrl C，它就输出收到信号量2
if I hit Ctrl C it says got signal 2

472
00:27:08,533 --> 00:27:10,733
我们稍后再看，但要是kill -l一下
we'll look later but if you do kill -l

473
00:27:10,766 --> 00:27:16,366
能看到信号量2是SIGINT
it'll tell you signal 2 is SIGINT

474
00:27:17,500 --> 00:27:21,500
按ctrl z，是信号量20 (SIGTSTP)sig terminal stop
control Z there's signal 20 (SIGTSTP)sig terminal stop

475
00:27:22,666 --> 00:27:24,733
很难关掉这个程序
it's just hard to kill this program

476
00:27:24,733 --> 00:27:26,199
现在我在另一个终端
in another terminal right now 

477
00:27:26,266 --> 00:27:29,366
执行这个kill -9
I'm gonna do this kill -9 

478
00:27:29,500 --> 00:27:32,333
我们先执行-19 SIGSTOP
actually let's do -19 first SIGSTOP 

479
00:27:32,333 --> 00:27:36,300
然后跟着 pgrep signal 
and then this guy pgrep signal so that

480
00:27:36,866 --> 00:27:39,533
现在我把它复制粘贴到另一个终端
so I'm gonna copy that paste it into another terminal

481
00:27:39,700 --> 00:27:40,533
好的
boom

482
00:27:40,700 --> 00:27:44,766
现在我们关了这个程序
so now we have stopped this binary 

483
00:27:44,900 --> 00:27:46,466
你可以用bg（口误）
and bg you can bg

484
00:27:46,700 --> 00:27:47,733
看这个列表
this list

485
00:27:48,966 --> 00:27:50,400
下面列出了后台信号
this list the background signals

486
00:27:50,400 --> 00:27:52,133
它收到的信号18是什么
what is signal 18 that it got

487
00:27:53,600 --> 00:27:55,466
哦，抱歉
oh bg sorry

488
00:27:56,866 --> 00:28:00,466
jobs是用来列出当前进程的
jobs is how you list the jobs that are currently around

489
00:28:01,133 --> 00:28:04,900
bg是用来把进程放到后台
bg is to send a job into the background

490
00:28:05,500 --> 00:28:07,766
然后恢复运行
and resume its running

491
00:28:07,900 --> 00:28:10,866
让它在后台恢复运行
resume running a process in the background

492
00:28:10,866 --> 00:28:14,533
bash把后台进程称之为jobs
jobs is what bash calls these background processes

493
00:28:15,900 --> 00:28:16,833
如果执行kill -l
if you do kill -l 

494
00:28:16,933 --> 00:28:17,366
我们看一看
let's take a look

495
00:28:17,533 --> 00:28:19,099
我打赌18是SIGCONT
I bet 18 is SIGCONT

496
00:28:19,100 --> 00:28:22,566
是的，18表示，你现在可以继续执行了
yep so 18 says hey you're now continuing

497
00:28:22,566 --> 00:28:26,300
因此，它触发了处理程序，然后恢复执行
so it triggers the handler and then resumes execution

498
00:28:28,000 --> 00:28:29,466
它现在在后台运行
so it's running in the background

499
00:28:29,466 --> 00:28:31,766
你可以用fg把它切回到前台
you can hit fg to bring it back to the foreground

500
00:28:31,766 --> 00:28:33,933
当然，现在我们又遇到了同样的问题
and now of course we're stuck with the same problem

501
00:28:34,400 --> 00:28:37,166
此时我再发送19
when I send this kill 19 again

502
00:28:37,466 --> 00:28:38,133
jobs看一下
jobs 

503
00:28:38,300 --> 00:28:39,700
现在它在后台，停了
now it stopped in the background

504
00:28:42,600 --> 00:28:43,400
我们看看
let's see

505
00:28:43,600 --> 00:28:46,500
当它在前台运行时，会收到窗口变更信号吗
in the foreground will it get the window yeah

506
00:28:46,500 --> 00:28:48,066
看，信号28
see signal 28

507
00:28:48,566 --> 00:28:51,066
好的，现在我要恢复直播画面
okay but now I need to fix my stream okay

508
00:28:51,200 --> 00:28:53,833
酷，收到了多次信号28
awesome got signal 28 many times 

509
00:28:53,833 --> 00:28:56,466
如果我们在另一个终端停掉它
if we stop it again in a different terminal

510
00:28:56,733 --> 00:29:00,966
信号28是SIGWINCH（WINdow CHange）
signal 28 is SIGWINCH window changed

511
00:29:01,300 --> 00:29:03,166
有很多酷的信号
so there's a lot of cool signals

512
00:29:03,533 --> 00:29:10,566
当你正在写入的文件的文件描述符失效时，会收到信号
there are signals that happen when a file descriptor you're writing to has stopped working

513
00:29:10,666 --> 00:29:13,866
比如，连接中断之类的
there are like connection drop or whatever

514
00:29:13,866 --> 00:29:16,566
程序遇到了段错误，也会收到信号
when your program segfaults that's a signal

515
00:29:16,566 --> 00:29:20,433
这个接收所有信号的例子程序中，没有段错误
so this program that catches everything is unsegfaultable

516
00:29:20,433 --> 00:29:23,299
不管怎样，这很有趣
anyways that's fun and all 

517
00:29:23,433 --> 00:29:24,766
我们来关了它
but let's kill it

518
00:29:24,766 --> 00:29:25,733
不能直接关
we can't do that 

519
00:29:25,733 --> 00:29:29,366
所以要执行kill -9 $(pgrep signal)
so what I'm gonna do is kill -9 pgrep signal

520
00:29:29,366 --> 00:29:31,933
signal是程序的名字，pgrep的作用是
that's the name of the binary all pgrep does

521
00:29:31,933 --> 00:29:33,566
我再暂停一下
actually let me pause it again

522
00:29:35,466 --> 00:29:39,966
pgrep会告诉你进程的id
pgrep just tells you its process ID 

523
00:29:39,966 --> 00:29:42,000
它和
it's the same as

524
00:29:42,666 --> 00:29:43,466
哦
oops

525
00:29:44,766 --> 00:29:46,300
和这个差不多
roughly the same as doing this

526
00:29:47,900 --> 00:29:49,766
这是我系统在后台升级
that's my system upgrading in the background

527
00:29:49,900 --> 00:29:51,566
这个是我们的signal程序
and then here's our signal guy alright

528
00:29:52,533 --> 00:29:54,966
现在它停在后台
so it is stopped in the background 

529
00:29:54,966 --> 00:29:56,633
如果我们把它放到前台
if we foreground it now 

530
00:29:56,633 --> 00:29:58,400
再kill -9
I'm gonna do kill -9

531
00:29:58,533 --> 00:29:59,966
关掉了
boom killed that 

532
00:29:59,966 --> 00:30:04,000
没办法捕获kill -9或kill -19
no way to catch kill dash 9 or kill dash 19

533
00:30:04,533 --> 00:30:05,466
这就是信号
that is signals 

534
00:30:05,466 --> 00:30:06,400
很酷
very cool stuff 

535
00:30:06,400 --> 00:30:10,966
你可以用信号做些很酷的事
using signals you can do some cool stuff 

536
00:30:11,100 --> 00:30:13,466
比如，再讲一个
you can for example one more thing

537
00:30:14,533 --> 00:30:16,266
我快速写个示例程序
I'm gonna write you a program real quick

538
00:30:16,266 --> 00:30:17,166
马上回来
I'll be right back

539
00:30:17,566 --> 00:30:19,533
好的，我回来了
all right I am back

540
00:30:19,766 --> 00:30:21,933
看一下我刚写的程序
let's take a look at this program I wrote for you

541
00:30:21,933 --> 00:30:23,466
这是一个有用的信号
this is a useful signal

542
00:30:23,733 --> 00:30:25,666
闹钟信号14
alarm signal 14

543
00:30:26,100 --> 00:30:27,466
kill -l看一下
so if you do kill -l

544
00:30:27,733 --> 00:30:28,466
就是这个
here it is 

545
00:30:28,466 --> 00:30:29,800
SIGALRM
beautiful SIGALRM

546
00:30:29,800 --> 00:30:32,700
当然，要是我在代码中include kill.c
of course if I had included kill.c

547
00:30:32,733 --> 00:30:34,800
我就可以用这个宏了
I could actually use this macro 

548
00:30:34,800 --> 00:30:38,666
但这个不碍事
but we're gonna rough it out

549
00:30:39,300 --> 00:30:44,466
我们就用实际的信号值
tough it out and use the actual signal number alright

550
00:30:44,900 --> 00:30:46,566
方便你记住
so that you can remember 

551
00:30:46,566 --> 00:30:48,866
信号14是个告警
signal 14 is alarm 

552
00:30:48,866 --> 00:30:51,900
这有一个alarm函数
there's a function called alarm

553
00:30:55,100 --> 00:30:57,800
它能为某个信号设置告警
it sets an alarm clock delivery for a signal 

554
00:30:57,800 --> 00:30:59,666
它告诉内核
so it tells the kernel hey

555
00:30:59,766 --> 00:31:01,766
它是个系统调用，它告诉内核
it's a syscall it tells the kernel hey

556
00:31:02,300 --> 00:31:05,900
在这里是，3秒后给我个信号14
 give me signal 14 in 3 seconds in this case 

557
00:31:05,900 --> 00:31:07,700
或是多久后
however many however long

558
00:31:09,366 --> 00:31:10,600
看起来它只支持秒
looks like it only supports seconds

559
00:31:10,600 --> 00:31:16,533
可能有其他细分系统调用支持纳秒之类的
probably there's a way syscall to support nanoseconds or whatever

560
00:31:18,766 --> 00:31:22,100
默认情况下，收到信号14，进程会退出
by default receiving signal 14 will kill your process

561
00:31:22,100 --> 00:31:24,566
它会先输出文字提示，然后关闭进程
it'll actually print alarm clock and kill your process

562
00:31:24,566 --> 00:31:25,866
我们要改变它
we're gonna change it 

563
00:31:25,866 --> 00:31:27,400
我们在这里捕获到它
we're gonna catch it here

564
00:31:27,700 --> 00:31:29,133
输出DING
and print ding

565
00:31:29,166 --> 00:31:29,900
然后退出
and then exit 

566
00:31:29,900 --> 00:31:30,966
你可以做别的
you can do anything

567
00:31:30,966 --> 00:31:32,500
不必退出
you don't have to exit 

568
00:31:32,500 --> 00:31:33,866
有个重要的事情
it's a great thing 

569
00:31:33,900 --> 00:31:36,666
我马上会讲，就是
an interesting thing I'll show you in a sec is that

570
00:31:36,666 --> 00:31:38,833
接收到一个信号
receiving a signal 

571
00:31:40,166 --> 00:31:44,799
能让你从某个代码块中跳出来
breaks your program out of certain block situations 

572
00:31:44,800 --> 00:31:46,833
比如从sleep状态跳出来
like a long sleep 

573
00:31:46,833 --> 00:31:48,766
我们编译
so we compile

574
00:31:52,400 --> 00:31:53,200
运行
we run

575
00:31:54,466 --> 00:31:57,600
它在这个死循环中，等3秒
it's gonna wait three seconds in this infinite loop

576
00:31:58,600 --> 00:31:59,400
我们
let's

577
00:32:01,966 --> 00:32:04,933
它会在这个死循环中等三秒
gonna wait three seconds in this infinite loop 

578
00:32:04,933 --> 00:32:09,333
然后会触发警报
and then the alarm will trigger

579
00:32:09,933 --> 00:32:12,700
然后执行这个信号处理函数
it'll hit this signal handler right here 

580
00:32:12,700 --> 00:32:14,533
输出DING，然后退出
printing and exit all right

581
00:32:15,533 --> 00:32:16,333
好的
awesome

582
00:32:17,933 --> 00:32:18,733
运行
run

583
00:32:18,733 --> 00:32:20,166
2 1
2 1

584
00:32:20,566 --> 00:32:22,333
叮
Ding boom

585
00:32:22,733 --> 00:32:26,833
酷，我改一下
awesome so let me show you another cool thing here 

586
00:32:26,833 --> 00:32:29,333
如果我们不退出
if we don't exit 

587
00:32:29,366 --> 00:32:31,100
当然，它会继续运行
of course this will keep running

588
00:32:31,100 --> 00:32:32,566
一直循环下去
it'll just keep looping

589
00:32:32,566 --> 00:32:33,966
我展示一下
let me just show you that

590
00:32:35,800 --> 00:32:38,466
1 2 3
1 2 3

591
00:32:39,466 --> 00:32:40,333
还接着运行
keeps running

592
00:32:41,766 --> 00:32:44,066
这种持续运行的方式很蠢
this is a silly way to run forever 

593
00:32:44,166 --> 00:32:46,166
因为这浪费了很大力气
because it puts a lot of strength

594
00:32:46,166 --> 00:32:48,966
你的CPU一直在运行
your CPU is just running constantly

595
00:32:49,000 --> 00:32:52,766
相反，可以sleep很长一段时间
instead you can sleep for a very long time

596
00:32:53,466 --> 00:32:55,666
这是10万秒
this is 100 thousand seconds

597
00:32:59,000 --> 00:32:59,800
但
but

598
00:32:59,966 --> 00:33:00,766
哦
oops

599
00:33:02,400 --> 00:33:05,800
1 2 3 boom
1 2 3 boom

600
00:33:05,800 --> 00:33:06,866
程序退出了
it terminated

601
00:33:06,866 --> 00:33:11,466
所以有一些系统调用是可以被信号打断的
there are certain system calls that are interruptible by signals 

602
00:33:11,466 --> 00:33:13,166
我想，类似的
I think in a similar way

603
00:33:14,533 --> 00:33:16,733
如果我们从标准输入中读取数据
so if we do read from standard in

604
00:33:22,066 --> 00:33:23,166
但不输入任何东西
and don't give it anything

605
00:33:23,166 --> 00:33:25,300
我猜也能被打断
I think we should also be able to interrupt that

606
00:33:26,500 --> 00:33:27,366
我们试一下
let's test

607
00:33:29,100 --> 00:33:30,000
我错了
I was wrong 

608
00:33:30,000 --> 00:33:33,300
read不会被alarm打断
so read doesn't get interrupted by an alarm

609
00:33:33,300 --> 00:33:34,100
好吧
all right

610
00:33:34,500 --> 00:33:35,000
重点是
point is 

611
00:33:35,000 --> 00:33:37,366
有其他方法能让read超时
there are other ways to make read time out

612
00:33:37,366 --> 00:33:40,700
但这太深入了
but that's going off on way too deep attention

613
00:33:40,966 --> 00:33:43,000
我还是改回去吧
let me just undo that 

614
00:33:43,000 --> 00:33:47,266
这是原来的alarm
so we have our old alarm binary file

615
00:33:47,466 --> 00:33:51,266
好的，这就是信号，我们不继续深入了
cool that's signals we're now going to move on

616
00:33:54,166 --> 00:33:56,966
另一种交互方式是共享内存
another way of interacting with the outside world is shared memory

617
00:33:56,966 --> 00:34:02,733
有多种方法可以与另一个进程建立共享内存
there are various ways to establish shared memory with another process

618
00:34:03,966 --> 00:34:05,333
最简单的一个方法是
the easiest one

619
00:34:06,600 --> 00:34:08,666
有方法是通过clone实现的
there are ways to do it through the clone syscalls

620
00:34:09,266 --> 00:34:12,099
但用fork是不行的
one way that you cannot do it is with fork 

621
00:34:12,133 --> 00:34:15,599
fork很有趣，它会分裂
fork very interestingly actually splits

622
00:34:16,100 --> 00:34:17,900
会先拷贝内存再写
makes the memory regions copy and write

623
00:34:17,900 --> 00:34:20,133
当进程想往里写的时候
whenever a process tries to write to it

624
00:34:20,300 --> 00:34:23,933
它会先复制一份内存，再往拷贝的自己的内存中写
it'll actually just copy it and write to its own private version

625
00:34:25,533 --> 00:34:27,466
但有其它方法
but there are other ways 

626
00:34:27,466 --> 00:34:31,800
有个目录/dev/shm
there's a file system that exists in /dev/shm 

627
00:34:31,800 --> 00:34:33,866
我给你展示一下
let me show it to you

628
00:34:36,166 --> 00:34:39,500
很多东西用了这个
this file system is used for a bunch of stuff

629
00:34:39,733 --> 00:34:41,133
我机器上没有
well not on my machine

630
00:34:41,266 --> 00:34:44,800
它基本就是一个内存映射的文件系统
but it's basically a memory mapped file system

631
00:34:44,966 --> 00:34:46,800
你可以在这里创建文件
you can create files here

632
00:34:49,966 --> 00:34:53,166
再用mmap映射这些文件
and map these files using mmap

633
00:34:54,466 --> 00:35:00,400
你可以在不同进程中，用文件描述符映射它
you can map a file by its file descriptor from multiple processes 

634
00:35:00,400 --> 00:35:03,066
然后同时访问它
and access it at the same time

635
00:35:03,100 --> 00:35:06,400
可以把它当作一种建立共享内存的简单方法
and use this as an easy way to set up shared memory

636
00:35:07,133 --> 00:35:08,000
很酷
very cool

637
00:35:08,866 --> 00:35:09,966
设置共享内存
set up shared memory

638
00:35:10,766 --> 00:35:11,866
很简单
super simple

639
00:35:12,500 --> 00:35:15,266
这是一种与外界交流的方式
and it's a way to communicate with outside world

640
00:35:15,366 --> 00:35:18,700
或者把共享内存用到别处
or with other things using that shared memory

641
00:35:19,700 --> 00:35:20,500
好吧
all right

642
00:35:21,066 --> 00:35:22,066
我们已经走到了尽头
we've come to the end

643
00:35:22,300 --> 00:35:23,566
现在该发生什么了
what happens now

644
00:35:23,666 --> 00:35:25,300
cat要终止了
cat terminates

645
00:35:25,700 --> 00:35:29,566
终止不是很重要
termination is surprisingly not so trivial right

646
00:35:29,900 --> 00:35:32,866
进程只有一两种终止方式
termination in a process can handle one or two ways

647
00:35:32,966 --> 00:35:35,200
收到一个没有处理函数的信号
receiving an unhandled signal 

648
00:35:35,200 --> 00:35:37,533
或者调用exit系统调用
or calling the exit system call

649
00:35:39,333 --> 00:35:42,666
这是进程结束的唯二方式
those are the only two ways that a process conterminated

650
00:35:42,666 --> 00:35:43,400
你可能会说
you might say 

651
00:35:43,400 --> 00:35:47,466
要是遇到段错误了呢，进程崩了呢
oh but what about a segmentation fault if my process crashes

652
00:35:47,533 --> 00:35:49,800
猜猜段错误是什么？信号
guess what segfault is a signal

653
00:35:49,800 --> 00:35:51,300
当进程崩溃时
when your process crashes

654
00:35:51,300 --> 00:35:53,733
实际上是它收到了一个信号
what actually happens is it receives a signal

655
00:35:54,100 --> 00:35:57,666
信号10
signal 10 and

656
00:35:58,800 --> 00:35:59,100
让我
let me 

657
00:35:59,100 --> 00:36:01,333
不知道为啥，有点不确定
now for some reason I just had a moment of doubt

658
00:36:03,866 --> 00:36:05,900
不是信号10
no of course not signal 10

659
00:36:05,900 --> 00:36:06,700
是信号11
it's signal 11

660
00:36:06,700 --> 00:36:08,400
我在说啥，累了累了
what am I saying it's been a long day

661
00:36:08,666 --> 00:36:14,300
它收到信号11，段错误，然后崩溃
it receives signal 11 the segfault and crashes

662
00:36:15,900 --> 00:36:17,100
说错了，不是崩溃
and not doesn't crash

663
00:36:17,233 --> 00:36:18,499
它收到信号11，进程终止
it receives a signal 11 and terminates 

664
00:36:18,600 --> 00:36:19,433
因为没有处理函数
because it doesn't handle it

665
00:36:19,566 --> 00:36:22,099
你可以为信号11，注册个信号处理程序
you can install a handler for signal 11

666
00:36:23,566 --> 00:36:26,000
让进程在段错误后，继续运行
and survive seg faults

667
00:36:26,000 --> 00:36:28,733
你甚至可以尝试修复问题，再继续运行
you can even try to fix things up and keep going

668
00:36:28,733 --> 00:36:30,566
但这通常是个坏主意
but that's generally a bad idea

669
00:36:32,966 --> 00:36:36,800
你也可以给其它没崩溃的进程发送信号11
you can also send a signal 11 to other processes that didn't crash 

670
00:36:36,800 --> 00:36:39,733
你可以用kill发信号
that you can you know send kill signals to 

671
00:36:39,733 --> 00:36:45,333
让它们没出错时，报段错误
and make them segfault without them doing anything wrong necessarily

672
00:36:45,366 --> 00:36:46,133
但不管怎样
but anyways 

673
00:36:46,133 --> 00:36:50,200
这是Linux中仅有的2种终止方法
these are the only two ways to go in Linux 

674
00:36:50,200 --> 00:36:52,766
退出后
after you go after you exit

675
00:36:53,533 --> 00:36:55,733
或者说被杀死后
or you get killed

676
00:36:57,700 --> 00:37:00,133
进程必须被接收
your process must be reaped 

677
00:37:00,333 --> 00:37:03,133
所以进程终止后
so after a process terminates

678
00:37:03,133 --> 00:37:05,400
它会进入僵尸状态
it'll remain in a zombie state

679
00:37:05,700 --> 00:37:07,766
直到它的父进程接收到它
until its parent waits on it

680
00:37:08,600 --> 00:37:12,300
如果不wait你的子进程，就终止了
if you don't wait on your children processes and you die

681
00:37:12,300 --> 00:37:13,733
子进程会重找一个父进程
they will be reparented

682
00:37:13,933 --> 00:37:15,400
并一直保持僵尸状态
and will remain zombies

683
00:37:15,400 --> 00:37:16,966
这以前是个大问题
this used to be a big problem 

684
00:37:16,966 --> 00:37:26,766
因为直到最近，Linux进程ID才只有16位
because until very recently Linux only had 16 bit integer for its process ID

685
00:37:26,900 --> 00:37:28,966
所以可能会用完进程ID
so you could actually run out of processes 

686
00:37:29,066 --> 00:37:31,566
但现在它是32位整数
now it's a 32 bit integer and

687
00:37:31,866 --> 00:37:33,933
很难用完它
it's much harder to run out of processes

688
00:37:34,500 --> 00:37:35,766
但这总归不好
but still not good

689
00:37:35,766 --> 00:37:38,200
执行ps aux时，会看到一大堆僵尸进程
you do ps aux and you see a ton of zombies

690
00:37:38,200 --> 00:37:39,766
它们是那些括号括起来的
they're the ones in parentheses

691
00:37:40,066 --> 00:37:40,866
不好看
not fun

692
00:37:41,533 --> 00:37:43,766
所以要接收你的子进程
so reap your processes

693
00:37:43,866 --> 00:37:46,733
用wait系统调用接收它们
use the wait system call to collect their status

694
00:37:47,166 --> 00:37:47,966
好的
all right

695
00:37:48,566 --> 00:37:50,733
就是这些
and that is it

696
00:37:50,733 --> 00:37:54,133
我们讲完了Linux进程的全部生命周期
we have gone through the entire life cycle of a Linux process

697
00:37:54,133 --> 00:37:57,166
我录了好几次
it has taken me dozens of tapes 

698
00:37:57,166 --> 00:37:59,733
我头几张PPT总出问题
I kept screwing up in the first couple of slides

699
00:38:00,700 --> 00:38:01,900
然后重录
and then kept restarting

700
00:38:01,900 --> 00:38:02,900
用了好几个小时了
it's been hours 

701
00:38:02,900 --> 00:38:04,400
我现在又渴又饿
I am thirsty and hungry

702
00:38:05,366 --> 00:38:06,433
超级累
super tired 

703
00:38:06,433 --> 00:38:09,133
谢谢你的坚持
thank you for sticking with it

704
00:38:09,666 --> 00:38:13,300
我们后面的课程再见
I will see you in future lectures 

705
00:38:13,300 --> 00:38:14,166
再见
good bye

