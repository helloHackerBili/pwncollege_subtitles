1
00:00:00,466 --> 00:00:01,500
你好黑客
hello hackers

2
00:00:01,500 --> 00:00:04,666
欢迎回到自动化漏洞发掘模块
welcome back to automated vulnerability discovery

3
00:00:04,666 --> 00:00:06,933
今天我们要讨论的是符号执行
today we're talking about symbolic execution

4
00:00:07,300 --> 00:00:08,766
动态符号执行
dynamic symbolic execution

5
00:00:08,766 --> 00:00:11,200
当然这是一个动态分析
of course it's a dynamic analysis

6
00:00:12,300 --> 00:00:15,766
这意味着为了分析代码
which means that in order to analyze what is going on with code

7
00:00:15,766 --> 00:00:17,733
必须执行它
it has to execute it 

8
00:00:19,200 --> 00:00:20,566
我们开始吧
so let's roll on 

9
00:00:20,600 --> 00:00:24,733
动态符号执行的核心思想
the core idea of dynamic symbolic execution

10
00:00:25,066 --> 00:00:32,966
是在所谓的符号数据域上模拟程序执行
is that you emulate the program on what is called a          symbolic data domain

11
00:00:33,066 --> 00:00:36,700
CPU工作在1和0上
a typical cpu operates on 1s and 0s right

12
00:00:36,700 --> 00:00:40,700
如果用read系统调用读入用户输入
if you read in user input using the read system call

13
00:00:40,866 --> 00:00:42,866
你得到的是1和0
what you get are 1s and 0s

14
00:00:42,966 --> 00:00:45,566
作为与程序交互的人
as a human interacting with the program

15
00:00:45,566 --> 00:00:50,166
你不能给它发送一个未知值的变量
you can't send it some variable with an unknown value

16
00:00:50,166 --> 00:00:55,333
但你可以创建一个模拟器来支持这个
but you could create an emulator that could support this

17
00:00:55,600 --> 00:01:00,466
所以它可以是1 0或者x
so it could be a one a zero or x

18
00:01:01,333 --> 00:01:06,966
然后随着你逐渐了解了
and then later on as you build up an understanding of

19
00:01:08,600 --> 00:01:09,700
已知数据是什么
what data is known

20
00:01:09,700 --> 00:01:10,733
未知数据是什么
what data is unknown

21
00:01:10,733 --> 00:01:16,966
根据cmp比较未知数据
and as unknown data starts being checked using compare instructions

22
00:01:18,766 --> 00:01:23,200
并基于比较结果跳转
those checks start being acted on using conditional jumps

23
00:01:23,466 --> 00:01:27,366
你可以建立起一个公式
you can actually build up formula that

24
00:01:29,266 --> 00:01:32,166
描述程序的行为
describe the behavior of the program

25
00:01:32,166 --> 00:01:39,333
获得程序输入、检查条件和程序输出之间的关系
given the relationship between program input conditional  checks and program output 

26
00:01:41,566 --> 00:01:44,333
你模拟这个程序
so you emulate the program

27
00:01:44,533 --> 00:01:48,066
提取出描述该程序的公式
you extract formulas that describe this program

28
00:01:48,100 --> 00:01:49,800
然后加上想要的约束
and then you add desired constraints 

29
00:01:49,933 --> 00:01:51,066
所以如果你想要获得flag
so if you want to get the flag

30
00:01:51,200 --> 00:01:52,466
我们会
we will say hey

31
00:01:53,900 --> 00:01:57,666
我们希望程序不要输出incorrect
we want the program output to not be incorrect

32
00:01:59,466 --> 00:02:02,800
我们把这个约束条件加到公式中
and we add this constraint to our formula 

33
00:02:02,900 --> 00:02:05,100
然后我们用约束求解器
and we use what is called a constraint solver 

34
00:02:05,700 --> 00:02:15,066
求解这个公式，得到未知数据的有效答案
to solve these formulas for valid answers for unknown      data 

35
00:02:15,700 --> 00:02:16,966
这就是符号执行
that is symbolic execution

36
00:02:16,966 --> 00:02:18,100
其实没这么简单
it's actually not this simple 

37
00:02:18,233 --> 00:02:20,133
这是一个非常简化的观点
this is a very simplified view

38
00:02:20,266 --> 00:02:22,500
我们将深入探讨为什么这并不简单
and we'll dive into why it's not simple 

39
00:02:23,200 --> 00:02:25,066
但首先让我们谈谈历史
but first let's talk about some history

40
00:02:25,133 --> 00:02:30,766
我在defcon一个程序分析的演讲中
i tracked symbolic execution back for a talk i gave at       defcon about program analysis

41
00:02:32,033 --> 00:02:34,866
追溯了符号执行的历史，到1975年
fairly far to 1975 

42
00:02:35,133 --> 00:02:37,866
1975年罗伯特·博耶
in 1975 Robert Boyer 

43
00:02:38,266 --> 00:02:45,233
现在是一所大学的名誉教授
now a professor Emeritus at one of the ut's 

44
00:02:45,300 --> 00:02:46,966
好像是德州大学奥斯汀分校
i want to say ut Austin

45
00:02:49,566 --> 00:02:53,033
创建了一个叫做SELECT的系统
created a system called SELECT 

46
00:02:53,533 --> 00:02:58,800
一种通过符号执行来查找程序中的错误的系统
a system that did symbolic execution to find bugs in        programs 

47
00:02:58,933 --> 00:03:04,466
1975年，很久以前了，安全还没成一个单独的领域
1975 very long time ago before really security was a field

48
00:03:06,000 --> 00:03:07,500
我觉得这太酷了
and i thought wow that's pretty cool

49
00:03:07,600 --> 00:03:10,833
这比第一篇模糊测试论文发表的时间还要早
that's earlier than let's say the first fuzzing paper came    out 

50
00:03:10,933 --> 00:03:12,100
可能这就是源头了
this is probably it

51
00:03:12,366 --> 00:03:13,166
但后来
but then

52
00:03:15,066 --> 00:03:16,200
几周前
a couple weeks ago

53
00:03:16,600 --> 00:03:24,166
在为竞争条件模块查找历史材料时，偶然发现
by chance while looking up the history of race conditions  for the race condition module

54
00:03:24,400 --> 00:03:30,900
克劳德·香农的硕士还是学士论文来着
i stumbled on to the master's thesis or maybe Bachelor's thesis of Claude Shannon 

55
00:03:31,100 --> 00:03:32,100
如果你不认识
if you don't know

56
00:03:32,666 --> 00:03:35,866
或者你通过香农的熵理论认识了他
or you might know Shannon from shannon's entropy 

57
00:03:36,700 --> 00:03:40,400
它是信息论的基本组成部分
a fundamental building block of information theory 

58
00:03:41,066 --> 00:03:41,933
如果你不知道的话
if you don't know it

59
00:03:42,066 --> 00:03:43,533
我强烈建议你学习它
i highly recommend you learn it 

60
00:03:43,566 --> 00:03:44,700
它非常酷
it's very very cool

61
00:03:48,133 --> 00:03:50,666
克劳德·香农在1938年
so Claude Shannon in 1938

62
00:03:50,800 --> 00:03:52,566
在他的硕士论文中
for his master's thesis 

63
00:03:52,866 --> 00:03:57,600
写了一篇用符号分析继电器和交换电路的论文
wrote a paper about symbolic analysis of Relay and          switching circuits

64
00:03:57,700 --> 00:03:58,700
他实际上
where he actually

65
00:04:02,133 --> 00:04:08,366
将识别竞争条件，作为这种符号分析的一个应用
identified race conditions as an application of this sort of symbolic analysis

66
00:04:08,366 --> 00:04:11,266
这不完全是我们所说的符号执行
it's not quite the symbolic execution we're talking about

67
00:04:11,266 --> 00:04:12,866
但是很接近了
but it's close 

68
00:04:12,966 --> 00:04:14,866
而且这是在很久很久以前
and it is so long ago 

69
00:04:15,033 --> 00:04:17,266
于是我想这应该差不多了
so i thought okay finally almost 

70
00:04:17,433 --> 00:04:19,266
这都差不多是一百年前了
i mean almost a hundred years

71
00:04:19,400 --> 00:04:23,300
差不多80年前
let's say you know almost 80 years ago

72
00:04:24,166 --> 00:04:25,533
源头一定是这个了
this has got to be it 

73
00:04:25,600 --> 00:04:27,733
这应该是源头了
this is the the origin

74
00:04:28,200 --> 00:04:29,733
超过了80年
or actually over 80 years ago 

75
00:04:29,766 --> 00:04:30,566
很酷
wow cool

76
00:04:32,133 --> 00:04:34,433
事实证明我大错特错了
well it turns out i was off by a lot 

77
00:04:35,233 --> 00:04:36,100
你可能会问怎么会
and you might say how

78
00:04:36,166 --> 00:04:38,900
怎么可能早于1938年呢
how can it be much earlier than 1938 

79
00:04:39,033 --> 00:04:43,200
实际上我们可以追溯到1842年
well we can dive back to 1842

80
00:04:44,600 --> 00:04:47,933
追述到Ada lovelace
to Ada lovelace

81
00:04:48,733 --> 00:04:52,133
和她对查尔斯·巴贝奇的分析机的分析
and her analyses of Charles Babbage's analytical engine

82
00:04:52,133 --> 00:04:59,600
它被认为是首个现代计算机
what is a design that is the first thing recognizable as a   modernish computer

83
00:05:01,966 --> 00:05:04,933
1842年Ada lovelace
in 1842 Ada lovelace

84
00:05:04,933 --> 00:05:11,566
对查尔斯·巴贝奇设计的这台机器写了许多分析
wrote a number of analyses of this machine designed by Charles babbage

85
00:05:11,700 --> 00:05:19,200
其中包括一个计算伯努利数的程序
and one of these included a program that computed 
Bernulli numbers

86
00:05:19,200 --> 00:05:22,666
历史上最早编写的程序之一
one of the first programs ever written in history

87
00:05:23,766 --> 00:05:26,200
它是Ada lovelace写的
written by Ada lovelace 

88
00:05:26,200 --> 00:05:28,133
如果你看
and if you look she

89
00:05:28,466 --> 00:05:32,700
这是她对这个程序的分析
this is a table of her analysis of this program

90
00:05:32,766 --> 00:05:37,100
她一步一步地记录了每个操作的作用
she goes through step by step of what each operation does

91
00:05:37,566 --> 00:05:39,700
以及结果是什么
and what the results are

92
00:05:39,700 --> 00:05:42,666
各种寄存器中的值是什么
what the values are in the various registers

93
00:05:44,566 --> 00:05:47,466
这些都是符号化的
and these are symbolic 

94
00:05:47,466 --> 00:05:56,133
她在1842年手工进行了符号执行
she is doing manual symbolic execution in 1842 

95
00:05:56,166 --> 00:06:01,300
这可能是最古老的分析示意图了
so this is probably the oldest analysis paradigm

96
00:06:01,300 --> 00:06:07,866
我们将讨论从19世纪中期到现在的动态符号执行
we'll talk about dynamic symbolic execution from the mid 19th century to today

97
00:06:08,966 --> 00:06:10,066
我们看看它是什么样的
let's see what it's like 

98
00:06:10,300 --> 00:06:13,033
如今的动态符号执行
today dynamic symbolic execution

99
00:06:13,266 --> 00:06:16,866
会模拟代码，转化成数据公式
emulates code to convert it into math

100
00:06:16,866 --> 00:06:18,533
这并不容易
this isn't easy right

101
00:06:19,800 --> 00:06:24,700
我们在第一张幻灯片中看到的是一种直接的转换
what we saw in that first slide was kind of a straight shot conversion

102
00:06:25,533 --> 00:06:27,733
实际上要复杂得多
what actually happens is a lot more complex

103
00:06:27,733 --> 00:06:33,166
符号执行必须像普通CPU一样按顺序执行代码
symbolic execution has to execute code in sequence like a normal cpu

104
00:06:33,333 --> 00:06:37,533
不同的是，它有一个可修改的模拟状态
the difference is it has an emulated state that it can mess with

105
00:06:37,533 --> 00:06:39,066
我关掉相机
i'm going to disable my camera

106
00:06:39,066 --> 00:06:40,933
这样你可以清楚地看到下一部分
so you can see this next part clearly 

107
00:06:41,100 --> 00:06:46,566
在符号模拟器中执行程序时
as you execute the program in a symbolic emulator

108
00:06:46,600 --> 00:06:50,833
每当程序遇到分支时
every time the program encounters a branch 

109
00:06:51,066 --> 00:06:55,366
模拟器就会多分出一个内部状态
the symbolic emulator has to branch its internal state into two 

110
00:06:55,666 --> 00:07:00,300
一个状态根据一个条件，进入一个分支
one of these states gets one condition that would follow   the branch

111
00:07:00,466 --> 00:07:03,900
另一个在该条件下，不会进入同一个分支
the other one gets the condition that would not follow the branch 

112
00:07:04,033 --> 00:07:06,633
这里的状态是，用户输入是42
here it is the user input being 42

113
00:07:06,766 --> 00:07:09,133
与用户输入不是42
versus the user input not being 42

114
00:07:09,133 --> 00:07:11,933
因为这是cmp指令检查
because that is what the compare instruction checked

115
00:07:12,000 --> 00:07:14,800
jmp指令据此跳转的
and the jump instruction acted on 

116
00:07:16,666 --> 00:07:19,733
当这些状态分离后
then once those states diverge 

117
00:07:19,766 --> 00:07:23,866
他们的行为就不一样了
they start doing kind of different things 

118
00:07:24,866 --> 00:07:27,433
在状态A
so in state A

119
00:07:28,033 --> 00:07:31,266
还有sendfile剩下的一部分
you have the leftovers of the sendfile call 

120
00:07:31,933 --> 00:07:35,266
实际上rax现在可能是flag的长度
actually probably rax would now be the length of the flag  or whatever 

121
00:07:35,900 --> 00:07:36,966
在状态B
in state B 

122
00:07:36,966 --> 00:07:41,200
你拿到了write的返回结果
you have the result of the write system call

123
00:07:41,533 --> 00:07:45,533
rax可能是写入的字节数
rax is also probably going to be the amount of bytes        written

124
00:07:46,133 --> 00:07:47,200
然后
and then of course

125
00:07:47,500 --> 00:07:50,366
指定的约束
the constraint that specifies

126
00:07:50,366 --> 00:07:52,433
这个状态中，是用户输入不能是42
the user input cannot be 42 here 

127
00:07:52,766 --> 00:07:54,266
这个状态中，是用户输入要是42
and has to be 42 here 

128
00:07:54,966 --> 00:08:00,466
并且对应的，这里的程序输出是INCORRECT
and the relationship of the program output being incorrect here

129
00:08:00,733 --> 00:08:05,100
这里的输出是flag
and being whatever the flag value is there

130
00:08:08,466 --> 00:08:12,666
这就是符号执行引擎的工作原理
that is how a symbolic execution engine works

131
00:08:12,666 --> 00:08:18,100
现在我们看一个符号执行引擎的实际例子
and we're going to look at it in practice right now on a     symbolic execution engine 

132
00:08:18,100 --> 00:08:23,933
这是我和我优秀的同事在研究生时期创建的
that i created with my awesome colleagues back in my     graduate career

133
00:08:23,933 --> 00:08:33,266
时至今日，在ASU的我们，依旧在此之上进行优化与研究
and that we still continue to improve develop and research on top of up to this day at ASU

134
00:08:34,666 --> 00:08:37,466
这个系统就是angr
which and this system is angr

135
00:08:38,066 --> 00:08:40,733
有很多符号执行引擎
there's a bunch of symbolic execution engines

136
00:08:40,733 --> 00:08:43,466
有更多的，积极研发中的，符号执行引擎
there are more symbolic execution engines on their active development

137
00:08:43,466 --> 00:08:46,266
相比于积极研发中的web浏览器
than there are web browsers on their active development

138
00:08:46,466 --> 00:08:48,600
我不知道为什么会这样
i'm not sure why this is

139
00:08:48,600 --> 00:08:50,600
但事情就是这样
but that is how it is

140
00:08:52,300 --> 00:08:54,033
angr不是唯一的
angr is not the only game in town 

141
00:08:54,066 --> 00:08:56,266
但它是我最熟悉的
it is just what i'm most familiar with

142
00:08:58,200 --> 00:09:01,100
并且是安装在pwn学院环境中的
and also what is installed in your containers

143
00:09:01,766 --> 00:09:03,333
我们来看看
so let's take a look

144
00:09:05,166 --> 00:09:09,033
我们有一个compare程序
we have our compare program 

145
00:09:09,200 --> 00:09:10,800
它接收一字节
that takes one byte 

146
00:09:10,933 --> 00:09:13,900
与另一个值比较，当然它是42
compares against a value of course it's 42 

147
00:09:14,200 --> 00:09:15,700
和幻灯片上的一模一样
it's exactly what was on the slide

148
00:09:15,866 --> 00:09:19,166
不相等的话，会告诉我们 failure，而不是incorrect
and then tells us failure instead of incorrect 

149
00:09:19,200 --> 00:09:21,100
相等的话，输出success
or success if it's correct

150
00:09:21,100 --> 00:09:23,400
我就没专门搞一个flag了
i didn't bother with a flag here 

151
00:09:24,066 --> 00:09:31,066
我们来看看如何用angr来解决这个问题
so let's check out how we would use angr to solve this

152
00:09:31,366 --> 00:09:33,533
在ipython中导入它
import it in ipython 

153
00:09:34,700 --> 00:09:37,800
angr有一个项目的概念
angr has a concept of a project 

154
00:09:37,800 --> 00:09:42,466
基本就是，打开的二进制程序，以及它用的所有库
this is basically an open binary along with its libraries and everything

155
00:09:44,466 --> 00:09:46,000
我们可以得到各种各样的信息
we can get various information

156
00:09:46,000 --> 00:09:48,033
比如入口地址
such as the entry point 

157
00:09:48,033 --> 00:09:55,800
我们可以获取入口地址处的反汇编块
we can get the block disassemble the block at that entry  point

158
00:10:01,800 --> 00:10:03,333
还有很多其他的东西
and various other things

159
00:10:03,333 --> 00:10:08,800
我们能做的一件事，是所谓的模拟管理器
one thing that we can do is create what is called a           simulation manager

160
00:10:09,066 --> 00:10:11,800
这就是我们说的模拟器
this is that emulator that we're talking about

161
00:10:12,400 --> 00:10:15,166
或者说是angr模拟器的接口
or the interface to the angr emulator

162
00:10:15,166 --> 00:10:18,033
它从一个激活状态开始
it starts out with an active state 

163
00:10:18,033 --> 00:10:21,766
这个状态有寄存器之类的东西
this is a state that has stuff like registers

164
00:10:22,366 --> 00:10:27,566
这些是寄存器的初始值
these are the registers that start out with the values

165
00:10:27,633 --> 00:10:35,333
程序刚开始执行时的值
that they start out with when the program begins             executing

166
00:10:36,300 --> 00:10:37,400
还有内存
we have memory 

167
00:10:37,400 --> 00:10:47,366
例如，我们加载elf的基址
so for example if we load memory at the base of the elf

168
00:10:47,700 --> 00:10:49,200
加载4字节
you can load four bytes

169
00:10:49,766 --> 00:10:53,333
这会读入 7F E L F，和预料的一样
those read 7f e l f as expected 

170
00:10:55,333 --> 00:10:57,466
这很酷
so that's all very cool

171
00:11:00,166 --> 00:11:01,500
实际上，让我
actually let's let me

172
00:11:02,933 --> 00:11:04,366
哦，我没装
oh i don't have it installed 

173
00:11:05,333 --> 00:11:07,533
我得想想怎么解码
now i have to remember how to decode this

174
00:11:17,566 --> 00:11:20,633
这是7f E L F
here is 7f elf 

175
00:11:25,066 --> 00:11:28,600
我们开始逐步执行
let's start stepping through execution

176
00:11:29,366 --> 00:11:32,366
我们正在模拟这个程序
we are emulating the program

177
00:11:32,366 --> 00:11:36,866
我们可以看到之前的状态
we can actually see the history of this state

178
00:11:40,900 --> 00:11:42,000
怎么回事
oops what's going on

179
00:11:45,200 --> 00:11:49,100
它在执行过程中走过的路径
the path that it took through the program executing

180
00:11:49,700 --> 00:11:52,500
这意味着有一个条件跳转
this means that there was a conditional jump

181
00:11:52,500 --> 00:11:56,066
但数学上只有一个条件可以满足
but only one condition could be satisfied mathematically 

182
00:11:56,633 --> 00:12:00,900
所以不会进入这个分支
so that cannot be taken 

183
00:12:01,200 --> 00:12:04,400
但是如果我们继续步入
but if we keep stepping 

184
00:12:04,400 --> 00:12:05,733
最终
eventually

185
00:12:07,866 --> 00:12:09,066
状态会分裂
the state will split 

186
00:12:09,166 --> 00:12:12,000
实际上，我们可以执行run(until=)
in fact we can say run until

187
00:12:13,733 --> 00:12:15,400
写一个python lambda函数
write a python lambda function 

188
00:12:15,500 --> 00:12:16,800
如果你不知道这是什么
if you don't know what this is 

189
00:12:17,033 --> 00:12:18,933
切到浏览器
swap out tab out

190
00:12:18,933 --> 00:12:19,666
快速查一下
look it up real quick 

191
00:12:19,900 --> 00:12:20,600
回来
come back 

192
00:12:20,833 --> 00:12:22,700
lambda函数接收一个
lambda function takes a

193
00:12:26,600 --> 00:12:30,400
该模拟管理器，作为参数
the same simulation manager as an argument

194
00:12:31,100 --> 00:12:33,700
然后
and it says

195
00:12:36,533 --> 00:12:41,000
计算停止执行的条件
and it just calculates a condition to stop executing at

196
00:12:41,000 --> 00:12:46,666
这里是，执行到有一个以上的状态时
so this will say execute until there is more than one active state

197
00:12:46,766 --> 00:12:49,033
现在有2个状态了
boom there's two active states now 

198
00:12:49,033 --> 00:12:50,133
发生了什么
so what happened

199
00:12:52,800 --> 00:12:53,933
我们来看一看
let's take a look

200
00:13:02,900 --> 00:13:07,900
这是两者的执行路径
here is the history of both

201
00:13:08,200 --> 00:13:11,100
他们最后都执行的是
and the last thing they both executed of course

202
00:13:11,100 --> 00:13:14,266
当然，因为直到最近，它们的路径都是相同的
because they were the same path until the same state until very recently

203
00:13:14,666 --> 00:13:18,500
有2个能满足的条件的块
was this block with two satisfiable successors

204
00:13:18,500 --> 00:13:21,566
这就是为什么模拟器中现在会有两个状态
that's why we now have two states in the emulator

205
00:13:22,666 --> 00:13:25,200
我们来看看这是什么
let's take a look at what this is

206
00:13:33,466 --> 00:13:37,066
是我们要找的cmp和jmp
and it's our compare and jump 

207
00:13:37,066 --> 00:13:37,566
很酷
cool

208
00:13:37,933 --> 00:13:39,333
我还想给你们看一样东西
one more thing i want to show you 

209
00:13:40,333 --> 00:13:41,666
在一个状态中
on one state

210
00:13:44,500 --> 00:13:48,833
我们有一个约束，是输入为42
we have a constraint that the input equals 42 

211
00:13:48,833 --> 00:13:50,366
另一个状态中
on the other one

212
00:13:50,733 --> 00:13:54,366
约束为，输入不等于42
we have a constraint that the input does not equal 42 

213
00:13:54,366 --> 00:13:56,033
很酷吧
pretty cool huh 

214
00:13:57,066 --> 00:13:58,700
我们继续
let's push forward

215
00:13:59,700 --> 00:14:02,866
这是
so this is

216
00:14:07,533 --> 00:14:09,766
这些是活跃状态
these are the active states

217
00:14:09,766 --> 00:14:10,933
我们要做的是
what we're gonna do

218
00:14:11,200 --> 00:14:12,000
叫
what is called

219
00:14:12,600 --> 00:14:14,133
我们执行到最后
we're gonna run until the end

220
00:14:14,133 --> 00:14:15,133
直到
until program

221
00:14:15,600 --> 00:14:17,433
直到所有状态都结束
until all states terminate 

222
00:14:17,433 --> 00:14:19,500
通常这是不会成功的
usually this is not successful 

223
00:14:19,500 --> 00:14:23,300
通常会像我们马上要讲到的
usually as we'll discuss in a second

224
00:14:23,766 --> 00:14:31,233
这些分析通常规模非常大
these analyses actually are very very very not scalable 

225
00:14:31,466 --> 00:14:32,500
它们不会终止
they don't terminate

226
00:14:34,500 --> 00:14:36,600
但是，不好意思
but excuse me

227
00:14:38,266 --> 00:14:41,166
这是一个非常非常简单的程序，所以会成功退出
this was a very very simple program and they did 

228
00:14:41,166 --> 00:14:44,700
你可以看一下它们现在的约束条件
and again you can look at the constraints now

229
00:14:44,900 --> 00:14:46,933
我们现在没有任何终结的状态了（口误）
we don't have any dead ended ones anymore

230
00:14:48,366 --> 00:14:50,400
哦，抱歉，激活的状态，它们都是终结的状态
oh sorry active ones they're both dead ended

231
00:14:52,566 --> 00:14:55,066
我们有这两种状态
so here we have these two states 

232
00:14:55,066 --> 00:15:00,900
一个的约束条件是等于42
one that has the constraint as equal

233
00:15:00,900 --> 00:15:02,833
一个是不等于42
one as not equal

234
00:15:03,166 --> 00:15:07,200
我们可以看的另一件事，是它们的标准输出
and another thing that we can look is their standard output

235
00:15:10,333 --> 00:15:12,266
你可以称之为具体化
you can call concretize

236
00:15:12,333 --> 00:15:14,066
具体化是
concretize is 

237
00:15:14,566 --> 00:15:18,133
具体化是查询约束求解器的过程
concretization is the process of querying a constraint solver 

238
00:15:18,333 --> 00:15:19,766
来解这个公式
to solve the formula

239
00:15:20,066 --> 00:15:21,466
从
to go from

240
00:15:22,200 --> 00:15:24,300
当然这些公式很简单
and of course these formulas are very simple 

241
00:15:24,500 --> 00:15:28,966
从数学公式，变成1与0
to go from mathematical formula to 1s and 0s

242
00:15:29,166 --> 00:15:34,233
所以，在输入不是42的状态中
so on one state the state that is not 42 

243
00:15:34,433 --> 00:15:35,466
它输出failure
it says failure 

244
00:15:35,933 --> 00:15:40,500
在输入是42的状态中
the state that where the standard input was 42 

245
00:15:41,100 --> 00:15:44,333
在状态1中，输出是success
this state 1 it says success 

246
00:15:45,266 --> 00:15:46,333
很酷
very cool

247
00:15:46,766 --> 00:15:48,500
我们也可以具体化
we can also concretize

248
00:15:48,700 --> 00:15:50,400
使用相同的技术
using the same technique

249
00:15:50,400 --> 00:15:53,266
用约束求解器，计算标准输入
with the constraint solvers standard input 

250
00:15:53,400 --> 00:15:58,366
所以成功状态
so on the state where we have a successful state

251
00:16:00,966 --> 00:16:02,133
输入是一个星号
the input is a star 

252
00:16:02,266 --> 00:16:03,733
让我们来看一看
let's take a look

253
00:16:06,100 --> 00:16:07,000
当然
and of course

254
00:16:07,133 --> 00:16:08,033
输出的是success
that's a success 

255
00:16:14,666 --> 00:16:15,866
很酷
that is awesome

256
00:16:16,166 --> 00:16:19,966
符号执行是最酷的工具
symbolic execution is the coolest kit on the block

257
00:16:20,300 --> 00:16:22,366
我们不需要其他任何东西
we don't need anything else

258
00:16:22,400 --> 00:16:24,866
我们就用它来探索软件
we'll just use this to explore software

259
00:16:25,000 --> 00:16:26,600
识别漏洞
identify vulnerabilities

260
00:16:26,700 --> 00:16:29,066
不幸的是，事实并非如此
unfortunately that is not the case 

261
00:16:29,133 --> 00:16:33,800
符号执行有严重的限制
symbolic execution has serious limitations

262
00:16:34,000 --> 00:16:35,366
这些限制就是
and these limitations are that 

263
00:16:35,400 --> 00:16:38,433
它必须追踪每一条路径来理解正在发生的事情
it has to follow every path to understand what is going on

264
00:16:38,566 --> 00:16:40,433
这是一个动态分析
it's a dynamic analysis

265
00:16:41,933 --> 00:16:44,966
我们现在研究的程序非常简单
the program that we are looking at is very simple

266
00:16:44,966 --> 00:16:46,333
只是比较是否是42
compares against 42 

267
00:16:46,333 --> 00:16:47,800
是的话，跳转获取flag
jumps to get the flag

268
00:16:48,200 --> 00:16:52,400
如果你有稍微复杂一点的东西呢
what if you had something that is just just a tiny bit more complex

269
00:16:52,566 --> 00:16:55,933
如果是调用atoi，ascii转整数
what if it called atoi ASCII to integer

270
00:16:56,266 --> 00:16:58,066
然后再和42比较
and then compared against 42 

271
00:16:58,700 --> 00:17:01,100
你实际上发送的是字符42
so you actually send 4 2 

272
00:17:01,566 --> 00:17:04,166
我突然意识到，这不对
oh i realized obviously that's not solvable 

273
00:17:04,166 --> 00:17:05,666
我来快速修正一下
let me fix that real quick

274
00:17:08,366 --> 00:17:09,766
好了，好多了
all right much better

275
00:17:09,766 --> 00:17:13,200
我们读入两个字节
so we have we read in two bytes

276
00:17:13,200 --> 00:17:14,633
然后调用atoi
and then we call atoi 

277
00:17:14,900 --> 00:17:16,300
如果你输入42
so if you type 42 

278
00:17:16,400 --> 00:17:20,866
那就会拿到这个correct
then you should get this correct 

279
00:17:20,966 --> 00:17:24,966
取决于atoi的实现方式
well it turns out that depending on the implementation of   atoi 

280
00:17:24,966 --> 00:17:27,433
符号执行无法解决这个问题了
symbolic execution can no longer solve this 

281
00:17:27,533 --> 00:17:30,300
想一下这样的atoi实现
consider this insane implementation of atoi 

282
00:17:30,333 --> 00:17:32,166
这不是一个很好的实现
it's not a very good implementation

283
00:17:36,066 --> 00:17:39,166
但是程序分析的有趣之处在于
but the interesting thing about doing program analysis

284
00:17:39,166 --> 00:17:42,200
你无法决定你要分析什么样的实现
is you don't get to decide what implementations you're 
analyzing

285
00:17:42,200 --> 00:17:49,366
你会分析你想要了解的程序代码
you analyze the code of the programs you want to get
 some understanding of 

286
00:17:49,533 --> 00:17:53,600
这些程序可能用这种疯狂的方式编写atoi
and those programs might have atoi implementations 
written in this insane way

287
00:17:53,966 --> 00:17:57,900
这样我们该怎么办
so how would we approach this

288
00:17:59,933 --> 00:18:05,433
我们在程序或函数执行时，跟踪执行者
let's just trace through the executor as it executes this 
program or this function

289
00:18:05,466 --> 00:18:08,800
我们从一个未知字符串开始
we start out with a string we don't know what is in it

290
00:18:08,833 --> 00:18:13,533
它是一个无约束的，我们从标准输入读入的数据
it is unconstrained input data that we just read in from 
standard in

291
00:18:14,866 --> 00:18:17,133
当然，我们知道长度为2
of course we know this is size 2

292
00:18:17,133 --> 00:18:19,666
我这里展示一下任意大小的情况
i'm just gonna show you for arbitrary sizes 

293
00:18:19,666 --> 00:18:24,700
在循环中的第一次，分裂出10个状态
the first time around the loop is we will split the state into ten

294
00:18:25,200 --> 00:18:29,400
取决于哪些约束条件给到这个状态
depending on which of these constraints gets added to the state

295
00:18:29,466 --> 00:18:31,466
我们会分成10个状态
we will split them all into ten

296
00:18:31,500 --> 00:18:34,566
实际上是11个，还有一个是默认状态(break)
and actually 11 one for the default constraint

297
00:18:34,600 --> 00:18:36,266
该状态输入的不是数字
where it's not a digit 

298
00:18:36,366 --> 00:18:37,933
我们要退出
i need to terminate it

299
00:18:38,666 --> 00:18:42,466
我们会给每个状态添加不同的约束
and we will just add different constraints to each one

300
00:18:43,200 --> 00:18:44,600
循环体执行一次后
so the first time through

301
00:18:44,766 --> 00:18:47,666
我们就有了10个不同状态
we have ten different states

302
00:18:47,866 --> 00:18:48,966
第二次执行
the second time

303
00:18:48,966 --> 00:18:52,666
每一个状态都会再分出10个不同的状态
each of these states will split into ten different states

304
00:18:53,733 --> 00:18:55,566
以此类推
and so on and so on

305
00:18:56,100 --> 00:19:00,766
这就是符号执行中所谓的状态爆炸
this is what's called a state explosion in symbolic execution

306
00:19:00,766 --> 00:19:05,766
这就是符号执行不可行的首要原因
and this is the number one reason that symbolic execution is non viable

307
00:19:08,466 --> 00:19:13,033
我们看看在angr中是什么样
let's take a look at what happens in angr

308
00:19:14,733 --> 00:19:17,833
我们来到ipython会话
let's grab our ipython session 

309
00:19:19,200 --> 00:19:24,066
我应该展示一下，我创造了一个相同的atoi.c
oh i should show you i created this exact thing atoi.c 

310
00:19:24,300 --> 00:19:26,100
它会输出success或failure
now it does success failure

311
00:19:26,366 --> 00:19:29,733
我会展示一下，输入42会成功
i'll show you that it does work with 42

312
00:19:29,900 --> 00:19:32,100
其它的不会
and not with other things 

313
00:19:36,966 --> 00:19:38,200
导入angr
import angr

314
00:19:42,600 --> 00:19:46,700
加载atoi程序
load the atoi binary

315
00:19:49,600 --> 00:19:51,200
创建模拟管理器
create the simulation manager 

316
00:19:51,866 --> 00:19:57,533
运行到有不止一个执行路径
let's run until there's more than one path

317
00:20:00,000 --> 00:20:01,333
好，现在有两个执行路径了
okay there are two paths 

318
00:20:02,366 --> 00:20:04,500
现在看看再步入会怎样
now let's see what happens when we step

319
00:20:04,600 --> 00:20:11,600
我们可以实时看到路径（状态）爆炸
let's we can see the path explosion happening in real time 

320
00:20:11,966 --> 00:20:12,566
就是这个
there it is 

321
00:20:12,866 --> 00:20:15,533
这些都在atoi函数中
this is all inside the atoi function

322
00:20:17,866 --> 00:20:19,800
这是个坏消息
that's a a bad news

323
00:20:21,133 --> 00:20:22,966
我们可以一直step很多次
and we can step for a very long time 

324
00:20:23,133 --> 00:20:26,300
有一个状态结束了
so there's one state that's dead ended 

325
00:20:26,366 --> 00:20:28,900
我们看看对应的输入是什么
let's see what its input is

326
00:20:30,733 --> 00:20:34,333
当然，我们可以查询约束解答器
we can still of course query the constraint solver

327
00:20:42,666 --> 00:20:46,733
在这个程序中，它实际上读取了10字节，而不是2字节
in this program i forgot it actually reads 10 bytes not two 

328
00:20:46,733 --> 00:20:47,866
很抱歉
sorry about that

329
00:20:48,000 --> 00:20:50,733
它读入的都是空字节
so it read all null bytes 

330
00:20:50,733 --> 00:20:56,100
在这种情况下，第一个字节不是整数，于是atoi返回0
so this is the case where the first byte is not an integer 
and atoi return zero

331
00:20:56,766 --> 00:21:00,400
我们继续step，直到我们遇到第二个结束状态
let's keep stepping until we get a second dead ended guy 

332
00:21:00,400 --> 00:21:01,266
现在你可以看到
now you can see 

333
00:21:01,266 --> 00:21:02,900
花的时间越来越长了
it's taking longer and longer

334
00:21:02,900 --> 00:21:07,433
因为它必须模拟187个块
because it has to emulate 187 blocks 

335
00:21:07,666 --> 00:21:09,566
每次我尝试step
every time i try to take a step forward 

336
00:21:09,566 --> 00:21:13,766
哦，来到了第二个结束状态
oh we have a second dead ended state

337
00:21:14,733 --> 00:21:17,900
这是第一个数字为0的情况
this is the case where the first number is a zero

338
00:21:25,000 --> 00:21:28,400
显然我们等不到运行完
obviously we're not going to sit through this 

339
00:21:28,400 --> 00:21:30,333
我再试一次
i'll do this one more time

340
00:21:32,133 --> 00:21:32,933
哦
oops

341
00:21:33,766 --> 00:21:34,666
下标超了一个
off by one

342
00:21:36,200 --> 00:21:37,600
这是第一个数字为1的情况
is the case where it's a one

343
00:21:39,466 --> 00:21:44,466
要经过很长时间和很多路径才能到达42
it'll take a very long time and a lot of paths to get to 42 
there

344
00:21:45,100 --> 00:21:49,133
我电脑内存耗尽都等不到它运行完
we won't reach it before my computer runs out of memory

345
00:21:51,466 --> 00:21:52,800
路径爆炸是个问题
path explosion is a problem

346
00:21:52,800 --> 00:21:57,166
有一些技术试图解决这个问题
there are some research techniques to try to solve it

347
00:21:57,166 --> 00:21:59,366
这个特定情况很容易解决
this specific case can be easily solved

348
00:21:59,366 --> 00:22:04,099
你可以使用一种技术合并状态
you can merge states using a technique

349
00:22:04,133 --> 00:22:13,433
该技术使用复杂数学公式，将多种状态合并成一种
called vary testing into mathematically complex formula 
but a single state 

350
00:22:13,433 --> 00:22:16,500
问题是，当你试图这么做的时候
the problem is when you try to do that

351
00:22:16,500 --> 00:22:19,066
当你得到越来越复杂的公式
as you get more and more complex formula 

352
00:22:19,066 --> 00:22:22,300
你会开始让解答器不知所措
you start overwhelming the solvers themselves 

353
00:22:22,366 --> 00:22:25,700
约束是用所谓的SMT解答器来解答的
constraints are solved using what is called smt solvers 

354
00:22:25,866 --> 00:22:30,366
这种技术称为 可满足性模块化理论
this is a technique called satisfiability modular theories

355
00:22:30,366 --> 00:22:38,066
这实际上是一个数学研究领域，研究如何解出这些约束
it's a mathematical area of research actually on how to 
solve these constraints

356
00:22:39,266 --> 00:22:41,066
SMT的基本思想是
and the basic idea of smt is 

357
00:22:41,066 --> 00:22:42,500
你有这些
you have these theories

358
00:22:42,500 --> 00:22:46,300
这些理论本质上编码了不同类型的简化结果
the theories encode different types of simplifications 
essentially 

359
00:22:46,400 --> 00:22:49,366
比如a*b=b*a
stuff like a times b equals b times a 

360
00:22:49,866 --> 00:22:51,600
更具体地说
or more specifically

361
00:22:52,500 --> 00:22:57,466
a*b != b*a + 0以外的数
a times b is not equal to b times a plus anything but a zero

362
00:22:57,600 --> 00:22:58,700
诸如此类的事情
and this sort of thing

363
00:22:59,266 --> 00:23:01,200
所以我们尝试了一些数学化简
so we try a bunch of math simplifications

364
00:23:01,200 --> 00:23:02,833
我们会检查一些常见情况
we check against common cases

365
00:23:02,933 --> 00:23:06,566
看是否能用这些化简，轻易解决问题
we check if something could be trivially solved using these simplifications

366
00:23:07,533 --> 00:23:08,500
如果不能
if not

367
00:23:08,500 --> 00:23:10,366
我们继续尝试不同的理论
we keep trying different theories

368
00:23:10,366 --> 00:23:12,800
直到我们耗尽了所有的理论
eventually we run out of theories

369
00:23:12,966 --> 00:23:15,200
用逻辑表达式构建一个模型
we synthesize a circuit 

370
00:23:15,700 --> 00:23:18,566
它表示实际涉及的比特
that represents the actual bits involved

371
00:23:18,666 --> 00:23:20,566
即使这些bit是未知的
even if those bits are unknown

372
00:23:20,666 --> 00:23:24,000
然后通过布尔可满足性解决问题
and then we resort to boolean satisfiability

373
00:23:24,033 --> 00:23:27,333
因为现在这些位是布尔值了
because now these bits are booleans

374
00:23:27,600 --> 00:23:28,666
1和0
ones and zeros 

375
00:23:28,666 --> 00:23:31,500
布尔可满足性称为SAT
Boolean SATisfiability is called SAT 

376
00:23:31,500 --> 00:23:33,766
这是一个NP完全问题
it is a NP Complete problem

377
00:23:33,866 --> 00:23:36,766
实际上是第一个被证明是NP完全的问题
actually the first problem to be proven to be NP Complete

378
00:23:36,900 --> 00:23:41,900
这意味着我们没有一个多项式时间的算法来解决这个问题
that means that we do not have a polynomial time 
algorithm that can solve this

379
00:23:42,333 --> 00:23:46,733
求解SAT的算法是指数型的
algorithms that solve SAT are exponential

380
00:23:47,533 --> 00:23:49,200
或者只是次指数
or just sub exponential

381
00:23:50,500 --> 00:23:54,600
所以解决复杂的程序会很慢
so it can be very slow to solve complex programs

382
00:23:54,633 --> 00:24:00,600
你饿死在电脑前，它可能都不会结束
as in it might not terminate before you starve to death in 
front of your computer

383
00:24:00,800 --> 00:24:05,700
结论就是，当面对复杂数据，复杂操作时
the takeaway here is faced with complex data complex 
operations

384
00:24:06,200 --> 00:24:07,666
符号执行会失败
symbolic executions fail

385
00:24:07,666 --> 00:24:09,266
不只是路径爆炸问题
not just due to path explosion

386
00:24:09,266 --> 00:24:12,933
也由于约束求解的局限性
but also due to constraint solving limitations 

387
00:24:13,066 --> 00:24:17,133
最后还有一个环境建模的问题
and finally there's a problem of modeling the environment

388
00:24:17,300 --> 00:24:20,500
你看到我们在angr中模拟一切
you saw that we were emulating everything in angr

389
00:24:21,000 --> 00:24:24,433
模拟CPU实际上很容易
emulating the cpu is actually easy 

390
00:24:24,800 --> 00:24:26,533
我改一下错别字
let me fix that typo there

391
00:24:32,166 --> 00:24:35,400
模拟CPU相对容易
emulating the cpu is relatively easy

392
00:24:36,466 --> 00:24:38,800
有现成的支持
there's existing support 

393
00:24:38,933 --> 00:24:41,666
我不想深入挖掘它
i don't want drill down that deeply

394
00:24:41,933 --> 00:24:46,233
基本就是，我们使用现有的代码
but basically we use existing code 

395
00:24:46,433 --> 00:24:51,966
来翻译x86 arm MIPS或其它架构
to translate x86 arm mips whatever architecture we're 
working on 

396
00:24:52,366 --> 00:24:54,833
到同一种之后我们模拟的语言
to a common language that we then emulate

397
00:24:55,166 --> 00:24:56,233
这并不难
that's not hard 

398
00:24:56,400 --> 00:24:58,700
困难的是模仿操作系统
what's hard is emulating the os

399
00:24:59,233 --> 00:25:01,400
read很简单，对吧
read is simple right

400
00:25:01,500 --> 00:25:04,200
当read系统调用被调用，会从标准输入读取数据
a read system called that gets data from standard in

401
00:25:04,700 --> 00:25:06,133
但load_module呢
but what about load_module

402
00:25:06,133 --> 00:25:08,566
它是一个加载内核模块的系统调用
a system call that loads a kernel module

403
00:25:08,566 --> 00:25:10,466
显然，我们不会运行整个内核
obviously we don't run the whole kernel

404
00:25:10,466 --> 00:25:12,300
如果你想运行整个内核
and if you try to run the whole kernel

405
00:25:12,333 --> 00:25:15,366
那么我们会遇到路径爆炸问题
then we'd run into the scalability issues of path explosion

406
00:25:16,566 --> 00:25:17,300
等等......
and so on

407
00:25:18,033 --> 00:25:26,166
所以这三个限制严重阻碍了符号执行的发展
so these three limitations really really heavily hold 
symbolic executions back

408
00:25:26,166 --> 00:25:29,600
如迈克尔·扎莱夫斯基的那句话
and be reminded of the quote by Michael Zalewski

409
00:25:29,600 --> 00:25:33,966
他是世界上最成功fuzzer的创造者
the creator of the most successful fuzzer in the world

410
00:25:35,000 --> 00:25:37,466
符号执行
that the uses of symbolic execution

411
00:25:37,933 --> 00:25:39,133
动态符号执行
concolic execution

412
00:25:39,133 --> 00:25:40,000
静态分析
static analysis

413
00:25:40,000 --> 00:25:41,600
以及其他新兴的
and other emerging technologies 

414
00:25:41,600 --> 00:25:45,766
寻找复杂的、非结构化和无注释代码中的漏洞的技术
to spot substantial vulnerabilities in complex unstructured and non annotated code

415
00:25:45,766 --> 00:25:47,166
还处在婴儿期
are still in their infancy

416
00:25:47,566 --> 00:25:49,200
请注意，他说的不是模糊测试技术
note he's not talking about fuzzers

417
00:25:49,200 --> 00:25:50,733
他在说这些东西
he's talking about this stuff

418
00:25:51,766 --> 00:25:54,266
这是一个活跃的研究领域
this is an active area of research

419
00:25:55,066 --> 00:25:58,666
世界上有很多学者
a lot of academics around the world

420
00:25:58,666 --> 00:26:01,400
包括我在亚利桑那州立大学实验室的人
including people in my lab at asu

421
00:26:01,400 --> 00:26:03,333
和我的同事
along with my colleagues

422
00:26:03,666 --> 00:26:05,000
我们正在研究这个
we're working on this

423
00:26:05,000 --> 00:26:07,600
如果你感兴趣，请告诉我们
if you're interested let us know

