1
00:00:00,700 --> 00:00:01,933
你好黑客
hello hackers

2
00:00:02,133 --> 00:00:07,766
欢迎来到pwn学院的自动化漏洞挖掘模块
welcome to the Automated Vulnerability Discovery Module of pwn College

3
00:00:08,700 --> 00:00:16,400
在本模块中，我们将学习如何自动识别漏洞
in this module we're going to look at how to automatically identify vulnerabilities

4
00:00:16,500 --> 00:00:19,900
我们整个学期都在讨论漏洞
we've been talking about vulnerabilities throughout the entire semester

5
00:00:20,000 --> 00:00:26,600
我们发现、理解、识别并利用了各种各样的漏洞
different types of vulnerabilities that you've examined understood identified in software and exploited

6
00:00:26,733 --> 00:00:31,266
一直没试过自动化查找漏洞
never going to try to figure out how to automatically find these vulnerabilities

7
00:00:31,533 --> 00:00:34,166
这并不容易
and it's not easy

8
00:00:35,333 --> 00:00:38,666
我们为什么要关心自动化漏洞挖掘
so why do we care about automatically finding them

9
00:00:39,000 --> 00:00:41,066
我们手动查找的好好地
you've done just fine finding them manually

10
00:00:41,700 --> 00:00:45,300
但是如果你回想一下课程的开始
but if you think back to the beginning of the course

11
00:00:45,300 --> 00:00:46,933
我们讨论过Phineas Fisher
we talked about Phineas Fisher

12
00:00:47,200 --> 00:00:51,000
黑掉黑客团队的著名黑客
the hacker that famously brought down Hacking Team

13
00:00:51,400 --> 00:00:56,300
使用找到的一个嵌入式设备上的0day漏洞
using an embedded device 0 day that they found 

14
00:00:56,700 --> 00:01:01,500
它是黑客团队暴露在互联网上的极少数设备之一
in one of the very few devices that Hacking Team had exposed to the internet

15
00:01:02,000 --> 00:01:06,000
这些设备没有公开的漏洞
there was no publicly known vulnerability in these devices

16
00:01:06,066 --> 00:01:09,599
但他表示我要黑进去
the Phineas Fisher just said I will get into that device

17
00:01:10,100 --> 00:01:13,266
他们检查了设备固件
they looked at the device firmware

18
00:01:13,600 --> 00:01:14,933
识别出了0day漏洞
identified a zero day

19
00:01:15,300 --> 00:01:16,700
获取到入侵点
and gained entry

20
00:01:16,900 --> 00:01:22,300
引发了连锁反应，基本上毁了HackingTeam公司
and started this chain reaction that basically destroyed Hacking Team as a company

21
00:01:26,000 --> 00:01:29,533
原因是我们手动挖掘赶不上时代
the bottom line is we're not keeping up

22
00:01:29,833 --> 00:01:34,566
这是一张历年CVE数量图表
this is a graph of the number of CVEs Common Vulnerability Enumeration

23
00:01:34,866 --> 00:01:39,199
CVE编号是给安全研究人员的奖杯
a trophy that is given to security researchers 

24
00:01:39,500 --> 00:01:45,300
用于表彰安全研究员发现并上报漏洞
that identify and report security vulnerabilities over time and

25
00:01:46,900 --> 00:01:53,500
可以清楚的看到CVE数量的大量上升
you can clearly see a gigantic increase in the number of CVEs granted 

26
00:01:53,733 --> 00:01:58,633
现在发现的CVE数量至少
where nowadays we are getting at least twice as many CVEs

27
00:01:58,766 --> 00:02:02,866
是零几年的2倍
as we did in the height of the early 2000s

28
00:02:05,566 --> 00:02:08,866
我们发现了很多漏洞
and we're finding a lot of bugs

29
00:02:09,400 --> 00:02:11,933
但想问一下
but it's valid to ask

30
00:02:12,233 --> 00:02:14,466
这是否意味着
does this mean that maybe there

31
00:02:14,466 --> 00:02:16,299
我们找到了这么多bug
we're finding all the bugs 

32
00:02:16,300 --> 00:02:18,033
未知bug应该变少了吧
and there are fewer bugs out there

33
00:02:20,066 --> 00:02:22,233
不幸的是，情况并非如此
unfortunately this doesn't seem to be the case

34
00:02:22,800 --> 00:02:26,033
如果这张图叠上
if you overlay this graph 

35
00:02:26,300 --> 00:02:33,400
这张2006年至今的Linux代码行数图
on a graph of the lines of code in the Linux kernel over time from 2006 to the modern day

36
00:02:34,900 --> 00:02:36,500
看起来很严峻
the picture looks grim

37
00:02:36,500 --> 00:02:41,733
如果我们假设代码有一定的bug率
if we assume that code is buggy to some percentage 

38
00:02:41,966 --> 00:02:45,299
假设每n行包含一个bug
where every n lines contains a bug 

39
00:02:45,300 --> 00:02:47,700
这是个合理的假设
which is not an unreasonable Assumption

40
00:02:47,766 --> 00:02:49,899
它不一定有科学依据支撑
it's not necessarily science backed

41
00:02:50,033 --> 00:02:53,399
但也许我们能从一些数据中看出来
but probably there is data that we could look around for this

42
00:02:53,466 --> 00:02:54,866
如果我们做这个假设
if we make this Assumption

43
00:02:56,500 --> 00:02:57,866
那么我们可以清楚地发现
then we can clearly see

44
00:02:58,066 --> 00:03:02,199
找到的bug数未达到应有的bug数
we are not finding as many bugs as we should be finding

45
00:03:02,200 --> 00:03:06,300
鉴于软件增加的复杂性
given the increase in complexity in the software that we're working with

46
00:03:07,500 --> 00:03:08,500
当然，你可能会说
of course you might say okay

47
00:03:08,500 --> 00:03:11,300
Linux内核代码量可能增长的比其它软件快
but the Linux kernel maybe is growing faster than other software

48
00:03:11,366 --> 00:03:13,666
但从另一方面来看
but on a whole different axis

49
00:03:13,666 --> 00:03:16,666
如今现有的软件数量远超过
we have much much much more software nowadays 

50
00:03:16,866 --> 00:03:18,799
前几年的软件数
than we did even a couple years ago

51
00:03:19,100 --> 00:03:21,333
数以百万计地增加的
the proliferation of millions and millions 

52
00:03:21,433 --> 00:03:27,599
像Javascript代码、框架、小辅助库等
of Javascript frameworks and little helper libraries and all of this insane stuff

53
00:03:28,266 --> 00:03:29,799
Github的崛起
the rise of Github 

54
00:03:30,100 --> 00:03:35,000
现有的Github仓库数是三年前的两倍
we have twice as many Github repositories now as we did just three years ago

55
00:03:35,300 --> 00:03:39,700
有很多代码可能被人们使用
it's a lot of code that is out there possibly being used by people

56
00:03:40,133 --> 00:03:42,999
几乎可以肯定是有漏洞的
probably almost certainly vulnerable

57
00:03:43,100 --> 00:03:51,100
所以我们需要一些自动化的方法来识别更多的漏洞
so we need some automated way of identifying more vulnerabilities

58
00:03:51,566 --> 00:03:53,866
显然这不是新鲜事
obviously this isn't news

59
00:03:54,200 --> 00:03:57,300
事实上，研究人员几十年来一直在思考这个问题
in fact researchers have been thinking about this for decades 

60
00:03:57,533 --> 00:04:02,033
不确定是不是从1949年起，总之很久之前
not quite back to 1949 but fairly far 

61
00:04:02,299 --> 00:04:11,899
1949年，艾伦·图灵，图灵机等概念的发明者
in 1949 Alan Turning whom you might know as the inventor of concepts such as the turning machine

62
00:04:12,500 --> 00:04:17,900
他是计算机科学史上非常重要的人物
very important figure in computer science history

63
00:04:19,600 --> 00:04:23,100
艾伦·图灵提出了一个算法
Alan Turning proposed an algorithm 

64
00:04:23,633 --> 00:04:32,266
它可以用来检查大型函数的正确性
that could be used to check a large routine a large function for correctness

65
00:04:32,433 --> 00:04:35,633
这是艾伦·图灵所关心的是
now Alan Turning was concerned about

66
00:04:35,900 --> 00:04:38,566
程序写得得当吗
is this program written properly

67
00:04:38,700 --> 00:04:41,166
一个非常值得关注的问题是这个程序的安全性
a very concern is this program written securely

68
00:04:41,366 --> 00:04:43,133
但是你可以这样说
but you can make the argument 

69
00:04:43,333 --> 00:04:44,699
很多团体也都这样认为
and various groups do make the argument that 

70
00:04:44,833 --> 00:04:47,699
如果说程序编写得当，它必须是安全的
if a program is written properly it will be secured 

71
00:04:47,933 --> 00:04:50,266
安全性应该是规范的一部分
that should be part of the proper specification

72
00:04:50,533 --> 00:04:51,966
有趣的是
interestingly enough

73
00:04:52,100 --> 00:04:55,666
艾伦·图灵谈到了检查程序
Alan Turning talks about checking programs

74
00:04:55,866 --> 00:04:58,466
我第一次读这篇论文的时候
 and the first time I read this paper 

75
00:04:58,700 --> 00:05:02,133
我觉得这家伙真是太超前了
i think wow this dude is so far ahead of his time

76
00:05:02,800 --> 00:05:07,000
讲到了这个校验者检查这个，那个校验者检查那个
talking about the verifier does this the verifier does that

77
00:05:07,400 --> 00:05:10,300
1949年，人们几乎不了解软件
people are barely thinking about software in 1949

78
00:05:10,400 --> 00:05:13,100
他已经在考虑用软件验证其他软件
and he's already thinking about software validating other software

79
00:05:13,300 --> 00:05:18,300
然后我读到一处
and then I got to a part in the paper

80
00:05:19,100 --> 00:05:24,500
这里的表达方式让我突然意识到
where something was phrased in a way that I suddenly realized 

81
00:05:24,700 --> 00:05:30,933
艾伦·图灵说的校验者
oh Alan Turning is talking about the verifier

82
00:05:31,166 --> 00:05:34,933
是指让人来验证（现在是拟人，那时是真人）
but the verifier that he means is a person that's verifying 

83
00:05:35,066 --> 00:05:36,333
论文中描述了
this paper described 

84
00:05:36,566 --> 00:05:40,699
人员检验代码所需的操作流程
the process that a human being should take to verify the correctness of code

85
00:05:40,700 --> 00:05:47,133
这与当今安全研究的不同点很有趣
which is a very interesting difference to how cybersecurity research is done nowadays

86
00:05:47,300 --> 00:05:52,300
因为现在安全研究的论文，比如我们实验室的论文
because all of our papers when we do cybersecurity research for example in my lab

87
00:05:53,200 --> 00:06:02,500
都在讨论一个自动化系统是如何分析代码找到漏洞的
discuss how an automated system would analyze code and check it for vulnerabilities

88
00:06:04,000 --> 00:06:06,466
我们继续
let's roll on

89
00:06:07,266 --> 00:06:10,166
在本模块中，我们将介绍两个主要的分析方法
in this module we'll cover two main analysis

90
00:06:11,200 --> 00:06:13,933
静态分析和动态分析
static analysis and dynamic analysis

91
00:06:13,966 --> 00:06:15,133
区别在于
the difference is

92
00:06:17,466 --> 00:06:19,899
实际这是个哲学辩题
actually this is a philosophical debate

93
00:06:20,200 --> 00:06:22,600
这些都是模糊的定义
these are muddy philosophical definition

94
00:06:22,600 --> 00:06:25,333
有的静态分析技术会执行某些代码
there are static techniques that execute some code

95
00:06:25,533 --> 00:06:27,599
有的动态分析技术不执行某些代码
there are dynamic techniques that don't execute some code

96
00:06:27,700 --> 00:06:29,100
但区别在于
but the difference is

97
00:06:29,200 --> 00:06:32,966
你的分析方法所执行或不执行的代码
does your analysis technique execute code or does it not execute code

98
00:06:33,200 --> 00:06:36,700
是不是你要分析的代码
specifically execute the code that you're trying to analyze

99
00:06:38,766 --> 00:06:41,666
这两种技术各有利弊
there are pros and cons to both techniques

100
00:06:41,666 --> 00:06:44,066
我先把这张幻灯片修好，马上回来
let me fix this slide I'll be right back

101
00:06:48,333 --> 00:06:51,799
两种技术各有利弊
there are pros and cons to both techniques

102
00:06:52,500 --> 00:06:56,900
静态分析的优点是不需要执行目标程序
the pro to static analysis is that you don't need to execute the program

103
00:06:56,966 --> 00:06:59,399
这真是太好了
this is humongously good

104
00:06:59,600 --> 00:07:02,933
有些程序很难执行
some programs are incredibly hard to get to execute

105
00:07:03,100 --> 00:07:06,300
等说到动态分析的时候我会举例子
I'll talk about that one when I mention dynamic analysis

106
00:07:07,000 --> 00:07:08,600
静态分析的另一个优点是
another pro of static analysis

107
00:07:08,600 --> 00:07:12,266
该技术是非常有根据的
actually these techniques are very founded

108
00:07:12,466 --> 00:07:19,499
可以被数学证明有用
and very solid foundations that are mathematically proven to result in success

109
00:07:19,500 --> 00:07:23,400
例如，静态分析可以保证
for example a static analysis could guarantee 

110
00:07:23,400 --> 00:07:27,500
能检测到所有类型的漏洞
the detection of all instances of a specific vulnerability

111
00:07:27,500 --> 00:07:36,566
比如，静态分析对缓冲区溢出的识别
let's say static analysis that identifies buffer overflows 

112
00:07:36,866 --> 00:07:41,466
能保证检测到所有缓冲区溢出
could actually guarantee the detection of every single buffer overflow

113
00:07:41,466 --> 00:07:44,266
问题是这也直接造成了它的一大缺点
the problem is this leads directly to the con

114
00:07:44,500 --> 00:07:49,866
很不精准，误报多
is that they're incredibly imprecise and they rely on so much information

115
00:07:50,000 --> 00:07:53,700
且需要在不执行程序的情况下从程序中提取很多信息
that they need to extract from the program itself without executing it

116
00:07:53,899 --> 00:07:57,999
因为他们无法在执行时到处打听发生了什么
they can't actually like poke around at what's happening during execution

117
00:07:58,000 --> 00:08:01,300
想象一下，如果你逆向时被要求不准使用gdb
imagine if you had to reverse engineer everything without GDB

118
00:08:01,366 --> 00:08:02,799
那将十分痛苦
that would be a pain in the butt

119
00:08:06,100 --> 00:08:09,500
它们需要源代码
they require source code even with

120
00:08:10,500 --> 00:08:14,100
也不一定，有的分析二进制代码
not always there are static masters techniques on binary code

121
00:08:14,766 --> 00:08:18,666
我们实验室正在研究这种
we are researching some of them in our research lab 

122
00:08:19,299 --> 00:08:24,599
但没有源代码中包含的信息，分析得很难受
but they suffer greatly without the information contained in source code

123
00:08:26,533 --> 00:08:28,999
即使有源代码，它们也非常不精确
and even with source code they're incredibly imprecise

124
00:08:29,333 --> 00:08:32,133
我的意思是
what I mean by this is consider I said

125
00:08:32,600 --> 00:08:36,333
静态分析确实能保证成功检测到所有的bug
static analysis can guarantee successful detection of all bugs 

126
00:08:36,733 --> 00:08:40,699
不管他们是根据哪个标准认定的bug
that according to whatever specification they consider bugs to be

127
00:08:42,466 --> 00:08:44,099
静态分析后
I can make a static analysis

128
00:08:44,100 --> 00:08:47,833
它会告诉你，你程序的每条指令（夸张手法）
and I'll tell you that at every instruction in your program 

129
00:08:47,933 --> 00:08:49,533
都有缓冲区溢出
you will sugar a buffer overflow

130
00:08:49,700 --> 00:08:52,900
严格来说，确实找到了程序中所有的缓冲区溢出
and technically I've just found all of your buffer overflows

131
00:08:53,166 --> 00:08:55,699
但这种分析没太大用处
but that analysis is not very useful

132
00:08:56,000 --> 00:09:03,000
静态分析能够保证发现缺陷
static analysis tend to be able to make guarantees that it will be able to find flaws

133
00:09:03,600 --> 00:09:08,700
然而，它会发现很多所谓的误报
however it will find a lot of what is called false positives detections 

134
00:09:08,800 --> 00:09:14,200
将正常代码误认为有问题
that are not actually an issue 

135
00:09:14,933 --> 00:09:16,099
正因为如此
and because of this actually

136
00:09:16,100 --> 00:09:23,200
静态分析的使用比您想象的要少得多
static analysis is much much less used than you might expect

137
00:09:24,500 --> 00:09:30,100
另一边动态分析
right on the other side of the equation dynamic analysis

138
00:09:30,200 --> 00:09:33,366
动态分析有它自己的优点
Dynamic analysis has its own pros 

139
00:09:33,466 --> 00:09:35,833
在程序运行时的动态分析
dynamic analysis  when you run the program 

140
00:09:36,133 --> 00:09:41,899
可能是在gdb中手动启动，或者在动态分析工具中自动启动
for example manually in GDB but automatically in dynamic analysis tools 

141
00:09:43,866 --> 00:09:45,099
优点是
the pros that typically

142
00:09:45,200 --> 00:09:48,200
动态分析通常(并非总是)不需要源代码
dynamic analysis typically, not always, doesn't require source code

143
00:09:48,200 --> 00:09:52,200
它能在程序运行时分析程序运行情况
it can actually run the program analyze what is going on etc

144
00:09:53,400 --> 00:09:57,500
或者说有的强大的动态分析技术
or let's say rather there are powerful dynamic analysis techniques that 

145
00:09:57,533 --> 00:09:58,733
不需要源代码
do not require source code

146
00:09:58,733 --> 00:10:01,666
动态分析是非常精确的
dynamic analysis is very precise

147
00:10:01,700 --> 00:10:03,133
当它发现bug时
when it finds a bug

148
00:10:03,166 --> 00:10:05,799
它能发现bug，是因为运行时触发了bug
it finds the bug because it has just triggered the bug

149
00:10:05,800 --> 00:10:12,100
这意味着它能提供触发bug的输入数据，用于复现
that means it can give you an input data  that you can use to retrigger the bug

150
00:10:12,400 --> 00:10:17,966
这不会把你的时间浪费在误报上
which means that dynamic analysis doesn't waste your time with false positives 

151
00:10:18,333 --> 00:10:20,166
检测到的bug都是真的
every detection is a true positive

152
00:10:20,300 --> 00:10:23,400
相对的
on the other side of that

153
00:10:24,300 --> 00:10:29,100
也只能发现触发到的代码的bug
you can only spot bugs if you have actually triggered that part of the code

154
00:10:29,933 --> 00:10:33,866
这被称为假阴性（漏报）
this is called false negatives where

155
00:10:33,933 --> 00:10:37,566
只要你不触发代码
if you just don't trigger code 

156
00:10:40,500 --> 00:10:45,000
动态分析系统将无法检测到那里的bug
the dynamic analysis system will fail to detect bugs there

157
00:10:45,000 --> 00:10:47,500
它不会明说没bug
well it won't say there are no bugs

158
00:10:47,500 --> 00:10:49,266
但它也不会说有bug
but it won't say that there are bugs

159
00:10:49,700 --> 00:10:50,566
漏报
false negative

160
00:10:50,900 --> 00:10:53,900
这就是所谓的代码覆盖问题
this is known as the dynamic coverage problem

161
00:10:53,900 --> 00:10:57,766
为了对代码进行动态分析
in order to reason about code dynamically 

162
00:10:57,800 --> 00:10:59,533
你需要覆盖那段代码
you need to cover that code 

163
00:10:59,700 --> 00:11:03,333
我们将在本模块的另一个视频中讨论代码覆盖
we'll talk about code coverage in another video in this module

164
00:11:05,100 --> 00:11:08,300
动态分析的另一个重要问题是
the other non-trivial issue that dynamic analysis has

165
00:11:08,533 --> 00:11:10,599
要分析就必须要运行代码
is you have to run the code to analyze it

166
00:11:10,766 --> 00:11:15,133
很明显，如果你在分析objdump或其他简单的东西
so obviously if you're analyzing objdump or something simple 

167
00:11:15,500 --> 00:11:17,700
那很简单，运行一下就行了
that's simple enough you just run it

168
00:11:18,400 --> 00:11:20,466
但若是复杂的程序呢
but what about complex programs

169
00:11:20,533 --> 00:11:25,666
若是那些需要复杂配置的程序呢
what about programs require complex configuration 

170
00:11:26,100 --> 00:11:27,733
库呢
what about libraries

171
00:11:27,800 --> 00:11:31,900
如何动态分析libc库
how do you dynamically analyze libc

172
00:11:32,166 --> 00:11:37,166
显然，你要能在不同程序触发libc中的代码
obviously you need to be able to trigger code inside libc through different programs

173
00:11:37,766 --> 00:11:39,766
看看libc会做什么
to see what libc does

174
00:11:39,933 --> 00:11:41,433
若是嵌入式设备呢
embedded devices

175
00:11:41,700 --> 00:11:45,366
如果你有一份固件样例
if you have a firmware sample

176
00:11:45,466 --> 00:11:48,466
就像Phineas Fisher对嵌入式设备做的那样
like Phineas Fisher did for some embedded device

177
00:11:48,766 --> 00:11:54,266
如何使用动态分析来分析它呢
how do you use dynamic analysis to actually analyze it

178
00:11:54,700 --> 00:11:56,800
这是一个尚未解决的问题
that is a very much an unsolved problem

179
00:11:57,866 --> 00:12:01,299
这导致一个问题是
and as a result one problem is that 

180
00:12:01,500 --> 00:12:06,900
通常情况下，动态分析无法发现bug
often times you can't find bugs with dynamic analysis

181
00:12:07,000 --> 00:12:10,200
当然，动态分析是
now of course dynamic analysis is of course

182
00:12:11,400 --> 00:12:15,500
也许对我来说很明显，但对你来说还不是
obvious to me perhaps but not yet to you 

183
00:12:15,733 --> 00:12:21,699
动态分析是当今人类自动化漏洞挖掘技术的王道
dynamic analysis is king in the current state of human technology

184
00:12:22,400 --> 00:12:24,466
我们将在整个模块中讨论它
as we'll talk about throughout the module

185
00:12:25,600 --> 00:12:33,100
我们（整个社会）用动态分析技术找到了大量bug
we are as a society able to find quite a lot of bugs using dynamic techniques currently

186
00:12:33,566 --> 00:12:36,266
静态分析技术还在追赶中
and static techniques are kind of catching up

187
00:12:36,766 --> 00:12:38,266
这个情况不是不变的
this wasn't always the case

188
00:12:38,300 --> 00:12:40,700
但就目前来说是这样
but it's currently the case right now

189
00:12:43,200 --> 00:12:46,966
在这个模块中要记住
keep in mind throughout this module

190
00:12:48,966 --> 00:12:50,399
Michael Zalewski 
Michael Zalewski 

191
00:12:50,500 --> 00:12:58,900
我们将在之后几集讨论他是谁
and we'll talk about who he is a couple of videos from now

192
00:12:59,200 --> 00:13:03,700
Michael Zalewski有一句名言
Michael Zalewski  has this famous quote

193
00:13:04,000 --> 00:13:16,000
目前的程序分析技术才刚刚起步
that all of this program analysis stuff right now is kind of just starting out

194
00:13:16,000 --> 00:13:17,466
这句话是2015年的
this quote is from 2015. 

195
00:13:17,633 --> 00:13:21,099
五年后，情况依然如此
five years later it is still the case that 

196
00:13:21,100 --> 00:13:26,466
使用符号执行、协执行、静态分析等新兴技术
the uses of symbolic execution concolic execution static analysis and other emerging technologies

197
00:13:26,600 --> 00:13:30,833
来发现复杂的、非结构化的和无注释的，代码中的漏洞
to spot substantial vulnerabilities in complex unstructured and non annotated code 

198
00:13:30,966 --> 00:13:32,399
尚处于萌芽阶段
are still in their infancy

199
00:13:32,733 --> 00:13:33,933
这很难
this is hard

200
00:13:34,200 --> 00:13:40,100
本模块旨在让你了解早期阶段的各种可能性
this module is designed to give you a glimpse at these early stages at what is possible

201
00:13:40,500 --> 00:13:42,866
也许能激励你
and maybe inspire you

202
00:13:43,400 --> 00:13:46,300
加入正在进行的研究
to jump in on the research being done

203
00:13:46,500 --> 00:13:48,333
让这一切成为现实
to try to make this a reality

204
00:13:48,800 --> 00:13:50,966
各地都在进行这项研究
this research is being done all over the place

205
00:13:51,200 --> 00:13:56,966
包括亚利桑那州立大学中我和我优秀同事们的实验室
including at Arizona State University in my lab along with my awesome colleagues

206
00:13:57,866 --> 00:13:59,966
如果你对这样的研究感兴趣
if you are interested in doing such research

207
00:13:59,966 --> 00:14:01,266
并看到了这里
and you made it this far in the course

208
00:14:01,533 --> 00:14:03,733
给我发邮件，我们详谈
shoot me an email and we'll talk

209
00:14:04,000 --> 00:14:07,000
我们在接下来的视频中再见
otherwise I'll see you in the rest of the videos

