1
00:00:00,500 --> 00:00:01,500
你好黑客
hello hackers

2
00:00:01,500 --> 00:00:04,900
欢迎回到自动化漏洞发掘
welcome back to automated vulnerability discovery

3
00:00:05,300 --> 00:00:08,066
我们在这个视频中讨论的是静态分析
we're talking about static analysis in this video 

4
00:00:09,000 --> 00:00:09,766
提醒一下
as a reminder

5
00:00:09,766 --> 00:00:17,999
静态分析是一种在不执行代码的情况下分析代码的技术
static analysis is a technique that will analyze code          without executing it 

6
00:00:18,666 --> 00:00:21,333
我们将介绍两种
we're going to cover two types

7
00:00:21,333 --> 00:00:22,499
一种是简单朴素的
one homespun

8
00:00:22,766 --> 00:00:31,999
一种是业界用的大型的工具
one kind of industrial and big and out there 

9
00:00:33,333 --> 00:00:36,066
我们从最基本的家庭作坊式的开始
we'll start with the homespun the basics

10
00:00:36,966 --> 00:00:37,666
实际上
turns out

11
00:00:37,666 --> 00:00:40,199
你已经做过静态分析了
you've already done static analysis 

12
00:00:40,300 --> 00:00:42,400
你有手动完成过静态分析
you've done static analysis manually 

13
00:00:42,533 --> 00:00:46,633
使用像ghidra、binary ninja之类的
using stuff like Ghidra, binary ninja 

14
00:00:47,200 --> 00:00:49,966
还有ida，如果你用过的话
Ida if you have used Ida

15
00:00:50,233 --> 00:00:52,733
更重要的是
and more importantly

16
00:00:52,733 --> 00:00:53,999
我说的朴素
when i say homespun

17
00:00:54,000 --> 00:00:58,933
是指像objdump grep和和??
i mean objdump grep sed and and ??

18
00:00:59,733 --> 00:01:05,066
你用过这些东西来查询过ROP gadgets
you have manually used these to search for ROP gadgets 

19
00:01:06,133 --> 00:01:08,833
反汇编二进制文件等
to disassemble a binary etc 

20
00:01:09,766 --> 00:01:12,366
事实证明，你同样可以
turns out you can do the same

21
00:01:14,200 --> 00:01:17,866
用相同的工具进行自动化的静态分析
you can use the same tools for automated static analysis

22
00:01:18,266 --> 00:01:22,366
事实上，在这个课程中，你手动采取的行动
and in fact the actions that you've taken manually through out the course 

23
00:01:22,633 --> 00:01:25,966
通常也可以被自动化
can often be automated as well

24
00:01:27,333 --> 00:01:30,899
通过我制作的一个例子
let's take a very quick look at what i mean by this 

25
00:01:32,266 --> 00:01:37,633
快速看一下我的意思
using a example i crafted 

26
00:01:37,666 --> 00:01:41,366
我有一个简单的程序
so i have a simple program 

27
00:01:42,033 --> 00:01:47,466
它会比较我传入的东西
that compares something that i pass in 

28
00:01:47,566 --> 00:01:48,733
它读取1个字节
it reads in 1 byte

29
00:01:48,733 --> 00:01:57,099
然后和常量42比较
and then compares it against a fixed value 42 

30
00:01:59,666 --> 00:02:00,566
问题是
and the question of course

31
00:02:00,566 --> 00:02:01,866
我看看它
i can look at this 

32
00:02:01,866 --> 00:02:03,299
就知道
and i can figure out 

33
00:02:03,300 --> 00:02:04,766
好吧，我看到它
okay well i looked at it

34
00:02:04,766 --> 00:02:07,566
假设我没有源代码
let's say i didn't have the source code 

35
00:02:07,666 --> 00:02:09,533
我会反汇编
i would disassemble

36
00:02:11,366 --> 00:02:17,566
编译好的程序的main
just main from the compile program

37
00:02:18,733 --> 00:02:19,366
这是main函数
here's main 

38
00:02:19,366 --> 00:02:20,166
我会看看它
i'd look at it

39
00:02:20,166 --> 00:02:21,033
我对它进行逆向工程
i'd reverse engineered it 

40
00:02:21,100 --> 00:02:22,400
我会看到cmp指令
i'd see this cmp instruction

41
00:02:22,466 --> 00:02:24,799
0x2a是42的十六进制表现形式
0x2a that's 42 in hex 

42
00:02:24,833 --> 00:02:25,666
我看到它
i would see that 

43
00:02:25,833 --> 00:02:30,433
我就知道了，我要传入42
and i would say oh okay i need to send in 42 

44
00:02:31,233 --> 00:02:32,399
传给compare
i hit compare

45
00:02:32,466 --> 00:02:35,399
他告诉我失败了
and it gives me a failure 

46
00:02:35,533 --> 00:02:37,899
哦不是0x42,是0x2a
not hex 42, 2a 

47
00:02:38,066 --> 00:02:39,366
好的，成功
all right success

48
00:02:39,466 --> 00:02:40,666
这就拿到flag了
and i have the flag

49
00:02:41,966 --> 00:02:46,533
这是一个使用objdump完成的手工分析
this was a manual analysis done using objdump 

50
00:02:47,000 --> 00:02:49,233
我可以自动完成它
turns out i can automate this 

51
00:02:49,766 --> 00:02:52,533
想象我是一个自动化系统
so imagine that i'm an automated system

52
00:02:52,566 --> 00:02:53,799
我必须创建一个自动化系统
i have to create an automated system

53
00:02:53,800 --> 00:02:55,600
它会检查二进制程序
that will take a look at this binary 

54
00:02:55,600 --> 00:02:58,533
弄清楚答案
and figure out oh what is the answer

55
00:02:59,100 --> 00:03:00,100
所以我创建
so i create

56
00:03:00,866 --> 00:03:01,899
我执行objdump
i do the objdump 

57
00:03:01,933 --> 00:03:03,399
我用pipe传给grep
i pipe that through grep

58
00:03:03,666 --> 00:03:05,299
搜索cmp指令
i search for the cmp instruction 

59
00:03:05,333 --> 00:03:06,066
只有一个
there's only one

60
00:03:06,166 --> 00:03:08,166
很好，至少main中只有一个
that's nice only one in main at least

61
00:03:08,733 --> 00:03:10,533
然后我做一些后期处理
then i do some post processing 

62
00:03:10,600 --> 00:03:14,666
删掉所有16进制数前的东西
to remove everything up to the hex number

63
00:03:15,800 --> 00:03:16,266
太棒了
awesome 

64
00:03:16,266 --> 00:03:17,266
这是我要的2a
there's my 2a 

65
00:03:17,400 --> 00:03:25,400
现在我们要把它传给echo
now we need to convert it into a into the echo 

66
00:03:26,500 --> 00:03:28,166
我们
so let's do

67
00:03:30,333 --> 00:03:31,999
用parallel
use parallel for this 

68
00:03:32,633 --> 00:03:33,999
执行 echo -e
do echo -e

69
00:03:36,933 --> 00:03:38,166
加上两个反斜杠
to put two backslashes

70
00:03:38,200 --> 00:03:39,866
这样能转义
so that it escapes the 

71
00:03:40,533 --> 00:03:43,399
这样能让反斜杠传到parallel中
so that make a backslash makes it all the way through     parallel

72
00:03:43,666 --> 00:03:47,533
这样就有echo -e \x
and i have echo -e backslash x 

73
00:03:47,600 --> 00:03:49,366
跟着输入
and then the input 

74
00:03:49,866 --> 00:03:52,799
这将其转换为ASCII字符
boom that converts it to ascii 

75
00:03:53,100 --> 00:03:54,400
当然
and of course

76
00:03:54,466 --> 00:03:56,266
如果我手动这样做，能成功
if i manually do that that works

77
00:03:56,466 --> 00:03:59,966
或者我可以将结果发给它，也行
or i can send that through and that works 

78
00:04:00,433 --> 00:04:00,799
成了
boom

79
00:04:00,833 --> 00:04:04,299
当然，这是基于人工观察的自动化分析
that is an automated analysis based on manual insights of course

80
00:04:04,333 --> 00:04:07,566
我事先知道要查找cmp指令
i knew that i need to look for the cmp instruction and so   forth

81
00:04:08,066 --> 00:04:11,266
但是我创建了一个自动化的分析
but i created an automated analysis

82
00:04:11,733 --> 00:04:16,199
它能识别程序需要的输入
that managed to do to identify the input that this program needs 

83
00:04:16,300 --> 00:04:19,200
只使用objdump grep sed
using objdump grep sed

84
00:04:21,600 --> 00:04:22,900
我们把场景放大
let's scale this out

85
00:04:23,000 --> 00:04:25,000
我创造了很多不同的比较
i created a ton of different compares 

86
00:04:25,066 --> 00:04:26,799
每一个需要不同的字节
each one taking a different byte

87
00:04:27,166 --> 00:04:31,566
如果我执行compare_65
so if i of course do compare 65

88
00:04:34,300 --> 00:04:35,400
好的，65
okay six five 

89
00:04:35,833 --> 00:04:38,233
这应该是0x41
this should take hex 41

90
00:04:38,700 --> 00:04:40,200
也就是A
which is capital a 

91
00:04:40,866 --> 00:04:42,299
它不接收其它数据
and it won't take anything else 

92
00:04:43,233 --> 00:04:44,366
当然
now of course

93
00:04:44,800 --> 00:04:46,466
我可以给这些都写个脚本
i can script all of these

94
00:04:48,766 --> 00:04:53,566
在一字节表示范围中，从0到255
i can go from 0 to 255 the whole range of the byte

95
00:04:54,000 --> 00:05:02,800
每一个程序，我都反汇编
and for each one i disassemble the right binary

96
00:05:05,333 --> 00:05:09,599
用我基于grep和sed的自动化分析程序
use my grep and sed based automatic analysis

97
00:05:09,933 --> 00:05:11,899
在这个分析程序中我没有执行任何目标程序
i don't execute anything in that analysis

98
00:05:11,966 --> 00:05:13,366
这是一个静态分析
it's a static analysis 

99
00:05:13,700 --> 00:05:17,533
分析后，执行一遍目标程序
and run that back through the binary i was executing

100
00:05:22,133 --> 00:05:24,433
几乎每次都成功
and i get success almost every time 

101
00:05:24,533 --> 00:05:26,066
0，第一次失败了
zero zero was a failure

102
00:05:26,100 --> 00:05:27,333
我想知道为什么
i wonder why 

103
00:05:27,766 --> 00:05:29,466
我们先不管它
we won't worry about it

104
00:05:29,966 --> 00:05:34,166
但这二百五十多都成
but success on these 250

105
00:05:38,333 --> 00:05:39,866
剩下的失败了
failures on the rest

106
00:05:46,366 --> 00:05:47,433
我们先不管它
we're not gonna worry about it 

107
00:05:47,433 --> 00:05:48,266
关键是
the point is

108
00:05:49,800 --> 00:05:51,666
我们成功了很多次
we had many successes

109
00:05:52,100 --> 00:05:54,033
不知道为什么我们失败了那么多次
not sure why we had many failures

110
00:05:54,166 --> 00:05:55,499
我猜是负数的原因
my guess is negative

111
00:05:55,666 --> 00:05:58,099
我定义的char而不是unsigned char
i defined it as a char and not an unsigned char

112
00:05:58,200 --> 00:05:58,966
这有关系吗?
would that matter

113
00:06:00,466 --> 00:06:02,033
是的，这可能有关系
yeah that would probably matter 

114
00:06:02,533 --> 00:06:03,366
总之
anyways

115
00:06:05,066 --> 00:06:08,633
关键是使用objdump、grep和sed
the point is using objdump grep and sed 

116
00:06:08,966 --> 00:06:11,933
我写了一个静态分析程序
i wrote what is essentially a static analysis

117
00:06:11,966 --> 00:06:13,533
这不是一个复杂的程序
it's not a very complicated one

118
00:06:13,900 --> 00:06:16,400
但也有人写了非常复杂的
but people have written very complicated ones

119
00:06:16,466 --> 00:06:18,099
当可以访问源代码时
when they have access to source code

120
00:06:18,566 --> 00:06:19,966
效果会更好
it can get even better

121
00:06:20,200 --> 00:06:22,866
你可以用grep创建复杂的查询
you can create complex queries using grep 

122
00:06:23,000 --> 00:06:24,200
基本上就是在说
that basically say hey

123
00:06:24,500 --> 00:06:37,400
是否存在一个没有长度值的scanf
is there a a scanf that doesn't have a length value 

124
00:06:37,900 --> 00:06:46,600
或是否read后，直接strcpy，中间不用strlen检查长度
or is there a read that goes directly into a strcpy that       doesn't have a strlen in between 

125
00:06:46,733 --> 00:06:48,199
你可以用grep检查
you can create these with grep

126
00:06:48,300 --> 00:06:51,166
grep是一个非常好的静态分析工具
grep is a very good tool for static analysis 

127
00:06:51,800 --> 00:06:54,166
我们看一个真东西
let's take a look at something real

128
00:06:56,466 --> 00:06:58,599
讨论一下codeQL
and we're going to talk about codeQL

129
00:06:58,633 --> 00:07:05,666
codeQL是一种查询语言，用于查询大型代码库中的安全属性
codeQL is a query language to query security properties   on large code bases 

130
00:07:05,766 --> 00:07:07,533
它由GitHub创建
it's created by GitHub

131
00:07:08,333 --> 00:07:13,266
或者说它是由GitHub收购的一个小团队创建的
or it was created by a small group that was acquired by   GitHub

132
00:07:14,366 --> 00:07:16,599
它提供了一种查询语言
and it provides a query language

133
00:07:16,633 --> 00:07:21,066
你可以用它描述你想要进行的分析
where you can describe analyses you want to carry out

134
00:07:21,133 --> 00:07:24,166
它会处理所有的疯狂细节
and it will handle all of the craziness of you know

135
00:07:24,533 --> 00:07:28,299
将代码转换成正确的格式等等
getting the code based into the right format etc etc etc

136
00:07:28,666 --> 00:07:34,066
事实上，如果你去lgtm.com网站
in fact if you go to this lgtm.com etc 

137
00:07:34,133 --> 00:07:35,933
你可以分析sudo
you can analyze sudo 

138
00:07:36,500 --> 00:07:38,333
我们快速做一下
and so let's do that real quick

139
00:07:44,733 --> 00:07:45,533
哦,不
oh no

140
00:07:46,366 --> 00:07:47,466
为什么没切过去
why doesn't this work

141
00:07:50,166 --> 00:07:51,366
好了
there we go 

142
00:07:53,333 --> 00:07:57,533
这是codeQL对sudo的分析
here is the codeQL analysis of sudo 

143
00:07:58,066 --> 00:07:58,899
放大后
if you scroll in

144
00:07:59,000 --> 00:08:01,166
你可以看到sudo有22个警告
you see there 22 warnings for sudo 

145
00:08:01,600 --> 00:08:06,300
往下翻，有一些现成的分析
scroll down there's some canned analyses

146
00:08:06,400 --> 00:08:10,000
它会运行codeql内部有的检查
so it'll run queries that it has internally 

147
00:08:10,400 --> 00:08:13,400
我们可以出去看看它们是什么等等
we can out go and look at what they are and so forth

148
00:08:14,133 --> 00:08:15,666
sudo这里主要是一些
mostly here in sudo

149
00:08:15,766 --> 00:08:19,133
你可以调用的危险函数
there's a bunch of these dangrous functions that you can  call

150
00:08:19,200 --> 00:08:21,633
这里有一个整数溢出
and then there's a integer overflow

151
00:08:21,700 --> 00:08:23,766
你对整数溢出很熟悉
you are very familiar with integer overflows 

152
00:08:23,866 --> 00:08:26,233
这是乘法导致的可能的整数溢出
as a result of multiplication in fact as well

153
00:08:26,300 --> 00:08:27,533
在内存错误模块讲的
from the memory errors module 

154
00:08:27,633 --> 00:08:36,799
sudo的这行代码可能存在乘法导致的整数溢出
turns out there might be a multiplication based integer     error right in this line in sudo

155
00:08:36,900 --> 00:08:40,333
应该检查一下，看看是不是真的有bug
someone should take a look and see if it's really a bug

156
00:08:40,666 --> 00:08:41,166
当然
of course

157
00:08:41,166 --> 00:08:42,933
Codeql是一种静态分析技术
codeql is a static technique 

158
00:08:43,000 --> 00:08:45,966
它可能是误报
and it could be a false positive

159
00:08:49,466 --> 00:08:52,333
其他静态分析工具
other tools for static analysis

160
00:08:52,466 --> 00:08:55,333
有很多很多
there are many many many many tools 

161
00:08:55,966 --> 00:08:56,866
我会指出几个
i'll point out a couple 

162
00:08:56,933 --> 00:08:58,199
一个是angr
one angr

163
00:08:58,366 --> 00:09:00,633
angr是一个Python库
angr is a Python library

164
00:09:00,966 --> 00:09:06,699
它以可编写脚本的方式提供了大量不同的分析功能
that provides a whole lot of different analysis capabilities  in a scriptable way

165
00:09:07,100 --> 00:09:08,366
举个例子
so for example

166
00:09:08,966 --> 00:09:11,099
我们回到这里
if we go here

167
00:09:13,200 --> 00:09:14,566
进入python
and we drop into python 

168
00:09:15,366 --> 00:09:16,399
导入 angr库
import angr

169
00:09:20,566 --> 00:09:21,533
加载好程序
load it up

170
00:09:22,466 --> 00:09:23,466
我们可以
we can for example

171
00:09:23,466 --> 00:09:25,699
例如，计算控制流图
compute a control flow greph

172
00:09:42,100 --> 00:09:43,266
哦
oh dear

173
00:09:44,700 --> 00:09:46,166
我们装载的
we're loaded 

174
00:09:46,566 --> 00:09:49,199
Angr不像
angr is not as easy to use as

175
00:09:51,166 --> 00:09:54,366
Angr可能是最容易使用的分析框架之一
angr is probably one of the easiest to use analysis            frameworks

176
00:09:54,466 --> 00:09:55,499
但也有一些问题
but there are some gotches 

177
00:09:56,466 --> 00:09:58,599
我们要关闭库加载
we're gonna turn off library loading

178
00:09:58,666 --> 00:10:01,733
这样分析就快多了
so that analysis goes much faster 

179
00:10:01,866 --> 00:10:03,499
快多了
boom that was much faster

180
00:10:05,400 --> 00:10:06,133
比如
and for example

181
00:10:06,200 --> 00:10:11,000
这里是二进制文件中的所有代码节点
here all of the code nodes in the binary

182
00:10:11,033 --> 00:10:12,299
类似于objdump的功能
similar to what objdump does

183
00:10:12,366 --> 00:10:16,366
但即使去除掉程序中的所有符号，angr仍然有效
but angr works even if the binary is stripped out of all      symbols

184
00:10:16,466 --> 00:10:19,466
而objdump需要这些符号
that objdumpb relies on to extract this

185
00:10:20,600 --> 00:10:21,500
有
there are

186
00:10:22,866 --> 00:10:24,566
看看有哪些函数
see what functions there are

187
00:10:32,866 --> 00:10:33,899
愚蠢的python
Silly python

188
00:10:37,133 --> 00:10:38,166
我们可以
we can do

189
00:10:47,700 --> 00:10:49,000
有哪些函数
what functions 

190
00:10:49,533 --> 00:10:50,999
能看到有一个main函数
may we see there's a main function

191
00:10:51,000 --> 00:10:51,966
还有一些其他的
a couple of others

192
00:10:52,066 --> 00:10:55,233
我们还可以做其他各种静态分析查询
and we can do other various static analysis queries 

193
00:10:55,266 --> 00:11:11,899
看看哪些代码触及了哪些数据，等等
see what pieces of code touch what data and so on and   etc 

194
00:11:12,433 --> 00:11:13,199
例如
for example

195
00:11:13,666 --> 00:11:19,899
angr能在二进制文件中识别出哪些数据
you can see what data angr was able to identify inside the binary

196
00:11:20,866 --> 00:11:24,899
例如在400318处
such as at location 400318

197
00:11:25,133 --> 00:11:27,766
有一个28字节的字符串之类的东西
there's a 28 byte string this sort of thing

198
00:11:28,266 --> 00:11:32,266
可能是这个小程序内置的东西
this tiny binary that's probably some built in stuff all right

199
00:11:32,666 --> 00:11:35,933
有这么个angr，如果你对它感兴趣
so there's angr if you're interested in angr

200
00:11:36,900 --> 00:11:40,133
有一个地方可以了解它
there is a place to get you started 

201
00:11:40,666 --> 00:11:48,333
docs.angr.io是对angr的完整介绍
docs.angr.io is an whole introduction into angr 

202
00:11:49,166 --> 00:11:51,199
讲述了它的核心概念
talks about the core concepts

203
00:11:51,300 --> 00:11:55,200
内置的分析策略、高级话题
talks about built in analyses advanced topics 

204
00:11:55,533 --> 00:11:56,733
你可以
you can go to

205
00:11:59,766 --> 00:12:01,466
你可以点击 angr示例
you can click on examples

206
00:12:02,066 --> 00:12:08,133
这里有一些具体有用有趣的例子
and there's just like examples that do specific useful         interesting things 

207
00:12:10,666 --> 00:12:11,566
这就是angr
that was angr 

208
00:12:12,233 --> 00:12:15,666
你应该熟悉ida、ghidra、binary ninja了
you're familiar with the Ida Ghidra binary Ninja 

209
00:12:16,200 --> 00:12:18,033
这些都支撑脚本扩展
these sort of things they're all scriptable

210
00:12:18,200 --> 00:12:21,000
你也可以在其中进行静态分析
you can also do static analysis in them

211
00:12:21,166 --> 00:12:22,533
binary ninja cloud不行
not binary Ninja cloud

212
00:12:22,666 --> 00:12:24,666
要桌面版的binary ninja
but binary Ninja Desktop 

213
00:12:24,766 --> 00:12:28,666
然后，如果你有幸拥有源代码访问权限
and then if you have the Luxury of having source code      access 

214
00:12:28,700 --> 00:12:31,666
Clang和GCC也可以编写脚本
clang and gcc are scriptable as well

215
00:12:31,933 --> 00:12:32,766
有很多
there are a lot 

216
00:12:32,933 --> 00:12:35,833
不能编写脚本，但可以使用它们来实现分析
or not scriptable but you can use them to implement        analyses 

217
00:12:35,833 --> 00:12:38,733
实际上，GCC已经进行了一些分析
in fact gcc will already do some analyses

218
00:12:38,800 --> 00:12:45,066
如果你不安全的使用像strcpy之类的，它会警告你
it'll warn you if you're unsafely using stuff like strcpy in    certain situations

219
00:12:45,500 --> 00:12:49,000
市面上有很多静态分析工具
there are a lot of static analysis tools out there

220
00:12:49,866 --> 00:12:52,299
也许有一天我们会扩展这个模块
maybe one day we'll expand this module

221
00:12:52,366 --> 00:12:55,733
或者可以分多个模块来覆盖它们
or maybe make it into multiple modules to cover many of  them

222
00:12:55,866 --> 00:12:56,733
但是现在
but for now 

223
00:12:56,733 --> 00:13:00,266
这是对静态分析的快速概述
this is a very quick overview of static analysis

224
00:13:01,566 --> 00:13:06,466
如果你对研究创建新的分析方法感兴趣的话
again if you're interested in doing research and creating   new analyses

225
00:13:07,266 --> 00:13:08,033
给我发封邮件
shoot me an email 

226
00:13:08,133 --> 00:13:09,466
如果你能走到这一步
if you made it this far 

227
00:13:09,766 --> 00:13:13,999
你可以帮助创建程序分析的未来
you could help create the future of program analysis

228
00:13:14,933 --> 00:13:16,199
下个视频见
see you in the next video

