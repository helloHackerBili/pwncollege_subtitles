1
00:00:00,466 --> 00:00:01,666
你好黑客
hello hackers

2
00:00:01,666 --> 00:00:06,466
欢迎回到pwn学院的漏洞自动发掘模块
welcome back to the Automated Vulnerability Discovery   Module of pwn College

3
00:00:06,466 --> 00:00:09,366
在这个视频中，我们将讨论模糊测试
in this video we're talking about fuzzing

4
00:00:09,366 --> 00:00:12,033
模糊测试是一种动态分析技术
fuzzing is a dynamic analysis technique 

5
00:00:12,166 --> 00:00:17,766
从某种意义上说，它是动态分析技术之王
it is the king of dynamic analysis techniques in some        sense

6
00:00:18,300 --> 00:00:22,900
提醒一下，动态分析技术是围绕
and as a reminder dynamic analysis technique is this built around

7
00:00:23,200 --> 00:00:25,933
是围绕这样一个概念构建的
dynamic analysis techniques are built around this concept that

8
00:00:25,933 --> 00:00:27,299
你能运行一个程序
you can run a program

9
00:00:27,300 --> 00:00:28,366
能看到它会做什么
you can see what it does

10
00:00:28,366 --> 00:00:31,099
你可以据此做出推断
and you can make inferences based off of that

11
00:00:32,700 --> 00:00:37,300
模糊测试的起源可追溯到20世纪50年代
fuzzing had its origins way back in the 1950s

12
00:00:37,533 --> 00:00:40,199
我找到了这篇博文
I tracked down this blog post

13
00:00:40,200 --> 00:00:45,733
这是我能找到的，关于模糊测试的最早的参考资料
this is as early as I could find a reference to the concept  of fuzzing

14
00:00:46,266 --> 00:00:53,533
当时，它们测试的程序还写在卡片上
and back then to test their programs which were on punch cards 

15
00:00:53,766 --> 00:00:55,033
通过在卡片上打孔来编程
programmed on punch cards

16
00:00:55,200 --> 00:01:00,900
开发人员会用之前丢弃的打孔卡
developers would take previously discarded punch cards  which

17
00:01:01,066 --> 00:01:03,966
读取里面的数据
you know could be read for their data 

18
00:01:03,966 --> 00:01:04,899
并使用它们
and use them

19
00:01:05,866 --> 00:01:11,733
把它们作为输入，输入到他们想要测试的程序中
fed them as input into the programs that they were trying  to test

20
00:01:12,133 --> 00:01:14,466
这些都是意外数据
just unexpected data

21
00:01:14,966 --> 00:01:16,966
这就是模糊测试
that is fuzzing

22
00:01:18,333 --> 00:01:21,066
向程序提供意外数据
the feeding of unexpected data to programs 

23
00:01:21,066 --> 00:01:23,266
看看他们是否会出现意外行为
to see if they will misbehave

24
00:01:23,700 --> 00:01:27,333
模糊测试是在20世纪80年代形成的
fuzzing was kind of scientifically framed in the 1980s

25
00:01:27,500 --> 00:01:34,300
30年后在一次学术会议上被重新探索和描述
30 years later rediscovered and described at an academic conference

26
00:01:34,300 --> 00:01:36,733
这是一个顶级软件工程会议
one of the top software engineering conferences

27
00:01:38,366 --> 00:01:40,733
最初的想法是
and the original idea 

28
00:01:40,733 --> 00:01:43,366
很简单
there was pretty simple

29
00:01:43,966 --> 00:01:45,499
你运行程序
you run the program

30
00:01:45,600 --> 00:01:47,066
给它发送随机的东西
you send it random stuff 

31
00:01:47,266 --> 00:01:48,566
看它是否会崩溃
and you see if it crashes

32
00:01:48,566 --> 00:01:49,466
结论是
and the takeaway was 

33
00:01:49,600 --> 00:01:54,266
当发送随机输入时，很多东西都表现异常
hey lots of stuff misbehaves when sent random input

34
00:01:54,933 --> 00:01:58,233
事实上，这里我展示了一个非常简单的fuzzer
in fact what I'm showing you here is a very simple fuzzer

35
00:01:58,900 --> 00:02:02,200
它是用bash编写的，带有一点python
it written in bash and with a little python stub 

36
00:02:02,600 --> 00:02:07,300
你发送随机数据
you send random data 

37
00:02:07,400 --> 00:02:08,966
这里用的cat /dev/urandom
this cat /dev/urandom 

38
00:02:08,966 --> 00:02:10,966
这是一个随机数据的接口
this is a random interface

39
00:02:12,000 --> 00:02:13,366
内核的接口
a interface to the kernel 

40
00:02:13,533 --> 00:02:17,133
内核会将随机数据发送到这个文件
where the kernel will send you random data on that file

41
00:02:17,866 --> 00:02:21,999
你可以运行任何你想运行的程序
and you run whatever you program you want to run

42
00:02:22,466 --> 00:02:23,366
看看它会不会崩溃
and see if it crash

43
00:02:23,500 --> 00:02:25,700
效果惊人
it's surprisingly effective

44
00:02:26,200 --> 00:02:28,900
我们看一个不同的例子
let's take a look for a different example 

45
00:02:28,966 --> 00:02:31,299
实际上不追求崩溃
actually not for crashing 

46
00:02:31,600 --> 00:02:35,266
我们有一个compare程序
we have this compare program that takes

47
00:02:36,133 --> 00:02:37,299
发生了什么事?
what is going on

48
00:02:37,866 --> 00:02:39,866
我们有一个compare程序
we have this compare program

49
00:02:40,500 --> 00:02:42,200
它接收一个字母
that takes one letter

50
00:02:42,933 --> 00:02:44,899
失败了会告诉我
and tells me that I failed

51
00:02:45,166 --> 00:02:48,299
用strings查看一下这个程序
if I look at the strings of this program 

52
00:02:48,533 --> 00:02:50,366
能看到里面有一个success字符串
I can see that there is a success

53
00:02:50,600 --> 00:02:55,500
所以应该有一个可触发的成功案例
so there should be a triggerable success case

54
00:02:55,700 --> 00:02:58,666
因为它只读一个字母
for because it only reads one letter

55
00:02:59,100 --> 00:03:01,666
剩下的都被送到shell了
the rest get sent to my shell

56
00:03:01,900 --> 00:03:06,000
总之，我们写一个fuzzer来搞定它
anyways let's write a fuzzer to solve this

57
00:03:07,000 --> 00:03:07,800
我们是这样做的
here's what we do 

58
00:03:17,733 --> 00:03:18,999
你可以看到
and you can see it's

59
00:03:19,800 --> 00:03:21,666
这些失败正在闪烁
these failures that are blinking

60
00:03:23,766 --> 00:03:25,199
因为每过一会
because every once in a while 

61
00:03:25,266 --> 00:03:27,466
会得到正确的输出
you get the correct output 

62
00:03:27,800 --> 00:03:30,100
上面写着success
and it said success

63
00:03:30,700 --> 00:03:31,666
实际上我们可以
we can actually

64
00:03:33,166 --> 00:03:35,466
将输出镜像到/dev/stderr
mirror that output to /dev/stderr

65
00:03:35,533 --> 00:03:37,533
然后我们就能看到它
and then we can actually see it

66
00:03:42,700 --> 00:03:43,500
哦,上帝
oh God

67
00:03:44,700 --> 00:03:45,100
好吧
okay

68
00:03:45,100 --> 00:03:46,033
这是一个错误
that was a mistake 

69
00:03:46,033 --> 00:03:49,266
我向终端发送了一堆二进制数据
I just sent a bunch of binary data to my terminal

70
00:03:51,666 --> 00:03:52,433
不弄了
we won't do that 

71
00:03:52,533 --> 00:03:53,499
但基本上
but basically

72
00:03:54,266 --> 00:03:56,066
我从上个视频中知道
I know from the last video 

73
00:03:56,066 --> 00:03:57,533
它需要一个*
that this takes a star

74
00:03:58,300 --> 00:03:59,533
成功了
and that was the success

75
00:03:59,533 --> 00:04:02,499
所以255次中的每一次
so every one out of 255 times

76
00:04:03,133 --> 00:04:04,999
哦，256次中的1次
oh one out of 256 times 

77
00:04:05,066 --> 00:04:08,333
我们发送了一个*
we end up sending a star

78
00:04:08,400 --> 00:04:09,200
它是正确的
it's the correct thing 

79
00:04:09,266 --> 00:04:10,633
我们触发了成功
and we hit success

80
00:04:10,966 --> 00:04:13,099
你可以很轻松地想象到
and you can easily imagine of course

81
00:04:13,266 --> 00:04:15,566
我们也可以通过这种方式引发崩溃
that we can also trigger crashes this way

82
00:04:15,566 --> 00:04:17,599
这是非常有效的
and this is surprisingly effective

83
00:04:18,100 --> 00:04:20,266
即使是这样的一个简单fuzzer
even these simple fuzzers even now 

84
00:04:20,566 --> 00:04:26,666
即使是现在，你在ubuntu上运行它
if you run this on an installable ubuntu

85
00:04:26,900 --> 00:04:28,566
你会发现一些崩溃
you will find crashes

86
00:04:28,566 --> 00:04:31,433
有人在babysuid做系列题目时，来找我
there were people coming to me in the babysuid module 

87
00:04:31,500 --> 00:04:34,633
说嘿，我写了这个
saying hey I wrote this 

88
00:04:35,200 --> 00:04:38,966
想通过模糊测试来获得flag
just to try to fuzz programs to get the flag

89
00:04:39,100 --> 00:04:40,866
然后我发现了一堆崩溃
and I found a bunch of crashes

90
00:04:40,866 --> 00:04:42,899
是的，它非常有效
yes it's shockingly effective 

91
00:04:43,000 --> 00:04:44,233
即使是这样一个简单的想法
even this simple idea 

92
00:04:44,600 --> 00:04:45,800
我一直说崩溃
so I keep saying crashes

93
00:04:45,900 --> 00:04:49,466
有一个monitor_for_crash.py
and there was a monitor_for_crashes.py

94
00:04:49,766 --> 00:04:51,833
这是为什么?
why is that 

95
00:04:51,933 --> 00:04:59,066
为什么我们的示例fuzzer要找崩溃
why does our example fuzzer conceptually look for           crashes

96
00:04:59,133 --> 00:05:01,733
因为崩溃有吸引力
well it's because crashes are attractive

97
00:05:01,733 --> 00:05:03,699
崩溃是非常令人兴奋的
crashes are very exciting

98
00:05:03,866 --> 00:05:05,466
崩溃意味着内存损坏
crashes imply memory corruption

99
00:05:05,466 --> 00:05:09,733
内存损坏预示着有实现代码执行的可能
memory corruption applies the potential for achieving       code execution

100
00:05:09,933 --> 00:05:12,666
而且崩溃是很容易看到的
but and crashes are very easy to see

101
00:05:12,866 --> 00:05:15,166
它们在程序外很容易看
they're very noticeable from outside of the program

102
00:05:15,233 --> 00:05:20,266
你不用对程序做些复杂的事，来观察是否崩溃
you don't actually need to do crazy stuff to the program to see if it has crashed

103
00:05:21,066 --> 00:05:23,066
调用进程可以简单地调用wait
the calling process can simply call wait

104
00:05:23,066 --> 00:05:26,466
wait将返回终止码
and wait will return the termination code

105
00:05:26,733 --> 00:05:29,299
然后你就知道这个进程是否崩溃了
and then you know that the process has crashed 

106
00:05:29,433 --> 00:05:31,466
这非常有用
which is super useful

107
00:05:34,500 --> 00:05:35,800
有些fuzzer
there are fuzzers

108
00:05:35,900 --> 00:05:38,333
可以检测到其他类型的漏洞
that can detect other types of vulnerabilities

109
00:05:38,333 --> 00:05:43,333
在竞争条件模块，我谈到了能识别竞争条件的fuzzer
I talked about fuzzers that can identify race conditions in  the race condition module

110
00:05:43,400 --> 00:05:45,800
有识别攻击算法的fuzzer
there are fuzzers that identify algorithmic attacks

111
00:05:45,800 --> 00:05:48,266
识别信息泄露的Fuzzers
fuzzers that identify information disclosure 

112
00:05:48,333 --> 00:05:49,999
但这更难做到
but this is harder to do

113
00:05:50,200 --> 00:05:51,500
要识别竞争条件
to identify race condition

114
00:05:51,500 --> 00:05:53,200
你需要考虑
you need to reason about the

115
00:05:53,366 --> 00:05:59,799
实际状态和互斥锁的正确状态，等等
actual versus the correct state of mutexes etc etc etc

116
00:05:59,866 --> 00:06:02,666
这是一件相当棘手的事情
it's a pretty tricky business

117
00:06:02,733 --> 00:06:06,133
所以人们倾向于关注内存损坏
so people tend to focus on memory corruption

118
00:06:08,166 --> 00:06:10,333
我们得到了内存损坏
so we got the memory corruption

119
00:06:11,400 --> 00:06:13,133
我们讲了这个简单的fuzzer
we have the simple fuzzer

120
00:06:13,200 --> 00:06:14,366
在这之后
after this

121
00:06:15,066 --> 00:06:16,866
在2010年代初
in the early 2010s

122
00:06:17,000 --> 00:06:20,066
人们转向了生成式模糊测试
people have moved on to generational fuzzing

123
00:06:20,066 --> 00:06:22,133
他们意识到
so they realized hey if I actually just

124
00:06:22,300 --> 00:06:25,766
如果我直接发送随机数到图像处理库
send /dev/urandom to an image processing library

125
00:06:26,566 --> 00:06:29,333
它立马会说，嘿，这不是JPEG
it is going to very quickly say hey that's not a JPEG

126
00:06:29,566 --> 00:06:31,566
它不会执行
and it'll won't actually execute 

127
00:06:31,933 --> 00:06:38,133
所有我们感兴趣的JPEG库或PNG库代码
all that juicy code deep inside Lib JPEG or Lib PNG

128
00:06:38,800 --> 00:06:41,600
我们想要执行它
that I actually want to get executed 

129
00:06:41,733 --> 00:06:47,466
才能观察里面的bug
so that you know I can observe bugs in it

130
00:06:47,900 --> 00:06:52,066
于是人们发明了一种生成式的模糊测试技术
and so people created a technique called generational fuzzing

131
00:06:52,066 --> 00:06:54,499
这个想法很直接
the idea is fairly straightforward

132
00:06:54,533 --> 00:06:57,766
创建一个文件生成器
you create a file generator

133
00:06:58,100 --> 00:07:00,700
例如，如果我对objdump进行模糊测试
for example if I'm fuzzing objdump

134
00:07:01,133 --> 00:07:03,133
它以ELF文件作为输入
which takes ELF files as input

135
00:07:03,133 --> 00:07:04,666
我会创建ELF文件
I will create ELF files 

136
00:07:04,666 --> 00:07:08,233
我有一个脚本generate_elf_file.py
and I have a script generate_elf_file.py 

137
00:07:08,300 --> 00:07:10,766
它会输出一堆ELF文件
that just shoots out a bunch of ELF files 

138
00:07:10,866 --> 00:07:17,133
稍微有点畸形，但可以识别为ELF文件
slightly maybe malformed but recognizable as ELF files

139
00:07:17,566 --> 00:07:20,133
然后我把它们发送到objdump中
and then I send them into objdump

140
00:07:22,100 --> 00:07:26,066
这种fuzzer的一个例子是Peach
an example of this type of fuzzer is Peach fuzzer

141
00:07:26,566 --> 00:07:30,933
Peach是一个文件格式模糊测试器
Peach fuzz is a file format Fuzzer 

142
00:07:31,000 --> 00:07:33,833
它接受XML指定的文件格式
that takes a file format specified in XML 

143
00:07:34,000 --> 00:07:36,000
并生成它的例子
and generates examples of it

144
00:07:36,066 --> 00:07:37,766
我在我的研究中使用过它
I've used it in my research

145
00:07:38,000 --> 00:07:44,900
如果你需要生成有效的文件，它就很好
it's pretty good stuff if you need to generate valid files 

146
00:07:45,066 --> 00:07:47,666
还可以使用其他技巧
and can use other techniques for example

147
00:07:50,500 --> 00:07:52,733
这将带我们来到现代
this brings us to the modern day

148
00:07:52,733 --> 00:07:54,866
要说的是突变模糊测试
which is mutational fuzzing

149
00:07:56,900 --> 00:08:02,333
突变式与生成式不是同一种模糊测试
mutational fuzzing is a different class of fuzzers from       generational fuzzing

150
00:08:02,400 --> 00:08:06,200
突变式的会基于已有输入进行变形
mutational fuzzing mutate existing inputs

151
00:08:06,566 --> 00:08:11,366
来尝试触发新bug和新的代码路径
to try to trigger new bugs and new code

152
00:08:13,533 --> 00:08:17,033
现在看来，这是一种很好的尝试
this is kind of now a very hacky best attempt 

153
00:08:17,066 --> 00:08:18,666
基本上有一个循环
but basically you have a loop

154
00:08:18,800 --> 00:08:21,800
在里面，随机选择之前用过的输入
where you pick some random input that you've tried before

155
00:08:22,200 --> 00:08:24,266
你会改变它
and you change it

156
00:08:24,700 --> 00:08:25,800
反转一个比特位
you flip a bit

157
00:08:26,133 --> 00:08:28,533
或旋转它
you rotate it 

158
00:08:28,700 --> 00:08:30,200
你把它切分出来
you splice it out 

159
00:08:30,400 --> 00:08:33,000
可能和其它输入拼接起来
maybe splice it with other input as well

160
00:08:33,066 --> 00:08:36,266
然后你试一下，看看程序是否会崩溃
and then you try that and see if the program crashes

161
00:08:37,233 --> 00:08:39,033
这里有几个核心问题
so there's a couple of core questions here

162
00:08:39,066 --> 00:08:42,366
一是我们如何选择哪些输入进行改变
one is how do we select what inputs to mutate

163
00:08:42,533 --> 00:08:45,266
二如何改变这些输入
and 2 how do we mutate these inputs

164
00:08:45,733 --> 00:08:52,166
这把我们带到了最近五年的前沿
and this brings us to really the cutting edge or of the last half decade let's say

165
00:08:54,100 --> 00:08:58,600
就是代码路径覆盖引导的突变模糊测试
which is code coverage guided mutational fuzzing

166
00:08:59,766 --> 00:09:02,299
现代的fuzzer有这样的逻辑
modern fuzzers have logic like this 

167
00:09:02,466 --> 00:09:06,533
它们从一堆输入开始
they start with a a bunch of inputs

168
00:09:06,600 --> 00:09:09,000
他们会把一堆数据输入程序
a bunch of data that they will feed into the program

169
00:09:09,000 --> 00:09:11,866
这被称为种子语料库
this is called the seed corpus

170
00:09:11,933 --> 00:09:13,133
这些是种子
these are seeds 

171
00:09:13,133 --> 00:09:16,099
我们会用这些种子，种出树来
and from these seeds we will grow trees

172
00:09:16,200 --> 00:09:18,500
然后它们进入这个分析循环
and then they enter this analysis loop 

173
00:09:18,766 --> 00:09:24,866
它们会在这里用输入执行程序
where they will execute the program with every pending    input

174
00:09:24,866 --> 00:09:26,999
最初用的种子语料库
initially this is the seed corpus

175
00:09:27,200 --> 00:09:32,266
它们会记录下执行的指令
they'll record what instructions were executed 

176
00:09:32,300 --> 00:09:40,966
或记录下在处理这些输入时，覆盖到的代码路径
or what coverage happened when processing these          pending inputs

177
00:09:41,200 --> 00:09:45,166
他们会标记出增加了代码覆盖率的输入
they'll mark the inputs that increase the code coverage

178
00:09:45,233 --> 00:09:47,333
执行了新的指令的输入
that executed new instructions

179
00:09:48,466 --> 00:09:50,366
标记为有趣的
as interesting 

180
00:09:50,600 --> 00:09:53,666
比如，这是一个有趣的输入
say hey this is an interesting input 

181
00:09:53,733 --> 00:09:56,199
它执行了新的指令
that triggered new instruction 

182
00:09:56,200 --> 00:09:58,533
也许我们稍微调整一下这个输入
maybe if we tweak it a little bit more

183
00:09:58,533 --> 00:09:59,666
它还会触发新的东西
it'll trigger even new things

184
00:09:59,700 --> 00:10:01,200
或者稍微调整一下
or if we tweak it a little bit more

185
00:10:01,500 --> 00:10:02,966
它会触发一个bug
it'll trigger a bug

186
00:10:03,533 --> 00:10:05,799
然后变异fuzzer
so then the mutational fuzzer

187
00:10:05,966 --> 00:10:07,933
会改变这些输入
will mutate those inputs

188
00:10:07,933 --> 00:10:11,133
最近增加了代码覆盖率的输入
the inputs that have recently increased code coverage

189
00:10:11,400 --> 00:10:13,366
生成一组新的待使用输入
to produce a new set of pending inputs

190
00:10:13,366 --> 00:10:16,766
这样循环下去，直到我们找到bug
and the cycle continues until we find bugs

191
00:10:18,066 --> 00:10:19,833
这里有几件事要注意
so a couple of things here 

192
00:10:19,933 --> 00:10:23,266
一，我们如何建立这个种子语料库
1 how do we build this seed corpus

193
00:10:23,266 --> 00:10:26,599
二，我们如何识别代码覆盖率的增加
2 how do we identify increases in code coverage 

194
00:10:26,700 --> 00:10:29,866
三，我们如何改变这些输入
and 3 how do we mutate these inputs

195
00:10:30,700 --> 00:10:33,866
这里这句话你应该挺熟悉的
from here this quote should be familiar now

196
00:10:33,933 --> 00:10:36,199
在这个模块的介绍视频中出现过
from the introduction video of this module

197
00:10:36,200 --> 00:10:38,333
从现在开始，我们将讨论
from here we're going to be talking about

198
00:10:38,733 --> 00:10:39,933
AFL
American Fuzzy Lop

199
00:10:40,000 --> 00:10:45,666
AFL的创始人讲的这句话
the creation of the person that made this quote

200
00:10:46,166 --> 00:10:47,733
AFL
American Fuzzy Lop

201
00:10:48,466 --> 00:10:51,966
是覆盖引导突变模糊测试的一种实现
is a specific implementation of coverage guided              mutational fuzzing

202
00:10:51,966 --> 00:10:52,766
它是
it was

203
00:10:52,900 --> 00:10:54,800
我不知道它是不是首个实现的
I don't know if it was the first implementation of it

204
00:10:54,800 --> 00:11:00,966
但它绝对是最声名远播的
but it was definitely the first widely radically famous         implementation of it

205
00:11:01,400 --> 00:11:06,766
它算是永久改变了程序分析的世界
then it kind of changed the world of program analysis       forever 

206
00:11:07,100 --> 00:11:08,733
首先我们来谈谈
so first let's talk about 

207
00:11:09,766 --> 00:11:13,966
你会传递给AFL的种子语料库
the seed corpus that you would pass to American Fuzzy   Lop to AFL

208
00:11:19,700 --> 00:11:20,666
我懵了一下
my mind just went blank

209
00:11:21,133 --> 00:11:23,266
总之，种子语料库很重要
anyways the seed corpus this is critical

210
00:11:23,733 --> 00:11:24,766
你们可能听说过
so you might have heard

211
00:11:24,766 --> 00:11:26,466
无限猴子理论，说
the infinite monkey theorem says

212
00:11:26,733 --> 00:11:30,333
可以将一群猴子和一堆打字机放在一起
you can put a bunch of monkeys with a bunch of              typewriters 

213
00:11:30,333 --> 00:11:31,499
然后让他们随机敲打字机
and have them hit them randomly

214
00:11:31,500 --> 00:11:33,733
最后你能看到莎士比亚的作品
and eventually you will have the works of Shakespeare

215
00:11:33,933 --> 00:11:36,999
但这需要很长很长的时间
but that's gonna take a very very very long time

216
00:11:37,100 --> 00:11:39,966
同样，如果你发送一堆随机数据
in the same way if you send a bunch of random data 

217
00:11:40,000 --> 00:11:43,966
然后你对这些随机数进行突变修改
and you start sending doing a bunch of random mutations off that random data

218
00:11:44,000 --> 00:11:49,333
即使使用覆盖引导，你也需要花费很长时间
it's going to take you a very long time even with coverage guided feedback

219
00:11:49,833 --> 00:11:53,299
才能实现一些有用的东西
to achieve something useful right

220
00:11:54,333 --> 00:11:57,133
所以你的种子语料能帮助猴子
so your seed corpus helps the monkeys

221
00:11:57,133 --> 00:11:58,999
你的种子语料库应该多种多样
your seed corpus should be varied

222
00:11:59,200 --> 00:12:01,066
它应该代表
it should represent kind of

223
00:12:02,733 --> 00:12:05,366
能对程序功能有良好的覆盖
a good coverage of program functionality

224
00:12:06,533 --> 00:12:12,233
如果你在模糊测试图像处理库
if you are fuzzing an image processing library 

225
00:12:12,400 --> 00:12:14,666
它支持多种文件格式
and it supports multiple files formats

226
00:12:15,066 --> 00:12:16,233
你应该，抱歉
you should excuse me 

227
00:12:16,233 --> 00:12:22,766
你的种子语料库中应该有多种图片格式
you should have multiple formats in your seed corpus 

228
00:12:22,833 --> 00:12:32,666
如果你正在测试一个ELF处理库
if you are fuzzing a elf processing library

229
00:12:32,866 --> 00:12:37,733
你可以考虑放置许多不同架构的elf
you might consider putting ELFs of lots of different          architectures

230
00:12:37,733 --> 00:12:39,166
诸如此类的事情
and all of these sort of things

231
00:12:39,166 --> 00:12:40,899
它应该稍微有点怪
it should be slightly weird

232
00:12:41,100 --> 00:12:44,600
应该接近程序的边缘情况
it should be close to edge cases of the program 

233
00:12:44,666 --> 00:12:48,699
这样fuzzer只修改一点
so that the fuzzer can fuzz it a little bit and

234
00:12:49,266 --> 00:12:51,166
就能触发奇怪的行为
trigger really weird behavior

235
00:12:51,333 --> 00:12:52,599
最简单的方法是什么
what's the easiest way to do this

236
00:12:52,600 --> 00:12:54,766
最简单的方法就是
the easiest way to do this is to look at 

237
00:12:57,066 --> 00:13:02,699
看看相关代码中触发bug的poc输入
proof of concept inputs that have triggered bugs in related code

238
00:13:03,200 --> 00:13:04,700
把它当作种子
and use that as seeds

239
00:13:04,700 --> 00:13:07,566
所以如果你在模糊测试图像处理库
so there if you're fuzzing an image processing library

240
00:13:07,666 --> 00:13:11,666
并且你听过另一个图像处理库中的一个bug
and you heard about a different bug in a different image   processing library

241
00:13:11,733 --> 00:13:14,299
就去看看那个库中触发bug的输入图像
go look at the image that triggers that bug in that library

242
00:13:14,300 --> 00:13:16,133
把它放到你要测试的库里
and put it in the library you're fuzzing

243
00:13:16,866 --> 00:13:22,099
理论上，它很可能接近触发bug的输入
and the likeliest scenarios it's conceptually closer to an     input that will trigger bugs

244
00:13:22,100 --> 00:13:28,666
由于一些未知原因，bug往往聚集在一起
bugs tend to cluster for a weird reason that people don't  necessarily understand

245
00:13:29,400 --> 00:13:34,066
你的语料库，或库中的种子
and your corpus or the individual seeds of your corpus

246
00:13:34,066 --> 00:13:35,766
不一定是语料库本身
not the corpus itself necessarily

247
00:13:35,800 --> 00:13:38,066
但单独的种子应该尽量小
but the individual seeds should be fairly small

248
00:13:39,866 --> 00:13:41,399
AFL
AFL as it functions

249
00:13:41,400 --> 00:13:45,000
会尝试修改你的输入的每一个比特位
will eventually try to mutate every bit of your inputs

250
00:13:45,300 --> 00:13:47,166
不要放没用的比特位
don't put useless bits

251
00:13:47,700 --> 00:13:54,466
每一个无用的比特，都会减少AFL探索新代码的时间
every useless bit reduces the amount of time that AFL is   exploring new code

252
00:13:57,366 --> 00:14:00,566
所以如果你在模糊测试C编译器
so if you're fuzzing the C compiler

253
00:14:01,100 --> 00:14:05,400
你不会想把注释放到语料库中
you probably don't want comments in your seed corpus for example

254
00:14:05,700 --> 00:14:07,600
这可能不是一个好例子
that might be a bad example but

255
00:14:08,666 --> 00:14:10,133
但这是一个例子
it is an example

256
00:14:11,266 --> 00:14:16,399
你还需要种子语料库尽量小
and also you want a small seed corpus in the sense that

257
00:14:16,400 --> 00:14:18,266
因为，你想用最少的种子
you want the smallest number of seeds

258
00:14:18,266 --> 00:14:20,699
覆盖所有
that can still cover all of the functionality

259
00:14:20,733 --> 00:14:21,966
你能触发的功能
that you are able to trigger 

260
00:14:21,966 --> 00:14:24,533
物尽其用
using all the seeds that you are disposed on the program

261
00:14:24,533 --> 00:14:25,999
而不是屯一堆放在那里
rather than having a bunch of

262
00:14:26,700 --> 00:14:30,133
这是大小和覆盖范围之间的平衡
this is a balance between size and coverage

263
00:14:30,200 --> 00:14:34,533
不要持有一堆小种子，每个触发一个功能
rather than having a bunch of tiny seeds that each trigger one functionality

264
00:14:34,533 --> 00:14:39,199
有时，只用少量的种子，触发大量功能，是有益的
it can sometimes be beneficial to have few seeds that       trigger a lot of functionality

265
00:14:39,600 --> 00:14:45,200
这样就可以执行一次程序，获得大量代码交互
so that you can get a lot of interaction within a single run of the binary going

266
00:14:45,800 --> 00:14:47,600
这显然是一种平衡
this is obviously a balance

267
00:14:48,066 --> 00:14:49,466
你不想要的是
which you really don't want are 

268
00:14:49,633 --> 00:14:54,333
由很多无效字节的大的输入
large inputs  that have a lot of this sort of deadwait bytes that

269
00:14:55,066 --> 00:14:56,699
因为在它们身上发生的突变，是没有意义的
for which mutation is pointless 

270
00:14:56,800 --> 00:14:57,733
比如注释
like comments

271
00:15:00,100 --> 00:15:03,600
接着我们讲讲代码覆盖率的测量
then we're moving on to measuring code coverage

272
00:15:03,600 --> 00:15:05,900
那么你怎么测量
so how do you measure

273
00:15:05,966 --> 00:15:08,199
你是否触发了新的代码路径
if you have triggered extra coverage

274
00:15:08,200 --> 00:15:14,066
实际上有很多技术可以做到这一点
there's actually a wide number of techniques that exist for this

275
00:15:14,733 --> 00:15:17,566
以及方法
and philosophies and so forth

276
00:15:17,866 --> 00:15:21,799
例如，你可以跟踪记录执行的每条指令
you might track for example every instruction that was     executed

277
00:15:22,333 --> 00:15:25,533
跟踪记录执行的基础代码块
you might track every basic block that was executed

278
00:15:26,100 --> 00:15:27,566
把它作为覆盖范围
and use that as coverage

279
00:15:27,566 --> 00:15:29,733
而AFL的做法是
what American Fuzzy lop does

280
00:15:29,966 --> 00:15:35,533
它看重的，不是输入触发的代码
is relying the input that it's not necessarily the code you    trigger that matters 

281
00:15:35,533 --> 00:15:37,966
而是它如何遍历代码
is how you traverse that code

282
00:15:38,566 --> 00:15:40,933
在相同的函数中
you might have the same function

283
00:15:41,966 --> 00:15:47,999
如果你按特定顺序执行代码块
and if you go through basic blocks in a given order

284
00:15:48,900 --> 00:15:50,800
它可能有不同的功能
it might have a different functionality 

285
00:15:50,800 --> 00:15:55,300
相比于按另一个顺序执行相同的代码块
than if you go through the same basic blocks in a different order

286
00:15:55,300 --> 00:15:58,600
所以AFL测量控制流转换
so AFL measures control flow transitions

287
00:15:58,600 --> 00:16:01,400
将基础代码块和jmp指令配对
pairs of basic blocks connected by jumps

288
00:16:01,900 --> 00:16:03,900
这就是它衡量代码覆盖率的方法
and that's how it measures code coverage

289
00:16:06,166 --> 00:16:09,399
终于说到如何改变代码了
and then finally how do you mutate code

290
00:16:09,400 --> 00:16:13,300
AFL有几种不同的改变方式
AFL mutates using several different mutators

291
00:16:14,466 --> 00:16:20,466
一是遍历输入数据，每次反转 L比特位
one mutator goes through and flips L bits at a time

292
00:16:20,900 --> 00:16:24,966
遍历时的步长为 S比特位
and walks the input file with S bit increments

293
00:16:25,800 --> 00:16:28,366
这是第一种改变方式
that's one that's its first mutator

294
00:16:28,366 --> 00:16:33,966
第二种方式，以8位为步长，遍历输入，每次加或减一个值
second mutator it actually does numerical computation     again on increments of the file

295
00:16:34,100 --> 00:16:39,266
第三种方式，用感兴趣的值，替换部分输入
then it swaps parts of the file with interesting values 

296
00:16:39,333 --> 00:16:46,266
感兴趣的值，指在边界的值
so values that are you know right on the edge of a bit      boundary

297
00:16:46,300 --> 00:16:48,300
这可能会触发off-by-one错误
that might trigger off by 1 errors 

298
00:16:48,366 --> 00:16:50,199
经常触发off-by-one错误
so frequently trigger off by 1 errors

299
00:16:50,200 --> 00:16:51,200
诸如此类的错误
these sort of things

300
00:16:52,100 --> 00:16:56,600
第四种，它还可以注入用户提供的值
it can inject user supply dictionary terms

301
00:16:56,600 --> 00:16:59,533
如果你在模糊测试一个XML文件
if you're fuzzing an XML file 

302
00:16:59,533 --> 00:17:06,266
那用一些XML实体拿去模糊测试，还是很有用的
then it's useful to put a dictionary with some XML entities and so forth

303
00:17:09,733 --> 00:17:18,399
那在这一步，AFL就会将输入变异成你给的值
that in this step AFL will actually mutate into your inputs

304
00:17:18,800 --> 00:17:21,000
AFL会做各种随机的调整
it will do various random tweaks

305
00:17:21,000 --> 00:17:23,400
还有一个很有趣的
and then a very interesting one

306
00:17:23,400 --> 00:17:25,766
它会将多个输入拼接在一起
it will splice multiple inputs together

307
00:17:26,166 --> 00:17:32,499
这些
so these mutated mutation mutators sorry 

308
00:17:33,666 --> 00:17:35,899
这些突变方法
these mutators basically

309
00:17:36,900 --> 00:17:38,700
加上那个循环
in the combination with that loop

310
00:17:38,700 --> 00:17:46,100
以及给定输入触发了多少代码的指标
with the fitness metric of how much code given input has  triggered

311
00:17:46,333 --> 00:17:50,199
这就把突变模糊变成了一种遗传算法
this turns mutational fuzzing into a genetic algorithm

312
00:17:51,166 --> 00:17:56,966
如果你学过包含遗传算法的算法课程
if you have taken an algorithmic course that covers          genetic algorithms

313
00:17:57,100 --> 00:18:00,400
遗传算法会分析一个解决方案
genetic algorithms analyze a solution

314
00:18:00,800 --> 00:18:02,333
确定其适应度函数
determine its fitness function

315
00:18:02,333 --> 00:18:03,266
然后改变它
and then mutate it 

316
00:18:03,400 --> 00:18:06,366
并将其与其他合适的解决方案结合起来
and breed it with other fit solutions 

317
00:18:06,600 --> 00:18:09,466
AFL对输入也做同样的事情
AFL does the same thing with inputs

318
00:18:12,466 --> 00:18:15,399
我多次提到模糊测试方法是王者
I mentioned several times fuzzing is king 

319
00:18:15,433 --> 00:18:17,766
而AFL是王者之中的王者
and that AFL specifically is king

320
00:18:17,966 --> 00:18:24,066
模糊测试无疑是我们所拥有的最好的程序分析技术
fuzzing is undeniably the best program analysis technique that we have

321
00:18:24,066 --> 00:18:26,699
它每年都会发现数千个bug
it finds thousands of bugs every year

322
00:18:27,066 --> 00:18:29,699
你可以在这张图上看到它的影响
and you can see the impact just on this graph

323
00:18:30,100 --> 00:18:30,833
这一年
the year 

324
00:18:30,833 --> 00:18:35,199
AFL最初于2013年11月发行
so AFL was released initially in November of 2013

325
00:18:36,266 --> 00:18:37,266
马上
right away 

326
00:18:37,533 --> 00:18:41,866
第二年发现的bug数就有大幅增加
there was a massive jump in the bugs that were               discovered the next year

327
00:18:42,066 --> 00:18:43,766
而且这一直持续了下去
and then this has kept going

328
00:18:43,800 --> 00:18:49,366
随着自动化bug查找的研究进入实用阶段
as research in automated bug finding reached practical     stage

329
00:18:49,366 --> 00:18:55,133
我想给你们看一下AFL的README
I want to show you AFL's readme actually

330
00:18:55,400 --> 00:18:59,366
这是这个项目的主页
this is the homepage of the project

331
00:19:00,800 --> 00:19:03,333
这是AFL的照片
this is actually a picture of AFL 

332
00:19:03,666 --> 00:19:06,833
在问答直播中，我将介绍如何使用它
in the live Q&A I'll go through how to use it 

333
00:19:06,833 --> 00:19:09,133
然后用不同方式使用它
and poke around it in different ways

334
00:19:09,833 --> 00:19:11,099
这里讲了些卖点
there's a sales pitch 

335
00:19:11,100 --> 00:19:12,400
然后是这个
and then there's this

336
00:19:13,366 --> 00:19:17,666
每个链接都是AFL发现的bug
each of these links is a bug found by AFL

337
00:19:20,466 --> 00:19:24,866
我很确定他们放弃了追踪记录
at some point I am pretty sure they just gave up keeping   track 

338
00:19:24,866 --> 00:19:27,533
这就是AFL
that's just AFL 

339
00:19:27,966 --> 00:19:29,366
然后还有fuzzer
then there have been fuzzers

340
00:19:29,366 --> 00:19:32,499
无数fuzzer受AFL启发
countless fuzzers inspired by AFL 

341
00:19:32,500 --> 00:19:36,366
并推动超越AFL
and pushing forward past AFL

342
00:19:38,500 --> 00:19:40,366
有太多fuzzer了，难以完整记录
there are too many fuzzers to keep track of 

343
00:19:40,433 --> 00:19:44,166
这是一个非常活跃的研究领域
this is a radically active area of research

344
00:19:45,200 --> 00:19:50,733
包括我和我在ASU的同事们的研究实验室
including my research lab along with my colleagues at     Arizona State University

345
00:19:51,700 --> 00:19:56,533
我们正在推动模糊测试向前发展
we are pushing the kind of state of fuzzing forward

346
00:19:56,533 --> 00:19:58,666
以及其他程序分析技术
along with other program analysis techniques

347
00:19:58,666 --> 00:20:01,899
如果你对学术研究感兴趣的话
again if you're interested in doing academic research

348
00:20:02,800 --> 00:20:04,500
不管是不是在ASU
whether or not it's at ASU

349
00:20:05,466 --> 00:20:06,299
给我说句话
shoot me a line 

350
00:20:06,300 --> 00:20:08,066
我很乐意回答你们的问题
and I'm happy to answer questions

351
00:20:09,533 --> 00:20:12,933
尤其是如果你能在pwn学院走到这一步
especially if you made it this far in pwn College

352
00:20:14,133 --> 00:20:16,299
回到前沿fuzzer
so cutting edge fuzzers 

353
00:20:16,300 --> 00:20:18,666
有太多了，根本记不全
there just too many to keep track of

354
00:20:18,666 --> 00:20:22,999
我会指出一些很酷的资源
I'll instead point out some really cool resources

355
00:20:23,400 --> 00:20:25,800
有一个叫OSS-Fuzz的项目
there's a project called OSS Fuzz 

356
00:20:25,900 --> 00:20:29,933
谷歌和OSS Fuzz的贡献者
basically Google and contributors to OSS Fuzz 

357
00:20:30,100 --> 00:20:38,733
利用了大量的开源软件和
have harness a lot of open source software and

358
00:20:39,500 --> 00:20:43,400
将其配置为易于运行和易于模糊测试
configured it to be runnable easily and fuzzable easily

359
00:20:44,000 --> 00:20:45,466
并可分析
and analyzable

360
00:20:46,133 --> 00:20:52,066
然后谷歌持续对这些项目进行模糊测试
and then Google actually goes through a continuously       fuzzes these projects

361
00:20:52,666 --> 00:20:55,033
然后报告bug
and then of course reports the bugs 

362
00:20:55,033 --> 00:20:58,499
很难准确说出发现了多少bug
and it's hard to even say how many bugs were found 

363
00:20:58,500 --> 00:20:59,133
但这是
but it is 

364
00:21:01,066 --> 00:21:03,199
是一个数不清的数字
it is countless numbers

365
00:21:04,600 --> 00:21:09,266
谷歌还有一个很酷的项目叫syzkaller
there is a really cool project also from Google called        syzkaller

366
00:21:09,333 --> 00:21:11,733
它是Linux系统的fuzzer
it is a system call fuzzer for Linux 

367
00:21:11,733 --> 00:21:14,733
它在用户空间fuzzlinux内核
so it fuzzes from user space up into the Linux kernel 

368
00:21:14,733 --> 00:21:15,999
查找内核bug
to find kernel bugs

369
00:21:16,000 --> 00:21:17,800
我个人在我的研究中使用过它
I've used it personally in my research 

370
00:21:17,933 --> 00:21:19,766
非常棒
it's quite awesome

371
00:21:20,566 --> 00:21:25,833
还有另一大家族的fuzzer
there is another kind of family of fuzzers 

372
00:21:25,833 --> 00:21:34,199
基于LLVM编译器的另一个分支
or another lineage based on LLVM the compiler                infrastructure

373
00:21:34,700 --> 00:21:38,533
现在主要由苹果和贡献者开发
now mostly developed by apple and contributors

374
00:21:39,133 --> 00:21:40,066
libfuzzer
libfuzzer

375
00:21:40,800 --> 00:21:42,733
需要源代码
requires source code

376
00:21:42,733 --> 00:21:45,633
这是一个集成的模糊测试库
it's a integrated fuzzing library 

377
00:21:45,633 --> 00:21:48,633
它集成到clang和LLVM
that's integrating to clang and LLVM 

378
00:21:48,633 --> 00:21:52,266
实际上OSS Fuzz也使用了libfuzzer
and actually OSS Fuzz uses libfuzzer as well

379
00:21:54,166 --> 00:21:59,399
这是在软件开发过程中模糊测试的好方法
and it's a great way to fuzz your software during              development 

380
00:21:59,533 --> 00:22:00,466
然后是
and then there is

381
00:22:01,166 --> 00:22:04,599
并将它集成到你的测试用例中
and to integrate into your test cases for your applications

382
00:22:04,600 --> 00:22:06,533
然后是AFL++
and then there's AFL plus plus

383
00:22:06,700 --> 00:22:10,000
AFL的最初开发者
the original developer of AFL

384
00:22:14,200 --> 00:22:15,833
在更新之间，花了些时间
takes time between updates

385
00:22:16,066 --> 00:22:18,133
于是社区创建了AFL++
and so the community created AFL plus plus

386
00:22:18,300 --> 00:22:22,000
加入了一些社区支持的修改
with some community supported editions

387
00:22:22,466 --> 00:22:24,399
还有一个很好的清单
there's also this great list 

388
00:22:24,433 --> 00:22:25,999
实际上有几个列表
actually there's several lists

389
00:22:26,066 --> 00:22:26,933
这是其中之一
but here's one of them 

390
00:22:27,200 --> 00:22:33,500
你可以在这里找到大量的资源、书籍和论文链接
where you can get tons of fuzzing resources, books, links  to papers 

391
00:22:33,666 --> 00:22:35,433
有很多很酷的东西
a lot of really cool stuff

392
00:22:35,600 --> 00:22:38,600
如果你对这类东西感兴趣
again if this sort of stuff interests you

393
00:22:39,166 --> 00:22:42,366
给我写封邮件，我们来谈谈
drop me a line and we'll talk about research

394
00:22:43,400 --> 00:22:45,266
下个视频见
see you in the next video

